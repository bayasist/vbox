
// ##### BEGINFILE "NATNetworkWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for INATNetwork.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef NATNetworkWrap_H_
#define NATNetworkWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE NATNetworkWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(INATNetwork)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(NATNetworkWrap, INATNetwork)
    DECLARE_NOT_AGGREGATABLE(NATNetworkWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(NATNetworkWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(INATNetwork)
        COM_INTERFACE_ENTRY2(IDispatch, INATNetwork)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(NATNetworkWrap)

    // public INATNetwork properties
    STDMETHOD(COMGETTER(NetworkName))(BSTR *aNetworkName);
    STDMETHOD(COMSETTER(NetworkName))(IN_BSTR aNetworkName);
    STDMETHOD(COMGETTER(Enabled))(BOOL *aEnabled);
    STDMETHOD(COMSETTER(Enabled))(BOOL aEnabled);
    STDMETHOD(COMGETTER(Network))(BSTR *aNetwork);
    STDMETHOD(COMSETTER(Network))(IN_BSTR aNetwork);
    STDMETHOD(COMGETTER(Gateway))(BSTR *aGateway);
    STDMETHOD(COMGETTER(IPv6Enabled))(BOOL *aIPv6Enabled);
    STDMETHOD(COMSETTER(IPv6Enabled))(BOOL aIPv6Enabled);
    STDMETHOD(COMGETTER(IPv6Prefix))(BSTR *aIPv6Prefix);
    STDMETHOD(COMSETTER(IPv6Prefix))(IN_BSTR aIPv6Prefix);
    STDMETHOD(COMGETTER(AdvertiseDefaultIPv6RouteEnabled))(BOOL *aAdvertiseDefaultIPv6RouteEnabled);
    STDMETHOD(COMSETTER(AdvertiseDefaultIPv6RouteEnabled))(BOOL aAdvertiseDefaultIPv6RouteEnabled);
    STDMETHOD(COMGETTER(NeedDhcpServer))(BOOL *aNeedDhcpServer);
    STDMETHOD(COMSETTER(NeedDhcpServer))(BOOL aNeedDhcpServer);
    STDMETHOD(COMGETTER(EventSource))(IEventSource **aEventSource);
    STDMETHOD(COMGETTER(PortForwardRules4))(ComSafeArrayOut(BSTR, aPortForwardRules4));
    STDMETHOD(COMGETTER(LocalMappings))(ComSafeArrayOut(BSTR, aLocalMappings));
    STDMETHOD(COMGETTER(LoopbackIp6))(LONG *aLoopbackIp6);
    STDMETHOD(COMSETTER(LoopbackIp6))(LONG aLoopbackIp6);
    STDMETHOD(COMGETTER(PortForwardRules6))(ComSafeArrayOut(BSTR, aPortForwardRules6));

    // public INATNetwork methods
    STDMETHOD(AddLocalMapping)(IN_BSTR aHostid,
                               LONG aOffset);
    STDMETHOD(AddPortForwardRule)(BOOL aIsIpv6,
                                  IN_BSTR aRuleName,
                                  NATProtocol_T aProto,
                                  IN_BSTR aHostIP,
                                  USHORT aHostPort,
                                  IN_BSTR aGuestIP,
                                  USHORT aGuestPort);
    STDMETHOD(RemovePortForwardRule)(BOOL aISipv6,
                                     IN_BSTR aRuleName);
    STDMETHOD(Start)(IN_BSTR aTrunkType);
    STDMETHOD(Stop)();

private:
    // wrapped INATNetwork properties
    virtual HRESULT getNetworkName(com::Utf8Str &aNetworkName) = 0;
    virtual HRESULT setNetworkName(const com::Utf8Str &aNetworkName) = 0;
    virtual HRESULT getEnabled(BOOL *aEnabled) = 0;
    virtual HRESULT setEnabled(BOOL aEnabled) = 0;
    virtual HRESULT getNetwork(com::Utf8Str &aNetwork) = 0;
    virtual HRESULT setNetwork(const com::Utf8Str &aNetwork) = 0;
    virtual HRESULT getGateway(com::Utf8Str &aGateway) = 0;
    virtual HRESULT getIPv6Enabled(BOOL *aIPv6Enabled) = 0;
    virtual HRESULT setIPv6Enabled(BOOL aIPv6Enabled) = 0;
    virtual HRESULT getIPv6Prefix(com::Utf8Str &aIPv6Prefix) = 0;
    virtual HRESULT setIPv6Prefix(const com::Utf8Str &aIPv6Prefix) = 0;
    virtual HRESULT getAdvertiseDefaultIPv6RouteEnabled(BOOL *aAdvertiseDefaultIPv6RouteEnabled) = 0;
    virtual HRESULT setAdvertiseDefaultIPv6RouteEnabled(BOOL aAdvertiseDefaultIPv6RouteEnabled) = 0;
    virtual HRESULT getNeedDhcpServer(BOOL *aNeedDhcpServer) = 0;
    virtual HRESULT setNeedDhcpServer(BOOL aNeedDhcpServer) = 0;
    virtual HRESULT getEventSource(ComPtr<IEventSource> &aEventSource) = 0;
    virtual HRESULT getPortForwardRules4(std::vector<com::Utf8Str> &aPortForwardRules4) = 0;
    virtual HRESULT getLocalMappings(std::vector<com::Utf8Str> &aLocalMappings) = 0;
    virtual HRESULT getLoopbackIp6(LONG *aLoopbackIp6) = 0;
    virtual HRESULT setLoopbackIp6(LONG aLoopbackIp6) = 0;
    virtual HRESULT getPortForwardRules6(std::vector<com::Utf8Str> &aPortForwardRules6) = 0;

    // wrapped INATNetwork methods
    virtual HRESULT addLocalMapping(const com::Utf8Str &aHostid,
                                    LONG aOffset) = 0;
    virtual HRESULT addPortForwardRule(BOOL aIsIpv6,
                                       const com::Utf8Str &aRuleName,
                                       NATProtocol_T aProto,
                                       const com::Utf8Str &aHostIP,
                                       USHORT aHostPort,
                                       const com::Utf8Str &aGuestIP,
                                       USHORT aGuestPort) = 0;
    virtual HRESULT removePortForwardRule(BOOL aISipv6,
                                          const com::Utf8Str &aRuleName) = 0;
    virtual HRESULT start(const com::Utf8Str &aTrunkType) = 0;
    virtual HRESULT stop() = 0;
};

#endif // !NATNetworkWrap_H_

// ##### ENDFILE "NATNetworkWrap.h"

// ##### BEGINFILE "NATNetworkWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for INATNetwork.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_NATNETWORK

#include "NATNetworkWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(NATNetworkWrap)

//
// INATNetwork properties
//

STDMETHODIMP NATNetworkWrap::COMGETTER(NetworkName)(BSTR *aNetworkName)
{
    LogRelFlow(("{%p} %s: enter aNetworkName=%p\n", this, "NATNetwork::getNetworkName", aNetworkName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNetworkName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNetworkName(BSTROutConverter(aNetworkName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNetworkName=%ls hrc=%Rhrc\n", this, "NATNetwork::getNetworkName", *aNetworkName, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::COMSETTER(NetworkName)(IN_BSTR aNetworkName)
{
    LogRelFlow(("{%p} %s: enter aNetworkName=%ls\n", this, "NATNetwork::setNetworkName", aNetworkName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setNetworkName(BSTRInConverter(aNetworkName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATNetwork::setNetworkName", hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::COMGETTER(Enabled)(BOOL *aEnabled)
{
    LogRelFlow(("{%p} %s: enter aEnabled=%p\n", this, "NATNetwork::getEnabled", aEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEnabled(aEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEnabled=%RTbool hrc=%Rhrc\n", this, "NATNetwork::getEnabled", *aEnabled, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::COMSETTER(Enabled)(BOOL aEnabled)
{
    LogRelFlow(("{%p} %s: enter aEnabled=%RTbool\n", this, "NATNetwork::setEnabled", aEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setEnabled(aEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATNetwork::setEnabled", hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::COMGETTER(Network)(BSTR *aNetwork)
{
    LogRelFlow(("{%p} %s: enter aNetwork=%p\n", this, "NATNetwork::getNetwork", aNetwork));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNetwork);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNetwork(BSTROutConverter(aNetwork).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNetwork=%ls hrc=%Rhrc\n", this, "NATNetwork::getNetwork", *aNetwork, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::COMSETTER(Network)(IN_BSTR aNetwork)
{
    LogRelFlow(("{%p} %s: enter aNetwork=%ls\n", this, "NATNetwork::setNetwork", aNetwork));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setNetwork(BSTRInConverter(aNetwork).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATNetwork::setNetwork", hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::COMGETTER(Gateway)(BSTR *aGateway)
{
    LogRelFlow(("{%p} %s: enter aGateway=%p\n", this, "NATNetwork::getGateway", aGateway));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGateway);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGateway(BSTROutConverter(aGateway).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGateway=%ls hrc=%Rhrc\n", this, "NATNetwork::getGateway", *aGateway, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::COMGETTER(IPv6Enabled)(BOOL *aIPv6Enabled)
{
    LogRelFlow(("{%p} %s: enter aIPv6Enabled=%p\n", this, "NATNetwork::getIPv6Enabled", aIPv6Enabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aIPv6Enabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getIPv6Enabled(aIPv6Enabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aIPv6Enabled=%RTbool hrc=%Rhrc\n", this, "NATNetwork::getIPv6Enabled", *aIPv6Enabled, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::COMSETTER(IPv6Enabled)(BOOL aIPv6Enabled)
{
    LogRelFlow(("{%p} %s: enter aIPv6Enabled=%RTbool\n", this, "NATNetwork::setIPv6Enabled", aIPv6Enabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setIPv6Enabled(aIPv6Enabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATNetwork::setIPv6Enabled", hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::COMGETTER(IPv6Prefix)(BSTR *aIPv6Prefix)
{
    LogRelFlow(("{%p} %s: enter aIPv6Prefix=%p\n", this, "NATNetwork::getIPv6Prefix", aIPv6Prefix));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aIPv6Prefix);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getIPv6Prefix(BSTROutConverter(aIPv6Prefix).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aIPv6Prefix=%ls hrc=%Rhrc\n", this, "NATNetwork::getIPv6Prefix", *aIPv6Prefix, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::COMSETTER(IPv6Prefix)(IN_BSTR aIPv6Prefix)
{
    LogRelFlow(("{%p} %s: enter aIPv6Prefix=%ls\n", this, "NATNetwork::setIPv6Prefix", aIPv6Prefix));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setIPv6Prefix(BSTRInConverter(aIPv6Prefix).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATNetwork::setIPv6Prefix", hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::COMGETTER(AdvertiseDefaultIPv6RouteEnabled)(BOOL *aAdvertiseDefaultIPv6RouteEnabled)
{
    LogRelFlow(("{%p} %s: enter aAdvertiseDefaultIPv6RouteEnabled=%p\n", this, "NATNetwork::getAdvertiseDefaultIPv6RouteEnabled", aAdvertiseDefaultIPv6RouteEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAdvertiseDefaultIPv6RouteEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAdvertiseDefaultIPv6RouteEnabled(aAdvertiseDefaultIPv6RouteEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAdvertiseDefaultIPv6RouteEnabled=%RTbool hrc=%Rhrc\n", this, "NATNetwork::getAdvertiseDefaultIPv6RouteEnabled", *aAdvertiseDefaultIPv6RouteEnabled, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::COMSETTER(AdvertiseDefaultIPv6RouteEnabled)(BOOL aAdvertiseDefaultIPv6RouteEnabled)
{
    LogRelFlow(("{%p} %s: enter aAdvertiseDefaultIPv6RouteEnabled=%RTbool\n", this, "NATNetwork::setAdvertiseDefaultIPv6RouteEnabled", aAdvertiseDefaultIPv6RouteEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setAdvertiseDefaultIPv6RouteEnabled(aAdvertiseDefaultIPv6RouteEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATNetwork::setAdvertiseDefaultIPv6RouteEnabled", hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::COMGETTER(NeedDhcpServer)(BOOL *aNeedDhcpServer)
{
    LogRelFlow(("{%p} %s: enter aNeedDhcpServer=%p\n", this, "NATNetwork::getNeedDhcpServer", aNeedDhcpServer));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNeedDhcpServer);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNeedDhcpServer(aNeedDhcpServer);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNeedDhcpServer=%RTbool hrc=%Rhrc\n", this, "NATNetwork::getNeedDhcpServer", *aNeedDhcpServer, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::COMSETTER(NeedDhcpServer)(BOOL aNeedDhcpServer)
{
    LogRelFlow(("{%p} %s: enter aNeedDhcpServer=%RTbool\n", this, "NATNetwork::setNeedDhcpServer", aNeedDhcpServer));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setNeedDhcpServer(aNeedDhcpServer);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATNetwork::setNeedDhcpServer", hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::COMGETTER(EventSource)(IEventSource **aEventSource)
{
    LogRelFlow(("{%p} %s: enter aEventSource=%p\n", this, "NATNetwork::getEventSource", aEventSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEventSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEventSource(ComTypeOutConverter<IEventSource>(aEventSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEventSource=%p hrc=%Rhrc\n", this, "NATNetwork::getEventSource", *aEventSource, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::COMGETTER(PortForwardRules4)(ComSafeArrayOut(BSTR, aPortForwardRules4))
{
    LogRelFlow(("{%p} %s: enter aPortForwardRules4=%p\n", this, "NATNetwork::getPortForwardRules4", aPortForwardRules4));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPortForwardRules4);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPortForwardRules4(ArrayBSTROutConverter(ComSafeArrayOutArg(aPortForwardRules4)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPortForwardRules4=%zu hrc=%Rhrc\n", this, "NATNetwork::getPortForwardRules4", ComSafeArraySize(*aPortForwardRules4), hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::COMGETTER(LocalMappings)(ComSafeArrayOut(BSTR, aLocalMappings))
{
    LogRelFlow(("{%p} %s: enter aLocalMappings=%p\n", this, "NATNetwork::getLocalMappings", aLocalMappings));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLocalMappings);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLocalMappings(ArrayBSTROutConverter(ComSafeArrayOutArg(aLocalMappings)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLocalMappings=%zu hrc=%Rhrc\n", this, "NATNetwork::getLocalMappings", ComSafeArraySize(*aLocalMappings), hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::COMGETTER(LoopbackIp6)(LONG *aLoopbackIp6)
{
    LogRelFlow(("{%p} %s: enter aLoopbackIp6=%p\n", this, "NATNetwork::getLoopbackIp6", aLoopbackIp6));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLoopbackIp6);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLoopbackIp6(aLoopbackIp6);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLoopbackIp6=%RI32 hrc=%Rhrc\n", this, "NATNetwork::getLoopbackIp6", *aLoopbackIp6, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::COMSETTER(LoopbackIp6)(LONG aLoopbackIp6)
{
    LogRelFlow(("{%p} %s: enter aLoopbackIp6=%RI32\n", this, "NATNetwork::setLoopbackIp6", aLoopbackIp6));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setLoopbackIp6(aLoopbackIp6);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATNetwork::setLoopbackIp6", hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::COMGETTER(PortForwardRules6)(ComSafeArrayOut(BSTR, aPortForwardRules6))
{
    LogRelFlow(("{%p} %s: enter aPortForwardRules6=%p\n", this, "NATNetwork::getPortForwardRules6", aPortForwardRules6));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPortForwardRules6);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPortForwardRules6(ArrayBSTROutConverter(ComSafeArrayOutArg(aPortForwardRules6)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPortForwardRules6=%zu hrc=%Rhrc\n", this, "NATNetwork::getPortForwardRules6", ComSafeArraySize(*aPortForwardRules6), hrc));
    return hrc;
}

//
// INATNetwork methods
//

STDMETHODIMP NATNetworkWrap::AddLocalMapping(IN_BSTR aHostid,
                                             LONG aOffset)
{
    LogRelFlow(("{%p} %s:enter aHostid=%ls aOffset=%RI32\n", this, "NATNetwork::addLocalMapping", aHostid, aOffset));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = addLocalMapping(BSTRInConverter(aHostid).str(),
                              aOffset);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATNetwork::addLocalMapping", hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::AddPortForwardRule(BOOL aIsIpv6,
                                                IN_BSTR aRuleName,
                                                NATProtocol_T aProto,
                                                IN_BSTR aHostIP,
                                                USHORT aHostPort,
                                                IN_BSTR aGuestIP,
                                                USHORT aGuestPort)
{
    LogRelFlow(("{%p} %s:enter aIsIpv6=%RTbool aRuleName=%ls aProto=%RU32 aHostIP=%ls aHostPort=%RU16 aGuestIP=%ls aGuestPort=%RU16\n", this, "NATNetwork::addPortForwardRule", aIsIpv6, aRuleName, aProto, aHostIP, aHostPort, aGuestIP, aGuestPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = addPortForwardRule(aIsIpv6,
                                 BSTRInConverter(aRuleName).str(),
                                 aProto,
                                 BSTRInConverter(aHostIP).str(),
                                 aHostPort,
                                 BSTRInConverter(aGuestIP).str(),
                                 aGuestPort);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATNetwork::addPortForwardRule", hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::RemovePortForwardRule(BOOL aISipv6,
                                                   IN_BSTR aRuleName)
{
    LogRelFlow(("{%p} %s:enter aISipv6=%RTbool aRuleName=%ls\n", this, "NATNetwork::removePortForwardRule", aISipv6, aRuleName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = removePortForwardRule(aISipv6,
                                    BSTRInConverter(aRuleName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATNetwork::removePortForwardRule", hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::Start(IN_BSTR aTrunkType)
{
    LogRelFlow(("{%p} %s:enter aTrunkType=%ls\n", this, "NATNetwork::start", aTrunkType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = start(BSTRInConverter(aTrunkType).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATNetwork::start", hrc));
    return hrc;
}

STDMETHODIMP NATNetworkWrap::Stop()
{
    LogRelFlow(("{%p} %s:enter\n", this, "NATNetwork::stop"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = stop();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATNetwork::stop", hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(NATNetworkWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(NATNetworkWrap, INATNetwork)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "NATNetworkWrap.cpp"

// ##### BEGINFILE "DHCPServerWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IDHCPServer.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef DHCPServerWrap_H_
#define DHCPServerWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE DHCPServerWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IDHCPServer)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(DHCPServerWrap, IDHCPServer)
    DECLARE_NOT_AGGREGATABLE(DHCPServerWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(DHCPServerWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IDHCPServer)
        COM_INTERFACE_ENTRY2(IDispatch, IDHCPServer)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(DHCPServerWrap)

    // public IDHCPServer properties
    STDMETHOD(COMGETTER(EventSource))(IEventSource **aEventSource);
    STDMETHOD(COMGETTER(Enabled))(BOOL *aEnabled);
    STDMETHOD(COMSETTER(Enabled))(BOOL aEnabled);
    STDMETHOD(COMGETTER(IPAddress))(BSTR *aIPAddress);
    STDMETHOD(COMGETTER(NetworkMask))(BSTR *aNetworkMask);
    STDMETHOD(COMGETTER(NetworkName))(BSTR *aNetworkName);
    STDMETHOD(COMGETTER(LowerIP))(BSTR *aLowerIP);
    STDMETHOD(COMGETTER(UpperIP))(BSTR *aUpperIP);
    STDMETHOD(COMGETTER(GlobalOptions))(ComSafeArrayOut(BSTR, aGlobalOptions));
    STDMETHOD(COMGETTER(VmConfigs))(ComSafeArrayOut(BSTR, aVmConfigs));

    // public IDHCPServer methods
    STDMETHOD(AddGlobalOption)(DhcpOpt_T aOption,
                               IN_BSTR aValue);
    STDMETHOD(AddVmSlotOption)(IN_BSTR aVmname,
                               LONG aSlot,
                               DhcpOpt_T aOption,
                               IN_BSTR aValue);
    STDMETHOD(RemoveVmSlotOptions)(IN_BSTR aVmname,
                                   LONG aSlot);
    STDMETHOD(GetVmSlotOptions)(IN_BSTR aVmname,
                                LONG aSlot,
                                ComSafeArrayOut(BSTR, aOption));
    STDMETHOD(GetMacOptions)(IN_BSTR aMac,
                             ComSafeArrayOut(BSTR, aOption));
    STDMETHOD(SetConfiguration)(IN_BSTR aIPAddress,
                                IN_BSTR aNetworkMask,
                                IN_BSTR aFromIPAddress,
                                IN_BSTR aToIPAddress);
    STDMETHOD(Start)(IN_BSTR aNetworkName,
                     IN_BSTR aTrunkName,
                     IN_BSTR aTrunkType);
    STDMETHOD(Stop)();

private:
    // wrapped IDHCPServer properties
    virtual HRESULT getEventSource(ComPtr<IEventSource> &aEventSource) = 0;
    virtual HRESULT getEnabled(BOOL *aEnabled) = 0;
    virtual HRESULT setEnabled(BOOL aEnabled) = 0;
    virtual HRESULT getIPAddress(com::Utf8Str &aIPAddress) = 0;
    virtual HRESULT getNetworkMask(com::Utf8Str &aNetworkMask) = 0;
    virtual HRESULT getNetworkName(com::Utf8Str &aNetworkName) = 0;
    virtual HRESULT getLowerIP(com::Utf8Str &aLowerIP) = 0;
    virtual HRESULT getUpperIP(com::Utf8Str &aUpperIP) = 0;
    virtual HRESULT getGlobalOptions(std::vector<com::Utf8Str> &aGlobalOptions) = 0;
    virtual HRESULT getVmConfigs(std::vector<com::Utf8Str> &aVmConfigs) = 0;

    // wrapped IDHCPServer methods
    virtual HRESULT addGlobalOption(DhcpOpt_T aOption,
                                    const com::Utf8Str &aValue) = 0;
    virtual HRESULT addVmSlotOption(const com::Utf8Str &aVmname,
                                    LONG aSlot,
                                    DhcpOpt_T aOption,
                                    const com::Utf8Str &aValue) = 0;
    virtual HRESULT removeVmSlotOptions(const com::Utf8Str &aVmname,
                                        LONG aSlot) = 0;
    virtual HRESULT getVmSlotOptions(const com::Utf8Str &aVmname,
                                     LONG aSlot,
                                     std::vector<com::Utf8Str> &aOption) = 0;
    virtual HRESULT getMacOptions(const com::Utf8Str &aMac,
                                  std::vector<com::Utf8Str> &aOption) = 0;
    virtual HRESULT setConfiguration(const com::Utf8Str &aIPAddress,
                                     const com::Utf8Str &aNetworkMask,
                                     const com::Utf8Str &aFromIPAddress,
                                     const com::Utf8Str &aToIPAddress) = 0;
    virtual HRESULT start(const com::Utf8Str &aNetworkName,
                          const com::Utf8Str &aTrunkName,
                          const com::Utf8Str &aTrunkType) = 0;
    virtual HRESULT stop() = 0;
};

#endif // !DHCPServerWrap_H_

// ##### ENDFILE "DHCPServerWrap.h"

// ##### BEGINFILE "DHCPServerWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IDHCPServer.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_DHCPSERVER

#include "DHCPServerWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(DHCPServerWrap)

//
// IDHCPServer properties
//

STDMETHODIMP DHCPServerWrap::COMGETTER(EventSource)(IEventSource **aEventSource)
{
    LogRelFlow(("{%p} %s: enter aEventSource=%p\n", this, "DHCPServer::getEventSource", aEventSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEventSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEventSource(ComTypeOutConverter<IEventSource>(aEventSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEventSource=%p hrc=%Rhrc\n", this, "DHCPServer::getEventSource", *aEventSource, hrc));
    return hrc;
}

STDMETHODIMP DHCPServerWrap::COMGETTER(Enabled)(BOOL *aEnabled)
{
    LogRelFlow(("{%p} %s: enter aEnabled=%p\n", this, "DHCPServer::getEnabled", aEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEnabled(aEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEnabled=%RTbool hrc=%Rhrc\n", this, "DHCPServer::getEnabled", *aEnabled, hrc));
    return hrc;
}

STDMETHODIMP DHCPServerWrap::COMSETTER(Enabled)(BOOL aEnabled)
{
    LogRelFlow(("{%p} %s: enter aEnabled=%RTbool\n", this, "DHCPServer::setEnabled", aEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setEnabled(aEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "DHCPServer::setEnabled", hrc));
    return hrc;
}

STDMETHODIMP DHCPServerWrap::COMGETTER(IPAddress)(BSTR *aIPAddress)
{
    LogRelFlow(("{%p} %s: enter aIPAddress=%p\n", this, "DHCPServer::getIPAddress", aIPAddress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aIPAddress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getIPAddress(BSTROutConverter(aIPAddress).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aIPAddress=%ls hrc=%Rhrc\n", this, "DHCPServer::getIPAddress", *aIPAddress, hrc));
    return hrc;
}

STDMETHODIMP DHCPServerWrap::COMGETTER(NetworkMask)(BSTR *aNetworkMask)
{
    LogRelFlow(("{%p} %s: enter aNetworkMask=%p\n", this, "DHCPServer::getNetworkMask", aNetworkMask));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNetworkMask);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNetworkMask(BSTROutConverter(aNetworkMask).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNetworkMask=%ls hrc=%Rhrc\n", this, "DHCPServer::getNetworkMask", *aNetworkMask, hrc));
    return hrc;
}

STDMETHODIMP DHCPServerWrap::COMGETTER(NetworkName)(BSTR *aNetworkName)
{
    LogRelFlow(("{%p} %s: enter aNetworkName=%p\n", this, "DHCPServer::getNetworkName", aNetworkName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNetworkName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNetworkName(BSTROutConverter(aNetworkName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNetworkName=%ls hrc=%Rhrc\n", this, "DHCPServer::getNetworkName", *aNetworkName, hrc));
    return hrc;
}

STDMETHODIMP DHCPServerWrap::COMGETTER(LowerIP)(BSTR *aLowerIP)
{
    LogRelFlow(("{%p} %s: enter aLowerIP=%p\n", this, "DHCPServer::getLowerIP", aLowerIP));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLowerIP);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLowerIP(BSTROutConverter(aLowerIP).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLowerIP=%ls hrc=%Rhrc\n", this, "DHCPServer::getLowerIP", *aLowerIP, hrc));
    return hrc;
}

STDMETHODIMP DHCPServerWrap::COMGETTER(UpperIP)(BSTR *aUpperIP)
{
    LogRelFlow(("{%p} %s: enter aUpperIP=%p\n", this, "DHCPServer::getUpperIP", aUpperIP));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUpperIP);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUpperIP(BSTROutConverter(aUpperIP).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUpperIP=%ls hrc=%Rhrc\n", this, "DHCPServer::getUpperIP", *aUpperIP, hrc));
    return hrc;
}

STDMETHODIMP DHCPServerWrap::COMGETTER(GlobalOptions)(ComSafeArrayOut(BSTR, aGlobalOptions))
{
    LogRelFlow(("{%p} %s: enter aGlobalOptions=%p\n", this, "DHCPServer::getGlobalOptions", aGlobalOptions));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGlobalOptions);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGlobalOptions(ArrayBSTROutConverter(ComSafeArrayOutArg(aGlobalOptions)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGlobalOptions=%zu hrc=%Rhrc\n", this, "DHCPServer::getGlobalOptions", ComSafeArraySize(*aGlobalOptions), hrc));
    return hrc;
}

STDMETHODIMP DHCPServerWrap::COMGETTER(VmConfigs)(ComSafeArrayOut(BSTR, aVmConfigs))
{
    LogRelFlow(("{%p} %s: enter aVmConfigs=%p\n", this, "DHCPServer::getVmConfigs", aVmConfigs));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVmConfigs);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVmConfigs(ArrayBSTROutConverter(ComSafeArrayOutArg(aVmConfigs)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVmConfigs=%zu hrc=%Rhrc\n", this, "DHCPServer::getVmConfigs", ComSafeArraySize(*aVmConfigs), hrc));
    return hrc;
}

//
// IDHCPServer methods
//

STDMETHODIMP DHCPServerWrap::AddGlobalOption(DhcpOpt_T aOption,
                                             IN_BSTR aValue)
{
    LogRelFlow(("{%p} %s:enter aOption=%RU32 aValue=%ls\n", this, "DHCPServer::addGlobalOption", aOption, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = addGlobalOption(aOption,
                              BSTRInConverter(aValue).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "DHCPServer::addGlobalOption", hrc));
    return hrc;
}

STDMETHODIMP DHCPServerWrap::AddVmSlotOption(IN_BSTR aVmname,
                                             LONG aSlot,
                                             DhcpOpt_T aOption,
                                             IN_BSTR aValue)
{
    LogRelFlow(("{%p} %s:enter aVmname=%ls aSlot=%RI32 aOption=%RU32 aValue=%ls\n", this, "DHCPServer::addVmSlotOption", aVmname, aSlot, aOption, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = addVmSlotOption(BSTRInConverter(aVmname).str(),
                              aSlot,
                              aOption,
                              BSTRInConverter(aValue).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "DHCPServer::addVmSlotOption", hrc));
    return hrc;
}

STDMETHODIMP DHCPServerWrap::RemoveVmSlotOptions(IN_BSTR aVmname,
                                                 LONG aSlot)
{
    LogRelFlow(("{%p} %s:enter aVmname=%ls aSlot=%RI32\n", this, "DHCPServer::removeVmSlotOptions", aVmname, aSlot));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = removeVmSlotOptions(BSTRInConverter(aVmname).str(),
                                  aSlot);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "DHCPServer::removeVmSlotOptions", hrc));
    return hrc;
}

STDMETHODIMP DHCPServerWrap::GetVmSlotOptions(IN_BSTR aVmname,
                                              LONG aSlot,
                                              ComSafeArrayOut(BSTR, aOption))
{
    LogRelFlow(("{%p} %s:enter aVmname=%ls aSlot=%RI32 aOption=%p\n", this, "DHCPServer::getVmSlotOptions", aVmname, aSlot, aOption));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOption);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVmSlotOptions(BSTRInConverter(aVmname).str(),
                               aSlot,
                               ArrayBSTROutConverter(ComSafeArrayOutArg(aOption)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aOption=%zu hrc=%Rhrc\n", this, "DHCPServer::getVmSlotOptions", ComSafeArraySize(*aOption), hrc));
    return hrc;
}

STDMETHODIMP DHCPServerWrap::GetMacOptions(IN_BSTR aMac,
                                           ComSafeArrayOut(BSTR, aOption))
{
    LogRelFlow(("{%p} %s:enter aMac=%ls aOption=%p\n", this, "DHCPServer::getMacOptions", aMac, aOption));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOption);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMacOptions(BSTRInConverter(aMac).str(),
                            ArrayBSTROutConverter(ComSafeArrayOutArg(aOption)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aOption=%zu hrc=%Rhrc\n", this, "DHCPServer::getMacOptions", ComSafeArraySize(*aOption), hrc));
    return hrc;
}

STDMETHODIMP DHCPServerWrap::SetConfiguration(IN_BSTR aIPAddress,
                                              IN_BSTR aNetworkMask,
                                              IN_BSTR aFromIPAddress,
                                              IN_BSTR aToIPAddress)
{
    LogRelFlow(("{%p} %s:enter aIPAddress=%ls aNetworkMask=%ls aFromIPAddress=%ls aToIPAddress=%ls\n", this, "DHCPServer::setConfiguration", aIPAddress, aNetworkMask, aFromIPAddress, aToIPAddress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setConfiguration(BSTRInConverter(aIPAddress).str(),
                               BSTRInConverter(aNetworkMask).str(),
                               BSTRInConverter(aFromIPAddress).str(),
                               BSTRInConverter(aToIPAddress).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "DHCPServer::setConfiguration", hrc));
    return hrc;
}

STDMETHODIMP DHCPServerWrap::Start(IN_BSTR aNetworkName,
                                   IN_BSTR aTrunkName,
                                   IN_BSTR aTrunkType)
{
    LogRelFlow(("{%p} %s:enter aNetworkName=%ls aTrunkName=%ls aTrunkType=%ls\n", this, "DHCPServer::start", aNetworkName, aTrunkName, aTrunkType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = start(BSTRInConverter(aNetworkName).str(),
                    BSTRInConverter(aTrunkName).str(),
                    BSTRInConverter(aTrunkType).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "DHCPServer::start", hrc));
    return hrc;
}

STDMETHODIMP DHCPServerWrap::Stop()
{
    LogRelFlow(("{%p} %s:enter\n", this, "DHCPServer::stop"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = stop();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "DHCPServer::stop", hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(DHCPServerWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(DHCPServerWrap, IDHCPServer)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "DHCPServerWrap.cpp"

// ##### BEGINFILE "VirtualBoxWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IVirtualBox.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef VirtualBoxWrap_H_
#define VirtualBoxWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE VirtualBoxWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IVirtualBox)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(VirtualBoxWrap, IVirtualBox)
    DECLARE_NOT_AGGREGATABLE(VirtualBoxWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(VirtualBoxWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IVirtualBox)
        COM_INTERFACE_ENTRY2(IDispatch, IVirtualBox)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(VirtualBoxWrap)

    // public IVirtualBox properties
    STDMETHOD(COMGETTER(Version))(BSTR *aVersion);
    STDMETHOD(COMGETTER(VersionNormalized))(BSTR *aVersionNormalized);
    STDMETHOD(COMGETTER(Revision))(ULONG *aRevision);
    STDMETHOD(COMGETTER(PackageType))(BSTR *aPackageType);
    STDMETHOD(COMGETTER(APIVersion))(BSTR *aAPIVersion);
    STDMETHOD(COMGETTER(HomeFolder))(BSTR *aHomeFolder);
    STDMETHOD(COMGETTER(SettingsFilePath))(BSTR *aSettingsFilePath);
    STDMETHOD(COMGETTER(Host))(IHost **aHost);
    STDMETHOD(COMGETTER(SystemProperties))(ISystemProperties **aSystemProperties);
    STDMETHOD(COMGETTER(Machines))(ComSafeArrayOut(IMachine *, aMachines));
    STDMETHOD(COMGETTER(MachineGroups))(ComSafeArrayOut(BSTR, aMachineGroups));
    STDMETHOD(COMGETTER(HardDisks))(ComSafeArrayOut(IMedium *, aHardDisks));
    STDMETHOD(COMGETTER(DVDImages))(ComSafeArrayOut(IMedium *, aDVDImages));
    STDMETHOD(COMGETTER(FloppyImages))(ComSafeArrayOut(IMedium *, aFloppyImages));
    STDMETHOD(COMGETTER(ProgressOperations))(ComSafeArrayOut(IProgress *, aProgressOperations));
    STDMETHOD(COMGETTER(GuestOSTypes))(ComSafeArrayOut(IGuestOSType *, aGuestOSTypes));
    STDMETHOD(COMGETTER(SharedFolders))(ComSafeArrayOut(ISharedFolder *, aSharedFolders));
    STDMETHOD(COMGETTER(PerformanceCollector))(IPerformanceCollector **aPerformanceCollector);
    STDMETHOD(COMGETTER(DHCPServers))(ComSafeArrayOut(IDHCPServer *, aDHCPServers));
    STDMETHOD(COMGETTER(NATNetworks))(ComSafeArrayOut(INATNetwork *, aNATNetworks));
    STDMETHOD(COMGETTER(EventSource))(IEventSource **aEventSource);
    STDMETHOD(COMGETTER(ExtensionPackManager))(IExtPackManager **aExtensionPackManager);
    STDMETHOD(COMGETTER(InternalNetworks))(ComSafeArrayOut(BSTR, aInternalNetworks));
    STDMETHOD(COMGETTER(GenericNetworkDrivers))(ComSafeArrayOut(BSTR, aGenericNetworkDrivers));

    // public IVirtualBox methods
    STDMETHOD(ComposeMachineFilename)(IN_BSTR aName,
                                      IN_BSTR aGroup,
                                      IN_BSTR aCreateFlags,
                                      IN_BSTR aBaseFolder,
                                      BSTR *aFile);
    STDMETHOD(CreateMachine)(IN_BSTR aSettingsFile,
                             IN_BSTR aName,
                             ComSafeArrayIn(IN_BSTR, aGroups),
                             IN_BSTR aOsTypeId,
                             IN_BSTR aFlags,
                             IMachine **aMachine);
    STDMETHOD(OpenMachine)(IN_BSTR aSettingsFile,
                           IMachine **aMachine);
    STDMETHOD(RegisterMachine)(IMachine *aMachine);
    STDMETHOD(FindMachine)(IN_BSTR aNameOrId,
                           IMachine **aMachine);
    STDMETHOD(GetMachinesByGroups)(ComSafeArrayIn(IN_BSTR, aGroups),
                                   ComSafeArrayOut(IMachine *, aMachines));
    STDMETHOD(GetMachineStates)(ComSafeArrayIn(IMachine *, aMachines),
                                ComSafeArrayOut(MachineState_T, aStates));
    STDMETHOD(CreateAppliance)(IAppliance **aAppliance);
    STDMETHOD(CreateHardDisk)(IN_BSTR aFormat,
                              IN_BSTR aLocation,
                              IMedium **aMedium);
    STDMETHOD(OpenMedium)(IN_BSTR aLocation,
                          DeviceType_T aDeviceType,
                          AccessMode_T aAccessMode,
                          BOOL aForceNewUuid,
                          IMedium **aMedium);
    STDMETHOD(GetGuestOSType)(IN_BSTR aId,
                              IGuestOSType **aType);
    STDMETHOD(CreateSharedFolder)(IN_BSTR aName,
                                  IN_BSTR aHostPath,
                                  BOOL aWritable,
                                  BOOL aAutomount);
    STDMETHOD(RemoveSharedFolder)(IN_BSTR aName);
    STDMETHOD(GetExtraDataKeys)(ComSafeArrayOut(BSTR, aKeys));
    STDMETHOD(GetExtraData)(IN_BSTR aKey,
                            BSTR *aValue);
    STDMETHOD(SetExtraData)(IN_BSTR aKey,
                            IN_BSTR aValue);
    STDMETHOD(SetSettingsSecret)(IN_BSTR aPassword);
    STDMETHOD(CreateDHCPServer)(IN_BSTR aName,
                                IDHCPServer **aServer);
    STDMETHOD(FindDHCPServerByNetworkName)(IN_BSTR aName,
                                           IDHCPServer **aServer);
    STDMETHOD(RemoveDHCPServer)(IDHCPServer *aServer);
    STDMETHOD(CreateNATNetwork)(IN_BSTR aNetworkName,
                                INATNetwork **aNetwork);
    STDMETHOD(FindNATNetworkByName)(IN_BSTR aNetworkName,
                                    INATNetwork **aNetwork);
    STDMETHOD(RemoveNATNetwork)(INATNetwork *aNetwork);
    STDMETHOD(CheckFirmwarePresent)(FirmwareType_T aFirmwareType,
                                    IN_BSTR aVersion,
                                    BSTR *aUrl,
                                    BSTR *aFile,
                                    BOOL *aResult);

private:
    // wrapped IVirtualBox properties
    virtual HRESULT getVersion(com::Utf8Str &aVersion) = 0;
    virtual HRESULT getVersionNormalized(com::Utf8Str &aVersionNormalized) = 0;
    virtual HRESULT getRevision(ULONG *aRevision) = 0;
    virtual HRESULT getPackageType(com::Utf8Str &aPackageType) = 0;
    virtual HRESULT getAPIVersion(com::Utf8Str &aAPIVersion) = 0;
    virtual HRESULT getHomeFolder(com::Utf8Str &aHomeFolder) = 0;
    virtual HRESULT getSettingsFilePath(com::Utf8Str &aSettingsFilePath) = 0;
    virtual HRESULT getHost(ComPtr<IHost> &aHost) = 0;
    virtual HRESULT getSystemProperties(ComPtr<ISystemProperties> &aSystemProperties) = 0;
    virtual HRESULT getMachines(std::vector<ComPtr<IMachine> > &aMachines) = 0;
    virtual HRESULT getMachineGroups(std::vector<com::Utf8Str> &aMachineGroups) = 0;
    virtual HRESULT getHardDisks(std::vector<ComPtr<IMedium> > &aHardDisks) = 0;
    virtual HRESULT getDVDImages(std::vector<ComPtr<IMedium> > &aDVDImages) = 0;
    virtual HRESULT getFloppyImages(std::vector<ComPtr<IMedium> > &aFloppyImages) = 0;
    virtual HRESULT getProgressOperations(std::vector<ComPtr<IProgress> > &aProgressOperations) = 0;
    virtual HRESULT getGuestOSTypes(std::vector<ComPtr<IGuestOSType> > &aGuestOSTypes) = 0;
    virtual HRESULT getSharedFolders(std::vector<ComPtr<ISharedFolder> > &aSharedFolders) = 0;
    virtual HRESULT getPerformanceCollector(ComPtr<IPerformanceCollector> &aPerformanceCollector) = 0;
    virtual HRESULT getDHCPServers(std::vector<ComPtr<IDHCPServer> > &aDHCPServers) = 0;
    virtual HRESULT getNATNetworks(std::vector<ComPtr<INATNetwork> > &aNATNetworks) = 0;
    virtual HRESULT getEventSource(ComPtr<IEventSource> &aEventSource) = 0;
    virtual HRESULT getExtensionPackManager(ComPtr<IExtPackManager> &aExtensionPackManager) = 0;
    virtual HRESULT getInternalNetworks(std::vector<com::Utf8Str> &aInternalNetworks) = 0;
    virtual HRESULT getGenericNetworkDrivers(std::vector<com::Utf8Str> &aGenericNetworkDrivers) = 0;

    // wrapped IVirtualBox methods
    virtual HRESULT composeMachineFilename(const com::Utf8Str &aName,
                                           const com::Utf8Str &aGroup,
                                           const com::Utf8Str &aCreateFlags,
                                           const com::Utf8Str &aBaseFolder,
                                           com::Utf8Str &aFile) = 0;
    virtual HRESULT createMachine(const com::Utf8Str &aSettingsFile,
                                  const com::Utf8Str &aName,
                                  const std::vector<com::Utf8Str> &aGroups,
                                  const com::Utf8Str &aOsTypeId,
                                  const com::Utf8Str &aFlags,
                                  ComPtr<IMachine> &aMachine) = 0;
    virtual HRESULT openMachine(const com::Utf8Str &aSettingsFile,
                                ComPtr<IMachine> &aMachine) = 0;
    virtual HRESULT registerMachine(const ComPtr<IMachine> &aMachine) = 0;
    virtual HRESULT findMachine(const com::Utf8Str &aNameOrId,
                                ComPtr<IMachine> &aMachine) = 0;
    virtual HRESULT getMachinesByGroups(const std::vector<com::Utf8Str> &aGroups,
                                        std::vector<ComPtr<IMachine> > &aMachines) = 0;
    virtual HRESULT getMachineStates(const std::vector<ComPtr<IMachine> > &aMachines,
                                     std::vector<MachineState_T> &aStates) = 0;
    virtual HRESULT createAppliance(ComPtr<IAppliance> &aAppliance) = 0;
    virtual HRESULT createHardDisk(const com::Utf8Str &aFormat,
                                   const com::Utf8Str &aLocation,
                                   ComPtr<IMedium> &aMedium) = 0;
    virtual HRESULT openMedium(const com::Utf8Str &aLocation,
                               DeviceType_T aDeviceType,
                               AccessMode_T aAccessMode,
                               BOOL aForceNewUuid,
                               ComPtr<IMedium> &aMedium) = 0;
    virtual HRESULT getGuestOSType(const com::Guid &aId,
                                   ComPtr<IGuestOSType> &aType) = 0;
    virtual HRESULT createSharedFolder(const com::Utf8Str &aName,
                                       const com::Utf8Str &aHostPath,
                                       BOOL aWritable,
                                       BOOL aAutomount) = 0;
    virtual HRESULT removeSharedFolder(const com::Utf8Str &aName) = 0;
    virtual HRESULT getExtraDataKeys(std::vector<com::Utf8Str> &aKeys) = 0;
    virtual HRESULT getExtraData(const com::Utf8Str &aKey,
                                 com::Utf8Str &aValue) = 0;
    virtual HRESULT setExtraData(const com::Utf8Str &aKey,
                                 const com::Utf8Str &aValue) = 0;
    virtual HRESULT setSettingsSecret(const com::Utf8Str &aPassword) = 0;
    virtual HRESULT createDHCPServer(const com::Utf8Str &aName,
                                     ComPtr<IDHCPServer> &aServer) = 0;
    virtual HRESULT findDHCPServerByNetworkName(const com::Utf8Str &aName,
                                                ComPtr<IDHCPServer> &aServer) = 0;
    virtual HRESULT removeDHCPServer(const ComPtr<IDHCPServer> &aServer) = 0;
    virtual HRESULT createNATNetwork(const com::Utf8Str &aNetworkName,
                                     ComPtr<INATNetwork> &aNetwork) = 0;
    virtual HRESULT findNATNetworkByName(const com::Utf8Str &aNetworkName,
                                         ComPtr<INATNetwork> &aNetwork) = 0;
    virtual HRESULT removeNATNetwork(const ComPtr<INATNetwork> &aNetwork) = 0;
    virtual HRESULT checkFirmwarePresent(FirmwareType_T aFirmwareType,
                                         const com::Utf8Str &aVersion,
                                         com::Utf8Str &aUrl,
                                         com::Utf8Str &aFile,
                                         BOOL *aResult) = 0;
};

#endif // !VirtualBoxWrap_H_

// ##### ENDFILE "VirtualBoxWrap.h"

// ##### BEGINFILE "VirtualBoxWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IVirtualBox.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_VIRTUALBOX

#include "VirtualBoxWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(VirtualBoxWrap)

//
// IVirtualBox properties
//

STDMETHODIMP VirtualBoxWrap::COMGETTER(Version)(BSTR *aVersion)
{
    LogRelFlow(("{%p} %s: enter aVersion=%p\n", this, "VirtualBox::getVersion", aVersion));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVersion);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVersion(BSTROutConverter(aVersion).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVersion=%ls hrc=%Rhrc\n", this, "VirtualBox::getVersion", *aVersion, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(VersionNormalized)(BSTR *aVersionNormalized)
{
    LogRelFlow(("{%p} %s: enter aVersionNormalized=%p\n", this, "VirtualBox::getVersionNormalized", aVersionNormalized));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVersionNormalized);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVersionNormalized(BSTROutConverter(aVersionNormalized).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVersionNormalized=%ls hrc=%Rhrc\n", this, "VirtualBox::getVersionNormalized", *aVersionNormalized, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(Revision)(ULONG *aRevision)
{
    LogRelFlow(("{%p} %s: enter aRevision=%p\n", this, "VirtualBox::getRevision", aRevision));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRevision);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRevision(aRevision);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRevision=%RU32 hrc=%Rhrc\n", this, "VirtualBox::getRevision", *aRevision, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(PackageType)(BSTR *aPackageType)
{
    LogRelFlow(("{%p} %s: enter aPackageType=%p\n", this, "VirtualBox::getPackageType", aPackageType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPackageType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPackageType(BSTROutConverter(aPackageType).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPackageType=%ls hrc=%Rhrc\n", this, "VirtualBox::getPackageType", *aPackageType, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(APIVersion)(BSTR *aAPIVersion)
{
    LogRelFlow(("{%p} %s: enter aAPIVersion=%p\n", this, "VirtualBox::getAPIVersion", aAPIVersion));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAPIVersion);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAPIVersion(BSTROutConverter(aAPIVersion).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAPIVersion=%ls hrc=%Rhrc\n", this, "VirtualBox::getAPIVersion", *aAPIVersion, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(HomeFolder)(BSTR *aHomeFolder)
{
    LogRelFlow(("{%p} %s: enter aHomeFolder=%p\n", this, "VirtualBox::getHomeFolder", aHomeFolder));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHomeFolder);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHomeFolder(BSTROutConverter(aHomeFolder).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHomeFolder=%ls hrc=%Rhrc\n", this, "VirtualBox::getHomeFolder", *aHomeFolder, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(SettingsFilePath)(BSTR *aSettingsFilePath)
{
    LogRelFlow(("{%p} %s: enter aSettingsFilePath=%p\n", this, "VirtualBox::getSettingsFilePath", aSettingsFilePath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSettingsFilePath);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSettingsFilePath(BSTROutConverter(aSettingsFilePath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSettingsFilePath=%ls hrc=%Rhrc\n", this, "VirtualBox::getSettingsFilePath", *aSettingsFilePath, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(Host)(IHost **aHost)
{
    LogRelFlow(("{%p} %s: enter aHost=%p\n", this, "VirtualBox::getHost", aHost));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHost);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHost(ComTypeOutConverter<IHost>(aHost).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHost=%p hrc=%Rhrc\n", this, "VirtualBox::getHost", *aHost, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(SystemProperties)(ISystemProperties **aSystemProperties)
{
    LogRelFlow(("{%p} %s: enter aSystemProperties=%p\n", this, "VirtualBox::getSystemProperties", aSystemProperties));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSystemProperties);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSystemProperties(ComTypeOutConverter<ISystemProperties>(aSystemProperties).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSystemProperties=%p hrc=%Rhrc\n", this, "VirtualBox::getSystemProperties", *aSystemProperties, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(Machines)(ComSafeArrayOut(IMachine *, aMachines))
{
    LogRelFlow(("{%p} %s: enter aMachines=%p\n", this, "VirtualBox::getMachines", aMachines));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachines);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachines(ArrayComTypeOutConverter<IMachine>(ComSafeArrayOutArg(aMachines)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachines=%zu hrc=%Rhrc\n", this, "VirtualBox::getMachines", ComSafeArraySize(*aMachines), hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(MachineGroups)(ComSafeArrayOut(BSTR, aMachineGroups))
{
    LogRelFlow(("{%p} %s: enter aMachineGroups=%p\n", this, "VirtualBox::getMachineGroups", aMachineGroups));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachineGroups);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachineGroups(ArrayBSTROutConverter(ComSafeArrayOutArg(aMachineGroups)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachineGroups=%zu hrc=%Rhrc\n", this, "VirtualBox::getMachineGroups", ComSafeArraySize(*aMachineGroups), hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(HardDisks)(ComSafeArrayOut(IMedium *, aHardDisks))
{
    LogRelFlow(("{%p} %s: enter aHardDisks=%p\n", this, "VirtualBox::getHardDisks", aHardDisks));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHardDisks);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHardDisks(ArrayComTypeOutConverter<IMedium>(ComSafeArrayOutArg(aHardDisks)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHardDisks=%zu hrc=%Rhrc\n", this, "VirtualBox::getHardDisks", ComSafeArraySize(*aHardDisks), hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(DVDImages)(ComSafeArrayOut(IMedium *, aDVDImages))
{
    LogRelFlow(("{%p} %s: enter aDVDImages=%p\n", this, "VirtualBox::getDVDImages", aDVDImages));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDVDImages);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDVDImages(ArrayComTypeOutConverter<IMedium>(ComSafeArrayOutArg(aDVDImages)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDVDImages=%zu hrc=%Rhrc\n", this, "VirtualBox::getDVDImages", ComSafeArraySize(*aDVDImages), hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(FloppyImages)(ComSafeArrayOut(IMedium *, aFloppyImages))
{
    LogRelFlow(("{%p} %s: enter aFloppyImages=%p\n", this, "VirtualBox::getFloppyImages", aFloppyImages));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFloppyImages);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFloppyImages(ArrayComTypeOutConverter<IMedium>(ComSafeArrayOutArg(aFloppyImages)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFloppyImages=%zu hrc=%Rhrc\n", this, "VirtualBox::getFloppyImages", ComSafeArraySize(*aFloppyImages), hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(ProgressOperations)(ComSafeArrayOut(IProgress *, aProgressOperations))
{
    LogRelFlow(("{%p} %s: enter aProgressOperations=%p\n", this, "VirtualBox::getProgressOperations", aProgressOperations));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgressOperations);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProgressOperations(ArrayComTypeOutConverter<IProgress>(ComSafeArrayOutArg(aProgressOperations)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProgressOperations=%zu hrc=%Rhrc\n", this, "VirtualBox::getProgressOperations", ComSafeArraySize(*aProgressOperations), hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(GuestOSTypes)(ComSafeArrayOut(IGuestOSType *, aGuestOSTypes))
{
    LogRelFlow(("{%p} %s: enter aGuestOSTypes=%p\n", this, "VirtualBox::getGuestOSTypes", aGuestOSTypes));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGuestOSTypes);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGuestOSTypes(ArrayComTypeOutConverter<IGuestOSType>(ComSafeArrayOutArg(aGuestOSTypes)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGuestOSTypes=%zu hrc=%Rhrc\n", this, "VirtualBox::getGuestOSTypes", ComSafeArraySize(*aGuestOSTypes), hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(SharedFolders)(ComSafeArrayOut(ISharedFolder *, aSharedFolders))
{
    LogRelFlow(("{%p} %s: enter aSharedFolders=%p\n", this, "VirtualBox::getSharedFolders", aSharedFolders));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSharedFolders);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSharedFolders(ArrayComTypeOutConverter<ISharedFolder>(ComSafeArrayOutArg(aSharedFolders)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSharedFolders=%zu hrc=%Rhrc\n", this, "VirtualBox::getSharedFolders", ComSafeArraySize(*aSharedFolders), hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(PerformanceCollector)(IPerformanceCollector **aPerformanceCollector)
{
    LogRelFlow(("{%p} %s: enter aPerformanceCollector=%p\n", this, "VirtualBox::getPerformanceCollector", aPerformanceCollector));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPerformanceCollector);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPerformanceCollector(ComTypeOutConverter<IPerformanceCollector>(aPerformanceCollector).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPerformanceCollector=%p hrc=%Rhrc\n", this, "VirtualBox::getPerformanceCollector", *aPerformanceCollector, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(DHCPServers)(ComSafeArrayOut(IDHCPServer *, aDHCPServers))
{
    LogRelFlow(("{%p} %s: enter aDHCPServers=%p\n", this, "VirtualBox::getDHCPServers", aDHCPServers));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDHCPServers);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDHCPServers(ArrayComTypeOutConverter<IDHCPServer>(ComSafeArrayOutArg(aDHCPServers)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDHCPServers=%zu hrc=%Rhrc\n", this, "VirtualBox::getDHCPServers", ComSafeArraySize(*aDHCPServers), hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(NATNetworks)(ComSafeArrayOut(INATNetwork *, aNATNetworks))
{
    LogRelFlow(("{%p} %s: enter aNATNetworks=%p\n", this, "VirtualBox::getNATNetworks", aNATNetworks));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNATNetworks);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNATNetworks(ArrayComTypeOutConverter<INATNetwork>(ComSafeArrayOutArg(aNATNetworks)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNATNetworks=%zu hrc=%Rhrc\n", this, "VirtualBox::getNATNetworks", ComSafeArraySize(*aNATNetworks), hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(EventSource)(IEventSource **aEventSource)
{
    LogRelFlow(("{%p} %s: enter aEventSource=%p\n", this, "VirtualBox::getEventSource", aEventSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEventSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEventSource(ComTypeOutConverter<IEventSource>(aEventSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEventSource=%p hrc=%Rhrc\n", this, "VirtualBox::getEventSource", *aEventSource, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(ExtensionPackManager)(IExtPackManager **aExtensionPackManager)
{
    LogRelFlow(("{%p} %s: enter aExtensionPackManager=%p\n", this, "VirtualBox::getExtensionPackManager", aExtensionPackManager));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aExtensionPackManager);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getExtensionPackManager(ComTypeOutConverter<IExtPackManager>(aExtensionPackManager).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aExtensionPackManager=%p hrc=%Rhrc\n", this, "VirtualBox::getExtensionPackManager", *aExtensionPackManager, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(InternalNetworks)(ComSafeArrayOut(BSTR, aInternalNetworks))
{
    LogRelFlow(("{%p} %s: enter aInternalNetworks=%p\n", this, "VirtualBox::getInternalNetworks", aInternalNetworks));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aInternalNetworks);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getInternalNetworks(ArrayBSTROutConverter(ComSafeArrayOutArg(aInternalNetworks)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aInternalNetworks=%zu hrc=%Rhrc\n", this, "VirtualBox::getInternalNetworks", ComSafeArraySize(*aInternalNetworks), hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::COMGETTER(GenericNetworkDrivers)(ComSafeArrayOut(BSTR, aGenericNetworkDrivers))
{
    LogRelFlow(("{%p} %s: enter aGenericNetworkDrivers=%p\n", this, "VirtualBox::getGenericNetworkDrivers", aGenericNetworkDrivers));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGenericNetworkDrivers);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGenericNetworkDrivers(ArrayBSTROutConverter(ComSafeArrayOutArg(aGenericNetworkDrivers)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGenericNetworkDrivers=%zu hrc=%Rhrc\n", this, "VirtualBox::getGenericNetworkDrivers", ComSafeArraySize(*aGenericNetworkDrivers), hrc));
    return hrc;
}

//
// IVirtualBox methods
//

STDMETHODIMP VirtualBoxWrap::ComposeMachineFilename(IN_BSTR aName,
                                                    IN_BSTR aGroup,
                                                    IN_BSTR aCreateFlags,
                                                    IN_BSTR aBaseFolder,
                                                    BSTR *aFile)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aGroup=%ls aCreateFlags=%ls aBaseFolder=%ls aFile=%p\n", this, "VirtualBox::composeMachineFilename", aName, aGroup, aCreateFlags, aBaseFolder, aFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFile);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = composeMachineFilename(BSTRInConverter(aName).str(),
                                     BSTRInConverter(aGroup).str(),
                                     BSTRInConverter(aCreateFlags).str(),
                                     BSTRInConverter(aBaseFolder).str(),
                                     BSTROutConverter(aFile).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aFile=%ls hrc=%Rhrc\n", this, "VirtualBox::composeMachineFilename", *aFile, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::CreateMachine(IN_BSTR aSettingsFile,
                                           IN_BSTR aName,
                                           ComSafeArrayIn(IN_BSTR, aGroups),
                                           IN_BSTR aOsTypeId,
                                           IN_BSTR aFlags,
                                           IMachine **aMachine)
{
    LogRelFlow(("{%p} %s:enter aSettingsFile=%ls aName=%ls aGroups=%zu aOsTypeId=%ls aFlags=%ls aMachine=%p\n", this, "VirtualBox::createMachine", aSettingsFile, aName, aGroups, aOsTypeId, aFlags, aMachine));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachine);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = createMachine(BSTRInConverter(aSettingsFile).str(),
                            BSTRInConverter(aName).str(),
                            ArrayBSTRInConverter(ComSafeArrayInArg(aGroups)).array(),
                            BSTRInConverter(aOsTypeId).str(),
                            BSTRInConverter(aFlags).str(),
                            ComTypeOutConverter<IMachine>(aMachine).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aMachine=%p hrc=%Rhrc\n", this, "VirtualBox::createMachine", *aMachine, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::OpenMachine(IN_BSTR aSettingsFile,
                                         IMachine **aMachine)
{
    LogRelFlow(("{%p} %s:enter aSettingsFile=%ls aMachine=%p\n", this, "VirtualBox::openMachine", aSettingsFile, aMachine));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachine);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = openMachine(BSTRInConverter(aSettingsFile).str(),
                          ComTypeOutConverter<IMachine>(aMachine).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aMachine=%p hrc=%Rhrc\n", this, "VirtualBox::openMachine", *aMachine, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::RegisterMachine(IMachine *aMachine)
{
    LogRelFlow(("{%p} %s:enter aMachine=%p\n", this, "VirtualBox::registerMachine", aMachine));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = registerMachine(ComTypeInConverter<IMachine>(aMachine).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VirtualBox::registerMachine", hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::FindMachine(IN_BSTR aNameOrId,
                                         IMachine **aMachine)
{
    LogRelFlow(("{%p} %s:enter aNameOrId=%ls aMachine=%p\n", this, "VirtualBox::findMachine", aNameOrId, aMachine));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachine);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = findMachine(BSTRInConverter(aNameOrId).str(),
                          ComTypeOutConverter<IMachine>(aMachine).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aMachine=%p hrc=%Rhrc\n", this, "VirtualBox::findMachine", *aMachine, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::GetMachinesByGroups(ComSafeArrayIn(IN_BSTR, aGroups),
                                                 ComSafeArrayOut(IMachine *, aMachines))
{
    LogRelFlow(("{%p} %s:enter aGroups=%zu aMachines=%p\n", this, "VirtualBox::getMachinesByGroups", aGroups, aMachines));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachines);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachinesByGroups(ArrayBSTRInConverter(ComSafeArrayInArg(aGroups)).array(),
                                  ArrayComTypeOutConverter<IMachine>(ComSafeArrayOutArg(aMachines)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aMachines=%zu hrc=%Rhrc\n", this, "VirtualBox::getMachinesByGroups", ComSafeArraySize(*aMachines), hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::GetMachineStates(ComSafeArrayIn(IMachine *, aMachines),
                                              ComSafeArrayOut(MachineState_T, aStates))
{
    LogRelFlow(("{%p} %s:enter aMachines=%zu aStates=%p\n", this, "VirtualBox::getMachineStates", aMachines, aStates));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStates);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachineStates(ArrayComTypeInConverter<IMachine>(ComSafeArrayInArg(aMachines)).array(),
                               ArrayOutConverter<MachineState_T>(ComSafeArrayOutArg(aStates)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aStates=%zu hrc=%Rhrc\n", this, "VirtualBox::getMachineStates", ComSafeArraySize(*aStates), hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::CreateAppliance(IAppliance **aAppliance)
{
    LogRelFlow(("{%p} %s:enter aAppliance=%p\n", this, "VirtualBox::createAppliance", aAppliance));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAppliance);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = createAppliance(ComTypeOutConverter<IAppliance>(aAppliance).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aAppliance=%p hrc=%Rhrc\n", this, "VirtualBox::createAppliance", *aAppliance, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::CreateHardDisk(IN_BSTR aFormat,
                                            IN_BSTR aLocation,
                                            IMedium **aMedium)
{
    LogRelFlow(("{%p} %s:enter aFormat=%ls aLocation=%ls aMedium=%p\n", this, "VirtualBox::createHardDisk", aFormat, aLocation, aMedium));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMedium);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = createHardDisk(BSTRInConverter(aFormat).str(),
                             BSTRInConverter(aLocation).str(),
                             ComTypeOutConverter<IMedium>(aMedium).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aMedium=%p hrc=%Rhrc\n", this, "VirtualBox::createHardDisk", *aMedium, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::OpenMedium(IN_BSTR aLocation,
                                        DeviceType_T aDeviceType,
                                        AccessMode_T aAccessMode,
                                        BOOL aForceNewUuid,
                                        IMedium **aMedium)
{
    LogRelFlow(("{%p} %s:enter aLocation=%ls aDeviceType=%RU32 aAccessMode=%RU32 aForceNewUuid=%RTbool aMedium=%p\n", this, "VirtualBox::openMedium", aLocation, aDeviceType, aAccessMode, aForceNewUuid, aMedium));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMedium);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = openMedium(BSTRInConverter(aLocation).str(),
                         aDeviceType,
                         aAccessMode,
                         aForceNewUuid,
                         ComTypeOutConverter<IMedium>(aMedium).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aMedium=%p hrc=%Rhrc\n", this, "VirtualBox::openMedium", *aMedium, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::GetGuestOSType(IN_BSTR aId,
                                            IGuestOSType **aType)
{
    LogRelFlow(("{%p} %s:enter aId=%ls aType=%p\n", this, "VirtualBox::getGuestOSType", aId, aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGuestOSType(UuidInConverter(aId).uuid(),
                             ComTypeOutConverter<IGuestOSType>(aType).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aType=%p hrc=%Rhrc\n", this, "VirtualBox::getGuestOSType", *aType, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::CreateSharedFolder(IN_BSTR aName,
                                                IN_BSTR aHostPath,
                                                BOOL aWritable,
                                                BOOL aAutomount)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aHostPath=%ls aWritable=%RTbool aAutomount=%RTbool\n", this, "VirtualBox::createSharedFolder", aName, aHostPath, aWritable, aAutomount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = createSharedFolder(BSTRInConverter(aName).str(),
                                 BSTRInConverter(aHostPath).str(),
                                 aWritable,
                                 aAutomount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VirtualBox::createSharedFolder", hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::RemoveSharedFolder(IN_BSTR aName)
{
    LogRelFlow(("{%p} %s:enter aName=%ls\n", this, "VirtualBox::removeSharedFolder", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = removeSharedFolder(BSTRInConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VirtualBox::removeSharedFolder", hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::GetExtraDataKeys(ComSafeArrayOut(BSTR, aKeys))
{
    LogRelFlow(("{%p} %s:enter aKeys=%p\n", this, "VirtualBox::getExtraDataKeys", aKeys));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aKeys);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getExtraDataKeys(ArrayBSTROutConverter(ComSafeArrayOutArg(aKeys)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aKeys=%zu hrc=%Rhrc\n", this, "VirtualBox::getExtraDataKeys", ComSafeArraySize(*aKeys), hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::GetExtraData(IN_BSTR aKey,
                                          BSTR *aValue)
{
    LogRelFlow(("{%p} %s:enter aKey=%ls aValue=%p\n", this, "VirtualBox::getExtraData", aKey, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aValue);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getExtraData(BSTRInConverter(aKey).str(),
                           BSTROutConverter(aValue).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aValue=%ls hrc=%Rhrc\n", this, "VirtualBox::getExtraData", *aValue, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::SetExtraData(IN_BSTR aKey,
                                          IN_BSTR aValue)
{
    LogRelFlow(("{%p} %s:enter aKey=%ls aValue=%ls\n", this, "VirtualBox::setExtraData", aKey, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setExtraData(BSTRInConverter(aKey).str(),
                           BSTRInConverter(aValue).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VirtualBox::setExtraData", hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::SetSettingsSecret(IN_BSTR aPassword)
{
    LogRelFlow(("{%p} %s:enter aPassword=%ls\n", this, "VirtualBox::setSettingsSecret", aPassword));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setSettingsSecret(BSTRInConverter(aPassword).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VirtualBox::setSettingsSecret", hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::CreateDHCPServer(IN_BSTR aName,
                                              IDHCPServer **aServer)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aServer=%p\n", this, "VirtualBox::createDHCPServer", aName, aServer));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aServer);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = createDHCPServer(BSTRInConverter(aName).str(),
                               ComTypeOutConverter<IDHCPServer>(aServer).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aServer=%p hrc=%Rhrc\n", this, "VirtualBox::createDHCPServer", *aServer, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::FindDHCPServerByNetworkName(IN_BSTR aName,
                                                         IDHCPServer **aServer)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aServer=%p\n", this, "VirtualBox::findDHCPServerByNetworkName", aName, aServer));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aServer);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = findDHCPServerByNetworkName(BSTRInConverter(aName).str(),
                                          ComTypeOutConverter<IDHCPServer>(aServer).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aServer=%p hrc=%Rhrc\n", this, "VirtualBox::findDHCPServerByNetworkName", *aServer, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::RemoveDHCPServer(IDHCPServer *aServer)
{
    LogRelFlow(("{%p} %s:enter aServer=%p\n", this, "VirtualBox::removeDHCPServer", aServer));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = removeDHCPServer(ComTypeInConverter<IDHCPServer>(aServer).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VirtualBox::removeDHCPServer", hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::CreateNATNetwork(IN_BSTR aNetworkName,
                                              INATNetwork **aNetwork)
{
    LogRelFlow(("{%p} %s:enter aNetworkName=%ls aNetwork=%p\n", this, "VirtualBox::createNATNetwork", aNetworkName, aNetwork));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNetwork);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = createNATNetwork(BSTRInConverter(aNetworkName).str(),
                               ComTypeOutConverter<INATNetwork>(aNetwork).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aNetwork=%p hrc=%Rhrc\n", this, "VirtualBox::createNATNetwork", *aNetwork, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::FindNATNetworkByName(IN_BSTR aNetworkName,
                                                  INATNetwork **aNetwork)
{
    LogRelFlow(("{%p} %s:enter aNetworkName=%ls aNetwork=%p\n", this, "VirtualBox::findNATNetworkByName", aNetworkName, aNetwork));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNetwork);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = findNATNetworkByName(BSTRInConverter(aNetworkName).str(),
                                   ComTypeOutConverter<INATNetwork>(aNetwork).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aNetwork=%p hrc=%Rhrc\n", this, "VirtualBox::findNATNetworkByName", *aNetwork, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::RemoveNATNetwork(INATNetwork *aNetwork)
{
    LogRelFlow(("{%p} %s:enter aNetwork=%p\n", this, "VirtualBox::removeNATNetwork", aNetwork));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = removeNATNetwork(ComTypeInConverter<INATNetwork>(aNetwork).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VirtualBox::removeNATNetwork", hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxWrap::CheckFirmwarePresent(FirmwareType_T aFirmwareType,
                                                  IN_BSTR aVersion,
                                                  BSTR *aUrl,
                                                  BSTR *aFile,
                                                  BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aFirmwareType=%RU32 aVersion=%ls aUrl=%p aFile=%p aResult=%p\n", this, "VirtualBox::checkFirmwarePresent", aFirmwareType, aVersion, aUrl, aFile, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUrl);
        CheckComArgOutPointerValidThrow(aFile);
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = checkFirmwarePresent(aFirmwareType,
                                   BSTRInConverter(aVersion).str(),
                                   BSTROutConverter(aUrl).str(),
                                   BSTROutConverter(aFile).str(),
                                   aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUrl=%ls *aFile=%ls aResult=%RTbool hrc=%Rhrc\n", this, "VirtualBox::checkFirmwarePresent", *aUrl, *aFile, *aResult, hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(VirtualBoxWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(VirtualBoxWrap, IVirtualBox)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "VirtualBoxWrap.cpp"

// ##### BEGINFILE "VFSExplorerWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IVFSExplorer.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef VFSExplorerWrap_H_
#define VFSExplorerWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE VFSExplorerWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IVFSExplorer)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(VFSExplorerWrap, IVFSExplorer)
    DECLARE_NOT_AGGREGATABLE(VFSExplorerWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(VFSExplorerWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IVFSExplorer)
        COM_INTERFACE_ENTRY2(IDispatch, IVFSExplorer)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(VFSExplorerWrap)

    // public IVFSExplorer properties
    STDMETHOD(COMGETTER(Path))(BSTR *aPath);
    STDMETHOD(COMGETTER(Type))(VFSType_T *aType);

    // public IVFSExplorer methods
    STDMETHOD(Update)(IProgress **aProgress);
    STDMETHOD(Cd)(IN_BSTR aDir,
                  IProgress **aProgress);
    STDMETHOD(CdUp)(IProgress **aProgress);
    STDMETHOD(EntryList)(ComSafeArrayOut(BSTR, aNames),
                         ComSafeArrayOut(ULONG, aTypes),
                         ComSafeArrayOut(LONG64, aSizes),
                         ComSafeArrayOut(ULONG, aModes));
    STDMETHOD(Exists)(ComSafeArrayIn(IN_BSTR, aNames),
                      ComSafeArrayOut(BSTR, aExists));
    STDMETHOD(Remove)(ComSafeArrayIn(IN_BSTR, aNames),
                      IProgress **aProgress);

private:
    // wrapped IVFSExplorer properties
    virtual HRESULT getPath(com::Utf8Str &aPath) = 0;
    virtual HRESULT getType(VFSType_T *aType) = 0;

    // wrapped IVFSExplorer methods
    virtual HRESULT update(ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT cd(const com::Utf8Str &aDir,
                       ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT cdUp(ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT entryList(std::vector<com::Utf8Str> &aNames,
                              std::vector<ULONG> &aTypes,
                              std::vector<LONG64> &aSizes,
                              std::vector<ULONG> &aModes) = 0;
    virtual HRESULT exists(const std::vector<com::Utf8Str> &aNames,
                           std::vector<com::Utf8Str> &aExists) = 0;
    virtual HRESULT remove(const std::vector<com::Utf8Str> &aNames,
                           ComPtr<IProgress> &aProgress) = 0;
};

#endif // !VFSExplorerWrap_H_

// ##### ENDFILE "VFSExplorerWrap.h"

// ##### BEGINFILE "VFSExplorerWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IVFSExplorer.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_VFSEXPLORER

#include "VFSExplorerWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(VFSExplorerWrap)

//
// IVFSExplorer properties
//

STDMETHODIMP VFSExplorerWrap::COMGETTER(Path)(BSTR *aPath)
{
    LogRelFlow(("{%p} %s: enter aPath=%p\n", this, "VFSExplorer::getPath", aPath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPath);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPath(BSTROutConverter(aPath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPath=%ls hrc=%Rhrc\n", this, "VFSExplorer::getPath", *aPath, hrc));
    return hrc;
}

STDMETHODIMP VFSExplorerWrap::COMGETTER(Type)(VFSType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "VFSExplorer::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "VFSExplorer::getType", *aType, hrc));
    return hrc;
}

//
// IVFSExplorer methods
//

STDMETHODIMP VFSExplorerWrap::Update(IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aProgress=%p\n", this, "VFSExplorer::update", aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = update(ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "VFSExplorer::update", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP VFSExplorerWrap::Cd(IN_BSTR aDir,
                                 IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aDir=%ls aProgress=%p\n", this, "VFSExplorer::cd", aDir, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = cd(BSTRInConverter(aDir).str(),
                 ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "VFSExplorer::cd", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP VFSExplorerWrap::CdUp(IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aProgress=%p\n", this, "VFSExplorer::cdUp", aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = cdUp(ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "VFSExplorer::cdUp", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP VFSExplorerWrap::EntryList(ComSafeArrayOut(BSTR, aNames),
                                        ComSafeArrayOut(ULONG, aTypes),
                                        ComSafeArrayOut(LONG64, aSizes),
                                        ComSafeArrayOut(ULONG, aModes))
{
    LogRelFlow(("{%p} %s:enter aNames=%p aTypes=%p aSizes=%p aModes=%p\n", this, "VFSExplorer::entryList", aNames, aTypes, aSizes, aModes));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNames);
        CheckComArgOutPointerValidThrow(aTypes);
        CheckComArgOutPointerValidThrow(aSizes);
        CheckComArgOutPointerValidThrow(aModes);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = entryList(ArrayBSTROutConverter(ComSafeArrayOutArg(aNames)).array(),
                        ArrayOutConverter<ULONG>(ComSafeArrayOutArg(aTypes)).array(),
                        ArrayOutConverter<LONG64>(ComSafeArrayOutArg(aSizes)).array(),
                        ArrayOutConverter<ULONG>(ComSafeArrayOutArg(aModes)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNames=%zu *aTypes=%zu *aSizes=%zu *aModes=%zu hrc=%Rhrc\n", this, "VFSExplorer::entryList", ComSafeArraySize(*aNames), ComSafeArraySize(*aTypes), ComSafeArraySize(*aSizes), ComSafeArraySize(*aModes), hrc));
    return hrc;
}

STDMETHODIMP VFSExplorerWrap::Exists(ComSafeArrayIn(IN_BSTR, aNames),
                                     ComSafeArrayOut(BSTR, aExists))
{
    LogRelFlow(("{%p} %s:enter aNames=%zu aExists=%p\n", this, "VFSExplorer::exists", aNames, aExists));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aExists);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = exists(ArrayBSTRInConverter(ComSafeArrayInArg(aNames)).array(),
                     ArrayBSTROutConverter(ComSafeArrayOutArg(aExists)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aExists=%zu hrc=%Rhrc\n", this, "VFSExplorer::exists", ComSafeArraySize(*aExists), hrc));
    return hrc;
}

STDMETHODIMP VFSExplorerWrap::Remove(ComSafeArrayIn(IN_BSTR, aNames),
                                     IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aNames=%zu aProgress=%p\n", this, "VFSExplorer::remove", aNames, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = remove(ArrayBSTRInConverter(ComSafeArrayInArg(aNames)).array(),
                     ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "VFSExplorer::remove", *aProgress, hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(VFSExplorerWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(VFSExplorerWrap, IVFSExplorer)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "VFSExplorerWrap.cpp"

// ##### BEGINFILE "ApplianceWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IAppliance.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef ApplianceWrap_H_
#define ApplianceWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE ApplianceWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IAppliance)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(ApplianceWrap, IAppliance)
    DECLARE_NOT_AGGREGATABLE(ApplianceWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(ApplianceWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IAppliance)
        COM_INTERFACE_ENTRY2(IDispatch, IAppliance)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(ApplianceWrap)

    // public IAppliance properties
    STDMETHOD(COMGETTER(Path))(BSTR *aPath);
    STDMETHOD(COMGETTER(Disks))(ComSafeArrayOut(BSTR, aDisks));
    STDMETHOD(COMGETTER(VirtualSystemDescriptions))(ComSafeArrayOut(IVirtualSystemDescription *, aVirtualSystemDescriptions));
    STDMETHOD(COMGETTER(Machines))(ComSafeArrayOut(BSTR, aMachines));

    // public IAppliance methods
    STDMETHOD(Read)(IN_BSTR aFile,
                    IProgress **aProgress);
    STDMETHOD(Interpret)();
    STDMETHOD(ImportMachines)(ComSafeArrayIn(ImportOptions_T, aOptions),
                              IProgress **aProgress);
    STDMETHOD(CreateVFSExplorer)(IN_BSTR aURI,
                                 IVFSExplorer **aExplorer);
    STDMETHOD(Write)(IN_BSTR aFormat,
                     ComSafeArrayIn(ExportOptions_T, aOptions),
                     IN_BSTR aPath,
                     IProgress **aProgress);
    STDMETHOD(GetWarnings)(ComSafeArrayOut(BSTR, aWarnings));

private:
    // wrapped IAppliance properties
    virtual HRESULT getPath(com::Utf8Str &aPath) = 0;
    virtual HRESULT getDisks(std::vector<com::Utf8Str> &aDisks) = 0;
    virtual HRESULT getVirtualSystemDescriptions(std::vector<ComPtr<IVirtualSystemDescription> > &aVirtualSystemDescriptions) = 0;
    virtual HRESULT getMachines(std::vector<com::Utf8Str> &aMachines) = 0;

    // wrapped IAppliance methods
    virtual HRESULT read(const com::Utf8Str &aFile,
                         ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT interpret() = 0;
    virtual HRESULT importMachines(const std::vector<ImportOptions_T> &aOptions,
                                   ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT createVFSExplorer(const com::Utf8Str &aURI,
                                      ComPtr<IVFSExplorer> &aExplorer) = 0;
    virtual HRESULT write(const com::Utf8Str &aFormat,
                          const std::vector<ExportOptions_T> &aOptions,
                          const com::Utf8Str &aPath,
                          ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT getWarnings(std::vector<com::Utf8Str> &aWarnings) = 0;
};

#endif // !ApplianceWrap_H_

// ##### ENDFILE "ApplianceWrap.h"

// ##### BEGINFILE "ApplianceWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IAppliance.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_APPLIANCE

#include "ApplianceWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(ApplianceWrap)

//
// IAppliance properties
//

STDMETHODIMP ApplianceWrap::COMGETTER(Path)(BSTR *aPath)
{
    LogRelFlow(("{%p} %s: enter aPath=%p\n", this, "Appliance::getPath", aPath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPath);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPath(BSTROutConverter(aPath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPath=%ls hrc=%Rhrc\n", this, "Appliance::getPath", *aPath, hrc));
    return hrc;
}

STDMETHODIMP ApplianceWrap::COMGETTER(Disks)(ComSafeArrayOut(BSTR, aDisks))
{
    LogRelFlow(("{%p} %s: enter aDisks=%p\n", this, "Appliance::getDisks", aDisks));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDisks);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDisks(ArrayBSTROutConverter(ComSafeArrayOutArg(aDisks)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDisks=%zu hrc=%Rhrc\n", this, "Appliance::getDisks", ComSafeArraySize(*aDisks), hrc));
    return hrc;
}

STDMETHODIMP ApplianceWrap::COMGETTER(VirtualSystemDescriptions)(ComSafeArrayOut(IVirtualSystemDescription *, aVirtualSystemDescriptions))
{
    LogRelFlow(("{%p} %s: enter aVirtualSystemDescriptions=%p\n", this, "Appliance::getVirtualSystemDescriptions", aVirtualSystemDescriptions));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVirtualSystemDescriptions);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVirtualSystemDescriptions(ArrayComTypeOutConverter<IVirtualSystemDescription>(ComSafeArrayOutArg(aVirtualSystemDescriptions)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVirtualSystemDescriptions=%zu hrc=%Rhrc\n", this, "Appliance::getVirtualSystemDescriptions", ComSafeArraySize(*aVirtualSystemDescriptions), hrc));
    return hrc;
}

STDMETHODIMP ApplianceWrap::COMGETTER(Machines)(ComSafeArrayOut(BSTR, aMachines))
{
    LogRelFlow(("{%p} %s: enter aMachines=%p\n", this, "Appliance::getMachines", aMachines));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachines);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachines(ArrayBSTROutConverter(ComSafeArrayOutArg(aMachines)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachines=%zu hrc=%Rhrc\n", this, "Appliance::getMachines", ComSafeArraySize(*aMachines), hrc));
    return hrc;
}

//
// IAppliance methods
//

STDMETHODIMP ApplianceWrap::Read(IN_BSTR aFile,
                                 IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aFile=%ls aProgress=%p\n", this, "Appliance::read", aFile, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = read(BSTRInConverter(aFile).str(),
                   ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Appliance::read", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP ApplianceWrap::Interpret()
{
    LogRelFlow(("{%p} %s:enter\n", this, "Appliance::interpret"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = interpret();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Appliance::interpret", hrc));
    return hrc;
}

STDMETHODIMP ApplianceWrap::ImportMachines(ComSafeArrayIn(ImportOptions_T, aOptions),
                                           IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aOptions=%zu aProgress=%p\n", this, "Appliance::importMachines", aOptions, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = importMachines(ArrayInConverter<ImportOptions_T>(ComSafeArrayInArg(aOptions)).array(),
                             ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Appliance::importMachines", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP ApplianceWrap::CreateVFSExplorer(IN_BSTR aURI,
                                              IVFSExplorer **aExplorer)
{
    LogRelFlow(("{%p} %s:enter aURI=%ls aExplorer=%p\n", this, "Appliance::createVFSExplorer", aURI, aExplorer));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aExplorer);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = createVFSExplorer(BSTRInConverter(aURI).str(),
                                ComTypeOutConverter<IVFSExplorer>(aExplorer).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aExplorer=%p hrc=%Rhrc\n", this, "Appliance::createVFSExplorer", *aExplorer, hrc));
    return hrc;
}

STDMETHODIMP ApplianceWrap::Write(IN_BSTR aFormat,
                                  ComSafeArrayIn(ExportOptions_T, aOptions),
                                  IN_BSTR aPath,
                                  IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aFormat=%ls aOptions=%zu aPath=%ls aProgress=%p\n", this, "Appliance::write", aFormat, aOptions, aPath, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = write(BSTRInConverter(aFormat).str(),
                    ArrayInConverter<ExportOptions_T>(ComSafeArrayInArg(aOptions)).array(),
                    BSTRInConverter(aPath).str(),
                    ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Appliance::write", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP ApplianceWrap::GetWarnings(ComSafeArrayOut(BSTR, aWarnings))
{
    LogRelFlow(("{%p} %s:enter aWarnings=%p\n", this, "Appliance::getWarnings", aWarnings));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWarnings);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWarnings(ArrayBSTROutConverter(ComSafeArrayOutArg(aWarnings)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aWarnings=%zu hrc=%Rhrc\n", this, "Appliance::getWarnings", ComSafeArraySize(*aWarnings), hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(ApplianceWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(ApplianceWrap, IAppliance)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "ApplianceWrap.cpp"

// ##### BEGINFILE "VirtualSystemDescriptionWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IVirtualSystemDescription.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef VirtualSystemDescriptionWrap_H_
#define VirtualSystemDescriptionWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE VirtualSystemDescriptionWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IVirtualSystemDescription)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(VirtualSystemDescriptionWrap, IVirtualSystemDescription)
    DECLARE_NOT_AGGREGATABLE(VirtualSystemDescriptionWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(VirtualSystemDescriptionWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IVirtualSystemDescription)
        COM_INTERFACE_ENTRY2(IDispatch, IVirtualSystemDescription)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(VirtualSystemDescriptionWrap)

    // public IVirtualSystemDescription properties
    STDMETHOD(COMGETTER(Count))(ULONG *aCount);

    // public IVirtualSystemDescription methods
    STDMETHOD(GetDescription)(ComSafeArrayOut(VirtualSystemDescriptionType_T, aTypes),
                              ComSafeArrayOut(BSTR, aRefs),
                              ComSafeArrayOut(BSTR, aOVFValues),
                              ComSafeArrayOut(BSTR, aVBoxValues),
                              ComSafeArrayOut(BSTR, aExtraConfigValues));
    STDMETHOD(GetDescriptionByType)(VirtualSystemDescriptionType_T aType,
                                    ComSafeArrayOut(VirtualSystemDescriptionType_T, aTypes),
                                    ComSafeArrayOut(BSTR, aRefs),
                                    ComSafeArrayOut(BSTR, aOVFValues),
                                    ComSafeArrayOut(BSTR, aVBoxValues),
                                    ComSafeArrayOut(BSTR, aExtraConfigValues));
    STDMETHOD(GetValuesByType)(VirtualSystemDescriptionType_T aType,
                               VirtualSystemDescriptionValueType_T aWhich,
                               ComSafeArrayOut(BSTR, aValues));
    STDMETHOD(SetFinalValues)(ComSafeArrayIn(BOOL, aEnabled),
                              ComSafeArrayIn(IN_BSTR, aVBoxValues),
                              ComSafeArrayIn(IN_BSTR, aExtraConfigValues));
    STDMETHOD(AddDescription)(VirtualSystemDescriptionType_T aType,
                              IN_BSTR aVBoxValue,
                              IN_BSTR aExtraConfigValue);

private:
    // wrapped IVirtualSystemDescription properties
    virtual HRESULT getCount(ULONG *aCount) = 0;

    // wrapped IVirtualSystemDescription methods
    virtual HRESULT getDescription(std::vector<VirtualSystemDescriptionType_T> &aTypes,
                                   std::vector<com::Utf8Str> &aRefs,
                                   std::vector<com::Utf8Str> &aOVFValues,
                                   std::vector<com::Utf8Str> &aVBoxValues,
                                   std::vector<com::Utf8Str> &aExtraConfigValues) = 0;
    virtual HRESULT getDescriptionByType(VirtualSystemDescriptionType_T aType,
                                         std::vector<VirtualSystemDescriptionType_T> &aTypes,
                                         std::vector<com::Utf8Str> &aRefs,
                                         std::vector<com::Utf8Str> &aOVFValues,
                                         std::vector<com::Utf8Str> &aVBoxValues,
                                         std::vector<com::Utf8Str> &aExtraConfigValues) = 0;
    virtual HRESULT getValuesByType(VirtualSystemDescriptionType_T aType,
                                    VirtualSystemDescriptionValueType_T aWhich,
                                    std::vector<com::Utf8Str> &aValues) = 0;
    virtual HRESULT setFinalValues(const std::vector<BOOL> &aEnabled,
                                   const std::vector<com::Utf8Str> &aVBoxValues,
                                   const std::vector<com::Utf8Str> &aExtraConfigValues) = 0;
    virtual HRESULT addDescription(VirtualSystemDescriptionType_T aType,
                                   const com::Utf8Str &aVBoxValue,
                                   const com::Utf8Str &aExtraConfigValue) = 0;
};

#endif // !VirtualSystemDescriptionWrap_H_

// ##### ENDFILE "VirtualSystemDescriptionWrap.h"

// ##### BEGINFILE "VirtualSystemDescriptionWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IVirtualSystemDescription.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_VIRTUALSYSTEMDESCRIPTION

#include "VirtualSystemDescriptionWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(VirtualSystemDescriptionWrap)

//
// IVirtualSystemDescription properties
//

STDMETHODIMP VirtualSystemDescriptionWrap::COMGETTER(Count)(ULONG *aCount)
{
    LogRelFlow(("{%p} %s: enter aCount=%p\n", this, "VirtualSystemDescription::getCount", aCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getCount(aCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aCount=%RU32 hrc=%Rhrc\n", this, "VirtualSystemDescription::getCount", *aCount, hrc));
    return hrc;
}

//
// IVirtualSystemDescription methods
//

STDMETHODIMP VirtualSystemDescriptionWrap::GetDescription(ComSafeArrayOut(VirtualSystemDescriptionType_T, aTypes),
                                                          ComSafeArrayOut(BSTR, aRefs),
                                                          ComSafeArrayOut(BSTR, aOVFValues),
                                                          ComSafeArrayOut(BSTR, aVBoxValues),
                                                          ComSafeArrayOut(BSTR, aExtraConfigValues))
{
    LogRelFlow(("{%p} %s:enter aTypes=%p aRefs=%p aOVFValues=%p aVBoxValues=%p aExtraConfigValues=%p\n", this, "VirtualSystemDescription::getDescription", aTypes, aRefs, aOVFValues, aVBoxValues, aExtraConfigValues));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aTypes);
        CheckComArgOutPointerValidThrow(aRefs);
        CheckComArgOutPointerValidThrow(aOVFValues);
        CheckComArgOutPointerValidThrow(aVBoxValues);
        CheckComArgOutPointerValidThrow(aExtraConfigValues);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDescription(ArrayOutConverter<VirtualSystemDescriptionType_T>(ComSafeArrayOutArg(aTypes)).array(),
                             ArrayBSTROutConverter(ComSafeArrayOutArg(aRefs)).array(),
                             ArrayBSTROutConverter(ComSafeArrayOutArg(aOVFValues)).array(),
                             ArrayBSTROutConverter(ComSafeArrayOutArg(aVBoxValues)).array(),
                             ArrayBSTROutConverter(ComSafeArrayOutArg(aExtraConfigValues)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aTypes=%zu *aRefs=%zu *aOVFValues=%zu *aVBoxValues=%zu *aExtraConfigValues=%zu hrc=%Rhrc\n", this, "VirtualSystemDescription::getDescription", ComSafeArraySize(*aTypes), ComSafeArraySize(*aRefs), ComSafeArraySize(*aOVFValues), ComSafeArraySize(*aVBoxValues), ComSafeArraySize(*aExtraConfigValues), hrc));
    return hrc;
}

STDMETHODIMP VirtualSystemDescriptionWrap::GetDescriptionByType(VirtualSystemDescriptionType_T aType,
                                                                ComSafeArrayOut(VirtualSystemDescriptionType_T, aTypes),
                                                                ComSafeArrayOut(BSTR, aRefs),
                                                                ComSafeArrayOut(BSTR, aOVFValues),
                                                                ComSafeArrayOut(BSTR, aVBoxValues),
                                                                ComSafeArrayOut(BSTR, aExtraConfigValues))
{
    LogRelFlow(("{%p} %s:enter aType=%RU32 aTypes=%p aRefs=%p aOVFValues=%p aVBoxValues=%p aExtraConfigValues=%p\n", this, "VirtualSystemDescription::getDescriptionByType", aType, aTypes, aRefs, aOVFValues, aVBoxValues, aExtraConfigValues));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aTypes);
        CheckComArgOutPointerValidThrow(aRefs);
        CheckComArgOutPointerValidThrow(aOVFValues);
        CheckComArgOutPointerValidThrow(aVBoxValues);
        CheckComArgOutPointerValidThrow(aExtraConfigValues);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDescriptionByType(aType,
                                   ArrayOutConverter<VirtualSystemDescriptionType_T>(ComSafeArrayOutArg(aTypes)).array(),
                                   ArrayBSTROutConverter(ComSafeArrayOutArg(aRefs)).array(),
                                   ArrayBSTROutConverter(ComSafeArrayOutArg(aOVFValues)).array(),
                                   ArrayBSTROutConverter(ComSafeArrayOutArg(aVBoxValues)).array(),
                                   ArrayBSTROutConverter(ComSafeArrayOutArg(aExtraConfigValues)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aTypes=%zu *aRefs=%zu *aOVFValues=%zu *aVBoxValues=%zu *aExtraConfigValues=%zu hrc=%Rhrc\n", this, "VirtualSystemDescription::getDescriptionByType", ComSafeArraySize(*aTypes), ComSafeArraySize(*aRefs), ComSafeArraySize(*aOVFValues), ComSafeArraySize(*aVBoxValues), ComSafeArraySize(*aExtraConfigValues), hrc));
    return hrc;
}

STDMETHODIMP VirtualSystemDescriptionWrap::GetValuesByType(VirtualSystemDescriptionType_T aType,
                                                           VirtualSystemDescriptionValueType_T aWhich,
                                                           ComSafeArrayOut(BSTR, aValues))
{
    LogRelFlow(("{%p} %s:enter aType=%RU32 aWhich=%RU32 aValues=%p\n", this, "VirtualSystemDescription::getValuesByType", aType, aWhich, aValues));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aValues);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getValuesByType(aType,
                              aWhich,
                              ArrayBSTROutConverter(ComSafeArrayOutArg(aValues)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aValues=%zu hrc=%Rhrc\n", this, "VirtualSystemDescription::getValuesByType", ComSafeArraySize(*aValues), hrc));
    return hrc;
}

STDMETHODIMP VirtualSystemDescriptionWrap::SetFinalValues(ComSafeArrayIn(BOOL, aEnabled),
                                                          ComSafeArrayIn(IN_BSTR, aVBoxValues),
                                                          ComSafeArrayIn(IN_BSTR, aExtraConfigValues))
{
    LogRelFlow(("{%p} %s:enter aEnabled=%zu aVBoxValues=%zu aExtraConfigValues=%zu\n", this, "VirtualSystemDescription::setFinalValues", aEnabled, aVBoxValues, aExtraConfigValues));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setFinalValues(ArrayInConverter<BOOL>(ComSafeArrayInArg(aEnabled)).array(),
                             ArrayBSTRInConverter(ComSafeArrayInArg(aVBoxValues)).array(),
                             ArrayBSTRInConverter(ComSafeArrayInArg(aExtraConfigValues)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VirtualSystemDescription::setFinalValues", hrc));
    return hrc;
}

STDMETHODIMP VirtualSystemDescriptionWrap::AddDescription(VirtualSystemDescriptionType_T aType,
                                                          IN_BSTR aVBoxValue,
                                                          IN_BSTR aExtraConfigValue)
{
    LogRelFlow(("{%p} %s:enter aType=%RU32 aVBoxValue=%ls aExtraConfigValue=%ls\n", this, "VirtualSystemDescription::addDescription", aType, aVBoxValue, aExtraConfigValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = addDescription(aType,
                             BSTRInConverter(aVBoxValue).str(),
                             BSTRInConverter(aExtraConfigValue).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VirtualSystemDescription::addDescription", hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(VirtualSystemDescriptionWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(VirtualSystemDescriptionWrap, IVirtualSystemDescription)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "VirtualSystemDescriptionWrap.cpp"

// ##### BEGINFILE "InternalMachineControlWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IInternalMachineControl.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef InternalMachineControlWrap_H_
#define InternalMachineControlWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE InternalMachineControlWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IInternalMachineControl)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(InternalMachineControlWrap, IInternalMachineControl)
    DECLARE_NOT_AGGREGATABLE(InternalMachineControlWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(InternalMachineControlWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IInternalMachineControl)
        COM_INTERFACE_ENTRY2(IDispatch, IInternalMachineControl)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(InternalMachineControlWrap)

    // public IInternalMachineControl properties

    // public IInternalMachineControl methods
    STDMETHOD(SetRemoveSavedStateFile)(BOOL aRemove);
    STDMETHOD(UpdateState)(MachineState_T aState);
    STDMETHOD(BeginPowerUp)(IProgress *aProgress);
    STDMETHOD(EndPowerUp)(LONG aResult);
    STDMETHOD(BeginPoweringDown)(IProgress **aProgress);
    STDMETHOD(EndPoweringDown)(LONG aResult,
                               IN_BSTR aErrMsg);
    STDMETHOD(RunUSBDeviceFilters)(IUSBDevice *aDevice,
                                   BOOL *aMatched,
                                   ULONG *aMaskedInterfaces);
    STDMETHOD(CaptureUSBDevice)(IN_BSTR aId);
    STDMETHOD(DetachUSBDevice)(IN_BSTR aId,
                               BOOL aDone);
    STDMETHOD(AutoCaptureUSBDevices)();
    STDMETHOD(DetachAllUSBDevices)(BOOL aDone);
    STDMETHOD(OnSessionEnd)(ISession *aSession,
                            IProgress **aProgress);
    STDMETHOD(BeginSavingState)(IProgress **aProgress,
                                BSTR *aStateFilePath);
    STDMETHOD(EndSavingState)(LONG aResult,
                              IN_BSTR aErrMsg);
    STDMETHOD(AdoptSavedState)(IN_BSTR aSavedStateFile);
    STDMETHOD(BeginTakingSnapshot)(IConsole *aInitiator,
                                   IN_BSTR aName,
                                   IN_BSTR aDescription,
                                   IProgress *aConsoleProgress,
                                   BOOL aFTakingSnapshotOnline,
                                   BSTR *aStateFilePath);
    STDMETHOD(EndTakingSnapshot)(BOOL aSuccess);
    STDMETHOD(DeleteSnapshot)(IConsole *aInitiator,
                              IN_BSTR aStartId,
                              IN_BSTR aEndId,
                              BOOL aDeleteAllChildren,
                              MachineState_T *aMachineState,
                              IProgress **aProgress);
    STDMETHOD(FinishOnlineMergeMedium)();
    STDMETHOD(RestoreSnapshot)(IConsole *aInitiator,
                               ISnapshot *aSnapshot,
                               MachineState_T *aMachineState,
                               IProgress **aProgress);
    STDMETHOD(PullGuestProperties)(ComSafeArrayOut(BSTR, aNames),
                                   ComSafeArrayOut(BSTR, aValues),
                                   ComSafeArrayOut(LONG64, aTimestamps),
                                   ComSafeArrayOut(BSTR, aFlags));
    STDMETHOD(PushGuestProperty)(IN_BSTR aName,
                                 IN_BSTR aValue,
                                 LONG64 aTimestamp,
                                 IN_BSTR aFlags);
    STDMETHOD(LockMedia)();
    STDMETHOD(UnlockMedia)();
    STDMETHOD(EjectMedium)(IMediumAttachment *aAttachment,
                           IMediumAttachment **aNewAttachment);
    STDMETHOD(ReportVmStatistics)(ULONG aValidStats,
                                  ULONG aCpuUser,
                                  ULONG aCpuKernel,
                                  ULONG aCpuIdle,
                                  ULONG aMemTotal,
                                  ULONG aMemFree,
                                  ULONG aMemBalloon,
                                  ULONG aMemShared,
                                  ULONG aMemCache,
                                  ULONG aPagedTotal,
                                  ULONG aMemAllocTotal,
                                  ULONG aMemFreeTotal,
                                  ULONG aMemBalloonTotal,
                                  ULONG aMemSharedTotal,
                                  ULONG aVmNetRx,
                                  ULONG aVmNetTx);

private:
    // wrapped IInternalMachineControl properties

    // wrapped IInternalMachineControl methods
    virtual HRESULT setRemoveSavedStateFile(BOOL aRemove) = 0;
    virtual HRESULT updateState(MachineState_T aState) = 0;
    virtual HRESULT beginPowerUp(const ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT endPowerUp(LONG aResult) = 0;
    virtual HRESULT beginPoweringDown(ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT endPoweringDown(LONG aResult,
                                    const com::Utf8Str &aErrMsg) = 0;
    virtual HRESULT runUSBDeviceFilters(const ComPtr<IUSBDevice> &aDevice,
                                        BOOL *aMatched,
                                        ULONG *aMaskedInterfaces) = 0;
    virtual HRESULT captureUSBDevice(const com::Guid &aId) = 0;
    virtual HRESULT detachUSBDevice(const com::Guid &aId,
                                    BOOL aDone) = 0;
    virtual HRESULT autoCaptureUSBDevices() = 0;
    virtual HRESULT detachAllUSBDevices(BOOL aDone) = 0;
    virtual HRESULT onSessionEnd(const ComPtr<ISession> &aSession,
                                 ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT beginSavingState(ComPtr<IProgress> &aProgress,
                                     com::Utf8Str &aStateFilePath) = 0;
    virtual HRESULT endSavingState(LONG aResult,
                                   const com::Utf8Str &aErrMsg) = 0;
    virtual HRESULT adoptSavedState(const com::Utf8Str &aSavedStateFile) = 0;
    virtual HRESULT beginTakingSnapshot(const ComPtr<IConsole> &aInitiator,
                                        const com::Utf8Str &aName,
                                        const com::Utf8Str &aDescription,
                                        const ComPtr<IProgress> &aConsoleProgress,
                                        BOOL aFTakingSnapshotOnline,
                                        com::Utf8Str &aStateFilePath) = 0;
    virtual HRESULT endTakingSnapshot(BOOL aSuccess) = 0;
    virtual HRESULT deleteSnapshot(const ComPtr<IConsole> &aInitiator,
                                   const com::Guid &aStartId,
                                   const com::Guid &aEndId,
                                   BOOL aDeleteAllChildren,
                                   MachineState_T *aMachineState,
                                   ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT finishOnlineMergeMedium() = 0;
    virtual HRESULT restoreSnapshot(const ComPtr<IConsole> &aInitiator,
                                    const ComPtr<ISnapshot> &aSnapshot,
                                    MachineState_T *aMachineState,
                                    ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT pullGuestProperties(std::vector<com::Utf8Str> &aNames,
                                        std::vector<com::Utf8Str> &aValues,
                                        std::vector<LONG64> &aTimestamps,
                                        std::vector<com::Utf8Str> &aFlags) = 0;
    virtual HRESULT pushGuestProperty(const com::Utf8Str &aName,
                                      const com::Utf8Str &aValue,
                                      LONG64 aTimestamp,
                                      const com::Utf8Str &aFlags) = 0;
    virtual HRESULT lockMedia() = 0;
    virtual HRESULT unlockMedia() = 0;
    virtual HRESULT ejectMedium(const ComPtr<IMediumAttachment> &aAttachment,
                                ComPtr<IMediumAttachment> &aNewAttachment) = 0;
    virtual HRESULT reportVmStatistics(ULONG aValidStats,
                                       ULONG aCpuUser,
                                       ULONG aCpuKernel,
                                       ULONG aCpuIdle,
                                       ULONG aMemTotal,
                                       ULONG aMemFree,
                                       ULONG aMemBalloon,
                                       ULONG aMemShared,
                                       ULONG aMemCache,
                                       ULONG aPagedTotal,
                                       ULONG aMemAllocTotal,
                                       ULONG aMemFreeTotal,
                                       ULONG aMemBalloonTotal,
                                       ULONG aMemSharedTotal,
                                       ULONG aVmNetRx,
                                       ULONG aVmNetTx) = 0;
};

#endif // !InternalMachineControlWrap_H_

// ##### ENDFILE "InternalMachineControlWrap.h"

// ##### BEGINFILE "InternalMachineControlWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IInternalMachineControl.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_INTERNALMACHINECONTROL

#include "InternalMachineControlWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(InternalMachineControlWrap)

//
// IInternalMachineControl properties
//

//
// IInternalMachineControl methods
//

STDMETHODIMP InternalMachineControlWrap::SetRemoveSavedStateFile(BOOL aRemove)
{
    LogRelFlow(("{%p} %s:enter aRemove=%RTbool\n", this, "InternalMachineControl::setRemoveSavedStateFile", aRemove));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setRemoveSavedStateFile(aRemove);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalMachineControl::setRemoveSavedStateFile", hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::UpdateState(MachineState_T aState)
{
    LogRelFlow(("{%p} %s:enter aState=%RU32\n", this, "InternalMachineControl::updateState", aState));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = updateState(aState);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalMachineControl::updateState", hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::BeginPowerUp(IProgress *aProgress)
{
    LogRelFlow(("{%p} %s:enter aProgress=%p\n", this, "InternalMachineControl::beginPowerUp", aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = beginPowerUp(ComTypeInConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalMachineControl::beginPowerUp", hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::EndPowerUp(LONG aResult)
{
    LogRelFlow(("{%p} %s:enter aResult=%RI32\n", this, "InternalMachineControl::endPowerUp", aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = endPowerUp(aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalMachineControl::endPowerUp", hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::BeginPoweringDown(IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aProgress=%p\n", this, "InternalMachineControl::beginPoweringDown", aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = beginPoweringDown(ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProgress=%p hrc=%Rhrc\n", this, "InternalMachineControl::beginPoweringDown", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::EndPoweringDown(LONG aResult,
                                                         IN_BSTR aErrMsg)
{
    LogRelFlow(("{%p} %s:enter aResult=%RI32 aErrMsg=%ls\n", this, "InternalMachineControl::endPoweringDown", aResult, aErrMsg));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = endPoweringDown(aResult,
                              BSTRInConverter(aErrMsg).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalMachineControl::endPoweringDown", hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::RunUSBDeviceFilters(IUSBDevice *aDevice,
                                                             BOOL *aMatched,
                                                             ULONG *aMaskedInterfaces)
{
    LogRelFlow(("{%p} %s:enter aDevice=%p aMatched=%p aMaskedInterfaces=%p\n", this, "InternalMachineControl::runUSBDeviceFilters", aDevice, aMatched, aMaskedInterfaces));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMatched);
        CheckComArgOutPointerValidThrow(aMaskedInterfaces);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = runUSBDeviceFilters(ComTypeInConverter<IUSBDevice>(aDevice).ptr(),
                                  aMatched,
                                  aMaskedInterfaces);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMatched=%RTbool *aMaskedInterfaces=%RU32 hrc=%Rhrc\n", this, "InternalMachineControl::runUSBDeviceFilters", *aMatched, *aMaskedInterfaces, hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::CaptureUSBDevice(IN_BSTR aId)
{
    LogRelFlow(("{%p} %s:enter aId=%ls\n", this, "InternalMachineControl::captureUSBDevice", aId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = captureUSBDevice(UuidInConverter(aId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalMachineControl::captureUSBDevice", hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::DetachUSBDevice(IN_BSTR aId,
                                                         BOOL aDone)
{
    LogRelFlow(("{%p} %s:enter aId=%ls aDone=%RTbool\n", this, "InternalMachineControl::detachUSBDevice", aId, aDone));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = detachUSBDevice(UuidInConverter(aId).uuid(),
                              aDone);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalMachineControl::detachUSBDevice", hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::AutoCaptureUSBDevices()
{
    LogRelFlow(("{%p} %s:enter\n", this, "InternalMachineControl::autoCaptureUSBDevices"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = autoCaptureUSBDevices();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalMachineControl::autoCaptureUSBDevices", hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::DetachAllUSBDevices(BOOL aDone)
{
    LogRelFlow(("{%p} %s:enter aDone=%RTbool\n", this, "InternalMachineControl::detachAllUSBDevices", aDone));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = detachAllUSBDevices(aDone);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalMachineControl::detachAllUSBDevices", hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::OnSessionEnd(ISession *aSession,
                                                      IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aSession=%p aProgress=%p\n", this, "InternalMachineControl::onSessionEnd", aSession, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = onSessionEnd(ComTypeInConverter<ISession>(aSession).ptr(),
                           ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "InternalMachineControl::onSessionEnd", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::BeginSavingState(IProgress **aProgress,
                                                          BSTR *aStateFilePath)
{
    LogRelFlow(("{%p} %s:enter aProgress=%p aStateFilePath=%p\n", this, "InternalMachineControl::beginSavingState", aProgress, aStateFilePath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);
        CheckComArgOutPointerValidThrow(aStateFilePath);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = beginSavingState(ComTypeOutConverter<IProgress>(aProgress).ptr(),
                               BSTROutConverter(aStateFilePath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProgress=%p *aStateFilePath=%ls hrc=%Rhrc\n", this, "InternalMachineControl::beginSavingState", *aProgress, *aStateFilePath, hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::EndSavingState(LONG aResult,
                                                        IN_BSTR aErrMsg)
{
    LogRelFlow(("{%p} %s:enter aResult=%RI32 aErrMsg=%ls\n", this, "InternalMachineControl::endSavingState", aResult, aErrMsg));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = endSavingState(aResult,
                             BSTRInConverter(aErrMsg).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalMachineControl::endSavingState", hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::AdoptSavedState(IN_BSTR aSavedStateFile)
{
    LogRelFlow(("{%p} %s:enter aSavedStateFile=%ls\n", this, "InternalMachineControl::adoptSavedState", aSavedStateFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = adoptSavedState(BSTRInConverter(aSavedStateFile).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalMachineControl::adoptSavedState", hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::BeginTakingSnapshot(IConsole *aInitiator,
                                                             IN_BSTR aName,
                                                             IN_BSTR aDescription,
                                                             IProgress *aConsoleProgress,
                                                             BOOL aFTakingSnapshotOnline,
                                                             BSTR *aStateFilePath)
{
    LogRelFlow(("{%p} %s:enter aInitiator=%p aName=%ls aDescription=%ls aConsoleProgress=%p aFTakingSnapshotOnline=%RTbool aStateFilePath=%p\n", this, "InternalMachineControl::beginTakingSnapshot", aInitiator, aName, aDescription, aConsoleProgress, aFTakingSnapshotOnline, aStateFilePath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStateFilePath);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = beginTakingSnapshot(ComTypeInConverter<IConsole>(aInitiator).ptr(),
                                  BSTRInConverter(aName).str(),
                                  BSTRInConverter(aDescription).str(),
                                  ComTypeInConverter<IProgress>(aConsoleProgress).ptr(),
                                  aFTakingSnapshotOnline,
                                  BSTROutConverter(aStateFilePath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aStateFilePath=%ls hrc=%Rhrc\n", this, "InternalMachineControl::beginTakingSnapshot", *aStateFilePath, hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::EndTakingSnapshot(BOOL aSuccess)
{
    LogRelFlow(("{%p} %s:enter aSuccess=%RTbool\n", this, "InternalMachineControl::endTakingSnapshot", aSuccess));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = endTakingSnapshot(aSuccess);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalMachineControl::endTakingSnapshot", hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::DeleteSnapshot(IConsole *aInitiator,
                                                        IN_BSTR aStartId,
                                                        IN_BSTR aEndId,
                                                        BOOL aDeleteAllChildren,
                                                        MachineState_T *aMachineState,
                                                        IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aInitiator=%p aStartId=%ls aEndId=%ls aDeleteAllChildren=%RTbool aMachineState=%p aProgress=%p\n", this, "InternalMachineControl::deleteSnapshot", aInitiator, aStartId, aEndId, aDeleteAllChildren, aMachineState, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachineState);
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = deleteSnapshot(ComTypeInConverter<IConsole>(aInitiator).ptr(),
                             UuidInConverter(aStartId).uuid(),
                             UuidInConverter(aEndId).uuid(),
                             aDeleteAllChildren,
                             aMachineState,
                             ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachineState=%RU32 aProgress=%p hrc=%Rhrc\n", this, "InternalMachineControl::deleteSnapshot", *aMachineState, *aProgress, hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::FinishOnlineMergeMedium()
{
    LogRelFlow(("{%p} %s:enter\n", this, "InternalMachineControl::finishOnlineMergeMedium"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = finishOnlineMergeMedium();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalMachineControl::finishOnlineMergeMedium", hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::RestoreSnapshot(IConsole *aInitiator,
                                                         ISnapshot *aSnapshot,
                                                         MachineState_T *aMachineState,
                                                         IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aInitiator=%p aSnapshot=%p aMachineState=%p aProgress=%p\n", this, "InternalMachineControl::restoreSnapshot", aInitiator, aSnapshot, aMachineState, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachineState);
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = restoreSnapshot(ComTypeInConverter<IConsole>(aInitiator).ptr(),
                              ComTypeInConverter<ISnapshot>(aSnapshot).ptr(),
                              aMachineState,
                              ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachineState=%RU32 aProgress=%p hrc=%Rhrc\n", this, "InternalMachineControl::restoreSnapshot", *aMachineState, *aProgress, hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::PullGuestProperties(ComSafeArrayOut(BSTR, aNames),
                                                             ComSafeArrayOut(BSTR, aValues),
                                                             ComSafeArrayOut(LONG64, aTimestamps),
                                                             ComSafeArrayOut(BSTR, aFlags))
{
    LogRelFlow(("{%p} %s:enter aNames=%p aValues=%p aTimestamps=%p aFlags=%p\n", this, "InternalMachineControl::pullGuestProperties", aNames, aValues, aTimestamps, aFlags));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNames);
        CheckComArgOutPointerValidThrow(aValues);
        CheckComArgOutPointerValidThrow(aTimestamps);
        CheckComArgOutPointerValidThrow(aFlags);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = pullGuestProperties(ArrayBSTROutConverter(ComSafeArrayOutArg(aNames)).array(),
                                  ArrayBSTROutConverter(ComSafeArrayOutArg(aValues)).array(),
                                  ArrayOutConverter<LONG64>(ComSafeArrayOutArg(aTimestamps)).array(),
                                  ArrayBSTROutConverter(ComSafeArrayOutArg(aFlags)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNames=%zu *aValues=%zu *aTimestamps=%zu *aFlags=%zu hrc=%Rhrc\n", this, "InternalMachineControl::pullGuestProperties", ComSafeArraySize(*aNames), ComSafeArraySize(*aValues), ComSafeArraySize(*aTimestamps), ComSafeArraySize(*aFlags), hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::PushGuestProperty(IN_BSTR aName,
                                                           IN_BSTR aValue,
                                                           LONG64 aTimestamp,
                                                           IN_BSTR aFlags)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aValue=%ls aTimestamp=%RI64 aFlags=%ls\n", this, "InternalMachineControl::pushGuestProperty", aName, aValue, aTimestamp, aFlags));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = pushGuestProperty(BSTRInConverter(aName).str(),
                                BSTRInConverter(aValue).str(),
                                aTimestamp,
                                BSTRInConverter(aFlags).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalMachineControl::pushGuestProperty", hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::LockMedia()
{
    LogRelFlow(("{%p} %s:enter\n", this, "InternalMachineControl::lockMedia"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = lockMedia();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalMachineControl::lockMedia", hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::UnlockMedia()
{
    LogRelFlow(("{%p} %s:enter\n", this, "InternalMachineControl::unlockMedia"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = unlockMedia();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalMachineControl::unlockMedia", hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::EjectMedium(IMediumAttachment *aAttachment,
                                                     IMediumAttachment **aNewAttachment)
{
    LogRelFlow(("{%p} %s:enter aAttachment=%p aNewAttachment=%p\n", this, "InternalMachineControl::ejectMedium", aAttachment, aNewAttachment));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNewAttachment);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = ejectMedium(ComTypeInConverter<IMediumAttachment>(aAttachment).ptr(),
                          ComTypeOutConverter<IMediumAttachment>(aNewAttachment).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aNewAttachment=%p hrc=%Rhrc\n", this, "InternalMachineControl::ejectMedium", *aNewAttachment, hrc));
    return hrc;
}

STDMETHODIMP InternalMachineControlWrap::ReportVmStatistics(ULONG aValidStats,
                                                            ULONG aCpuUser,
                                                            ULONG aCpuKernel,
                                                            ULONG aCpuIdle,
                                                            ULONG aMemTotal,
                                                            ULONG aMemFree,
                                                            ULONG aMemBalloon,
                                                            ULONG aMemShared,
                                                            ULONG aMemCache,
                                                            ULONG aPagedTotal,
                                                            ULONG aMemAllocTotal,
                                                            ULONG aMemFreeTotal,
                                                            ULONG aMemBalloonTotal,
                                                            ULONG aMemSharedTotal,
                                                            ULONG aVmNetRx,
                                                            ULONG aVmNetTx)
{
    LogRelFlow(("{%p} %s:enter aValidStats=%RU32 aCpuUser=%RU32 aCpuKernel=%RU32 aCpuIdle=%RU32 aMemTotal=%RU32 aMemFree=%RU32 aMemBalloon=%RU32 aMemShared=%RU32 aMemCache=%RU32 aPagedTotal=%RU32 aMemAllocTotal=%RU32 aMemFreeTotal=%RU32 aMemBalloonTotal=%RU32 aMemSharedTotal=%RU32 aVmNetRx=%RU32 aVmNetTx=%RU32\n", this, "InternalMachineControl::reportVmStatistics", aValidStats, aCpuUser, aCpuKernel, aCpuIdle, aMemTotal, aMemFree, aMemBalloon, aMemShared, aMemCache, aPagedTotal, aMemAllocTotal, aMemFreeTotal, aMemBalloonTotal, aMemSharedTotal, aVmNetRx, aVmNetTx));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = reportVmStatistics(aValidStats,
                                 aCpuUser,
                                 aCpuKernel,
                                 aCpuIdle,
                                 aMemTotal,
                                 aMemFree,
                                 aMemBalloon,
                                 aMemShared,
                                 aMemCache,
                                 aPagedTotal,
                                 aMemAllocTotal,
                                 aMemFreeTotal,
                                 aMemBalloonTotal,
                                 aMemSharedTotal,
                                 aVmNetRx,
                                 aVmNetTx);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalMachineControl::reportVmStatistics", hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(InternalMachineControlWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(InternalMachineControlWrap, IInternalMachineControl)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "InternalMachineControlWrap.cpp"

// ##### BEGINFILE "BIOSSettingsWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IBIOSSettings.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef BIOSSettingsWrap_H_
#define BIOSSettingsWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE BIOSSettingsWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IBIOSSettings)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(BIOSSettingsWrap, IBIOSSettings)
    DECLARE_NOT_AGGREGATABLE(BIOSSettingsWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(BIOSSettingsWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IBIOSSettings)
        COM_INTERFACE_ENTRY2(IDispatch, IBIOSSettings)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(BIOSSettingsWrap)

    // public IBIOSSettings properties
    STDMETHOD(COMGETTER(LogoFadeIn))(BOOL *aLogoFadeIn);
    STDMETHOD(COMSETTER(LogoFadeIn))(BOOL aLogoFadeIn);
    STDMETHOD(COMGETTER(LogoFadeOut))(BOOL *aLogoFadeOut);
    STDMETHOD(COMSETTER(LogoFadeOut))(BOOL aLogoFadeOut);
    STDMETHOD(COMGETTER(LogoDisplayTime))(ULONG *aLogoDisplayTime);
    STDMETHOD(COMSETTER(LogoDisplayTime))(ULONG aLogoDisplayTime);
    STDMETHOD(COMGETTER(LogoImagePath))(BSTR *aLogoImagePath);
    STDMETHOD(COMSETTER(LogoImagePath))(IN_BSTR aLogoImagePath);
    STDMETHOD(COMGETTER(BootMenuMode))(BIOSBootMenuMode_T *aBootMenuMode);
    STDMETHOD(COMSETTER(BootMenuMode))(BIOSBootMenuMode_T aBootMenuMode);
    STDMETHOD(COMGETTER(ACPIEnabled))(BOOL *aACPIEnabled);
    STDMETHOD(COMSETTER(ACPIEnabled))(BOOL aACPIEnabled);
    STDMETHOD(COMGETTER(IOAPICEnabled))(BOOL *aIOAPICEnabled);
    STDMETHOD(COMSETTER(IOAPICEnabled))(BOOL aIOAPICEnabled);
    STDMETHOD(COMGETTER(TimeOffset))(LONG64 *aTimeOffset);
    STDMETHOD(COMSETTER(TimeOffset))(LONG64 aTimeOffset);
    STDMETHOD(COMGETTER(PXEDebugEnabled))(BOOL *aPXEDebugEnabled);
    STDMETHOD(COMSETTER(PXEDebugEnabled))(BOOL aPXEDebugEnabled);
    STDMETHOD(COMGETTER(NonVolatileStorageFile))(BSTR *aNonVolatileStorageFile);

    // public IBIOSSettings methods

private:
    // wrapped IBIOSSettings properties
    virtual HRESULT getLogoFadeIn(BOOL *aLogoFadeIn) = 0;
    virtual HRESULT setLogoFadeIn(BOOL aLogoFadeIn) = 0;
    virtual HRESULT getLogoFadeOut(BOOL *aLogoFadeOut) = 0;
    virtual HRESULT setLogoFadeOut(BOOL aLogoFadeOut) = 0;
    virtual HRESULT getLogoDisplayTime(ULONG *aLogoDisplayTime) = 0;
    virtual HRESULT setLogoDisplayTime(ULONG aLogoDisplayTime) = 0;
    virtual HRESULT getLogoImagePath(com::Utf8Str &aLogoImagePath) = 0;
    virtual HRESULT setLogoImagePath(const com::Utf8Str &aLogoImagePath) = 0;
    virtual HRESULT getBootMenuMode(BIOSBootMenuMode_T *aBootMenuMode) = 0;
    virtual HRESULT setBootMenuMode(BIOSBootMenuMode_T aBootMenuMode) = 0;
    virtual HRESULT getACPIEnabled(BOOL *aACPIEnabled) = 0;
    virtual HRESULT setACPIEnabled(BOOL aACPIEnabled) = 0;
    virtual HRESULT getIOAPICEnabled(BOOL *aIOAPICEnabled) = 0;
    virtual HRESULT setIOAPICEnabled(BOOL aIOAPICEnabled) = 0;
    virtual HRESULT getTimeOffset(LONG64 *aTimeOffset) = 0;
    virtual HRESULT setTimeOffset(LONG64 aTimeOffset) = 0;
    virtual HRESULT getPXEDebugEnabled(BOOL *aPXEDebugEnabled) = 0;
    virtual HRESULT setPXEDebugEnabled(BOOL aPXEDebugEnabled) = 0;
    virtual HRESULT getNonVolatileStorageFile(com::Utf8Str &aNonVolatileStorageFile) = 0;

    // wrapped IBIOSSettings methods
};

#endif // !BIOSSettingsWrap_H_

// ##### ENDFILE "BIOSSettingsWrap.h"

// ##### BEGINFILE "BIOSSettingsWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IBIOSSettings.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_BIOSSETTINGS

#include "BIOSSettingsWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(BIOSSettingsWrap)

//
// IBIOSSettings properties
//

STDMETHODIMP BIOSSettingsWrap::COMGETTER(LogoFadeIn)(BOOL *aLogoFadeIn)
{
    LogRelFlow(("{%p} %s: enter aLogoFadeIn=%p\n", this, "BIOSSettings::getLogoFadeIn", aLogoFadeIn));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLogoFadeIn);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLogoFadeIn(aLogoFadeIn);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLogoFadeIn=%RTbool hrc=%Rhrc\n", this, "BIOSSettings::getLogoFadeIn", *aLogoFadeIn, hrc));
    return hrc;
}

STDMETHODIMP BIOSSettingsWrap::COMSETTER(LogoFadeIn)(BOOL aLogoFadeIn)
{
    LogRelFlow(("{%p} %s: enter aLogoFadeIn=%RTbool\n", this, "BIOSSettings::setLogoFadeIn", aLogoFadeIn));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setLogoFadeIn(aLogoFadeIn);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "BIOSSettings::setLogoFadeIn", hrc));
    return hrc;
}

STDMETHODIMP BIOSSettingsWrap::COMGETTER(LogoFadeOut)(BOOL *aLogoFadeOut)
{
    LogRelFlow(("{%p} %s: enter aLogoFadeOut=%p\n", this, "BIOSSettings::getLogoFadeOut", aLogoFadeOut));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLogoFadeOut);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLogoFadeOut(aLogoFadeOut);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLogoFadeOut=%RTbool hrc=%Rhrc\n", this, "BIOSSettings::getLogoFadeOut", *aLogoFadeOut, hrc));
    return hrc;
}

STDMETHODIMP BIOSSettingsWrap::COMSETTER(LogoFadeOut)(BOOL aLogoFadeOut)
{
    LogRelFlow(("{%p} %s: enter aLogoFadeOut=%RTbool\n", this, "BIOSSettings::setLogoFadeOut", aLogoFadeOut));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setLogoFadeOut(aLogoFadeOut);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "BIOSSettings::setLogoFadeOut", hrc));
    return hrc;
}

STDMETHODIMP BIOSSettingsWrap::COMGETTER(LogoDisplayTime)(ULONG *aLogoDisplayTime)
{
    LogRelFlow(("{%p} %s: enter aLogoDisplayTime=%p\n", this, "BIOSSettings::getLogoDisplayTime", aLogoDisplayTime));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLogoDisplayTime);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLogoDisplayTime(aLogoDisplayTime);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLogoDisplayTime=%RU32 hrc=%Rhrc\n", this, "BIOSSettings::getLogoDisplayTime", *aLogoDisplayTime, hrc));
    return hrc;
}

STDMETHODIMP BIOSSettingsWrap::COMSETTER(LogoDisplayTime)(ULONG aLogoDisplayTime)
{
    LogRelFlow(("{%p} %s: enter aLogoDisplayTime=%RU32\n", this, "BIOSSettings::setLogoDisplayTime", aLogoDisplayTime));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setLogoDisplayTime(aLogoDisplayTime);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "BIOSSettings::setLogoDisplayTime", hrc));
    return hrc;
}

STDMETHODIMP BIOSSettingsWrap::COMGETTER(LogoImagePath)(BSTR *aLogoImagePath)
{
    LogRelFlow(("{%p} %s: enter aLogoImagePath=%p\n", this, "BIOSSettings::getLogoImagePath", aLogoImagePath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLogoImagePath);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLogoImagePath(BSTROutConverter(aLogoImagePath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLogoImagePath=%ls hrc=%Rhrc\n", this, "BIOSSettings::getLogoImagePath", *aLogoImagePath, hrc));
    return hrc;
}

STDMETHODIMP BIOSSettingsWrap::COMSETTER(LogoImagePath)(IN_BSTR aLogoImagePath)
{
    LogRelFlow(("{%p} %s: enter aLogoImagePath=%ls\n", this, "BIOSSettings::setLogoImagePath", aLogoImagePath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setLogoImagePath(BSTRInConverter(aLogoImagePath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "BIOSSettings::setLogoImagePath", hrc));
    return hrc;
}

STDMETHODIMP BIOSSettingsWrap::COMGETTER(BootMenuMode)(BIOSBootMenuMode_T *aBootMenuMode)
{
    LogRelFlow(("{%p} %s: enter aBootMenuMode=%p\n", this, "BIOSSettings::getBootMenuMode", aBootMenuMode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBootMenuMode);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBootMenuMode(aBootMenuMode);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBootMenuMode=%RU32 hrc=%Rhrc\n", this, "BIOSSettings::getBootMenuMode", *aBootMenuMode, hrc));
    return hrc;
}

STDMETHODIMP BIOSSettingsWrap::COMSETTER(BootMenuMode)(BIOSBootMenuMode_T aBootMenuMode)
{
    LogRelFlow(("{%p} %s: enter aBootMenuMode=%RU32\n", this, "BIOSSettings::setBootMenuMode", aBootMenuMode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setBootMenuMode(aBootMenuMode);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "BIOSSettings::setBootMenuMode", hrc));
    return hrc;
}

STDMETHODIMP BIOSSettingsWrap::COMGETTER(ACPIEnabled)(BOOL *aACPIEnabled)
{
    LogRelFlow(("{%p} %s: enter aACPIEnabled=%p\n", this, "BIOSSettings::getACPIEnabled", aACPIEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aACPIEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getACPIEnabled(aACPIEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aACPIEnabled=%RTbool hrc=%Rhrc\n", this, "BIOSSettings::getACPIEnabled", *aACPIEnabled, hrc));
    return hrc;
}

STDMETHODIMP BIOSSettingsWrap::COMSETTER(ACPIEnabled)(BOOL aACPIEnabled)
{
    LogRelFlow(("{%p} %s: enter aACPIEnabled=%RTbool\n", this, "BIOSSettings::setACPIEnabled", aACPIEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setACPIEnabled(aACPIEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "BIOSSettings::setACPIEnabled", hrc));
    return hrc;
}

STDMETHODIMP BIOSSettingsWrap::COMGETTER(IOAPICEnabled)(BOOL *aIOAPICEnabled)
{
    LogRelFlow(("{%p} %s: enter aIOAPICEnabled=%p\n", this, "BIOSSettings::getIOAPICEnabled", aIOAPICEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aIOAPICEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getIOAPICEnabled(aIOAPICEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aIOAPICEnabled=%RTbool hrc=%Rhrc\n", this, "BIOSSettings::getIOAPICEnabled", *aIOAPICEnabled, hrc));
    return hrc;
}

STDMETHODIMP BIOSSettingsWrap::COMSETTER(IOAPICEnabled)(BOOL aIOAPICEnabled)
{
    LogRelFlow(("{%p} %s: enter aIOAPICEnabled=%RTbool\n", this, "BIOSSettings::setIOAPICEnabled", aIOAPICEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setIOAPICEnabled(aIOAPICEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "BIOSSettings::setIOAPICEnabled", hrc));
    return hrc;
}

STDMETHODIMP BIOSSettingsWrap::COMGETTER(TimeOffset)(LONG64 *aTimeOffset)
{
    LogRelFlow(("{%p} %s: enter aTimeOffset=%p\n", this, "BIOSSettings::getTimeOffset", aTimeOffset));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aTimeOffset);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getTimeOffset(aTimeOffset);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aTimeOffset=%RI64 hrc=%Rhrc\n", this, "BIOSSettings::getTimeOffset", *aTimeOffset, hrc));
    return hrc;
}

STDMETHODIMP BIOSSettingsWrap::COMSETTER(TimeOffset)(LONG64 aTimeOffset)
{
    LogRelFlow(("{%p} %s: enter aTimeOffset=%RI64\n", this, "BIOSSettings::setTimeOffset", aTimeOffset));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setTimeOffset(aTimeOffset);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "BIOSSettings::setTimeOffset", hrc));
    return hrc;
}

STDMETHODIMP BIOSSettingsWrap::COMGETTER(PXEDebugEnabled)(BOOL *aPXEDebugEnabled)
{
    LogRelFlow(("{%p} %s: enter aPXEDebugEnabled=%p\n", this, "BIOSSettings::getPXEDebugEnabled", aPXEDebugEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPXEDebugEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPXEDebugEnabled(aPXEDebugEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPXEDebugEnabled=%RTbool hrc=%Rhrc\n", this, "BIOSSettings::getPXEDebugEnabled", *aPXEDebugEnabled, hrc));
    return hrc;
}

STDMETHODIMP BIOSSettingsWrap::COMSETTER(PXEDebugEnabled)(BOOL aPXEDebugEnabled)
{
    LogRelFlow(("{%p} %s: enter aPXEDebugEnabled=%RTbool\n", this, "BIOSSettings::setPXEDebugEnabled", aPXEDebugEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setPXEDebugEnabled(aPXEDebugEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "BIOSSettings::setPXEDebugEnabled", hrc));
    return hrc;
}

STDMETHODIMP BIOSSettingsWrap::COMGETTER(NonVolatileStorageFile)(BSTR *aNonVolatileStorageFile)
{
    LogRelFlow(("{%p} %s: enter aNonVolatileStorageFile=%p\n", this, "BIOSSettings::getNonVolatileStorageFile", aNonVolatileStorageFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNonVolatileStorageFile);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNonVolatileStorageFile(BSTROutConverter(aNonVolatileStorageFile).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNonVolatileStorageFile=%ls hrc=%Rhrc\n", this, "BIOSSettings::getNonVolatileStorageFile", *aNonVolatileStorageFile, hrc));
    return hrc;
}

//
// IBIOSSettings methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(BIOSSettingsWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(BIOSSettingsWrap, IBIOSSettings)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "BIOSSettingsWrap.cpp"

// ##### BEGINFILE "PCIAddressWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IPCIAddress.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef PCIAddressWrap_H_
#define PCIAddressWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE PCIAddressWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IPCIAddress)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(PCIAddressWrap, IPCIAddress)
    DECLARE_NOT_AGGREGATABLE(PCIAddressWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(PCIAddressWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IPCIAddress)
        COM_INTERFACE_ENTRY2(IDispatch, IPCIAddress)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(PCIAddressWrap)

    // public IPCIAddress properties
    STDMETHOD(COMGETTER(Bus))(SHORT *aBus);
    STDMETHOD(COMSETTER(Bus))(SHORT aBus);
    STDMETHOD(COMGETTER(Device))(SHORT *aDevice);
    STDMETHOD(COMSETTER(Device))(SHORT aDevice);
    STDMETHOD(COMGETTER(DevFunction))(SHORT *aDevFunction);
    STDMETHOD(COMSETTER(DevFunction))(SHORT aDevFunction);

    // public IPCIAddress methods
    STDMETHOD(AsLong)(LONG *aResult);
    STDMETHOD(FromLong)(LONG aNumber);

private:
    // wrapped IPCIAddress properties
    virtual HRESULT getBus(SHORT *aBus) = 0;
    virtual HRESULT setBus(SHORT aBus) = 0;
    virtual HRESULT getDevice(SHORT *aDevice) = 0;
    virtual HRESULT setDevice(SHORT aDevice) = 0;
    virtual HRESULT getDevFunction(SHORT *aDevFunction) = 0;
    virtual HRESULT setDevFunction(SHORT aDevFunction) = 0;

    // wrapped IPCIAddress methods
    virtual HRESULT asLong(LONG *aResult) = 0;
    virtual HRESULT fromLong(LONG aNumber) = 0;
};

#endif // !PCIAddressWrap_H_

// ##### ENDFILE "PCIAddressWrap.h"

// ##### BEGINFILE "PCIAddressWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IPCIAddress.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_PCIADDRESS

#include "PCIAddressWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(PCIAddressWrap)

//
// IPCIAddress properties
//

STDMETHODIMP PCIAddressWrap::COMGETTER(Bus)(SHORT *aBus)
{
    LogRelFlow(("{%p} %s: enter aBus=%p\n", this, "PCIAddress::getBus", aBus));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBus);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBus(aBus);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBus=%RI16 hrc=%Rhrc\n", this, "PCIAddress::getBus", *aBus, hrc));
    return hrc;
}

STDMETHODIMP PCIAddressWrap::COMSETTER(Bus)(SHORT aBus)
{
    LogRelFlow(("{%p} %s: enter aBus=%RI16\n", this, "PCIAddress::setBus", aBus));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setBus(aBus);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "PCIAddress::setBus", hrc));
    return hrc;
}

STDMETHODIMP PCIAddressWrap::COMGETTER(Device)(SHORT *aDevice)
{
    LogRelFlow(("{%p} %s: enter aDevice=%p\n", this, "PCIAddress::getDevice", aDevice));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDevice);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDevice(aDevice);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDevice=%RI16 hrc=%Rhrc\n", this, "PCIAddress::getDevice", *aDevice, hrc));
    return hrc;
}

STDMETHODIMP PCIAddressWrap::COMSETTER(Device)(SHORT aDevice)
{
    LogRelFlow(("{%p} %s: enter aDevice=%RI16\n", this, "PCIAddress::setDevice", aDevice));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setDevice(aDevice);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "PCIAddress::setDevice", hrc));
    return hrc;
}

STDMETHODIMP PCIAddressWrap::COMGETTER(DevFunction)(SHORT *aDevFunction)
{
    LogRelFlow(("{%p} %s: enter aDevFunction=%p\n", this, "PCIAddress::getDevFunction", aDevFunction));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDevFunction);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDevFunction(aDevFunction);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDevFunction=%RI16 hrc=%Rhrc\n", this, "PCIAddress::getDevFunction", *aDevFunction, hrc));
    return hrc;
}

STDMETHODIMP PCIAddressWrap::COMSETTER(DevFunction)(SHORT aDevFunction)
{
    LogRelFlow(("{%p} %s: enter aDevFunction=%RI16\n", this, "PCIAddress::setDevFunction", aDevFunction));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setDevFunction(aDevFunction);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "PCIAddress::setDevFunction", hrc));
    return hrc;
}

//
// IPCIAddress methods
//

STDMETHODIMP PCIAddressWrap::AsLong(LONG *aResult)
{
    LogRelFlow(("{%p} %s:enter aResult=%p\n", this, "PCIAddress::asLong", aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = asLong(aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RI32 hrc=%Rhrc\n", this, "PCIAddress::asLong", *aResult, hrc));
    return hrc;
}

STDMETHODIMP PCIAddressWrap::FromLong(LONG aNumber)
{
    LogRelFlow(("{%p} %s:enter aNumber=%RI32\n", this, "PCIAddress::fromLong", aNumber));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = fromLong(aNumber);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "PCIAddress::fromLong", hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(PCIAddressWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(PCIAddressWrap, IPCIAddress)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "PCIAddressWrap.cpp"

// ##### BEGINFILE "PCIDeviceAttachmentWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IPCIDeviceAttachment.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef PCIDeviceAttachmentWrap_H_
#define PCIDeviceAttachmentWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE PCIDeviceAttachmentWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IPCIDeviceAttachment)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(PCIDeviceAttachmentWrap, IPCIDeviceAttachment)
    DECLARE_NOT_AGGREGATABLE(PCIDeviceAttachmentWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(PCIDeviceAttachmentWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IPCIDeviceAttachment)
        COM_INTERFACE_ENTRY2(IDispatch, IPCIDeviceAttachment)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(PCIDeviceAttachmentWrap)

    // public IPCIDeviceAttachment properties
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(IsPhysicalDevice))(BOOL *aIsPhysicalDevice);
    STDMETHOD(COMGETTER(HostAddress))(LONG *aHostAddress);
    STDMETHOD(COMGETTER(GuestAddress))(LONG *aGuestAddress);

    // public IPCIDeviceAttachment methods

private:
    // wrapped IPCIDeviceAttachment properties
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getIsPhysicalDevice(BOOL *aIsPhysicalDevice) = 0;
    virtual HRESULT getHostAddress(LONG *aHostAddress) = 0;
    virtual HRESULT getGuestAddress(LONG *aGuestAddress) = 0;

    // wrapped IPCIDeviceAttachment methods
};

#endif // !PCIDeviceAttachmentWrap_H_

// ##### ENDFILE "PCIDeviceAttachmentWrap.h"

// ##### BEGINFILE "PCIDeviceAttachmentWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IPCIDeviceAttachment.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_PCIDEVICEATTACHMENT

#include "PCIDeviceAttachmentWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(PCIDeviceAttachmentWrap)

//
// IPCIDeviceAttachment properties
//

STDMETHODIMP PCIDeviceAttachmentWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "PCIDeviceAttachment::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "PCIDeviceAttachment::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP PCIDeviceAttachmentWrap::COMGETTER(IsPhysicalDevice)(BOOL *aIsPhysicalDevice)
{
    LogRelFlow(("{%p} %s: enter aIsPhysicalDevice=%p\n", this, "PCIDeviceAttachment::getIsPhysicalDevice", aIsPhysicalDevice));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aIsPhysicalDevice);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getIsPhysicalDevice(aIsPhysicalDevice);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aIsPhysicalDevice=%RTbool hrc=%Rhrc\n", this, "PCIDeviceAttachment::getIsPhysicalDevice", *aIsPhysicalDevice, hrc));
    return hrc;
}

STDMETHODIMP PCIDeviceAttachmentWrap::COMGETTER(HostAddress)(LONG *aHostAddress)
{
    LogRelFlow(("{%p} %s: enter aHostAddress=%p\n", this, "PCIDeviceAttachment::getHostAddress", aHostAddress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHostAddress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHostAddress(aHostAddress);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHostAddress=%RI32 hrc=%Rhrc\n", this, "PCIDeviceAttachment::getHostAddress", *aHostAddress, hrc));
    return hrc;
}

STDMETHODIMP PCIDeviceAttachmentWrap::COMGETTER(GuestAddress)(LONG *aGuestAddress)
{
    LogRelFlow(("{%p} %s: enter aGuestAddress=%p\n", this, "PCIDeviceAttachment::getGuestAddress", aGuestAddress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGuestAddress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGuestAddress(aGuestAddress);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGuestAddress=%RI32 hrc=%Rhrc\n", this, "PCIDeviceAttachment::getGuestAddress", *aGuestAddress, hrc));
    return hrc;
}

//
// IPCIDeviceAttachment methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(PCIDeviceAttachmentWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(PCIDeviceAttachmentWrap, IPCIDeviceAttachment)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "PCIDeviceAttachmentWrap.cpp"

// ##### BEGINFILE "MachineWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IMachine.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef MachineWrap_H_
#define MachineWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE MachineWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IMachine)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(MachineWrap, IMachine)
    DECLARE_NOT_AGGREGATABLE(MachineWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(MachineWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IMachine)
        COM_INTERFACE_ENTRY2(IDispatch, IMachine)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(MachineWrap)

    // public IMachine properties
    STDMETHOD(COMGETTER(Parent))(IVirtualBox **aParent);
    STDMETHOD(COMGETTER(Icon))(ComSafeArrayOut(BYTE, aIcon));
    STDMETHOD(COMSETTER(Icon))(ComSafeArrayIn(BYTE, aIcon));
    STDMETHOD(COMGETTER(Accessible))(BOOL *aAccessible);
    STDMETHOD(COMGETTER(AccessError))(IVirtualBoxErrorInfo **aAccessError);
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMSETTER(Name))(IN_BSTR aName);
    STDMETHOD(COMGETTER(Description))(BSTR *aDescription);
    STDMETHOD(COMSETTER(Description))(IN_BSTR aDescription);
    STDMETHOD(COMGETTER(Id))(BSTR *aId);
    STDMETHOD(COMGETTER(Groups))(ComSafeArrayOut(BSTR, aGroups));
    STDMETHOD(COMSETTER(Groups))(ComSafeArrayIn(IN_BSTR, aGroups));
    STDMETHOD(COMGETTER(OSTypeId))(BSTR *aOSTypeId);
    STDMETHOD(COMSETTER(OSTypeId))(IN_BSTR aOSTypeId);
    STDMETHOD(COMGETTER(HardwareVersion))(BSTR *aHardwareVersion);
    STDMETHOD(COMSETTER(HardwareVersion))(IN_BSTR aHardwareVersion);
    STDMETHOD(COMGETTER(HardwareUUID))(BSTR *aHardwareUUID);
    STDMETHOD(COMSETTER(HardwareUUID))(IN_BSTR aHardwareUUID);
    STDMETHOD(COMGETTER(CPUCount))(ULONG *aCPUCount);
    STDMETHOD(COMSETTER(CPUCount))(ULONG aCPUCount);
    STDMETHOD(COMGETTER(CPUHotPlugEnabled))(BOOL *aCPUHotPlugEnabled);
    STDMETHOD(COMSETTER(CPUHotPlugEnabled))(BOOL aCPUHotPlugEnabled);
    STDMETHOD(COMGETTER(CPUExecutionCap))(ULONG *aCPUExecutionCap);
    STDMETHOD(COMSETTER(CPUExecutionCap))(ULONG aCPUExecutionCap);
    STDMETHOD(COMGETTER(MemorySize))(ULONG *aMemorySize);
    STDMETHOD(COMSETTER(MemorySize))(ULONG aMemorySize);
    STDMETHOD(COMGETTER(MemoryBalloonSize))(ULONG *aMemoryBalloonSize);
    STDMETHOD(COMSETTER(MemoryBalloonSize))(ULONG aMemoryBalloonSize);
    STDMETHOD(COMGETTER(PageFusionEnabled))(BOOL *aPageFusionEnabled);
    STDMETHOD(COMSETTER(PageFusionEnabled))(BOOL aPageFusionEnabled);
    STDMETHOD(COMGETTER(GraphicsControllerType))(GraphicsControllerType_T *aGraphicsControllerType);
    STDMETHOD(COMSETTER(GraphicsControllerType))(GraphicsControllerType_T aGraphicsControllerType);
    STDMETHOD(COMGETTER(VRAMSize))(ULONG *aVRAMSize);
    STDMETHOD(COMSETTER(VRAMSize))(ULONG aVRAMSize);
    STDMETHOD(COMGETTER(Accelerate3DEnabled))(BOOL *aAccelerate3DEnabled);
    STDMETHOD(COMSETTER(Accelerate3DEnabled))(BOOL aAccelerate3DEnabled);
    STDMETHOD(COMGETTER(Accelerate2DVideoEnabled))(BOOL *aAccelerate2DVideoEnabled);
    STDMETHOD(COMSETTER(Accelerate2DVideoEnabled))(BOOL aAccelerate2DVideoEnabled);
    STDMETHOD(COMGETTER(MonitorCount))(ULONG *aMonitorCount);
    STDMETHOD(COMSETTER(MonitorCount))(ULONG aMonitorCount);
    STDMETHOD(COMGETTER(VideoCaptureEnabled))(BOOL *aVideoCaptureEnabled);
    STDMETHOD(COMSETTER(VideoCaptureEnabled))(BOOL aVideoCaptureEnabled);
    STDMETHOD(COMGETTER(VideoCaptureScreens))(ComSafeArrayOut(BOOL, aVideoCaptureScreens));
    STDMETHOD(COMSETTER(VideoCaptureScreens))(ComSafeArrayIn(BOOL, aVideoCaptureScreens));
    STDMETHOD(COMGETTER(VideoCaptureFile))(BSTR *aVideoCaptureFile);
    STDMETHOD(COMSETTER(VideoCaptureFile))(IN_BSTR aVideoCaptureFile);
    STDMETHOD(COMGETTER(VideoCaptureWidth))(ULONG *aVideoCaptureWidth);
    STDMETHOD(COMSETTER(VideoCaptureWidth))(ULONG aVideoCaptureWidth);
    STDMETHOD(COMGETTER(VideoCaptureHeight))(ULONG *aVideoCaptureHeight);
    STDMETHOD(COMSETTER(VideoCaptureHeight))(ULONG aVideoCaptureHeight);
    STDMETHOD(COMGETTER(VideoCaptureRate))(ULONG *aVideoCaptureRate);
    STDMETHOD(COMSETTER(VideoCaptureRate))(ULONG aVideoCaptureRate);
    STDMETHOD(COMGETTER(VideoCaptureFPS))(ULONG *aVideoCaptureFPS);
    STDMETHOD(COMSETTER(VideoCaptureFPS))(ULONG aVideoCaptureFPS);
    STDMETHOD(COMGETTER(BIOSSettings))(IBIOSSettings **aBIOSSettings);
    STDMETHOD(COMGETTER(FirmwareType))(FirmwareType_T *aFirmwareType);
    STDMETHOD(COMSETTER(FirmwareType))(FirmwareType_T aFirmwareType);
    STDMETHOD(COMGETTER(PointingHIDType))(PointingHIDType_T *aPointingHIDType);
    STDMETHOD(COMSETTER(PointingHIDType))(PointingHIDType_T aPointingHIDType);
    STDMETHOD(COMGETTER(KeyboardHIDType))(KeyboardHIDType_T *aKeyboardHIDType);
    STDMETHOD(COMSETTER(KeyboardHIDType))(KeyboardHIDType_T aKeyboardHIDType);
    STDMETHOD(COMGETTER(HPETEnabled))(BOOL *aHPETEnabled);
    STDMETHOD(COMSETTER(HPETEnabled))(BOOL aHPETEnabled);
    STDMETHOD(COMGETTER(ChipsetType))(ChipsetType_T *aChipsetType);
    STDMETHOD(COMSETTER(ChipsetType))(ChipsetType_T aChipsetType);
    STDMETHOD(COMGETTER(SnapshotFolder))(BSTR *aSnapshotFolder);
    STDMETHOD(COMSETTER(SnapshotFolder))(IN_BSTR aSnapshotFolder);
    STDMETHOD(COMGETTER(VRDEServer))(IVRDEServer **aVRDEServer);
    STDMETHOD(COMGETTER(EmulatedUSBCardReaderEnabled))(BOOL *aEmulatedUSBCardReaderEnabled);
    STDMETHOD(COMSETTER(EmulatedUSBCardReaderEnabled))(BOOL aEmulatedUSBCardReaderEnabled);
    STDMETHOD(COMGETTER(MediumAttachments))(ComSafeArrayOut(IMediumAttachment *, aMediumAttachments));
    STDMETHOD(COMGETTER(USBControllers))(ComSafeArrayOut(IUSBController *, aUSBControllers));
    STDMETHOD(COMGETTER(USBDeviceFilters))(IUSBDeviceFilters **aUSBDeviceFilters);
    STDMETHOD(COMGETTER(AudioAdapter))(IAudioAdapter **aAudioAdapter);
    STDMETHOD(COMGETTER(StorageControllers))(ComSafeArrayOut(IStorageController *, aStorageControllers));
    STDMETHOD(COMGETTER(SettingsFilePath))(BSTR *aSettingsFilePath);
    STDMETHOD(COMGETTER(SettingsModified))(BOOL *aSettingsModified);
    STDMETHOD(COMGETTER(SessionState))(SessionState_T *aSessionState);
    STDMETHOD(COMGETTER(SessionType))(BSTR *aSessionType);
    STDMETHOD(COMGETTER(SessionPID))(ULONG *aSessionPID);
    STDMETHOD(COMGETTER(State))(MachineState_T *aState);
    STDMETHOD(COMGETTER(LastStateChange))(LONG64 *aLastStateChange);
    STDMETHOD(COMGETTER(StateFilePath))(BSTR *aStateFilePath);
    STDMETHOD(COMGETTER(LogFolder))(BSTR *aLogFolder);
    STDMETHOD(COMGETTER(CurrentSnapshot))(ISnapshot **aCurrentSnapshot);
    STDMETHOD(COMGETTER(SnapshotCount))(ULONG *aSnapshotCount);
    STDMETHOD(COMGETTER(CurrentStateModified))(BOOL *aCurrentStateModified);
    STDMETHOD(COMGETTER(SharedFolders))(ComSafeArrayOut(ISharedFolder *, aSharedFolders));
    STDMETHOD(COMGETTER(ClipboardMode))(ClipboardMode_T *aClipboardMode);
    STDMETHOD(COMSETTER(ClipboardMode))(ClipboardMode_T aClipboardMode);
    STDMETHOD(COMGETTER(DragAndDropMode))(DragAndDropMode_T *aDragAndDropMode);
    STDMETHOD(COMSETTER(DragAndDropMode))(DragAndDropMode_T aDragAndDropMode);
    STDMETHOD(COMGETTER(GuestPropertyNotificationPatterns))(BSTR *aGuestPropertyNotificationPatterns);
    STDMETHOD(COMSETTER(GuestPropertyNotificationPatterns))(IN_BSTR aGuestPropertyNotificationPatterns);
    STDMETHOD(COMGETTER(TeleporterEnabled))(BOOL *aTeleporterEnabled);
    STDMETHOD(COMSETTER(TeleporterEnabled))(BOOL aTeleporterEnabled);
    STDMETHOD(COMGETTER(TeleporterPort))(ULONG *aTeleporterPort);
    STDMETHOD(COMSETTER(TeleporterPort))(ULONG aTeleporterPort);
    STDMETHOD(COMGETTER(TeleporterAddress))(BSTR *aTeleporterAddress);
    STDMETHOD(COMSETTER(TeleporterAddress))(IN_BSTR aTeleporterAddress);
    STDMETHOD(COMGETTER(TeleporterPassword))(BSTR *aTeleporterPassword);
    STDMETHOD(COMSETTER(TeleporterPassword))(IN_BSTR aTeleporterPassword);
    STDMETHOD(COMGETTER(FaultToleranceState))(FaultToleranceState_T *aFaultToleranceState);
    STDMETHOD(COMSETTER(FaultToleranceState))(FaultToleranceState_T aFaultToleranceState);
    STDMETHOD(COMGETTER(FaultTolerancePort))(ULONG *aFaultTolerancePort);
    STDMETHOD(COMSETTER(FaultTolerancePort))(ULONG aFaultTolerancePort);
    STDMETHOD(COMGETTER(FaultToleranceAddress))(BSTR *aFaultToleranceAddress);
    STDMETHOD(COMSETTER(FaultToleranceAddress))(IN_BSTR aFaultToleranceAddress);
    STDMETHOD(COMGETTER(FaultTolerancePassword))(BSTR *aFaultTolerancePassword);
    STDMETHOD(COMSETTER(FaultTolerancePassword))(IN_BSTR aFaultTolerancePassword);
    STDMETHOD(COMGETTER(FaultToleranceSyncInterval))(ULONG *aFaultToleranceSyncInterval);
    STDMETHOD(COMSETTER(FaultToleranceSyncInterval))(ULONG aFaultToleranceSyncInterval);
    STDMETHOD(COMGETTER(RTCUseUTC))(BOOL *aRTCUseUTC);
    STDMETHOD(COMSETTER(RTCUseUTC))(BOOL aRTCUseUTC);
    STDMETHOD(COMGETTER(IOCacheEnabled))(BOOL *aIOCacheEnabled);
    STDMETHOD(COMSETTER(IOCacheEnabled))(BOOL aIOCacheEnabled);
    STDMETHOD(COMGETTER(IOCacheSize))(ULONG *aIOCacheSize);
    STDMETHOD(COMSETTER(IOCacheSize))(ULONG aIOCacheSize);
    STDMETHOD(COMGETTER(PCIDeviceAssignments))(ComSafeArrayOut(IPCIDeviceAttachment *, aPCIDeviceAssignments));
    STDMETHOD(COMGETTER(BandwidthControl))(IBandwidthControl **aBandwidthControl);
    STDMETHOD(COMGETTER(TracingEnabled))(BOOL *aTracingEnabled);
    STDMETHOD(COMSETTER(TracingEnabled))(BOOL aTracingEnabled);
    STDMETHOD(COMGETTER(TracingConfig))(BSTR *aTracingConfig);
    STDMETHOD(COMSETTER(TracingConfig))(IN_BSTR aTracingConfig);
    STDMETHOD(COMGETTER(AllowTracingToAccessVM))(BOOL *aAllowTracingToAccessVM);
    STDMETHOD(COMSETTER(AllowTracingToAccessVM))(BOOL aAllowTracingToAccessVM);
    STDMETHOD(COMGETTER(AutostartEnabled))(BOOL *aAutostartEnabled);
    STDMETHOD(COMSETTER(AutostartEnabled))(BOOL aAutostartEnabled);
    STDMETHOD(COMGETTER(AutostartDelay))(ULONG *aAutostartDelay);
    STDMETHOD(COMSETTER(AutostartDelay))(ULONG aAutostartDelay);
    STDMETHOD(COMGETTER(AutostopType))(AutostopType_T *aAutostopType);
    STDMETHOD(COMSETTER(AutostopType))(AutostopType_T aAutostopType);
    STDMETHOD(COMGETTER(DefaultFrontend))(BSTR *aDefaultFrontend);
    STDMETHOD(COMSETTER(DefaultFrontend))(IN_BSTR aDefaultFrontend);
    STDMETHOD(COMGETTER(USBProxyAvailable))(BOOL *aUSBProxyAvailable);

    // public IMachine methods
    STDMETHOD(LockMachine)(ISession *aSession,
                           LockType_T aLockType);
    STDMETHOD(LaunchVMProcess)(ISession *aSession,
                               IN_BSTR aType,
                               IN_BSTR aEnvironment,
                               IProgress **aProgress);
    STDMETHOD(SetBootOrder)(ULONG aPosition,
                            DeviceType_T aDevice);
    STDMETHOD(GetBootOrder)(ULONG aPosition,
                            DeviceType_T *aDevice);
    STDMETHOD(AttachDevice)(IN_BSTR aName,
                            LONG aControllerPort,
                            LONG aDevice,
                            DeviceType_T aType,
                            IMedium *aMedium);
    STDMETHOD(AttachDeviceWithoutMedium)(IN_BSTR aName,
                                         LONG aControllerPort,
                                         LONG aDevice,
                                         DeviceType_T aType);
    STDMETHOD(DetachDevice)(IN_BSTR aName,
                            LONG aControllerPort,
                            LONG aDevice);
    STDMETHOD(PassthroughDevice)(IN_BSTR aName,
                                 LONG aControllerPort,
                                 LONG aDevice,
                                 BOOL aPassthrough);
    STDMETHOD(TemporaryEjectDevice)(IN_BSTR aName,
                                    LONG aControllerPort,
                                    LONG aDevice,
                                    BOOL aTemporaryEject);
    STDMETHOD(NonRotationalDevice)(IN_BSTR aName,
                                   LONG aControllerPort,
                                   LONG aDevice,
                                   BOOL aNonRotational);
    STDMETHOD(SetAutoDiscardForDevice)(IN_BSTR aName,
                                       LONG aControllerPort,
                                       LONG aDevice,
                                       BOOL aDiscard);
    STDMETHOD(SetHotPluggableForDevice)(IN_BSTR aName,
                                        LONG aControllerPort,
                                        LONG aDevice,
                                        BOOL aHotPluggable);
    STDMETHOD(SetBandwidthGroupForDevice)(IN_BSTR aName,
                                          LONG aControllerPort,
                                          LONG aDevice,
                                          IBandwidthGroup *aBandwidthGroup);
    STDMETHOD(SetNoBandwidthGroupForDevice)(IN_BSTR aName,
                                            LONG aControllerPort,
                                            LONG aDevice);
    STDMETHOD(UnmountMedium)(IN_BSTR aName,
                             LONG aControllerPort,
                             LONG aDevice,
                             BOOL aForce);
    STDMETHOD(MountMedium)(IN_BSTR aName,
                           LONG aControllerPort,
                           LONG aDevice,
                           IMedium *aMedium,
                           BOOL aForce);
    STDMETHOD(GetMedium)(IN_BSTR aName,
                         LONG aControllerPort,
                         LONG aDevice,
                         IMedium **aMedium);
    STDMETHOD(GetMediumAttachmentsOfController)(IN_BSTR aName,
                                                ComSafeArrayOut(IMediumAttachment *, aMediumAttachments));
    STDMETHOD(GetMediumAttachment)(IN_BSTR aName,
                                   LONG aControllerPort,
                                   LONG aDevice,
                                   IMediumAttachment **aAttachment);
    STDMETHOD(AttachHostPCIDevice)(LONG aHostAddress,
                                   LONG aDesiredGuestAddress,
                                   BOOL aTryToUnbind);
    STDMETHOD(DetachHostPCIDevice)(LONG aHostAddress);
    STDMETHOD(GetNetworkAdapter)(ULONG aSlot,
                                 INetworkAdapter **aAdapter);
    STDMETHOD(AddStorageController)(IN_BSTR aName,
                                    StorageBus_T aConnectionType,
                                    IStorageController **aController);
    STDMETHOD(GetStorageControllerByName)(IN_BSTR aName,
                                          IStorageController **aStorageController);
    STDMETHOD(GetStorageControllerByInstance)(ULONG aInstance,
                                              IStorageController **aStorageController);
    STDMETHOD(RemoveStorageController)(IN_BSTR aName);
    STDMETHOD(SetStorageControllerBootable)(IN_BSTR aName,
                                            BOOL aBootable);
    STDMETHOD(AddUSBController)(IN_BSTR aName,
                                USBControllerType_T aType,
                                IUSBController **aController);
    STDMETHOD(RemoveUSBController)(IN_BSTR aName);
    STDMETHOD(GetUSBControllerByName)(IN_BSTR aName,
                                      IUSBController **aController);
    STDMETHOD(GetUSBControllerCountByType)(USBControllerType_T aType,
                                           ULONG *aControllers);
    STDMETHOD(GetSerialPort)(ULONG aSlot,
                             ISerialPort **aPort);
    STDMETHOD(GetParallelPort)(ULONG aSlot,
                               IParallelPort **aPort);
    STDMETHOD(GetExtraDataKeys)(ComSafeArrayOut(BSTR, aKeys));
    STDMETHOD(GetExtraData)(IN_BSTR aKey,
                            BSTR *aValue);
    STDMETHOD(SetExtraData)(IN_BSTR aKey,
                            IN_BSTR aValue);
    STDMETHOD(GetCPUProperty)(CPUPropertyType_T aProperty,
                              BOOL *aValue);
    STDMETHOD(SetCPUProperty)(CPUPropertyType_T aProperty,
                              BOOL aValue);
    STDMETHOD(GetCPUIDLeaf)(ULONG aId,
                            ULONG *aValEax,
                            ULONG *aValEbx,
                            ULONG *aValEcx,
                            ULONG *aValEdx);
    STDMETHOD(SetCPUIDLeaf)(ULONG aId,
                            ULONG aValEax,
                            ULONG aValEbx,
                            ULONG aValEcx,
                            ULONG aValEdx);
    STDMETHOD(RemoveCPUIDLeaf)(ULONG aId);
    STDMETHOD(RemoveAllCPUIDLeaves)();
    STDMETHOD(GetHWVirtExProperty)(HWVirtExPropertyType_T aProperty,
                                   BOOL *aValue);
    STDMETHOD(SetHWVirtExProperty)(HWVirtExPropertyType_T aProperty,
                                   BOOL aValue);
    STDMETHOD(SetSettingsFilePath)(IN_BSTR aSettingsFilePath,
                                   IProgress **aProgress);
    STDMETHOD(SaveSettings)();
    STDMETHOD(DiscardSettings)();
    STDMETHOD(Unregister)(CleanupMode_T aCleanupMode,
                          ComSafeArrayOut(IMedium *, aMedia));
    STDMETHOD(DeleteConfig)(ComSafeArrayIn(IMedium *, aMedia),
                            IProgress **aProgress);
    STDMETHOD(ExportTo)(IAppliance *aAppliance,
                        IN_BSTR aLocation,
                        IVirtualSystemDescription **aDescription);
    STDMETHOD(FindSnapshot)(IN_BSTR aNameOrId,
                            ISnapshot **aSnapshot);
    STDMETHOD(CreateSharedFolder)(IN_BSTR aName,
                                  IN_BSTR aHostPath,
                                  BOOL aWritable,
                                  BOOL aAutomount);
    STDMETHOD(RemoveSharedFolder)(IN_BSTR aName);
    STDMETHOD(CanShowConsoleWindow)(BOOL *aCanShow);
    STDMETHOD(ShowConsoleWindow)(LONG64 *aWinId);
    STDMETHOD(GetGuestProperty)(IN_BSTR aName,
                                BSTR *aValue,
                                LONG64 *aTimestamp,
                                BSTR *aFlags);
    STDMETHOD(GetGuestPropertyValue)(IN_BSTR aProperty,
                                     BSTR *aValue);
    STDMETHOD(GetGuestPropertyTimestamp)(IN_BSTR aProperty,
                                         LONG64 *aValue);
    STDMETHOD(SetGuestProperty)(IN_BSTR aProperty,
                                IN_BSTR aValue,
                                IN_BSTR aFlags);
    STDMETHOD(SetGuestPropertyValue)(IN_BSTR aProperty,
                                     IN_BSTR aValue);
    STDMETHOD(DeleteGuestProperty)(IN_BSTR aName);
    STDMETHOD(EnumerateGuestProperties)(IN_BSTR aPatterns,
                                        ComSafeArrayOut(BSTR, aNames),
                                        ComSafeArrayOut(BSTR, aValues),
                                        ComSafeArrayOut(LONG64, aTimestamps),
                                        ComSafeArrayOut(BSTR, aFlags));
    STDMETHOD(QuerySavedGuestScreenInfo)(ULONG aScreenId,
                                         ULONG *aOriginX,
                                         ULONG *aOriginY,
                                         ULONG *aWidth,
                                         ULONG *aHeight,
                                         BOOL *aEnabled);
    STDMETHOD(QuerySavedThumbnailSize)(ULONG aScreenId,
                                       ULONG *aSize,
                                       ULONG *aWidth,
                                       ULONG *aHeight);
    STDMETHOD(ReadSavedThumbnailToArray)(ULONG aScreenId,
                                         BOOL aBGR,
                                         ULONG *aWidth,
                                         ULONG *aHeight,
                                         ComSafeArrayOut(BYTE, aData));
    STDMETHOD(ReadSavedThumbnailPNGToArray)(ULONG aScreenId,
                                            ULONG *aWidth,
                                            ULONG *aHeight,
                                            ComSafeArrayOut(BYTE, aData));
    STDMETHOD(QuerySavedScreenshotPNGSize)(ULONG aScreenId,
                                           ULONG *aSize,
                                           ULONG *aWidth,
                                           ULONG *aHeight);
    STDMETHOD(ReadSavedScreenshotPNGToArray)(ULONG aScreenId,
                                             ULONG *aWidth,
                                             ULONG *aHeight,
                                             ComSafeArrayOut(BYTE, aData));
    STDMETHOD(HotPlugCPU)(ULONG aCpu);
    STDMETHOD(HotUnplugCPU)(ULONG aCpu);
    STDMETHOD(GetCPUStatus)(ULONG aCpu,
                            BOOL *aAttached);
    STDMETHOD(QueryLogFilename)(ULONG aIdx,
                                BSTR *aFilename);
    STDMETHOD(ReadLog)(ULONG aIdx,
                       LONG64 aOffset,
                       LONG64 aSize,
                       ComSafeArrayOut(BYTE, aData));
    STDMETHOD(CloneTo)(IMachine *aTarget,
                       CloneMode_T aMode,
                       ComSafeArrayIn(CloneOptions_T, aOptions),
                       IProgress **aProgress);

private:
    // wrapped IMachine properties
    virtual HRESULT getParent(ComPtr<IVirtualBox> &aParent) = 0;
    virtual HRESULT getIcon(std::vector<BYTE> &aIcon) = 0;
    virtual HRESULT setIcon(const std::vector<BYTE> &aIcon) = 0;
    virtual HRESULT getAccessible(BOOL *aAccessible) = 0;
    virtual HRESULT getAccessError(ComPtr<IVirtualBoxErrorInfo> &aAccessError) = 0;
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT setName(const com::Utf8Str &aName) = 0;
    virtual HRESULT getDescription(com::Utf8Str &aDescription) = 0;
    virtual HRESULT setDescription(const com::Utf8Str &aDescription) = 0;
    virtual HRESULT getId(com::Guid &aId) = 0;
    virtual HRESULT getGroups(std::vector<com::Utf8Str> &aGroups) = 0;
    virtual HRESULT setGroups(const std::vector<com::Utf8Str> &aGroups) = 0;
    virtual HRESULT getOSTypeId(com::Utf8Str &aOSTypeId) = 0;
    virtual HRESULT setOSTypeId(const com::Utf8Str &aOSTypeId) = 0;
    virtual HRESULT getHardwareVersion(com::Utf8Str &aHardwareVersion) = 0;
    virtual HRESULT setHardwareVersion(const com::Utf8Str &aHardwareVersion) = 0;
    virtual HRESULT getHardwareUUID(com::Guid &aHardwareUUID) = 0;
    virtual HRESULT setHardwareUUID(const com::Guid &aHardwareUUID) = 0;
    virtual HRESULT getCPUCount(ULONG *aCPUCount) = 0;
    virtual HRESULT setCPUCount(ULONG aCPUCount) = 0;
    virtual HRESULT getCPUHotPlugEnabled(BOOL *aCPUHotPlugEnabled) = 0;
    virtual HRESULT setCPUHotPlugEnabled(BOOL aCPUHotPlugEnabled) = 0;
    virtual HRESULT getCPUExecutionCap(ULONG *aCPUExecutionCap) = 0;
    virtual HRESULT setCPUExecutionCap(ULONG aCPUExecutionCap) = 0;
    virtual HRESULT getMemorySize(ULONG *aMemorySize) = 0;
    virtual HRESULT setMemorySize(ULONG aMemorySize) = 0;
    virtual HRESULT getMemoryBalloonSize(ULONG *aMemoryBalloonSize) = 0;
    virtual HRESULT setMemoryBalloonSize(ULONG aMemoryBalloonSize) = 0;
    virtual HRESULT getPageFusionEnabled(BOOL *aPageFusionEnabled) = 0;
    virtual HRESULT setPageFusionEnabled(BOOL aPageFusionEnabled) = 0;
    virtual HRESULT getGraphicsControllerType(GraphicsControllerType_T *aGraphicsControllerType) = 0;
    virtual HRESULT setGraphicsControllerType(GraphicsControllerType_T aGraphicsControllerType) = 0;
    virtual HRESULT getVRAMSize(ULONG *aVRAMSize) = 0;
    virtual HRESULT setVRAMSize(ULONG aVRAMSize) = 0;
    virtual HRESULT getAccelerate3DEnabled(BOOL *aAccelerate3DEnabled) = 0;
    virtual HRESULT setAccelerate3DEnabled(BOOL aAccelerate3DEnabled) = 0;
    virtual HRESULT getAccelerate2DVideoEnabled(BOOL *aAccelerate2DVideoEnabled) = 0;
    virtual HRESULT setAccelerate2DVideoEnabled(BOOL aAccelerate2DVideoEnabled) = 0;
    virtual HRESULT getMonitorCount(ULONG *aMonitorCount) = 0;
    virtual HRESULT setMonitorCount(ULONG aMonitorCount) = 0;
    virtual HRESULT getVideoCaptureEnabled(BOOL *aVideoCaptureEnabled) = 0;
    virtual HRESULT setVideoCaptureEnabled(BOOL aVideoCaptureEnabled) = 0;
    virtual HRESULT getVideoCaptureScreens(std::vector<BOOL> &aVideoCaptureScreens) = 0;
    virtual HRESULT setVideoCaptureScreens(const std::vector<BOOL> &aVideoCaptureScreens) = 0;
    virtual HRESULT getVideoCaptureFile(com::Utf8Str &aVideoCaptureFile) = 0;
    virtual HRESULT setVideoCaptureFile(const com::Utf8Str &aVideoCaptureFile) = 0;
    virtual HRESULT getVideoCaptureWidth(ULONG *aVideoCaptureWidth) = 0;
    virtual HRESULT setVideoCaptureWidth(ULONG aVideoCaptureWidth) = 0;
    virtual HRESULT getVideoCaptureHeight(ULONG *aVideoCaptureHeight) = 0;
    virtual HRESULT setVideoCaptureHeight(ULONG aVideoCaptureHeight) = 0;
    virtual HRESULT getVideoCaptureRate(ULONG *aVideoCaptureRate) = 0;
    virtual HRESULT setVideoCaptureRate(ULONG aVideoCaptureRate) = 0;
    virtual HRESULT getVideoCaptureFPS(ULONG *aVideoCaptureFPS) = 0;
    virtual HRESULT setVideoCaptureFPS(ULONG aVideoCaptureFPS) = 0;
    virtual HRESULT getBIOSSettings(ComPtr<IBIOSSettings> &aBIOSSettings) = 0;
    virtual HRESULT getFirmwareType(FirmwareType_T *aFirmwareType) = 0;
    virtual HRESULT setFirmwareType(FirmwareType_T aFirmwareType) = 0;
    virtual HRESULT getPointingHIDType(PointingHIDType_T *aPointingHIDType) = 0;
    virtual HRESULT setPointingHIDType(PointingHIDType_T aPointingHIDType) = 0;
    virtual HRESULT getKeyboardHIDType(KeyboardHIDType_T *aKeyboardHIDType) = 0;
    virtual HRESULT setKeyboardHIDType(KeyboardHIDType_T aKeyboardHIDType) = 0;
    virtual HRESULT getHPETEnabled(BOOL *aHPETEnabled) = 0;
    virtual HRESULT setHPETEnabled(BOOL aHPETEnabled) = 0;
    virtual HRESULT getChipsetType(ChipsetType_T *aChipsetType) = 0;
    virtual HRESULT setChipsetType(ChipsetType_T aChipsetType) = 0;
    virtual HRESULT getSnapshotFolder(com::Utf8Str &aSnapshotFolder) = 0;
    virtual HRESULT setSnapshotFolder(const com::Utf8Str &aSnapshotFolder) = 0;
    virtual HRESULT getVRDEServer(ComPtr<IVRDEServer> &aVRDEServer) = 0;
    virtual HRESULT getEmulatedUSBCardReaderEnabled(BOOL *aEmulatedUSBCardReaderEnabled) = 0;
    virtual HRESULT setEmulatedUSBCardReaderEnabled(BOOL aEmulatedUSBCardReaderEnabled) = 0;
    virtual HRESULT getMediumAttachments(std::vector<ComPtr<IMediumAttachment> > &aMediumAttachments) = 0;
    virtual HRESULT getUSBControllers(std::vector<ComPtr<IUSBController> > &aUSBControllers) = 0;
    virtual HRESULT getUSBDeviceFilters(ComPtr<IUSBDeviceFilters> &aUSBDeviceFilters) = 0;
    virtual HRESULT getAudioAdapter(ComPtr<IAudioAdapter> &aAudioAdapter) = 0;
    virtual HRESULT getStorageControllers(std::vector<ComPtr<IStorageController> > &aStorageControllers) = 0;
    virtual HRESULT getSettingsFilePath(com::Utf8Str &aSettingsFilePath) = 0;
    virtual HRESULT getSettingsModified(BOOL *aSettingsModified) = 0;
    virtual HRESULT getSessionState(SessionState_T *aSessionState) = 0;
    virtual HRESULT getSessionType(com::Utf8Str &aSessionType) = 0;
    virtual HRESULT getSessionPID(ULONG *aSessionPID) = 0;
    virtual HRESULT getState(MachineState_T *aState) = 0;
    virtual HRESULT getLastStateChange(LONG64 *aLastStateChange) = 0;
    virtual HRESULT getStateFilePath(com::Utf8Str &aStateFilePath) = 0;
    virtual HRESULT getLogFolder(com::Utf8Str &aLogFolder) = 0;
    virtual HRESULT getCurrentSnapshot(ComPtr<ISnapshot> &aCurrentSnapshot) = 0;
    virtual HRESULT getSnapshotCount(ULONG *aSnapshotCount) = 0;
    virtual HRESULT getCurrentStateModified(BOOL *aCurrentStateModified) = 0;
    virtual HRESULT getSharedFolders(std::vector<ComPtr<ISharedFolder> > &aSharedFolders) = 0;
    virtual HRESULT getClipboardMode(ClipboardMode_T *aClipboardMode) = 0;
    virtual HRESULT setClipboardMode(ClipboardMode_T aClipboardMode) = 0;
    virtual HRESULT getDragAndDropMode(DragAndDropMode_T *aDragAndDropMode) = 0;
    virtual HRESULT setDragAndDropMode(DragAndDropMode_T aDragAndDropMode) = 0;
    virtual HRESULT getGuestPropertyNotificationPatterns(com::Utf8Str &aGuestPropertyNotificationPatterns) = 0;
    virtual HRESULT setGuestPropertyNotificationPatterns(const com::Utf8Str &aGuestPropertyNotificationPatterns) = 0;
    virtual HRESULT getTeleporterEnabled(BOOL *aTeleporterEnabled) = 0;
    virtual HRESULT setTeleporterEnabled(BOOL aTeleporterEnabled) = 0;
    virtual HRESULT getTeleporterPort(ULONG *aTeleporterPort) = 0;
    virtual HRESULT setTeleporterPort(ULONG aTeleporterPort) = 0;
    virtual HRESULT getTeleporterAddress(com::Utf8Str &aTeleporterAddress) = 0;
    virtual HRESULT setTeleporterAddress(const com::Utf8Str &aTeleporterAddress) = 0;
    virtual HRESULT getTeleporterPassword(com::Utf8Str &aTeleporterPassword) = 0;
    virtual HRESULT setTeleporterPassword(const com::Utf8Str &aTeleporterPassword) = 0;
    virtual HRESULT getFaultToleranceState(FaultToleranceState_T *aFaultToleranceState) = 0;
    virtual HRESULT setFaultToleranceState(FaultToleranceState_T aFaultToleranceState) = 0;
    virtual HRESULT getFaultTolerancePort(ULONG *aFaultTolerancePort) = 0;
    virtual HRESULT setFaultTolerancePort(ULONG aFaultTolerancePort) = 0;
    virtual HRESULT getFaultToleranceAddress(com::Utf8Str &aFaultToleranceAddress) = 0;
    virtual HRESULT setFaultToleranceAddress(const com::Utf8Str &aFaultToleranceAddress) = 0;
    virtual HRESULT getFaultTolerancePassword(com::Utf8Str &aFaultTolerancePassword) = 0;
    virtual HRESULT setFaultTolerancePassword(const com::Utf8Str &aFaultTolerancePassword) = 0;
    virtual HRESULT getFaultToleranceSyncInterval(ULONG *aFaultToleranceSyncInterval) = 0;
    virtual HRESULT setFaultToleranceSyncInterval(ULONG aFaultToleranceSyncInterval) = 0;
    virtual HRESULT getRTCUseUTC(BOOL *aRTCUseUTC) = 0;
    virtual HRESULT setRTCUseUTC(BOOL aRTCUseUTC) = 0;
    virtual HRESULT getIOCacheEnabled(BOOL *aIOCacheEnabled) = 0;
    virtual HRESULT setIOCacheEnabled(BOOL aIOCacheEnabled) = 0;
    virtual HRESULT getIOCacheSize(ULONG *aIOCacheSize) = 0;
    virtual HRESULT setIOCacheSize(ULONG aIOCacheSize) = 0;
    virtual HRESULT getPCIDeviceAssignments(std::vector<ComPtr<IPCIDeviceAttachment> > &aPCIDeviceAssignments) = 0;
    virtual HRESULT getBandwidthControl(ComPtr<IBandwidthControl> &aBandwidthControl) = 0;
    virtual HRESULT getTracingEnabled(BOOL *aTracingEnabled) = 0;
    virtual HRESULT setTracingEnabled(BOOL aTracingEnabled) = 0;
    virtual HRESULT getTracingConfig(com::Utf8Str &aTracingConfig) = 0;
    virtual HRESULT setTracingConfig(const com::Utf8Str &aTracingConfig) = 0;
    virtual HRESULT getAllowTracingToAccessVM(BOOL *aAllowTracingToAccessVM) = 0;
    virtual HRESULT setAllowTracingToAccessVM(BOOL aAllowTracingToAccessVM) = 0;
    virtual HRESULT getAutostartEnabled(BOOL *aAutostartEnabled) = 0;
    virtual HRESULT setAutostartEnabled(BOOL aAutostartEnabled) = 0;
    virtual HRESULT getAutostartDelay(ULONG *aAutostartDelay) = 0;
    virtual HRESULT setAutostartDelay(ULONG aAutostartDelay) = 0;
    virtual HRESULT getAutostopType(AutostopType_T *aAutostopType) = 0;
    virtual HRESULT setAutostopType(AutostopType_T aAutostopType) = 0;
    virtual HRESULT getDefaultFrontend(com::Utf8Str &aDefaultFrontend) = 0;
    virtual HRESULT setDefaultFrontend(const com::Utf8Str &aDefaultFrontend) = 0;
    virtual HRESULT getUSBProxyAvailable(BOOL *aUSBProxyAvailable) = 0;

    // wrapped IMachine methods
    virtual HRESULT lockMachine(const ComPtr<ISession> &aSession,
                                LockType_T aLockType) = 0;
    virtual HRESULT launchVMProcess(const ComPtr<ISession> &aSession,
                                    const com::Utf8Str &aType,
                                    const com::Utf8Str &aEnvironment,
                                    ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT setBootOrder(ULONG aPosition,
                                 DeviceType_T aDevice) = 0;
    virtual HRESULT getBootOrder(ULONG aPosition,
                                 DeviceType_T *aDevice) = 0;
    virtual HRESULT attachDevice(const com::Utf8Str &aName,
                                 LONG aControllerPort,
                                 LONG aDevice,
                                 DeviceType_T aType,
                                 const ComPtr<IMedium> &aMedium) = 0;
    virtual HRESULT attachDeviceWithoutMedium(const com::Utf8Str &aName,
                                              LONG aControllerPort,
                                              LONG aDevice,
                                              DeviceType_T aType) = 0;
    virtual HRESULT detachDevice(const com::Utf8Str &aName,
                                 LONG aControllerPort,
                                 LONG aDevice) = 0;
    virtual HRESULT passthroughDevice(const com::Utf8Str &aName,
                                      LONG aControllerPort,
                                      LONG aDevice,
                                      BOOL aPassthrough) = 0;
    virtual HRESULT temporaryEjectDevice(const com::Utf8Str &aName,
                                         LONG aControllerPort,
                                         LONG aDevice,
                                         BOOL aTemporaryEject) = 0;
    virtual HRESULT nonRotationalDevice(const com::Utf8Str &aName,
                                        LONG aControllerPort,
                                        LONG aDevice,
                                        BOOL aNonRotational) = 0;
    virtual HRESULT setAutoDiscardForDevice(const com::Utf8Str &aName,
                                            LONG aControllerPort,
                                            LONG aDevice,
                                            BOOL aDiscard) = 0;
    virtual HRESULT setHotPluggableForDevice(const com::Utf8Str &aName,
                                             LONG aControllerPort,
                                             LONG aDevice,
                                             BOOL aHotPluggable) = 0;
    virtual HRESULT setBandwidthGroupForDevice(const com::Utf8Str &aName,
                                               LONG aControllerPort,
                                               LONG aDevice,
                                               const ComPtr<IBandwidthGroup> &aBandwidthGroup) = 0;
    virtual HRESULT setNoBandwidthGroupForDevice(const com::Utf8Str &aName,
                                                 LONG aControllerPort,
                                                 LONG aDevice) = 0;
    virtual HRESULT unmountMedium(const com::Utf8Str &aName,
                                  LONG aControllerPort,
                                  LONG aDevice,
                                  BOOL aForce) = 0;
    virtual HRESULT mountMedium(const com::Utf8Str &aName,
                                LONG aControllerPort,
                                LONG aDevice,
                                const ComPtr<IMedium> &aMedium,
                                BOOL aForce) = 0;
    virtual HRESULT getMedium(const com::Utf8Str &aName,
                              LONG aControllerPort,
                              LONG aDevice,
                              ComPtr<IMedium> &aMedium) = 0;
    virtual HRESULT getMediumAttachmentsOfController(const com::Utf8Str &aName,
                                                     std::vector<ComPtr<IMediumAttachment> > &aMediumAttachments) = 0;
    virtual HRESULT getMediumAttachment(const com::Utf8Str &aName,
                                        LONG aControllerPort,
                                        LONG aDevice,
                                        ComPtr<IMediumAttachment> &aAttachment) = 0;
    virtual HRESULT attachHostPCIDevice(LONG aHostAddress,
                                        LONG aDesiredGuestAddress,
                                        BOOL aTryToUnbind) = 0;
    virtual HRESULT detachHostPCIDevice(LONG aHostAddress) = 0;
    virtual HRESULT getNetworkAdapter(ULONG aSlot,
                                      ComPtr<INetworkAdapter> &aAdapter) = 0;
    virtual HRESULT addStorageController(const com::Utf8Str &aName,
                                         StorageBus_T aConnectionType,
                                         ComPtr<IStorageController> &aController) = 0;
    virtual HRESULT getStorageControllerByName(const com::Utf8Str &aName,
                                               ComPtr<IStorageController> &aStorageController) = 0;
    virtual HRESULT getStorageControllerByInstance(ULONG aInstance,
                                                   ComPtr<IStorageController> &aStorageController) = 0;
    virtual HRESULT removeStorageController(const com::Utf8Str &aName) = 0;
    virtual HRESULT setStorageControllerBootable(const com::Utf8Str &aName,
                                                 BOOL aBootable) = 0;
    virtual HRESULT addUSBController(const com::Utf8Str &aName,
                                     USBControllerType_T aType,
                                     ComPtr<IUSBController> &aController) = 0;
    virtual HRESULT removeUSBController(const com::Utf8Str &aName) = 0;
    virtual HRESULT getUSBControllerByName(const com::Utf8Str &aName,
                                           ComPtr<IUSBController> &aController) = 0;
    virtual HRESULT getUSBControllerCountByType(USBControllerType_T aType,
                                                ULONG *aControllers) = 0;
    virtual HRESULT getSerialPort(ULONG aSlot,
                                  ComPtr<ISerialPort> &aPort) = 0;
    virtual HRESULT getParallelPort(ULONG aSlot,
                                    ComPtr<IParallelPort> &aPort) = 0;
    virtual HRESULT getExtraDataKeys(std::vector<com::Utf8Str> &aKeys) = 0;
    virtual HRESULT getExtraData(const com::Utf8Str &aKey,
                                 com::Utf8Str &aValue) = 0;
    virtual HRESULT setExtraData(const com::Utf8Str &aKey,
                                 const com::Utf8Str &aValue) = 0;
    virtual HRESULT getCPUProperty(CPUPropertyType_T aProperty,
                                   BOOL *aValue) = 0;
    virtual HRESULT setCPUProperty(CPUPropertyType_T aProperty,
                                   BOOL aValue) = 0;
    virtual HRESULT getCPUIDLeaf(ULONG aId,
                                 ULONG *aValEax,
                                 ULONG *aValEbx,
                                 ULONG *aValEcx,
                                 ULONG *aValEdx) = 0;
    virtual HRESULT setCPUIDLeaf(ULONG aId,
                                 ULONG aValEax,
                                 ULONG aValEbx,
                                 ULONG aValEcx,
                                 ULONG aValEdx) = 0;
    virtual HRESULT removeCPUIDLeaf(ULONG aId) = 0;
    virtual HRESULT removeAllCPUIDLeaves() = 0;
    virtual HRESULT getHWVirtExProperty(HWVirtExPropertyType_T aProperty,
                                        BOOL *aValue) = 0;
    virtual HRESULT setHWVirtExProperty(HWVirtExPropertyType_T aProperty,
                                        BOOL aValue) = 0;
    virtual HRESULT setSettingsFilePath(const com::Utf8Str &aSettingsFilePath,
                                        ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT saveSettings() = 0;
    virtual HRESULT discardSettings() = 0;
    virtual HRESULT unregister(CleanupMode_T aCleanupMode,
                               std::vector<ComPtr<IMedium> > &aMedia) = 0;
    virtual HRESULT deleteConfig(const std::vector<ComPtr<IMedium> > &aMedia,
                                 ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT exportTo(const ComPtr<IAppliance> &aAppliance,
                             const com::Utf8Str &aLocation,
                             ComPtr<IVirtualSystemDescription> &aDescription) = 0;
    virtual HRESULT findSnapshot(const com::Utf8Str &aNameOrId,
                                 ComPtr<ISnapshot> &aSnapshot) = 0;
    virtual HRESULT createSharedFolder(const com::Utf8Str &aName,
                                       const com::Utf8Str &aHostPath,
                                       BOOL aWritable,
                                       BOOL aAutomount) = 0;
    virtual HRESULT removeSharedFolder(const com::Utf8Str &aName) = 0;
    virtual HRESULT canShowConsoleWindow(BOOL *aCanShow) = 0;
    virtual HRESULT showConsoleWindow(LONG64 *aWinId) = 0;
    virtual HRESULT getGuestProperty(const com::Utf8Str &aName,
                                     com::Utf8Str &aValue,
                                     LONG64 *aTimestamp,
                                     com::Utf8Str &aFlags) = 0;
    virtual HRESULT getGuestPropertyValue(const com::Utf8Str &aProperty,
                                          com::Utf8Str &aValue) = 0;
    virtual HRESULT getGuestPropertyTimestamp(const com::Utf8Str &aProperty,
                                              LONG64 *aValue) = 0;
    virtual HRESULT setGuestProperty(const com::Utf8Str &aProperty,
                                     const com::Utf8Str &aValue,
                                     const com::Utf8Str &aFlags) = 0;
    virtual HRESULT setGuestPropertyValue(const com::Utf8Str &aProperty,
                                          const com::Utf8Str &aValue) = 0;
    virtual HRESULT deleteGuestProperty(const com::Utf8Str &aName) = 0;
    virtual HRESULT enumerateGuestProperties(const com::Utf8Str &aPatterns,
                                             std::vector<com::Utf8Str> &aNames,
                                             std::vector<com::Utf8Str> &aValues,
                                             std::vector<LONG64> &aTimestamps,
                                             std::vector<com::Utf8Str> &aFlags) = 0;
    virtual HRESULT querySavedGuestScreenInfo(ULONG aScreenId,
                                              ULONG *aOriginX,
                                              ULONG *aOriginY,
                                              ULONG *aWidth,
                                              ULONG *aHeight,
                                              BOOL *aEnabled) = 0;
    virtual HRESULT querySavedThumbnailSize(ULONG aScreenId,
                                            ULONG *aSize,
                                            ULONG *aWidth,
                                            ULONG *aHeight) = 0;
    virtual HRESULT readSavedThumbnailToArray(ULONG aScreenId,
                                              BOOL aBGR,
                                              ULONG *aWidth,
                                              ULONG *aHeight,
                                              std::vector<BYTE> &aData) = 0;
    virtual HRESULT readSavedThumbnailPNGToArray(ULONG aScreenId,
                                                 ULONG *aWidth,
                                                 ULONG *aHeight,
                                                 std::vector<BYTE> &aData) = 0;
    virtual HRESULT querySavedScreenshotPNGSize(ULONG aScreenId,
                                                ULONG *aSize,
                                                ULONG *aWidth,
                                                ULONG *aHeight) = 0;
    virtual HRESULT readSavedScreenshotPNGToArray(ULONG aScreenId,
                                                  ULONG *aWidth,
                                                  ULONG *aHeight,
                                                  std::vector<BYTE> &aData) = 0;
    virtual HRESULT hotPlugCPU(ULONG aCpu) = 0;
    virtual HRESULT hotUnplugCPU(ULONG aCpu) = 0;
    virtual HRESULT getCPUStatus(ULONG aCpu,
                                 BOOL *aAttached) = 0;
    virtual HRESULT queryLogFilename(ULONG aIdx,
                                     com::Utf8Str &aFilename) = 0;
    virtual HRESULT readLog(ULONG aIdx,
                            LONG64 aOffset,
                            LONG64 aSize,
                            std::vector<BYTE> &aData) = 0;
    virtual HRESULT cloneTo(const ComPtr<IMachine> &aTarget,
                            CloneMode_T aMode,
                            const std::vector<CloneOptions_T> &aOptions,
                            ComPtr<IProgress> &aProgress) = 0;
};

#endif // !MachineWrap_H_

// ##### ENDFILE "MachineWrap.h"

// ##### BEGINFILE "MachineWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IMachine.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_MACHINE

#include "MachineWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(MachineWrap)

//
// IMachine properties
//

STDMETHODIMP MachineWrap::COMGETTER(Parent)(IVirtualBox **aParent)
{
    LogRelFlow(("{%p} %s: enter aParent=%p\n", this, "Machine::getParent", aParent));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aParent);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getParent(ComTypeOutConverter<IVirtualBox>(aParent).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aParent=%p hrc=%Rhrc\n", this, "Machine::getParent", *aParent, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(Icon)(ComSafeArrayOut(BYTE, aIcon))
{
    LogRelFlow(("{%p} %s: enter aIcon=%p\n", this, "Machine::getIcon", aIcon));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aIcon);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getIcon(ArrayOutConverter<BYTE>(ComSafeArrayOutArg(aIcon)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aIcon=%zu hrc=%Rhrc\n", this, "Machine::getIcon", ComSafeArraySize(*aIcon), hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(Icon)(ComSafeArrayIn(BYTE, aIcon))
{
    LogRelFlow(("{%p} %s: enter aIcon=%zu\n", this, "Machine::setIcon", ComSafeArraySize(aIcon)));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setIcon(ArrayInConverter<BYTE>(ComSafeArrayInArg(aIcon)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setIcon", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(Accessible)(BOOL *aAccessible)
{
    LogRelFlow(("{%p} %s: enter aAccessible=%p\n", this, "Machine::getAccessible", aAccessible));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAccessible);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAccessible(aAccessible);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAccessible=%RTbool hrc=%Rhrc\n", this, "Machine::getAccessible", *aAccessible, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(AccessError)(IVirtualBoxErrorInfo **aAccessError)
{
    LogRelFlow(("{%p} %s: enter aAccessError=%p\n", this, "Machine::getAccessError", aAccessError));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAccessError);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAccessError(ComTypeOutConverter<IVirtualBoxErrorInfo>(aAccessError).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAccessError=%p hrc=%Rhrc\n", this, "Machine::getAccessError", *aAccessError, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "Machine::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "Machine::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(Name)(IN_BSTR aName)
{
    LogRelFlow(("{%p} %s: enter aName=%ls\n", this, "Machine::setName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setName(BSTRInConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setName", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(Description)(BSTR *aDescription)
{
    LogRelFlow(("{%p} %s: enter aDescription=%p\n", this, "Machine::getDescription", aDescription));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDescription);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDescription(BSTROutConverter(aDescription).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDescription=%ls hrc=%Rhrc\n", this, "Machine::getDescription", *aDescription, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(Description)(IN_BSTR aDescription)
{
    LogRelFlow(("{%p} %s: enter aDescription=%ls\n", this, "Machine::setDescription", aDescription));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setDescription(BSTRInConverter(aDescription).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setDescription", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(Id)(BSTR *aId)
{
    LogRelFlow(("{%p} %s: enter aId=%p\n", this, "Machine::getId", aId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getId(UuidOutConverter(aId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aId=%ls hrc=%Rhrc\n", this, "Machine::getId", *aId, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(Groups)(ComSafeArrayOut(BSTR, aGroups))
{
    LogRelFlow(("{%p} %s: enter aGroups=%p\n", this, "Machine::getGroups", aGroups));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGroups);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGroups(ArrayBSTROutConverter(ComSafeArrayOutArg(aGroups)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGroups=%zu hrc=%Rhrc\n", this, "Machine::getGroups", ComSafeArraySize(*aGroups), hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(Groups)(ComSafeArrayIn(IN_BSTR, aGroups))
{
    LogRelFlow(("{%p} %s: enter aGroups=%zu\n", this, "Machine::setGroups", ComSafeArraySize(aGroups)));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setGroups(ArrayBSTRInConverter(ComSafeArrayInArg(aGroups)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setGroups", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(OSTypeId)(BSTR *aOSTypeId)
{
    LogRelFlow(("{%p} %s: enter aOSTypeId=%p\n", this, "Machine::getOSTypeId", aOSTypeId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOSTypeId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOSTypeId(BSTROutConverter(aOSTypeId).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOSTypeId=%ls hrc=%Rhrc\n", this, "Machine::getOSTypeId", *aOSTypeId, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(OSTypeId)(IN_BSTR aOSTypeId)
{
    LogRelFlow(("{%p} %s: enter aOSTypeId=%ls\n", this, "Machine::setOSTypeId", aOSTypeId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setOSTypeId(BSTRInConverter(aOSTypeId).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setOSTypeId", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(HardwareVersion)(BSTR *aHardwareVersion)
{
    LogRelFlow(("{%p} %s: enter aHardwareVersion=%p\n", this, "Machine::getHardwareVersion", aHardwareVersion));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHardwareVersion);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHardwareVersion(BSTROutConverter(aHardwareVersion).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHardwareVersion=%ls hrc=%Rhrc\n", this, "Machine::getHardwareVersion", *aHardwareVersion, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(HardwareVersion)(IN_BSTR aHardwareVersion)
{
    LogRelFlow(("{%p} %s: enter aHardwareVersion=%ls\n", this, "Machine::setHardwareVersion", aHardwareVersion));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setHardwareVersion(BSTRInConverter(aHardwareVersion).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setHardwareVersion", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(HardwareUUID)(BSTR *aHardwareUUID)
{
    LogRelFlow(("{%p} %s: enter aHardwareUUID=%p\n", this, "Machine::getHardwareUUID", aHardwareUUID));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHardwareUUID);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHardwareUUID(UuidOutConverter(aHardwareUUID).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHardwareUUID=%ls hrc=%Rhrc\n", this, "Machine::getHardwareUUID", *aHardwareUUID, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(HardwareUUID)(IN_BSTR aHardwareUUID)
{
    LogRelFlow(("{%p} %s: enter aHardwareUUID=%ls\n", this, "Machine::setHardwareUUID", aHardwareUUID));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setHardwareUUID(UuidInConverter(aHardwareUUID).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setHardwareUUID", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(CPUCount)(ULONG *aCPUCount)
{
    LogRelFlow(("{%p} %s: enter aCPUCount=%p\n", this, "Machine::getCPUCount", aCPUCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCPUCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getCPUCount(aCPUCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aCPUCount=%RU32 hrc=%Rhrc\n", this, "Machine::getCPUCount", *aCPUCount, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(CPUCount)(ULONG aCPUCount)
{
    LogRelFlow(("{%p} %s: enter aCPUCount=%RU32\n", this, "Machine::setCPUCount", aCPUCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setCPUCount(aCPUCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setCPUCount", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(CPUHotPlugEnabled)(BOOL *aCPUHotPlugEnabled)
{
    LogRelFlow(("{%p} %s: enter aCPUHotPlugEnabled=%p\n", this, "Machine::getCPUHotPlugEnabled", aCPUHotPlugEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCPUHotPlugEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getCPUHotPlugEnabled(aCPUHotPlugEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aCPUHotPlugEnabled=%RTbool hrc=%Rhrc\n", this, "Machine::getCPUHotPlugEnabled", *aCPUHotPlugEnabled, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(CPUHotPlugEnabled)(BOOL aCPUHotPlugEnabled)
{
    LogRelFlow(("{%p} %s: enter aCPUHotPlugEnabled=%RTbool\n", this, "Machine::setCPUHotPlugEnabled", aCPUHotPlugEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setCPUHotPlugEnabled(aCPUHotPlugEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setCPUHotPlugEnabled", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(CPUExecutionCap)(ULONG *aCPUExecutionCap)
{
    LogRelFlow(("{%p} %s: enter aCPUExecutionCap=%p\n", this, "Machine::getCPUExecutionCap", aCPUExecutionCap));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCPUExecutionCap);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getCPUExecutionCap(aCPUExecutionCap);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aCPUExecutionCap=%RU32 hrc=%Rhrc\n", this, "Machine::getCPUExecutionCap", *aCPUExecutionCap, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(CPUExecutionCap)(ULONG aCPUExecutionCap)
{
    LogRelFlow(("{%p} %s: enter aCPUExecutionCap=%RU32\n", this, "Machine::setCPUExecutionCap", aCPUExecutionCap));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setCPUExecutionCap(aCPUExecutionCap);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setCPUExecutionCap", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(MemorySize)(ULONG *aMemorySize)
{
    LogRelFlow(("{%p} %s: enter aMemorySize=%p\n", this, "Machine::getMemorySize", aMemorySize));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMemorySize);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMemorySize(aMemorySize);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMemorySize=%RU32 hrc=%Rhrc\n", this, "Machine::getMemorySize", *aMemorySize, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(MemorySize)(ULONG aMemorySize)
{
    LogRelFlow(("{%p} %s: enter aMemorySize=%RU32\n", this, "Machine::setMemorySize", aMemorySize));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setMemorySize(aMemorySize);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setMemorySize", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(MemoryBalloonSize)(ULONG *aMemoryBalloonSize)
{
    LogRelFlow(("{%p} %s: enter aMemoryBalloonSize=%p\n", this, "Machine::getMemoryBalloonSize", aMemoryBalloonSize));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMemoryBalloonSize);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMemoryBalloonSize(aMemoryBalloonSize);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMemoryBalloonSize=%RU32 hrc=%Rhrc\n", this, "Machine::getMemoryBalloonSize", *aMemoryBalloonSize, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(MemoryBalloonSize)(ULONG aMemoryBalloonSize)
{
    LogRelFlow(("{%p} %s: enter aMemoryBalloonSize=%RU32\n", this, "Machine::setMemoryBalloonSize", aMemoryBalloonSize));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setMemoryBalloonSize(aMemoryBalloonSize);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setMemoryBalloonSize", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(PageFusionEnabled)(BOOL *aPageFusionEnabled)
{
    LogRelFlow(("{%p} %s: enter aPageFusionEnabled=%p\n", this, "Machine::getPageFusionEnabled", aPageFusionEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPageFusionEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPageFusionEnabled(aPageFusionEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPageFusionEnabled=%RTbool hrc=%Rhrc\n", this, "Machine::getPageFusionEnabled", *aPageFusionEnabled, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(PageFusionEnabled)(BOOL aPageFusionEnabled)
{
    LogRelFlow(("{%p} %s: enter aPageFusionEnabled=%RTbool\n", this, "Machine::setPageFusionEnabled", aPageFusionEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setPageFusionEnabled(aPageFusionEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setPageFusionEnabled", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(GraphicsControllerType)(GraphicsControllerType_T *aGraphicsControllerType)
{
    LogRelFlow(("{%p} %s: enter aGraphicsControllerType=%p\n", this, "Machine::getGraphicsControllerType", aGraphicsControllerType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGraphicsControllerType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGraphicsControllerType(aGraphicsControllerType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGraphicsControllerType=%RU32 hrc=%Rhrc\n", this, "Machine::getGraphicsControllerType", *aGraphicsControllerType, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(GraphicsControllerType)(GraphicsControllerType_T aGraphicsControllerType)
{
    LogRelFlow(("{%p} %s: enter aGraphicsControllerType=%RU32\n", this, "Machine::setGraphicsControllerType", aGraphicsControllerType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setGraphicsControllerType(aGraphicsControllerType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setGraphicsControllerType", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(VRAMSize)(ULONG *aVRAMSize)
{
    LogRelFlow(("{%p} %s: enter aVRAMSize=%p\n", this, "Machine::getVRAMSize", aVRAMSize));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVRAMSize);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVRAMSize(aVRAMSize);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVRAMSize=%RU32 hrc=%Rhrc\n", this, "Machine::getVRAMSize", *aVRAMSize, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(VRAMSize)(ULONG aVRAMSize)
{
    LogRelFlow(("{%p} %s: enter aVRAMSize=%RU32\n", this, "Machine::setVRAMSize", aVRAMSize));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setVRAMSize(aVRAMSize);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setVRAMSize", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(Accelerate3DEnabled)(BOOL *aAccelerate3DEnabled)
{
    LogRelFlow(("{%p} %s: enter aAccelerate3DEnabled=%p\n", this, "Machine::getAccelerate3DEnabled", aAccelerate3DEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAccelerate3DEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAccelerate3DEnabled(aAccelerate3DEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAccelerate3DEnabled=%RTbool hrc=%Rhrc\n", this, "Machine::getAccelerate3DEnabled", *aAccelerate3DEnabled, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(Accelerate3DEnabled)(BOOL aAccelerate3DEnabled)
{
    LogRelFlow(("{%p} %s: enter aAccelerate3DEnabled=%RTbool\n", this, "Machine::setAccelerate3DEnabled", aAccelerate3DEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setAccelerate3DEnabled(aAccelerate3DEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setAccelerate3DEnabled", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(Accelerate2DVideoEnabled)(BOOL *aAccelerate2DVideoEnabled)
{
    LogRelFlow(("{%p} %s: enter aAccelerate2DVideoEnabled=%p\n", this, "Machine::getAccelerate2DVideoEnabled", aAccelerate2DVideoEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAccelerate2DVideoEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAccelerate2DVideoEnabled(aAccelerate2DVideoEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAccelerate2DVideoEnabled=%RTbool hrc=%Rhrc\n", this, "Machine::getAccelerate2DVideoEnabled", *aAccelerate2DVideoEnabled, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(Accelerate2DVideoEnabled)(BOOL aAccelerate2DVideoEnabled)
{
    LogRelFlow(("{%p} %s: enter aAccelerate2DVideoEnabled=%RTbool\n", this, "Machine::setAccelerate2DVideoEnabled", aAccelerate2DVideoEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setAccelerate2DVideoEnabled(aAccelerate2DVideoEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setAccelerate2DVideoEnabled", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(MonitorCount)(ULONG *aMonitorCount)
{
    LogRelFlow(("{%p} %s: enter aMonitorCount=%p\n", this, "Machine::getMonitorCount", aMonitorCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMonitorCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMonitorCount(aMonitorCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMonitorCount=%RU32 hrc=%Rhrc\n", this, "Machine::getMonitorCount", *aMonitorCount, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(MonitorCount)(ULONG aMonitorCount)
{
    LogRelFlow(("{%p} %s: enter aMonitorCount=%RU32\n", this, "Machine::setMonitorCount", aMonitorCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setMonitorCount(aMonitorCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setMonitorCount", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(VideoCaptureEnabled)(BOOL *aVideoCaptureEnabled)
{
    LogRelFlow(("{%p} %s: enter aVideoCaptureEnabled=%p\n", this, "Machine::getVideoCaptureEnabled", aVideoCaptureEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVideoCaptureEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVideoCaptureEnabled(aVideoCaptureEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVideoCaptureEnabled=%RTbool hrc=%Rhrc\n", this, "Machine::getVideoCaptureEnabled", *aVideoCaptureEnabled, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(VideoCaptureEnabled)(BOOL aVideoCaptureEnabled)
{
    LogRelFlow(("{%p} %s: enter aVideoCaptureEnabled=%RTbool\n", this, "Machine::setVideoCaptureEnabled", aVideoCaptureEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setVideoCaptureEnabled(aVideoCaptureEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setVideoCaptureEnabled", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(VideoCaptureScreens)(ComSafeArrayOut(BOOL, aVideoCaptureScreens))
{
    LogRelFlow(("{%p} %s: enter aVideoCaptureScreens=%p\n", this, "Machine::getVideoCaptureScreens", aVideoCaptureScreens));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVideoCaptureScreens);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVideoCaptureScreens(ArrayOutConverter<BOOL>(ComSafeArrayOutArg(aVideoCaptureScreens)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVideoCaptureScreens=%zu hrc=%Rhrc\n", this, "Machine::getVideoCaptureScreens", ComSafeArraySize(*aVideoCaptureScreens), hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(VideoCaptureScreens)(ComSafeArrayIn(BOOL, aVideoCaptureScreens))
{
    LogRelFlow(("{%p} %s: enter aVideoCaptureScreens=%zu\n", this, "Machine::setVideoCaptureScreens", ComSafeArraySize(aVideoCaptureScreens)));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setVideoCaptureScreens(ArrayInConverter<BOOL>(ComSafeArrayInArg(aVideoCaptureScreens)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setVideoCaptureScreens", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(VideoCaptureFile)(BSTR *aVideoCaptureFile)
{
    LogRelFlow(("{%p} %s: enter aVideoCaptureFile=%p\n", this, "Machine::getVideoCaptureFile", aVideoCaptureFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVideoCaptureFile);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVideoCaptureFile(BSTROutConverter(aVideoCaptureFile).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVideoCaptureFile=%ls hrc=%Rhrc\n", this, "Machine::getVideoCaptureFile", *aVideoCaptureFile, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(VideoCaptureFile)(IN_BSTR aVideoCaptureFile)
{
    LogRelFlow(("{%p} %s: enter aVideoCaptureFile=%ls\n", this, "Machine::setVideoCaptureFile", aVideoCaptureFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setVideoCaptureFile(BSTRInConverter(aVideoCaptureFile).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setVideoCaptureFile", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(VideoCaptureWidth)(ULONG *aVideoCaptureWidth)
{
    LogRelFlow(("{%p} %s: enter aVideoCaptureWidth=%p\n", this, "Machine::getVideoCaptureWidth", aVideoCaptureWidth));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVideoCaptureWidth);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVideoCaptureWidth(aVideoCaptureWidth);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVideoCaptureWidth=%RU32 hrc=%Rhrc\n", this, "Machine::getVideoCaptureWidth", *aVideoCaptureWidth, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(VideoCaptureWidth)(ULONG aVideoCaptureWidth)
{
    LogRelFlow(("{%p} %s: enter aVideoCaptureWidth=%RU32\n", this, "Machine::setVideoCaptureWidth", aVideoCaptureWidth));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setVideoCaptureWidth(aVideoCaptureWidth);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setVideoCaptureWidth", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(VideoCaptureHeight)(ULONG *aVideoCaptureHeight)
{
    LogRelFlow(("{%p} %s: enter aVideoCaptureHeight=%p\n", this, "Machine::getVideoCaptureHeight", aVideoCaptureHeight));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVideoCaptureHeight);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVideoCaptureHeight(aVideoCaptureHeight);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVideoCaptureHeight=%RU32 hrc=%Rhrc\n", this, "Machine::getVideoCaptureHeight", *aVideoCaptureHeight, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(VideoCaptureHeight)(ULONG aVideoCaptureHeight)
{
    LogRelFlow(("{%p} %s: enter aVideoCaptureHeight=%RU32\n", this, "Machine::setVideoCaptureHeight", aVideoCaptureHeight));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setVideoCaptureHeight(aVideoCaptureHeight);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setVideoCaptureHeight", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(VideoCaptureRate)(ULONG *aVideoCaptureRate)
{
    LogRelFlow(("{%p} %s: enter aVideoCaptureRate=%p\n", this, "Machine::getVideoCaptureRate", aVideoCaptureRate));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVideoCaptureRate);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVideoCaptureRate(aVideoCaptureRate);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVideoCaptureRate=%RU32 hrc=%Rhrc\n", this, "Machine::getVideoCaptureRate", *aVideoCaptureRate, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(VideoCaptureRate)(ULONG aVideoCaptureRate)
{
    LogRelFlow(("{%p} %s: enter aVideoCaptureRate=%RU32\n", this, "Machine::setVideoCaptureRate", aVideoCaptureRate));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setVideoCaptureRate(aVideoCaptureRate);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setVideoCaptureRate", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(VideoCaptureFPS)(ULONG *aVideoCaptureFPS)
{
    LogRelFlow(("{%p} %s: enter aVideoCaptureFPS=%p\n", this, "Machine::getVideoCaptureFPS", aVideoCaptureFPS));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVideoCaptureFPS);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVideoCaptureFPS(aVideoCaptureFPS);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVideoCaptureFPS=%RU32 hrc=%Rhrc\n", this, "Machine::getVideoCaptureFPS", *aVideoCaptureFPS, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(VideoCaptureFPS)(ULONG aVideoCaptureFPS)
{
    LogRelFlow(("{%p} %s: enter aVideoCaptureFPS=%RU32\n", this, "Machine::setVideoCaptureFPS", aVideoCaptureFPS));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setVideoCaptureFPS(aVideoCaptureFPS);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setVideoCaptureFPS", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(BIOSSettings)(IBIOSSettings **aBIOSSettings)
{
    LogRelFlow(("{%p} %s: enter aBIOSSettings=%p\n", this, "Machine::getBIOSSettings", aBIOSSettings));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBIOSSettings);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBIOSSettings(ComTypeOutConverter<IBIOSSettings>(aBIOSSettings).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBIOSSettings=%p hrc=%Rhrc\n", this, "Machine::getBIOSSettings", *aBIOSSettings, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(FirmwareType)(FirmwareType_T *aFirmwareType)
{
    LogRelFlow(("{%p} %s: enter aFirmwareType=%p\n", this, "Machine::getFirmwareType", aFirmwareType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFirmwareType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFirmwareType(aFirmwareType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFirmwareType=%RU32 hrc=%Rhrc\n", this, "Machine::getFirmwareType", *aFirmwareType, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(FirmwareType)(FirmwareType_T aFirmwareType)
{
    LogRelFlow(("{%p} %s: enter aFirmwareType=%RU32\n", this, "Machine::setFirmwareType", aFirmwareType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setFirmwareType(aFirmwareType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setFirmwareType", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(PointingHIDType)(PointingHIDType_T *aPointingHIDType)
{
    LogRelFlow(("{%p} %s: enter aPointingHIDType=%p\n", this, "Machine::getPointingHIDType", aPointingHIDType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPointingHIDType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPointingHIDType(aPointingHIDType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPointingHIDType=%RU32 hrc=%Rhrc\n", this, "Machine::getPointingHIDType", *aPointingHIDType, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(PointingHIDType)(PointingHIDType_T aPointingHIDType)
{
    LogRelFlow(("{%p} %s: enter aPointingHIDType=%RU32\n", this, "Machine::setPointingHIDType", aPointingHIDType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setPointingHIDType(aPointingHIDType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setPointingHIDType", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(KeyboardHIDType)(KeyboardHIDType_T *aKeyboardHIDType)
{
    LogRelFlow(("{%p} %s: enter aKeyboardHIDType=%p\n", this, "Machine::getKeyboardHIDType", aKeyboardHIDType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aKeyboardHIDType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getKeyboardHIDType(aKeyboardHIDType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aKeyboardHIDType=%RU32 hrc=%Rhrc\n", this, "Machine::getKeyboardHIDType", *aKeyboardHIDType, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(KeyboardHIDType)(KeyboardHIDType_T aKeyboardHIDType)
{
    LogRelFlow(("{%p} %s: enter aKeyboardHIDType=%RU32\n", this, "Machine::setKeyboardHIDType", aKeyboardHIDType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setKeyboardHIDType(aKeyboardHIDType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setKeyboardHIDType", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(HPETEnabled)(BOOL *aHPETEnabled)
{
    LogRelFlow(("{%p} %s: enter aHPETEnabled=%p\n", this, "Machine::getHPETEnabled", aHPETEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHPETEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHPETEnabled(aHPETEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHPETEnabled=%RTbool hrc=%Rhrc\n", this, "Machine::getHPETEnabled", *aHPETEnabled, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(HPETEnabled)(BOOL aHPETEnabled)
{
    LogRelFlow(("{%p} %s: enter aHPETEnabled=%RTbool\n", this, "Machine::setHPETEnabled", aHPETEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setHPETEnabled(aHPETEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setHPETEnabled", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(ChipsetType)(ChipsetType_T *aChipsetType)
{
    LogRelFlow(("{%p} %s: enter aChipsetType=%p\n", this, "Machine::getChipsetType", aChipsetType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aChipsetType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getChipsetType(aChipsetType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aChipsetType=%RU32 hrc=%Rhrc\n", this, "Machine::getChipsetType", *aChipsetType, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(ChipsetType)(ChipsetType_T aChipsetType)
{
    LogRelFlow(("{%p} %s: enter aChipsetType=%RU32\n", this, "Machine::setChipsetType", aChipsetType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setChipsetType(aChipsetType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setChipsetType", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(SnapshotFolder)(BSTR *aSnapshotFolder)
{
    LogRelFlow(("{%p} %s: enter aSnapshotFolder=%p\n", this, "Machine::getSnapshotFolder", aSnapshotFolder));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSnapshotFolder);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSnapshotFolder(BSTROutConverter(aSnapshotFolder).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSnapshotFolder=%ls hrc=%Rhrc\n", this, "Machine::getSnapshotFolder", *aSnapshotFolder, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(SnapshotFolder)(IN_BSTR aSnapshotFolder)
{
    LogRelFlow(("{%p} %s: enter aSnapshotFolder=%ls\n", this, "Machine::setSnapshotFolder", aSnapshotFolder));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setSnapshotFolder(BSTRInConverter(aSnapshotFolder).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setSnapshotFolder", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(VRDEServer)(IVRDEServer **aVRDEServer)
{
    LogRelFlow(("{%p} %s: enter aVRDEServer=%p\n", this, "Machine::getVRDEServer", aVRDEServer));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVRDEServer);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVRDEServer(ComTypeOutConverter<IVRDEServer>(aVRDEServer).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVRDEServer=%p hrc=%Rhrc\n", this, "Machine::getVRDEServer", *aVRDEServer, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(EmulatedUSBCardReaderEnabled)(BOOL *aEmulatedUSBCardReaderEnabled)
{
    LogRelFlow(("{%p} %s: enter aEmulatedUSBCardReaderEnabled=%p\n", this, "Machine::getEmulatedUSBCardReaderEnabled", aEmulatedUSBCardReaderEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEmulatedUSBCardReaderEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEmulatedUSBCardReaderEnabled(aEmulatedUSBCardReaderEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEmulatedUSBCardReaderEnabled=%RTbool hrc=%Rhrc\n", this, "Machine::getEmulatedUSBCardReaderEnabled", *aEmulatedUSBCardReaderEnabled, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(EmulatedUSBCardReaderEnabled)(BOOL aEmulatedUSBCardReaderEnabled)
{
    LogRelFlow(("{%p} %s: enter aEmulatedUSBCardReaderEnabled=%RTbool\n", this, "Machine::setEmulatedUSBCardReaderEnabled", aEmulatedUSBCardReaderEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setEmulatedUSBCardReaderEnabled(aEmulatedUSBCardReaderEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setEmulatedUSBCardReaderEnabled", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(MediumAttachments)(ComSafeArrayOut(IMediumAttachment *, aMediumAttachments))
{
    LogRelFlow(("{%p} %s: enter aMediumAttachments=%p\n", this, "Machine::getMediumAttachments", aMediumAttachments));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMediumAttachments);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMediumAttachments(ArrayComTypeOutConverter<IMediumAttachment>(ComSafeArrayOutArg(aMediumAttachments)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMediumAttachments=%zu hrc=%Rhrc\n", this, "Machine::getMediumAttachments", ComSafeArraySize(*aMediumAttachments), hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(USBControllers)(ComSafeArrayOut(IUSBController *, aUSBControllers))
{
    LogRelFlow(("{%p} %s: enter aUSBControllers=%p\n", this, "Machine::getUSBControllers", aUSBControllers));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUSBControllers);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUSBControllers(ArrayComTypeOutConverter<IUSBController>(ComSafeArrayOutArg(aUSBControllers)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUSBControllers=%zu hrc=%Rhrc\n", this, "Machine::getUSBControllers", ComSafeArraySize(*aUSBControllers), hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(USBDeviceFilters)(IUSBDeviceFilters **aUSBDeviceFilters)
{
    LogRelFlow(("{%p} %s: enter aUSBDeviceFilters=%p\n", this, "Machine::getUSBDeviceFilters", aUSBDeviceFilters));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUSBDeviceFilters);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUSBDeviceFilters(ComTypeOutConverter<IUSBDeviceFilters>(aUSBDeviceFilters).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUSBDeviceFilters=%p hrc=%Rhrc\n", this, "Machine::getUSBDeviceFilters", *aUSBDeviceFilters, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(AudioAdapter)(IAudioAdapter **aAudioAdapter)
{
    LogRelFlow(("{%p} %s: enter aAudioAdapter=%p\n", this, "Machine::getAudioAdapter", aAudioAdapter));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAudioAdapter);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAudioAdapter(ComTypeOutConverter<IAudioAdapter>(aAudioAdapter).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAudioAdapter=%p hrc=%Rhrc\n", this, "Machine::getAudioAdapter", *aAudioAdapter, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(StorageControllers)(ComSafeArrayOut(IStorageController *, aStorageControllers))
{
    LogRelFlow(("{%p} %s: enter aStorageControllers=%p\n", this, "Machine::getStorageControllers", aStorageControllers));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStorageControllers);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getStorageControllers(ArrayComTypeOutConverter<IStorageController>(ComSafeArrayOutArg(aStorageControllers)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aStorageControllers=%zu hrc=%Rhrc\n", this, "Machine::getStorageControllers", ComSafeArraySize(*aStorageControllers), hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(SettingsFilePath)(BSTR *aSettingsFilePath)
{
    LogRelFlow(("{%p} %s: enter aSettingsFilePath=%p\n", this, "Machine::getSettingsFilePath", aSettingsFilePath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSettingsFilePath);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSettingsFilePath(BSTROutConverter(aSettingsFilePath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSettingsFilePath=%ls hrc=%Rhrc\n", this, "Machine::getSettingsFilePath", *aSettingsFilePath, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(SettingsModified)(BOOL *aSettingsModified)
{
    LogRelFlow(("{%p} %s: enter aSettingsModified=%p\n", this, "Machine::getSettingsModified", aSettingsModified));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSettingsModified);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSettingsModified(aSettingsModified);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSettingsModified=%RTbool hrc=%Rhrc\n", this, "Machine::getSettingsModified", *aSettingsModified, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(SessionState)(SessionState_T *aSessionState)
{
    LogRelFlow(("{%p} %s: enter aSessionState=%p\n", this, "Machine::getSessionState", aSessionState));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSessionState);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSessionState(aSessionState);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSessionState=%RU32 hrc=%Rhrc\n", this, "Machine::getSessionState", *aSessionState, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(SessionType)(BSTR *aSessionType)
{
    LogRelFlow(("{%p} %s: enter aSessionType=%p\n", this, "Machine::getSessionType", aSessionType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSessionType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSessionType(BSTROutConverter(aSessionType).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSessionType=%ls hrc=%Rhrc\n", this, "Machine::getSessionType", *aSessionType, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(SessionPID)(ULONG *aSessionPID)
{
    LogRelFlow(("{%p} %s: enter aSessionPID=%p\n", this, "Machine::getSessionPID", aSessionPID));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSessionPID);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSessionPID(aSessionPID);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSessionPID=%RU32 hrc=%Rhrc\n", this, "Machine::getSessionPID", *aSessionPID, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(State)(MachineState_T *aState)
{
    LogRelFlow(("{%p} %s: enter aState=%p\n", this, "Machine::getState", aState));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aState);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getState(aState);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aState=%RU32 hrc=%Rhrc\n", this, "Machine::getState", *aState, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(LastStateChange)(LONG64 *aLastStateChange)
{
    LogRelFlow(("{%p} %s: enter aLastStateChange=%p\n", this, "Machine::getLastStateChange", aLastStateChange));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLastStateChange);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLastStateChange(aLastStateChange);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLastStateChange=%RI64 hrc=%Rhrc\n", this, "Machine::getLastStateChange", *aLastStateChange, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(StateFilePath)(BSTR *aStateFilePath)
{
    LogRelFlow(("{%p} %s: enter aStateFilePath=%p\n", this, "Machine::getStateFilePath", aStateFilePath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStateFilePath);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getStateFilePath(BSTROutConverter(aStateFilePath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aStateFilePath=%ls hrc=%Rhrc\n", this, "Machine::getStateFilePath", *aStateFilePath, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(LogFolder)(BSTR *aLogFolder)
{
    LogRelFlow(("{%p} %s: enter aLogFolder=%p\n", this, "Machine::getLogFolder", aLogFolder));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLogFolder);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLogFolder(BSTROutConverter(aLogFolder).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLogFolder=%ls hrc=%Rhrc\n", this, "Machine::getLogFolder", *aLogFolder, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(CurrentSnapshot)(ISnapshot **aCurrentSnapshot)
{
    LogRelFlow(("{%p} %s: enter aCurrentSnapshot=%p\n", this, "Machine::getCurrentSnapshot", aCurrentSnapshot));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCurrentSnapshot);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getCurrentSnapshot(ComTypeOutConverter<ISnapshot>(aCurrentSnapshot).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aCurrentSnapshot=%p hrc=%Rhrc\n", this, "Machine::getCurrentSnapshot", *aCurrentSnapshot, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(SnapshotCount)(ULONG *aSnapshotCount)
{
    LogRelFlow(("{%p} %s: enter aSnapshotCount=%p\n", this, "Machine::getSnapshotCount", aSnapshotCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSnapshotCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSnapshotCount(aSnapshotCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSnapshotCount=%RU32 hrc=%Rhrc\n", this, "Machine::getSnapshotCount", *aSnapshotCount, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(CurrentStateModified)(BOOL *aCurrentStateModified)
{
    LogRelFlow(("{%p} %s: enter aCurrentStateModified=%p\n", this, "Machine::getCurrentStateModified", aCurrentStateModified));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCurrentStateModified);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getCurrentStateModified(aCurrentStateModified);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aCurrentStateModified=%RTbool hrc=%Rhrc\n", this, "Machine::getCurrentStateModified", *aCurrentStateModified, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(SharedFolders)(ComSafeArrayOut(ISharedFolder *, aSharedFolders))
{
    LogRelFlow(("{%p} %s: enter aSharedFolders=%p\n", this, "Machine::getSharedFolders", aSharedFolders));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSharedFolders);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSharedFolders(ArrayComTypeOutConverter<ISharedFolder>(ComSafeArrayOutArg(aSharedFolders)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSharedFolders=%zu hrc=%Rhrc\n", this, "Machine::getSharedFolders", ComSafeArraySize(*aSharedFolders), hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(ClipboardMode)(ClipboardMode_T *aClipboardMode)
{
    LogRelFlow(("{%p} %s: enter aClipboardMode=%p\n", this, "Machine::getClipboardMode", aClipboardMode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aClipboardMode);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getClipboardMode(aClipboardMode);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aClipboardMode=%RU32 hrc=%Rhrc\n", this, "Machine::getClipboardMode", *aClipboardMode, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(ClipboardMode)(ClipboardMode_T aClipboardMode)
{
    LogRelFlow(("{%p} %s: enter aClipboardMode=%RU32\n", this, "Machine::setClipboardMode", aClipboardMode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setClipboardMode(aClipboardMode);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setClipboardMode", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(DragAndDropMode)(DragAndDropMode_T *aDragAndDropMode)
{
    LogRelFlow(("{%p} %s: enter aDragAndDropMode=%p\n", this, "Machine::getDragAndDropMode", aDragAndDropMode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDragAndDropMode);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDragAndDropMode(aDragAndDropMode);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDragAndDropMode=%RU32 hrc=%Rhrc\n", this, "Machine::getDragAndDropMode", *aDragAndDropMode, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(DragAndDropMode)(DragAndDropMode_T aDragAndDropMode)
{
    LogRelFlow(("{%p} %s: enter aDragAndDropMode=%RU32\n", this, "Machine::setDragAndDropMode", aDragAndDropMode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setDragAndDropMode(aDragAndDropMode);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setDragAndDropMode", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(GuestPropertyNotificationPatterns)(BSTR *aGuestPropertyNotificationPatterns)
{
    LogRelFlow(("{%p} %s: enter aGuestPropertyNotificationPatterns=%p\n", this, "Machine::getGuestPropertyNotificationPatterns", aGuestPropertyNotificationPatterns));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGuestPropertyNotificationPatterns);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGuestPropertyNotificationPatterns(BSTROutConverter(aGuestPropertyNotificationPatterns).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGuestPropertyNotificationPatterns=%ls hrc=%Rhrc\n", this, "Machine::getGuestPropertyNotificationPatterns", *aGuestPropertyNotificationPatterns, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(GuestPropertyNotificationPatterns)(IN_BSTR aGuestPropertyNotificationPatterns)
{
    LogRelFlow(("{%p} %s: enter aGuestPropertyNotificationPatterns=%ls\n", this, "Machine::setGuestPropertyNotificationPatterns", aGuestPropertyNotificationPatterns));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setGuestPropertyNotificationPatterns(BSTRInConverter(aGuestPropertyNotificationPatterns).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setGuestPropertyNotificationPatterns", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(TeleporterEnabled)(BOOL *aTeleporterEnabled)
{
    LogRelFlow(("{%p} %s: enter aTeleporterEnabled=%p\n", this, "Machine::getTeleporterEnabled", aTeleporterEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aTeleporterEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getTeleporterEnabled(aTeleporterEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aTeleporterEnabled=%RTbool hrc=%Rhrc\n", this, "Machine::getTeleporterEnabled", *aTeleporterEnabled, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(TeleporterEnabled)(BOOL aTeleporterEnabled)
{
    LogRelFlow(("{%p} %s: enter aTeleporterEnabled=%RTbool\n", this, "Machine::setTeleporterEnabled", aTeleporterEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setTeleporterEnabled(aTeleporterEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setTeleporterEnabled", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(TeleporterPort)(ULONG *aTeleporterPort)
{
    LogRelFlow(("{%p} %s: enter aTeleporterPort=%p\n", this, "Machine::getTeleporterPort", aTeleporterPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aTeleporterPort);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getTeleporterPort(aTeleporterPort);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aTeleporterPort=%RU32 hrc=%Rhrc\n", this, "Machine::getTeleporterPort", *aTeleporterPort, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(TeleporterPort)(ULONG aTeleporterPort)
{
    LogRelFlow(("{%p} %s: enter aTeleporterPort=%RU32\n", this, "Machine::setTeleporterPort", aTeleporterPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setTeleporterPort(aTeleporterPort);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setTeleporterPort", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(TeleporterAddress)(BSTR *aTeleporterAddress)
{
    LogRelFlow(("{%p} %s: enter aTeleporterAddress=%p\n", this, "Machine::getTeleporterAddress", aTeleporterAddress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aTeleporterAddress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getTeleporterAddress(BSTROutConverter(aTeleporterAddress).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aTeleporterAddress=%ls hrc=%Rhrc\n", this, "Machine::getTeleporterAddress", *aTeleporterAddress, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(TeleporterAddress)(IN_BSTR aTeleporterAddress)
{
    LogRelFlow(("{%p} %s: enter aTeleporterAddress=%ls\n", this, "Machine::setTeleporterAddress", aTeleporterAddress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setTeleporterAddress(BSTRInConverter(aTeleporterAddress).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setTeleporterAddress", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(TeleporterPassword)(BSTR *aTeleporterPassword)
{
    LogRelFlow(("{%p} %s: enter aTeleporterPassword=%p\n", this, "Machine::getTeleporterPassword", aTeleporterPassword));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aTeleporterPassword);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getTeleporterPassword(BSTROutConverter(aTeleporterPassword).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aTeleporterPassword=%ls hrc=%Rhrc\n", this, "Machine::getTeleporterPassword", *aTeleporterPassword, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(TeleporterPassword)(IN_BSTR aTeleporterPassword)
{
    LogRelFlow(("{%p} %s: enter aTeleporterPassword=%ls\n", this, "Machine::setTeleporterPassword", aTeleporterPassword));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setTeleporterPassword(BSTRInConverter(aTeleporterPassword).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setTeleporterPassword", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(FaultToleranceState)(FaultToleranceState_T *aFaultToleranceState)
{
    LogRelFlow(("{%p} %s: enter aFaultToleranceState=%p\n", this, "Machine::getFaultToleranceState", aFaultToleranceState));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFaultToleranceState);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFaultToleranceState(aFaultToleranceState);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFaultToleranceState=%RU32 hrc=%Rhrc\n", this, "Machine::getFaultToleranceState", *aFaultToleranceState, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(FaultToleranceState)(FaultToleranceState_T aFaultToleranceState)
{
    LogRelFlow(("{%p} %s: enter aFaultToleranceState=%RU32\n", this, "Machine::setFaultToleranceState", aFaultToleranceState));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setFaultToleranceState(aFaultToleranceState);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setFaultToleranceState", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(FaultTolerancePort)(ULONG *aFaultTolerancePort)
{
    LogRelFlow(("{%p} %s: enter aFaultTolerancePort=%p\n", this, "Machine::getFaultTolerancePort", aFaultTolerancePort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFaultTolerancePort);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFaultTolerancePort(aFaultTolerancePort);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFaultTolerancePort=%RU32 hrc=%Rhrc\n", this, "Machine::getFaultTolerancePort", *aFaultTolerancePort, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(FaultTolerancePort)(ULONG aFaultTolerancePort)
{
    LogRelFlow(("{%p} %s: enter aFaultTolerancePort=%RU32\n", this, "Machine::setFaultTolerancePort", aFaultTolerancePort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setFaultTolerancePort(aFaultTolerancePort);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setFaultTolerancePort", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(FaultToleranceAddress)(BSTR *aFaultToleranceAddress)
{
    LogRelFlow(("{%p} %s: enter aFaultToleranceAddress=%p\n", this, "Machine::getFaultToleranceAddress", aFaultToleranceAddress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFaultToleranceAddress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFaultToleranceAddress(BSTROutConverter(aFaultToleranceAddress).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFaultToleranceAddress=%ls hrc=%Rhrc\n", this, "Machine::getFaultToleranceAddress", *aFaultToleranceAddress, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(FaultToleranceAddress)(IN_BSTR aFaultToleranceAddress)
{
    LogRelFlow(("{%p} %s: enter aFaultToleranceAddress=%ls\n", this, "Machine::setFaultToleranceAddress", aFaultToleranceAddress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setFaultToleranceAddress(BSTRInConverter(aFaultToleranceAddress).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setFaultToleranceAddress", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(FaultTolerancePassword)(BSTR *aFaultTolerancePassword)
{
    LogRelFlow(("{%p} %s: enter aFaultTolerancePassword=%p\n", this, "Machine::getFaultTolerancePassword", aFaultTolerancePassword));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFaultTolerancePassword);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFaultTolerancePassword(BSTROutConverter(aFaultTolerancePassword).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFaultTolerancePassword=%ls hrc=%Rhrc\n", this, "Machine::getFaultTolerancePassword", *aFaultTolerancePassword, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(FaultTolerancePassword)(IN_BSTR aFaultTolerancePassword)
{
    LogRelFlow(("{%p} %s: enter aFaultTolerancePassword=%ls\n", this, "Machine::setFaultTolerancePassword", aFaultTolerancePassword));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setFaultTolerancePassword(BSTRInConverter(aFaultTolerancePassword).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setFaultTolerancePassword", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(FaultToleranceSyncInterval)(ULONG *aFaultToleranceSyncInterval)
{
    LogRelFlow(("{%p} %s: enter aFaultToleranceSyncInterval=%p\n", this, "Machine::getFaultToleranceSyncInterval", aFaultToleranceSyncInterval));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFaultToleranceSyncInterval);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFaultToleranceSyncInterval(aFaultToleranceSyncInterval);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFaultToleranceSyncInterval=%RU32 hrc=%Rhrc\n", this, "Machine::getFaultToleranceSyncInterval", *aFaultToleranceSyncInterval, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(FaultToleranceSyncInterval)(ULONG aFaultToleranceSyncInterval)
{
    LogRelFlow(("{%p} %s: enter aFaultToleranceSyncInterval=%RU32\n", this, "Machine::setFaultToleranceSyncInterval", aFaultToleranceSyncInterval));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setFaultToleranceSyncInterval(aFaultToleranceSyncInterval);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setFaultToleranceSyncInterval", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(RTCUseUTC)(BOOL *aRTCUseUTC)
{
    LogRelFlow(("{%p} %s: enter aRTCUseUTC=%p\n", this, "Machine::getRTCUseUTC", aRTCUseUTC));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRTCUseUTC);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRTCUseUTC(aRTCUseUTC);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRTCUseUTC=%RTbool hrc=%Rhrc\n", this, "Machine::getRTCUseUTC", *aRTCUseUTC, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(RTCUseUTC)(BOOL aRTCUseUTC)
{
    LogRelFlow(("{%p} %s: enter aRTCUseUTC=%RTbool\n", this, "Machine::setRTCUseUTC", aRTCUseUTC));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setRTCUseUTC(aRTCUseUTC);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setRTCUseUTC", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(IOCacheEnabled)(BOOL *aIOCacheEnabled)
{
    LogRelFlow(("{%p} %s: enter aIOCacheEnabled=%p\n", this, "Machine::getIOCacheEnabled", aIOCacheEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aIOCacheEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getIOCacheEnabled(aIOCacheEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aIOCacheEnabled=%RTbool hrc=%Rhrc\n", this, "Machine::getIOCacheEnabled", *aIOCacheEnabled, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(IOCacheEnabled)(BOOL aIOCacheEnabled)
{
    LogRelFlow(("{%p} %s: enter aIOCacheEnabled=%RTbool\n", this, "Machine::setIOCacheEnabled", aIOCacheEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setIOCacheEnabled(aIOCacheEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setIOCacheEnabled", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(IOCacheSize)(ULONG *aIOCacheSize)
{
    LogRelFlow(("{%p} %s: enter aIOCacheSize=%p\n", this, "Machine::getIOCacheSize", aIOCacheSize));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aIOCacheSize);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getIOCacheSize(aIOCacheSize);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aIOCacheSize=%RU32 hrc=%Rhrc\n", this, "Machine::getIOCacheSize", *aIOCacheSize, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(IOCacheSize)(ULONG aIOCacheSize)
{
    LogRelFlow(("{%p} %s: enter aIOCacheSize=%RU32\n", this, "Machine::setIOCacheSize", aIOCacheSize));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setIOCacheSize(aIOCacheSize);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setIOCacheSize", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(PCIDeviceAssignments)(ComSafeArrayOut(IPCIDeviceAttachment *, aPCIDeviceAssignments))
{
    LogRelFlow(("{%p} %s: enter aPCIDeviceAssignments=%p\n", this, "Machine::getPCIDeviceAssignments", aPCIDeviceAssignments));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPCIDeviceAssignments);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPCIDeviceAssignments(ArrayComTypeOutConverter<IPCIDeviceAttachment>(ComSafeArrayOutArg(aPCIDeviceAssignments)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPCIDeviceAssignments=%zu hrc=%Rhrc\n", this, "Machine::getPCIDeviceAssignments", ComSafeArraySize(*aPCIDeviceAssignments), hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(BandwidthControl)(IBandwidthControl **aBandwidthControl)
{
    LogRelFlow(("{%p} %s: enter aBandwidthControl=%p\n", this, "Machine::getBandwidthControl", aBandwidthControl));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBandwidthControl);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBandwidthControl(ComTypeOutConverter<IBandwidthControl>(aBandwidthControl).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBandwidthControl=%p hrc=%Rhrc\n", this, "Machine::getBandwidthControl", *aBandwidthControl, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(TracingEnabled)(BOOL *aTracingEnabled)
{
    LogRelFlow(("{%p} %s: enter aTracingEnabled=%p\n", this, "Machine::getTracingEnabled", aTracingEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aTracingEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getTracingEnabled(aTracingEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aTracingEnabled=%RTbool hrc=%Rhrc\n", this, "Machine::getTracingEnabled", *aTracingEnabled, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(TracingEnabled)(BOOL aTracingEnabled)
{
    LogRelFlow(("{%p} %s: enter aTracingEnabled=%RTbool\n", this, "Machine::setTracingEnabled", aTracingEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setTracingEnabled(aTracingEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setTracingEnabled", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(TracingConfig)(BSTR *aTracingConfig)
{
    LogRelFlow(("{%p} %s: enter aTracingConfig=%p\n", this, "Machine::getTracingConfig", aTracingConfig));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aTracingConfig);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getTracingConfig(BSTROutConverter(aTracingConfig).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aTracingConfig=%ls hrc=%Rhrc\n", this, "Machine::getTracingConfig", *aTracingConfig, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(TracingConfig)(IN_BSTR aTracingConfig)
{
    LogRelFlow(("{%p} %s: enter aTracingConfig=%ls\n", this, "Machine::setTracingConfig", aTracingConfig));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setTracingConfig(BSTRInConverter(aTracingConfig).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setTracingConfig", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(AllowTracingToAccessVM)(BOOL *aAllowTracingToAccessVM)
{
    LogRelFlow(("{%p} %s: enter aAllowTracingToAccessVM=%p\n", this, "Machine::getAllowTracingToAccessVM", aAllowTracingToAccessVM));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAllowTracingToAccessVM);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAllowTracingToAccessVM(aAllowTracingToAccessVM);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAllowTracingToAccessVM=%RTbool hrc=%Rhrc\n", this, "Machine::getAllowTracingToAccessVM", *aAllowTracingToAccessVM, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(AllowTracingToAccessVM)(BOOL aAllowTracingToAccessVM)
{
    LogRelFlow(("{%p} %s: enter aAllowTracingToAccessVM=%RTbool\n", this, "Machine::setAllowTracingToAccessVM", aAllowTracingToAccessVM));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setAllowTracingToAccessVM(aAllowTracingToAccessVM);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setAllowTracingToAccessVM", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(AutostartEnabled)(BOOL *aAutostartEnabled)
{
    LogRelFlow(("{%p} %s: enter aAutostartEnabled=%p\n", this, "Machine::getAutostartEnabled", aAutostartEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAutostartEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAutostartEnabled(aAutostartEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAutostartEnabled=%RTbool hrc=%Rhrc\n", this, "Machine::getAutostartEnabled", *aAutostartEnabled, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(AutostartEnabled)(BOOL aAutostartEnabled)
{
    LogRelFlow(("{%p} %s: enter aAutostartEnabled=%RTbool\n", this, "Machine::setAutostartEnabled", aAutostartEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setAutostartEnabled(aAutostartEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setAutostartEnabled", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(AutostartDelay)(ULONG *aAutostartDelay)
{
    LogRelFlow(("{%p} %s: enter aAutostartDelay=%p\n", this, "Machine::getAutostartDelay", aAutostartDelay));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAutostartDelay);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAutostartDelay(aAutostartDelay);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAutostartDelay=%RU32 hrc=%Rhrc\n", this, "Machine::getAutostartDelay", *aAutostartDelay, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(AutostartDelay)(ULONG aAutostartDelay)
{
    LogRelFlow(("{%p} %s: enter aAutostartDelay=%RU32\n", this, "Machine::setAutostartDelay", aAutostartDelay));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setAutostartDelay(aAutostartDelay);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setAutostartDelay", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(AutostopType)(AutostopType_T *aAutostopType)
{
    LogRelFlow(("{%p} %s: enter aAutostopType=%p\n", this, "Machine::getAutostopType", aAutostopType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAutostopType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAutostopType(aAutostopType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAutostopType=%RU32 hrc=%Rhrc\n", this, "Machine::getAutostopType", *aAutostopType, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(AutostopType)(AutostopType_T aAutostopType)
{
    LogRelFlow(("{%p} %s: enter aAutostopType=%RU32\n", this, "Machine::setAutostopType", aAutostopType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setAutostopType(aAutostopType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setAutostopType", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(DefaultFrontend)(BSTR *aDefaultFrontend)
{
    LogRelFlow(("{%p} %s: enter aDefaultFrontend=%p\n", this, "Machine::getDefaultFrontend", aDefaultFrontend));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDefaultFrontend);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDefaultFrontend(BSTROutConverter(aDefaultFrontend).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDefaultFrontend=%ls hrc=%Rhrc\n", this, "Machine::getDefaultFrontend", *aDefaultFrontend, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMSETTER(DefaultFrontend)(IN_BSTR aDefaultFrontend)
{
    LogRelFlow(("{%p} %s: enter aDefaultFrontend=%ls\n", this, "Machine::setDefaultFrontend", aDefaultFrontend));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setDefaultFrontend(BSTRInConverter(aDefaultFrontend).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setDefaultFrontend", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::COMGETTER(USBProxyAvailable)(BOOL *aUSBProxyAvailable)
{
    LogRelFlow(("{%p} %s: enter aUSBProxyAvailable=%p\n", this, "Machine::getUSBProxyAvailable", aUSBProxyAvailable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUSBProxyAvailable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUSBProxyAvailable(aUSBProxyAvailable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUSBProxyAvailable=%RTbool hrc=%Rhrc\n", this, "Machine::getUSBProxyAvailable", *aUSBProxyAvailable, hrc));
    return hrc;
}

//
// IMachine methods
//

STDMETHODIMP MachineWrap::LockMachine(ISession *aSession,
                                      LockType_T aLockType)
{
    LogRelFlow(("{%p} %s:enter aSession=%p aLockType=%RU32\n", this, "Machine::lockMachine", aSession, aLockType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = lockMachine(ComTypeInConverter<ISession>(aSession).ptr(),
                          aLockType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::lockMachine", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::LaunchVMProcess(ISession *aSession,
                                          IN_BSTR aType,
                                          IN_BSTR aEnvironment,
                                          IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aSession=%p aType=%ls aEnvironment=%ls aProgress=%p\n", this, "Machine::launchVMProcess", aSession, aType, aEnvironment, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = launchVMProcess(ComTypeInConverter<ISession>(aSession).ptr(),
                              BSTRInConverter(aType).str(),
                              BSTRInConverter(aEnvironment).str(),
                              ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Machine::launchVMProcess", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::SetBootOrder(ULONG aPosition,
                                       DeviceType_T aDevice)
{
    LogRelFlow(("{%p} %s:enter aPosition=%RU32 aDevice=%RU32\n", this, "Machine::setBootOrder", aPosition, aDevice));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setBootOrder(aPosition,
                           aDevice);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setBootOrder", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::GetBootOrder(ULONG aPosition,
                                       DeviceType_T *aDevice)
{
    LogRelFlow(("{%p} %s:enter aPosition=%RU32 aDevice=%p\n", this, "Machine::getBootOrder", aPosition, aDevice));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDevice);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBootOrder(aPosition,
                           aDevice);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aDevice=%RU32 hrc=%Rhrc\n", this, "Machine::getBootOrder", *aDevice, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::AttachDevice(IN_BSTR aName,
                                       LONG aControllerPort,
                                       LONG aDevice,
                                       DeviceType_T aType,
                                       IMedium *aMedium)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aControllerPort=%RI32 aDevice=%RI32 aType=%RU32 aMedium=%p\n", this, "Machine::attachDevice", aName, aControllerPort, aDevice, aType, aMedium));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = attachDevice(BSTRInConverter(aName).str(),
                           aControllerPort,
                           aDevice,
                           aType,
                           ComTypeInConverter<IMedium>(aMedium).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::attachDevice", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::AttachDeviceWithoutMedium(IN_BSTR aName,
                                                    LONG aControllerPort,
                                                    LONG aDevice,
                                                    DeviceType_T aType)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aControllerPort=%RI32 aDevice=%RI32 aType=%RU32\n", this, "Machine::attachDeviceWithoutMedium", aName, aControllerPort, aDevice, aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = attachDeviceWithoutMedium(BSTRInConverter(aName).str(),
                                        aControllerPort,
                                        aDevice,
                                        aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::attachDeviceWithoutMedium", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::DetachDevice(IN_BSTR aName,
                                       LONG aControllerPort,
                                       LONG aDevice)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aControllerPort=%RI32 aDevice=%RI32\n", this, "Machine::detachDevice", aName, aControllerPort, aDevice));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = detachDevice(BSTRInConverter(aName).str(),
                           aControllerPort,
                           aDevice);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::detachDevice", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::PassthroughDevice(IN_BSTR aName,
                                            LONG aControllerPort,
                                            LONG aDevice,
                                            BOOL aPassthrough)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aControllerPort=%RI32 aDevice=%RI32 aPassthrough=%RTbool\n", this, "Machine::passthroughDevice", aName, aControllerPort, aDevice, aPassthrough));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = passthroughDevice(BSTRInConverter(aName).str(),
                                aControllerPort,
                                aDevice,
                                aPassthrough);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::passthroughDevice", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::TemporaryEjectDevice(IN_BSTR aName,
                                               LONG aControllerPort,
                                               LONG aDevice,
                                               BOOL aTemporaryEject)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aControllerPort=%RI32 aDevice=%RI32 aTemporaryEject=%RTbool\n", this, "Machine::temporaryEjectDevice", aName, aControllerPort, aDevice, aTemporaryEject));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = temporaryEjectDevice(BSTRInConverter(aName).str(),
                                   aControllerPort,
                                   aDevice,
                                   aTemporaryEject);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::temporaryEjectDevice", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::NonRotationalDevice(IN_BSTR aName,
                                              LONG aControllerPort,
                                              LONG aDevice,
                                              BOOL aNonRotational)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aControllerPort=%RI32 aDevice=%RI32 aNonRotational=%RTbool\n", this, "Machine::nonRotationalDevice", aName, aControllerPort, aDevice, aNonRotational));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = nonRotationalDevice(BSTRInConverter(aName).str(),
                                  aControllerPort,
                                  aDevice,
                                  aNonRotational);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::nonRotationalDevice", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::SetAutoDiscardForDevice(IN_BSTR aName,
                                                  LONG aControllerPort,
                                                  LONG aDevice,
                                                  BOOL aDiscard)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aControllerPort=%RI32 aDevice=%RI32 aDiscard=%RTbool\n", this, "Machine::setAutoDiscardForDevice", aName, aControllerPort, aDevice, aDiscard));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setAutoDiscardForDevice(BSTRInConverter(aName).str(),
                                      aControllerPort,
                                      aDevice,
                                      aDiscard);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setAutoDiscardForDevice", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::SetHotPluggableForDevice(IN_BSTR aName,
                                                   LONG aControllerPort,
                                                   LONG aDevice,
                                                   BOOL aHotPluggable)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aControllerPort=%RI32 aDevice=%RI32 aHotPluggable=%RTbool\n", this, "Machine::setHotPluggableForDevice", aName, aControllerPort, aDevice, aHotPluggable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setHotPluggableForDevice(BSTRInConverter(aName).str(),
                                       aControllerPort,
                                       aDevice,
                                       aHotPluggable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setHotPluggableForDevice", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::SetBandwidthGroupForDevice(IN_BSTR aName,
                                                     LONG aControllerPort,
                                                     LONG aDevice,
                                                     IBandwidthGroup *aBandwidthGroup)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aControllerPort=%RI32 aDevice=%RI32 aBandwidthGroup=%p\n", this, "Machine::setBandwidthGroupForDevice", aName, aControllerPort, aDevice, aBandwidthGroup));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setBandwidthGroupForDevice(BSTRInConverter(aName).str(),
                                         aControllerPort,
                                         aDevice,
                                         ComTypeInConverter<IBandwidthGroup>(aBandwidthGroup).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setBandwidthGroupForDevice", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::SetNoBandwidthGroupForDevice(IN_BSTR aName,
                                                       LONG aControllerPort,
                                                       LONG aDevice)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aControllerPort=%RI32 aDevice=%RI32\n", this, "Machine::setNoBandwidthGroupForDevice", aName, aControllerPort, aDevice));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setNoBandwidthGroupForDevice(BSTRInConverter(aName).str(),
                                           aControllerPort,
                                           aDevice);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setNoBandwidthGroupForDevice", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::UnmountMedium(IN_BSTR aName,
                                        LONG aControllerPort,
                                        LONG aDevice,
                                        BOOL aForce)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aControllerPort=%RI32 aDevice=%RI32 aForce=%RTbool\n", this, "Machine::unmountMedium", aName, aControllerPort, aDevice, aForce));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = unmountMedium(BSTRInConverter(aName).str(),
                            aControllerPort,
                            aDevice,
                            aForce);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::unmountMedium", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::MountMedium(IN_BSTR aName,
                                      LONG aControllerPort,
                                      LONG aDevice,
                                      IMedium *aMedium,
                                      BOOL aForce)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aControllerPort=%RI32 aDevice=%RI32 aMedium=%p aForce=%RTbool\n", this, "Machine::mountMedium", aName, aControllerPort, aDevice, aMedium, aForce));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = mountMedium(BSTRInConverter(aName).str(),
                          aControllerPort,
                          aDevice,
                          ComTypeInConverter<IMedium>(aMedium).ptr(),
                          aForce);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::mountMedium", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::GetMedium(IN_BSTR aName,
                                    LONG aControllerPort,
                                    LONG aDevice,
                                    IMedium **aMedium)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aControllerPort=%RI32 aDevice=%RI32 aMedium=%p\n", this, "Machine::getMedium", aName, aControllerPort, aDevice, aMedium));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMedium);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMedium(BSTRInConverter(aName).str(),
                        aControllerPort,
                        aDevice,
                        ComTypeOutConverter<IMedium>(aMedium).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aMedium=%p hrc=%Rhrc\n", this, "Machine::getMedium", *aMedium, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::GetMediumAttachmentsOfController(IN_BSTR aName,
                                                           ComSafeArrayOut(IMediumAttachment *, aMediumAttachments))
{
    LogRelFlow(("{%p} %s:enter aName=%ls aMediumAttachments=%p\n", this, "Machine::getMediumAttachmentsOfController", aName, aMediumAttachments));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMediumAttachments);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMediumAttachmentsOfController(BSTRInConverter(aName).str(),
                                               ArrayComTypeOutConverter<IMediumAttachment>(ComSafeArrayOutArg(aMediumAttachments)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aMediumAttachments=%zu hrc=%Rhrc\n", this, "Machine::getMediumAttachmentsOfController", ComSafeArraySize(*aMediumAttachments), hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::GetMediumAttachment(IN_BSTR aName,
                                              LONG aControllerPort,
                                              LONG aDevice,
                                              IMediumAttachment **aAttachment)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aControllerPort=%RI32 aDevice=%RI32 aAttachment=%p\n", this, "Machine::getMediumAttachment", aName, aControllerPort, aDevice, aAttachment));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAttachment);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMediumAttachment(BSTRInConverter(aName).str(),
                                  aControllerPort,
                                  aDevice,
                                  ComTypeOutConverter<IMediumAttachment>(aAttachment).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aAttachment=%p hrc=%Rhrc\n", this, "Machine::getMediumAttachment", *aAttachment, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::AttachHostPCIDevice(LONG aHostAddress,
                                              LONG aDesiredGuestAddress,
                                              BOOL aTryToUnbind)
{
    LogRelFlow(("{%p} %s:enter aHostAddress=%RI32 aDesiredGuestAddress=%RI32 aTryToUnbind=%RTbool\n", this, "Machine::attachHostPCIDevice", aHostAddress, aDesiredGuestAddress, aTryToUnbind));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = attachHostPCIDevice(aHostAddress,
                                  aDesiredGuestAddress,
                                  aTryToUnbind);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::attachHostPCIDevice", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::DetachHostPCIDevice(LONG aHostAddress)
{
    LogRelFlow(("{%p} %s:enter aHostAddress=%RI32\n", this, "Machine::detachHostPCIDevice", aHostAddress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = detachHostPCIDevice(aHostAddress);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::detachHostPCIDevice", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::GetNetworkAdapter(ULONG aSlot,
                                            INetworkAdapter **aAdapter)
{
    LogRelFlow(("{%p} %s:enter aSlot=%RU32 aAdapter=%p\n", this, "Machine::getNetworkAdapter", aSlot, aAdapter));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAdapter);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNetworkAdapter(aSlot,
                                ComTypeOutConverter<INetworkAdapter>(aAdapter).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aAdapter=%p hrc=%Rhrc\n", this, "Machine::getNetworkAdapter", *aAdapter, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::AddStorageController(IN_BSTR aName,
                                               StorageBus_T aConnectionType,
                                               IStorageController **aController)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aConnectionType=%RU32 aController=%p\n", this, "Machine::addStorageController", aName, aConnectionType, aController));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aController);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = addStorageController(BSTRInConverter(aName).str(),
                                   aConnectionType,
                                   ComTypeOutConverter<IStorageController>(aController).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aController=%p hrc=%Rhrc\n", this, "Machine::addStorageController", *aController, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::GetStorageControllerByName(IN_BSTR aName,
                                                     IStorageController **aStorageController)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aStorageController=%p\n", this, "Machine::getStorageControllerByName", aName, aStorageController));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStorageController);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getStorageControllerByName(BSTRInConverter(aName).str(),
                                         ComTypeOutConverter<IStorageController>(aStorageController).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aStorageController=%p hrc=%Rhrc\n", this, "Machine::getStorageControllerByName", *aStorageController, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::GetStorageControllerByInstance(ULONG aInstance,
                                                         IStorageController **aStorageController)
{
    LogRelFlow(("{%p} %s:enter aInstance=%RU32 aStorageController=%p\n", this, "Machine::getStorageControllerByInstance", aInstance, aStorageController));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStorageController);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getStorageControllerByInstance(aInstance,
                                             ComTypeOutConverter<IStorageController>(aStorageController).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aStorageController=%p hrc=%Rhrc\n", this, "Machine::getStorageControllerByInstance", *aStorageController, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::RemoveStorageController(IN_BSTR aName)
{
    LogRelFlow(("{%p} %s:enter aName=%ls\n", this, "Machine::removeStorageController", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = removeStorageController(BSTRInConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::removeStorageController", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::SetStorageControllerBootable(IN_BSTR aName,
                                                       BOOL aBootable)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aBootable=%RTbool\n", this, "Machine::setStorageControllerBootable", aName, aBootable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setStorageControllerBootable(BSTRInConverter(aName).str(),
                                           aBootable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setStorageControllerBootable", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::AddUSBController(IN_BSTR aName,
                                           USBControllerType_T aType,
                                           IUSBController **aController)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aType=%RU32 aController=%p\n", this, "Machine::addUSBController", aName, aType, aController));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aController);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = addUSBController(BSTRInConverter(aName).str(),
                               aType,
                               ComTypeOutConverter<IUSBController>(aController).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aController=%p hrc=%Rhrc\n", this, "Machine::addUSBController", *aController, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::RemoveUSBController(IN_BSTR aName)
{
    LogRelFlow(("{%p} %s:enter aName=%ls\n", this, "Machine::removeUSBController", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = removeUSBController(BSTRInConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::removeUSBController", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::GetUSBControllerByName(IN_BSTR aName,
                                                 IUSBController **aController)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aController=%p\n", this, "Machine::getUSBControllerByName", aName, aController));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aController);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUSBControllerByName(BSTRInConverter(aName).str(),
                                     ComTypeOutConverter<IUSBController>(aController).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aController=%p hrc=%Rhrc\n", this, "Machine::getUSBControllerByName", *aController, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::GetUSBControllerCountByType(USBControllerType_T aType,
                                                      ULONG *aControllers)
{
    LogRelFlow(("{%p} %s:enter aType=%RU32 aControllers=%p\n", this, "Machine::getUSBControllerCountByType", aType, aControllers));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aControllers);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUSBControllerCountByType(aType,
                                          aControllers);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aControllers=%RU32 hrc=%Rhrc\n", this, "Machine::getUSBControllerCountByType", *aControllers, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::GetSerialPort(ULONG aSlot,
                                        ISerialPort **aPort)
{
    LogRelFlow(("{%p} %s:enter aSlot=%RU32 aPort=%p\n", this, "Machine::getSerialPort", aSlot, aPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPort);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSerialPort(aSlot,
                            ComTypeOutConverter<ISerialPort>(aPort).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aPort=%p hrc=%Rhrc\n", this, "Machine::getSerialPort", *aPort, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::GetParallelPort(ULONG aSlot,
                                          IParallelPort **aPort)
{
    LogRelFlow(("{%p} %s:enter aSlot=%RU32 aPort=%p\n", this, "Machine::getParallelPort", aSlot, aPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPort);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getParallelPort(aSlot,
                              ComTypeOutConverter<IParallelPort>(aPort).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aPort=%p hrc=%Rhrc\n", this, "Machine::getParallelPort", *aPort, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::GetExtraDataKeys(ComSafeArrayOut(BSTR, aKeys))
{
    LogRelFlow(("{%p} %s:enter aKeys=%p\n", this, "Machine::getExtraDataKeys", aKeys));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aKeys);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getExtraDataKeys(ArrayBSTROutConverter(ComSafeArrayOutArg(aKeys)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aKeys=%zu hrc=%Rhrc\n", this, "Machine::getExtraDataKeys", ComSafeArraySize(*aKeys), hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::GetExtraData(IN_BSTR aKey,
                                       BSTR *aValue)
{
    LogRelFlow(("{%p} %s:enter aKey=%ls aValue=%p\n", this, "Machine::getExtraData", aKey, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aValue);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getExtraData(BSTRInConverter(aKey).str(),
                           BSTROutConverter(aValue).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aValue=%ls hrc=%Rhrc\n", this, "Machine::getExtraData", *aValue, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::SetExtraData(IN_BSTR aKey,
                                       IN_BSTR aValue)
{
    LogRelFlow(("{%p} %s:enter aKey=%ls aValue=%ls\n", this, "Machine::setExtraData", aKey, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setExtraData(BSTRInConverter(aKey).str(),
                           BSTRInConverter(aValue).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setExtraData", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::GetCPUProperty(CPUPropertyType_T aProperty,
                                         BOOL *aValue)
{
    LogRelFlow(("{%p} %s:enter aProperty=%RU32 aValue=%p\n", this, "Machine::getCPUProperty", aProperty, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aValue);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getCPUProperty(aProperty,
                             aValue);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aValue=%RTbool hrc=%Rhrc\n", this, "Machine::getCPUProperty", *aValue, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::SetCPUProperty(CPUPropertyType_T aProperty,
                                         BOOL aValue)
{
    LogRelFlow(("{%p} %s:enter aProperty=%RU32 aValue=%RTbool\n", this, "Machine::setCPUProperty", aProperty, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setCPUProperty(aProperty,
                             aValue);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setCPUProperty", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::GetCPUIDLeaf(ULONG aId,
                                       ULONG *aValEax,
                                       ULONG *aValEbx,
                                       ULONG *aValEcx,
                                       ULONG *aValEdx)
{
    LogRelFlow(("{%p} %s:enter aId=%RU32 aValEax=%p aValEbx=%p aValEcx=%p aValEdx=%p\n", this, "Machine::getCPUIDLeaf", aId, aValEax, aValEbx, aValEcx, aValEdx));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aValEax);
        CheckComArgOutPointerValidThrow(aValEbx);
        CheckComArgOutPointerValidThrow(aValEcx);
        CheckComArgOutPointerValidThrow(aValEdx);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getCPUIDLeaf(aId,
                           aValEax,
                           aValEbx,
                           aValEcx,
                           aValEdx);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aValEax=%RU32 *aValEbx=%RU32 *aValEcx=%RU32 *aValEdx=%RU32 hrc=%Rhrc\n", this, "Machine::getCPUIDLeaf", *aValEax, *aValEbx, *aValEcx, *aValEdx, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::SetCPUIDLeaf(ULONG aId,
                                       ULONG aValEax,
                                       ULONG aValEbx,
                                       ULONG aValEcx,
                                       ULONG aValEdx)
{
    LogRelFlow(("{%p} %s:enter aId=%RU32 aValEax=%RU32 aValEbx=%RU32 aValEcx=%RU32 aValEdx=%RU32\n", this, "Machine::setCPUIDLeaf", aId, aValEax, aValEbx, aValEcx, aValEdx));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setCPUIDLeaf(aId,
                           aValEax,
                           aValEbx,
                           aValEcx,
                           aValEdx);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setCPUIDLeaf", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::RemoveCPUIDLeaf(ULONG aId)
{
    LogRelFlow(("{%p} %s:enter aId=%RU32\n", this, "Machine::removeCPUIDLeaf", aId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = removeCPUIDLeaf(aId);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::removeCPUIDLeaf", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::RemoveAllCPUIDLeaves()
{
    LogRelFlow(("{%p} %s:enter\n", this, "Machine::removeAllCPUIDLeaves"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = removeAllCPUIDLeaves();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::removeAllCPUIDLeaves", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::GetHWVirtExProperty(HWVirtExPropertyType_T aProperty,
                                              BOOL *aValue)
{
    LogRelFlow(("{%p} %s:enter aProperty=%RU32 aValue=%p\n", this, "Machine::getHWVirtExProperty", aProperty, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aValue);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHWVirtExProperty(aProperty,
                                  aValue);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aValue=%RTbool hrc=%Rhrc\n", this, "Machine::getHWVirtExProperty", *aValue, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::SetHWVirtExProperty(HWVirtExPropertyType_T aProperty,
                                              BOOL aValue)
{
    LogRelFlow(("{%p} %s:enter aProperty=%RU32 aValue=%RTbool\n", this, "Machine::setHWVirtExProperty", aProperty, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setHWVirtExProperty(aProperty,
                                  aValue);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setHWVirtExProperty", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::SetSettingsFilePath(IN_BSTR aSettingsFilePath,
                                              IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aSettingsFilePath=%ls aProgress=%p\n", this, "Machine::setSettingsFilePath", aSettingsFilePath, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setSettingsFilePath(BSTRInConverter(aSettingsFilePath).str(),
                                  ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Machine::setSettingsFilePath", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::SaveSettings()
{
    LogRelFlow(("{%p} %s:enter\n", this, "Machine::saveSettings"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = saveSettings();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::saveSettings", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::DiscardSettings()
{
    LogRelFlow(("{%p} %s:enter\n", this, "Machine::discardSettings"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = discardSettings();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::discardSettings", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::Unregister(CleanupMode_T aCleanupMode,
                                     ComSafeArrayOut(IMedium *, aMedia))
{
    LogRelFlow(("{%p} %s:enter aCleanupMode=%RU32 aMedia=%p\n", this, "Machine::unregister", aCleanupMode, aMedia));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMedia);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = unregister(aCleanupMode,
                         ArrayComTypeOutConverter<IMedium>(ComSafeArrayOutArg(aMedia)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aMedia=%zu hrc=%Rhrc\n", this, "Machine::unregister", ComSafeArraySize(*aMedia), hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::DeleteConfig(ComSafeArrayIn(IMedium *, aMedia),
                                       IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aMedia=%zu aProgress=%p\n", this, "Machine::deleteConfig", aMedia, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = deleteConfig(ArrayComTypeInConverter<IMedium>(ComSafeArrayInArg(aMedia)).array(),
                           ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Machine::deleteConfig", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::ExportTo(IAppliance *aAppliance,
                                   IN_BSTR aLocation,
                                   IVirtualSystemDescription **aDescription)
{
    LogRelFlow(("{%p} %s:enter aAppliance=%p aLocation=%ls aDescription=%p\n", this, "Machine::exportTo", aAppliance, aLocation, aDescription));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDescription);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = exportTo(ComTypeInConverter<IAppliance>(aAppliance).ptr(),
                       BSTRInConverter(aLocation).str(),
                       ComTypeOutConverter<IVirtualSystemDescription>(aDescription).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aDescription=%p hrc=%Rhrc\n", this, "Machine::exportTo", *aDescription, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::FindSnapshot(IN_BSTR aNameOrId,
                                       ISnapshot **aSnapshot)
{
    LogRelFlow(("{%p} %s:enter aNameOrId=%ls aSnapshot=%p\n", this, "Machine::findSnapshot", aNameOrId, aSnapshot));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSnapshot);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = findSnapshot(BSTRInConverter(aNameOrId).str(),
                           ComTypeOutConverter<ISnapshot>(aSnapshot).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aSnapshot=%p hrc=%Rhrc\n", this, "Machine::findSnapshot", *aSnapshot, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::CreateSharedFolder(IN_BSTR aName,
                                             IN_BSTR aHostPath,
                                             BOOL aWritable,
                                             BOOL aAutomount)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aHostPath=%ls aWritable=%RTbool aAutomount=%RTbool\n", this, "Machine::createSharedFolder", aName, aHostPath, aWritable, aAutomount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = createSharedFolder(BSTRInConverter(aName).str(),
                                 BSTRInConverter(aHostPath).str(),
                                 aWritable,
                                 aAutomount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::createSharedFolder", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::RemoveSharedFolder(IN_BSTR aName)
{
    LogRelFlow(("{%p} %s:enter aName=%ls\n", this, "Machine::removeSharedFolder", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = removeSharedFolder(BSTRInConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::removeSharedFolder", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::CanShowConsoleWindow(BOOL *aCanShow)
{
    LogRelFlow(("{%p} %s:enter aCanShow=%p\n", this, "Machine::canShowConsoleWindow", aCanShow));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCanShow);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = canShowConsoleWindow(aCanShow);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aCanShow=%RTbool hrc=%Rhrc\n", this, "Machine::canShowConsoleWindow", *aCanShow, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::ShowConsoleWindow(LONG64 *aWinId)
{
    LogRelFlow(("{%p} %s:enter aWinId=%p\n", this, "Machine::showConsoleWindow", aWinId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWinId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = showConsoleWindow(aWinId);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aWinId=%RI64 hrc=%Rhrc\n", this, "Machine::showConsoleWindow", *aWinId, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::GetGuestProperty(IN_BSTR aName,
                                           BSTR *aValue,
                                           LONG64 *aTimestamp,
                                           BSTR *aFlags)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aValue=%p aTimestamp=%p aFlags=%p\n", this, "Machine::getGuestProperty", aName, aValue, aTimestamp, aFlags));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aValue);
        CheckComArgOutPointerValidThrow(aTimestamp);
        CheckComArgOutPointerValidThrow(aFlags);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGuestProperty(BSTRInConverter(aName).str(),
                               BSTROutConverter(aValue).str(),
                               aTimestamp,
                               BSTROutConverter(aFlags).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aValue=%ls *aTimestamp=%RI64 *aFlags=%ls hrc=%Rhrc\n", this, "Machine::getGuestProperty", *aValue, *aTimestamp, *aFlags, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::GetGuestPropertyValue(IN_BSTR aProperty,
                                                BSTR *aValue)
{
    LogRelFlow(("{%p} %s:enter aProperty=%ls aValue=%p\n", this, "Machine::getGuestPropertyValue", aProperty, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aValue);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGuestPropertyValue(BSTRInConverter(aProperty).str(),
                                    BSTROutConverter(aValue).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aValue=%ls hrc=%Rhrc\n", this, "Machine::getGuestPropertyValue", *aValue, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::GetGuestPropertyTimestamp(IN_BSTR aProperty,
                                                    LONG64 *aValue)
{
    LogRelFlow(("{%p} %s:enter aProperty=%ls aValue=%p\n", this, "Machine::getGuestPropertyTimestamp", aProperty, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aValue);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGuestPropertyTimestamp(BSTRInConverter(aProperty).str(),
                                        aValue);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aValue=%RI64 hrc=%Rhrc\n", this, "Machine::getGuestPropertyTimestamp", *aValue, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::SetGuestProperty(IN_BSTR aProperty,
                                           IN_BSTR aValue,
                                           IN_BSTR aFlags)
{
    LogRelFlow(("{%p} %s:enter aProperty=%ls aValue=%ls aFlags=%ls\n", this, "Machine::setGuestProperty", aProperty, aValue, aFlags));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setGuestProperty(BSTRInConverter(aProperty).str(),
                               BSTRInConverter(aValue).str(),
                               BSTRInConverter(aFlags).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setGuestProperty", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::SetGuestPropertyValue(IN_BSTR aProperty,
                                                IN_BSTR aValue)
{
    LogRelFlow(("{%p} %s:enter aProperty=%ls aValue=%ls\n", this, "Machine::setGuestPropertyValue", aProperty, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setGuestPropertyValue(BSTRInConverter(aProperty).str(),
                                    BSTRInConverter(aValue).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::setGuestPropertyValue", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::DeleteGuestProperty(IN_BSTR aName)
{
    LogRelFlow(("{%p} %s:enter aName=%ls\n", this, "Machine::deleteGuestProperty", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = deleteGuestProperty(BSTRInConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::deleteGuestProperty", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::EnumerateGuestProperties(IN_BSTR aPatterns,
                                                   ComSafeArrayOut(BSTR, aNames),
                                                   ComSafeArrayOut(BSTR, aValues),
                                                   ComSafeArrayOut(LONG64, aTimestamps),
                                                   ComSafeArrayOut(BSTR, aFlags))
{
    LogRelFlow(("{%p} %s:enter aPatterns=%ls aNames=%p aValues=%p aTimestamps=%p aFlags=%p\n", this, "Machine::enumerateGuestProperties", aPatterns, aNames, aValues, aTimestamps, aFlags));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNames);
        CheckComArgOutPointerValidThrow(aValues);
        CheckComArgOutPointerValidThrow(aTimestamps);
        CheckComArgOutPointerValidThrow(aFlags);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = enumerateGuestProperties(BSTRInConverter(aPatterns).str(),
                                       ArrayBSTROutConverter(ComSafeArrayOutArg(aNames)).array(),
                                       ArrayBSTROutConverter(ComSafeArrayOutArg(aValues)).array(),
                                       ArrayOutConverter<LONG64>(ComSafeArrayOutArg(aTimestamps)).array(),
                                       ArrayBSTROutConverter(ComSafeArrayOutArg(aFlags)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNames=%zu *aValues=%zu *aTimestamps=%zu *aFlags=%zu hrc=%Rhrc\n", this, "Machine::enumerateGuestProperties", ComSafeArraySize(*aNames), ComSafeArraySize(*aValues), ComSafeArraySize(*aTimestamps), ComSafeArraySize(*aFlags), hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::QuerySavedGuestScreenInfo(ULONG aScreenId,
                                                    ULONG *aOriginX,
                                                    ULONG *aOriginY,
                                                    ULONG *aWidth,
                                                    ULONG *aHeight,
                                                    BOOL *aEnabled)
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32 aOriginX=%p aOriginY=%p aWidth=%p aHeight=%p aEnabled=%p\n", this, "Machine::querySavedGuestScreenInfo", aScreenId, aOriginX, aOriginY, aWidth, aHeight, aEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOriginX);
        CheckComArgOutPointerValidThrow(aOriginY);
        CheckComArgOutPointerValidThrow(aWidth);
        CheckComArgOutPointerValidThrow(aHeight);
        CheckComArgOutPointerValidThrow(aEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = querySavedGuestScreenInfo(aScreenId,
                                        aOriginX,
                                        aOriginY,
                                        aWidth,
                                        aHeight,
                                        aEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOriginX=%RU32 *aOriginY=%RU32 *aWidth=%RU32 *aHeight=%RU32 *aEnabled=%RTbool hrc=%Rhrc\n", this, "Machine::querySavedGuestScreenInfo", *aOriginX, *aOriginY, *aWidth, *aHeight, *aEnabled, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::QuerySavedThumbnailSize(ULONG aScreenId,
                                                  ULONG *aSize,
                                                  ULONG *aWidth,
                                                  ULONG *aHeight)
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32 aSize=%p aWidth=%p aHeight=%p\n", this, "Machine::querySavedThumbnailSize", aScreenId, aSize, aWidth, aHeight));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSize);
        CheckComArgOutPointerValidThrow(aWidth);
        CheckComArgOutPointerValidThrow(aHeight);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = querySavedThumbnailSize(aScreenId,
                                      aSize,
                                      aWidth,
                                      aHeight);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSize=%RU32 *aWidth=%RU32 *aHeight=%RU32 hrc=%Rhrc\n", this, "Machine::querySavedThumbnailSize", *aSize, *aWidth, *aHeight, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::ReadSavedThumbnailToArray(ULONG aScreenId,
                                                    BOOL aBGR,
                                                    ULONG *aWidth,
                                                    ULONG *aHeight,
                                                    ComSafeArrayOut(BYTE, aData))
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32 aBGR=%RTbool aWidth=%p aHeight=%p aData=%p\n", this, "Machine::readSavedThumbnailToArray", aScreenId, aBGR, aWidth, aHeight, aData));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWidth);
        CheckComArgOutPointerValidThrow(aHeight);
        CheckComArgOutPointerValidThrow(aData);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = readSavedThumbnailToArray(aScreenId,
                                        aBGR,
                                        aWidth,
                                        aHeight,
                                        ArrayOutConverter<BYTE>(ComSafeArrayOutArg(aData)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWidth=%RU32 *aHeight=%RU32 aData=%zu hrc=%Rhrc\n", this, "Machine::readSavedThumbnailToArray", *aWidth, *aHeight, ComSafeArraySize(*aData), hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::ReadSavedThumbnailPNGToArray(ULONG aScreenId,
                                                       ULONG *aWidth,
                                                       ULONG *aHeight,
                                                       ComSafeArrayOut(BYTE, aData))
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32 aWidth=%p aHeight=%p aData=%p\n", this, "Machine::readSavedThumbnailPNGToArray", aScreenId, aWidth, aHeight, aData));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWidth);
        CheckComArgOutPointerValidThrow(aHeight);
        CheckComArgOutPointerValidThrow(aData);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = readSavedThumbnailPNGToArray(aScreenId,
                                           aWidth,
                                           aHeight,
                                           ArrayOutConverter<BYTE>(ComSafeArrayOutArg(aData)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWidth=%RU32 *aHeight=%RU32 aData=%zu hrc=%Rhrc\n", this, "Machine::readSavedThumbnailPNGToArray", *aWidth, *aHeight, ComSafeArraySize(*aData), hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::QuerySavedScreenshotPNGSize(ULONG aScreenId,
                                                      ULONG *aSize,
                                                      ULONG *aWidth,
                                                      ULONG *aHeight)
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32 aSize=%p aWidth=%p aHeight=%p\n", this, "Machine::querySavedScreenshotPNGSize", aScreenId, aSize, aWidth, aHeight));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSize);
        CheckComArgOutPointerValidThrow(aWidth);
        CheckComArgOutPointerValidThrow(aHeight);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = querySavedScreenshotPNGSize(aScreenId,
                                          aSize,
                                          aWidth,
                                          aHeight);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSize=%RU32 *aWidth=%RU32 *aHeight=%RU32 hrc=%Rhrc\n", this, "Machine::querySavedScreenshotPNGSize", *aSize, *aWidth, *aHeight, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::ReadSavedScreenshotPNGToArray(ULONG aScreenId,
                                                        ULONG *aWidth,
                                                        ULONG *aHeight,
                                                        ComSafeArrayOut(BYTE, aData))
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32 aWidth=%p aHeight=%p aData=%p\n", this, "Machine::readSavedScreenshotPNGToArray", aScreenId, aWidth, aHeight, aData));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWidth);
        CheckComArgOutPointerValidThrow(aHeight);
        CheckComArgOutPointerValidThrow(aData);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = readSavedScreenshotPNGToArray(aScreenId,
                                            aWidth,
                                            aHeight,
                                            ArrayOutConverter<BYTE>(ComSafeArrayOutArg(aData)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWidth=%RU32 *aHeight=%RU32 aData=%zu hrc=%Rhrc\n", this, "Machine::readSavedScreenshotPNGToArray", *aWidth, *aHeight, ComSafeArraySize(*aData), hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::HotPlugCPU(ULONG aCpu)
{
    LogRelFlow(("{%p} %s:enter aCpu=%RU32\n", this, "Machine::hotPlugCPU", aCpu));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = hotPlugCPU(aCpu);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::hotPlugCPU", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::HotUnplugCPU(ULONG aCpu)
{
    LogRelFlow(("{%p} %s:enter aCpu=%RU32\n", this, "Machine::hotUnplugCPU", aCpu));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = hotUnplugCPU(aCpu);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Machine::hotUnplugCPU", hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::GetCPUStatus(ULONG aCpu,
                                       BOOL *aAttached)
{
    LogRelFlow(("{%p} %s:enter aCpu=%RU32 aAttached=%p\n", this, "Machine::getCPUStatus", aCpu, aAttached));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAttached);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getCPUStatus(aCpu,
                           aAttached);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aAttached=%RTbool hrc=%Rhrc\n", this, "Machine::getCPUStatus", *aAttached, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::QueryLogFilename(ULONG aIdx,
                                           BSTR *aFilename)
{
    LogRelFlow(("{%p} %s:enter aIdx=%RU32 aFilename=%p\n", this, "Machine::queryLogFilename", aIdx, aFilename));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFilename);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = queryLogFilename(aIdx,
                               BSTROutConverter(aFilename).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aFilename=%ls hrc=%Rhrc\n", this, "Machine::queryLogFilename", *aFilename, hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::ReadLog(ULONG aIdx,
                                  LONG64 aOffset,
                                  LONG64 aSize,
                                  ComSafeArrayOut(BYTE, aData))
{
    LogRelFlow(("{%p} %s:enter aIdx=%RU32 aOffset=%RI64 aSize=%RI64 aData=%p\n", this, "Machine::readLog", aIdx, aOffset, aSize, aData));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aData);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = readLog(aIdx,
                      aOffset,
                      aSize,
                      ArrayOutConverter<BYTE>(ComSafeArrayOutArg(aData)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aData=%zu hrc=%Rhrc\n", this, "Machine::readLog", ComSafeArraySize(*aData), hrc));
    return hrc;
}

STDMETHODIMP MachineWrap::CloneTo(IMachine *aTarget,
                                  CloneMode_T aMode,
                                  ComSafeArrayIn(CloneOptions_T, aOptions),
                                  IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aTarget=%p aMode=%RU32 aOptions=%zu aProgress=%p\n", this, "Machine::cloneTo", aTarget, aMode, aOptions, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = cloneTo(ComTypeInConverter<IMachine>(aTarget).ptr(),
                      aMode,
                      ArrayInConverter<CloneOptions_T>(ComSafeArrayInArg(aOptions)).array(),
                      ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Machine::cloneTo", *aProgress, hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(MachineWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(MachineWrap, IMachine)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "MachineWrap.cpp"

// ##### BEGINFILE "EmulatedUSBWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IEmulatedUSB.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef EmulatedUSBWrap_H_
#define EmulatedUSBWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE EmulatedUSBWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IEmulatedUSB)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(EmulatedUSBWrap, IEmulatedUSB)
    DECLARE_NOT_AGGREGATABLE(EmulatedUSBWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(EmulatedUSBWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IEmulatedUSB)
        COM_INTERFACE_ENTRY2(IDispatch, IEmulatedUSB)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(EmulatedUSBWrap)

    // public IEmulatedUSB properties
    STDMETHOD(COMGETTER(Webcams))(ComSafeArrayOut(BSTR, aWebcams));

    // public IEmulatedUSB methods
    STDMETHOD(WebcamAttach)(IN_BSTR aPath,
                            IN_BSTR aSettings);
    STDMETHOD(WebcamDetach)(IN_BSTR aPath);

private:
    // wrapped IEmulatedUSB properties
    virtual HRESULT getWebcams(std::vector<com::Utf8Str> &aWebcams) = 0;

    // wrapped IEmulatedUSB methods
    virtual HRESULT webcamAttach(const com::Utf8Str &aPath,
                                 const com::Utf8Str &aSettings) = 0;
    virtual HRESULT webcamDetach(const com::Utf8Str &aPath) = 0;
};

#endif // !EmulatedUSBWrap_H_

// ##### ENDFILE "EmulatedUSBWrap.h"

// ##### BEGINFILE "EmulatedUSBWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IEmulatedUSB.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_EMULATEDUSB

#include "EmulatedUSBWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(EmulatedUSBWrap)

//
// IEmulatedUSB properties
//

STDMETHODIMP EmulatedUSBWrap::COMGETTER(Webcams)(ComSafeArrayOut(BSTR, aWebcams))
{
    LogRelFlow(("{%p} %s: enter aWebcams=%p\n", this, "EmulatedUSB::getWebcams", aWebcams));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWebcams);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWebcams(ArrayBSTROutConverter(ComSafeArrayOutArg(aWebcams)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWebcams=%zu hrc=%Rhrc\n", this, "EmulatedUSB::getWebcams", ComSafeArraySize(*aWebcams), hrc));
    return hrc;
}

//
// IEmulatedUSB methods
//

STDMETHODIMP EmulatedUSBWrap::WebcamAttach(IN_BSTR aPath,
                                           IN_BSTR aSettings)
{
    LogRelFlow(("{%p} %s:enter aPath=%ls aSettings=%ls\n", this, "EmulatedUSB::webcamAttach", aPath, aSettings));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = webcamAttach(BSTRInConverter(aPath).str(),
                           BSTRInConverter(aSettings).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "EmulatedUSB::webcamAttach", hrc));
    return hrc;
}

STDMETHODIMP EmulatedUSBWrap::WebcamDetach(IN_BSTR aPath)
{
    LogRelFlow(("{%p} %s:enter aPath=%ls\n", this, "EmulatedUSB::webcamDetach", aPath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = webcamDetach(BSTRInConverter(aPath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "EmulatedUSB::webcamDetach", hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(EmulatedUSBWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(EmulatedUSBWrap, IEmulatedUSB)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "EmulatedUSBWrap.cpp"

// ##### BEGINFILE "VRDEServerInfoWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IVRDEServerInfo.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef VRDEServerInfoWrap_H_
#define VRDEServerInfoWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE VRDEServerInfoWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IVRDEServerInfo)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(VRDEServerInfoWrap, IVRDEServerInfo)
    DECLARE_NOT_AGGREGATABLE(VRDEServerInfoWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(VRDEServerInfoWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IVRDEServerInfo)
        COM_INTERFACE_ENTRY2(IDispatch, IVRDEServerInfo)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(VRDEServerInfoWrap)

    // public IVRDEServerInfo properties
    STDMETHOD(COMGETTER(Active))(BOOL *aActive);
    STDMETHOD(COMGETTER(Port))(LONG *aPort);
    STDMETHOD(COMGETTER(NumberOfClients))(ULONG *aNumberOfClients);
    STDMETHOD(COMGETTER(BeginTime))(LONG64 *aBeginTime);
    STDMETHOD(COMGETTER(EndTime))(LONG64 *aEndTime);
    STDMETHOD(COMGETTER(BytesSent))(LONG64 *aBytesSent);
    STDMETHOD(COMGETTER(BytesSentTotal))(LONG64 *aBytesSentTotal);
    STDMETHOD(COMGETTER(BytesReceived))(LONG64 *aBytesReceived);
    STDMETHOD(COMGETTER(BytesReceivedTotal))(LONG64 *aBytesReceivedTotal);
    STDMETHOD(COMGETTER(User))(BSTR *aUser);
    STDMETHOD(COMGETTER(Domain))(BSTR *aDomain);
    STDMETHOD(COMGETTER(ClientName))(BSTR *aClientName);
    STDMETHOD(COMGETTER(ClientIP))(BSTR *aClientIP);
    STDMETHOD(COMGETTER(ClientVersion))(ULONG *aClientVersion);
    STDMETHOD(COMGETTER(EncryptionStyle))(ULONG *aEncryptionStyle);

    // public IVRDEServerInfo methods

private:
    // wrapped IVRDEServerInfo properties
    virtual HRESULT getActive(BOOL *aActive) = 0;
    virtual HRESULT getPort(LONG *aPort) = 0;
    virtual HRESULT getNumberOfClients(ULONG *aNumberOfClients) = 0;
    virtual HRESULT getBeginTime(LONG64 *aBeginTime) = 0;
    virtual HRESULT getEndTime(LONG64 *aEndTime) = 0;
    virtual HRESULT getBytesSent(LONG64 *aBytesSent) = 0;
    virtual HRESULT getBytesSentTotal(LONG64 *aBytesSentTotal) = 0;
    virtual HRESULT getBytesReceived(LONG64 *aBytesReceived) = 0;
    virtual HRESULT getBytesReceivedTotal(LONG64 *aBytesReceivedTotal) = 0;
    virtual HRESULT getUser(com::Utf8Str &aUser) = 0;
    virtual HRESULT getDomain(com::Utf8Str &aDomain) = 0;
    virtual HRESULT getClientName(com::Utf8Str &aClientName) = 0;
    virtual HRESULT getClientIP(com::Utf8Str &aClientIP) = 0;
    virtual HRESULT getClientVersion(ULONG *aClientVersion) = 0;
    virtual HRESULT getEncryptionStyle(ULONG *aEncryptionStyle) = 0;

    // wrapped IVRDEServerInfo methods
};

#endif // !VRDEServerInfoWrap_H_

// ##### ENDFILE "VRDEServerInfoWrap.h"

// ##### BEGINFILE "VRDEServerInfoWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IVRDEServerInfo.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_VRDESERVERINFO

#include "VRDEServerInfoWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(VRDEServerInfoWrap)

//
// IVRDEServerInfo properties
//

STDMETHODIMP VRDEServerInfoWrap::COMGETTER(Active)(BOOL *aActive)
{
    LogRelFlow(("{%p} %s: enter aActive=%p\n", this, "VRDEServerInfo::getActive", aActive));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aActive);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getActive(aActive);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aActive=%RTbool hrc=%Rhrc\n", this, "VRDEServerInfo::getActive", *aActive, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerInfoWrap::COMGETTER(Port)(LONG *aPort)
{
    LogRelFlow(("{%p} %s: enter aPort=%p\n", this, "VRDEServerInfo::getPort", aPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPort);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPort(aPort);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPort=%RI32 hrc=%Rhrc\n", this, "VRDEServerInfo::getPort", *aPort, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerInfoWrap::COMGETTER(NumberOfClients)(ULONG *aNumberOfClients)
{
    LogRelFlow(("{%p} %s: enter aNumberOfClients=%p\n", this, "VRDEServerInfo::getNumberOfClients", aNumberOfClients));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNumberOfClients);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNumberOfClients(aNumberOfClients);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNumberOfClients=%RU32 hrc=%Rhrc\n", this, "VRDEServerInfo::getNumberOfClients", *aNumberOfClients, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerInfoWrap::COMGETTER(BeginTime)(LONG64 *aBeginTime)
{
    LogRelFlow(("{%p} %s: enter aBeginTime=%p\n", this, "VRDEServerInfo::getBeginTime", aBeginTime));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBeginTime);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBeginTime(aBeginTime);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBeginTime=%RI64 hrc=%Rhrc\n", this, "VRDEServerInfo::getBeginTime", *aBeginTime, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerInfoWrap::COMGETTER(EndTime)(LONG64 *aEndTime)
{
    LogRelFlow(("{%p} %s: enter aEndTime=%p\n", this, "VRDEServerInfo::getEndTime", aEndTime));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEndTime);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEndTime(aEndTime);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEndTime=%RI64 hrc=%Rhrc\n", this, "VRDEServerInfo::getEndTime", *aEndTime, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerInfoWrap::COMGETTER(BytesSent)(LONG64 *aBytesSent)
{
    LogRelFlow(("{%p} %s: enter aBytesSent=%p\n", this, "VRDEServerInfo::getBytesSent", aBytesSent));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBytesSent);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBytesSent(aBytesSent);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBytesSent=%RI64 hrc=%Rhrc\n", this, "VRDEServerInfo::getBytesSent", *aBytesSent, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerInfoWrap::COMGETTER(BytesSentTotal)(LONG64 *aBytesSentTotal)
{
    LogRelFlow(("{%p} %s: enter aBytesSentTotal=%p\n", this, "VRDEServerInfo::getBytesSentTotal", aBytesSentTotal));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBytesSentTotal);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBytesSentTotal(aBytesSentTotal);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBytesSentTotal=%RI64 hrc=%Rhrc\n", this, "VRDEServerInfo::getBytesSentTotal", *aBytesSentTotal, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerInfoWrap::COMGETTER(BytesReceived)(LONG64 *aBytesReceived)
{
    LogRelFlow(("{%p} %s: enter aBytesReceived=%p\n", this, "VRDEServerInfo::getBytesReceived", aBytesReceived));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBytesReceived);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBytesReceived(aBytesReceived);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBytesReceived=%RI64 hrc=%Rhrc\n", this, "VRDEServerInfo::getBytesReceived", *aBytesReceived, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerInfoWrap::COMGETTER(BytesReceivedTotal)(LONG64 *aBytesReceivedTotal)
{
    LogRelFlow(("{%p} %s: enter aBytesReceivedTotal=%p\n", this, "VRDEServerInfo::getBytesReceivedTotal", aBytesReceivedTotal));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBytesReceivedTotal);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBytesReceivedTotal(aBytesReceivedTotal);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBytesReceivedTotal=%RI64 hrc=%Rhrc\n", this, "VRDEServerInfo::getBytesReceivedTotal", *aBytesReceivedTotal, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerInfoWrap::COMGETTER(User)(BSTR *aUser)
{
    LogRelFlow(("{%p} %s: enter aUser=%p\n", this, "VRDEServerInfo::getUser", aUser));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUser);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUser(BSTROutConverter(aUser).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUser=%ls hrc=%Rhrc\n", this, "VRDEServerInfo::getUser", *aUser, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerInfoWrap::COMGETTER(Domain)(BSTR *aDomain)
{
    LogRelFlow(("{%p} %s: enter aDomain=%p\n", this, "VRDEServerInfo::getDomain", aDomain));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDomain);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDomain(BSTROutConverter(aDomain).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDomain=%ls hrc=%Rhrc\n", this, "VRDEServerInfo::getDomain", *aDomain, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerInfoWrap::COMGETTER(ClientName)(BSTR *aClientName)
{
    LogRelFlow(("{%p} %s: enter aClientName=%p\n", this, "VRDEServerInfo::getClientName", aClientName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aClientName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getClientName(BSTROutConverter(aClientName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aClientName=%ls hrc=%Rhrc\n", this, "VRDEServerInfo::getClientName", *aClientName, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerInfoWrap::COMGETTER(ClientIP)(BSTR *aClientIP)
{
    LogRelFlow(("{%p} %s: enter aClientIP=%p\n", this, "VRDEServerInfo::getClientIP", aClientIP));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aClientIP);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getClientIP(BSTROutConverter(aClientIP).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aClientIP=%ls hrc=%Rhrc\n", this, "VRDEServerInfo::getClientIP", *aClientIP, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerInfoWrap::COMGETTER(ClientVersion)(ULONG *aClientVersion)
{
    LogRelFlow(("{%p} %s: enter aClientVersion=%p\n", this, "VRDEServerInfo::getClientVersion", aClientVersion));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aClientVersion);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getClientVersion(aClientVersion);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aClientVersion=%RU32 hrc=%Rhrc\n", this, "VRDEServerInfo::getClientVersion", *aClientVersion, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerInfoWrap::COMGETTER(EncryptionStyle)(ULONG *aEncryptionStyle)
{
    LogRelFlow(("{%p} %s: enter aEncryptionStyle=%p\n", this, "VRDEServerInfo::getEncryptionStyle", aEncryptionStyle));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEncryptionStyle);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEncryptionStyle(aEncryptionStyle);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEncryptionStyle=%RU32 hrc=%Rhrc\n", this, "VRDEServerInfo::getEncryptionStyle", *aEncryptionStyle, hrc));
    return hrc;
}

//
// IVRDEServerInfo methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(VRDEServerInfoWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(VRDEServerInfoWrap, IVRDEServerInfo)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "VRDEServerInfoWrap.cpp"

// ##### BEGINFILE "ConsoleWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IConsole.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef ConsoleWrap_H_
#define ConsoleWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE ConsoleWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IConsole)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(ConsoleWrap, IConsole)
    DECLARE_NOT_AGGREGATABLE(ConsoleWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(ConsoleWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IConsole)
        COM_INTERFACE_ENTRY2(IDispatch, IConsole)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(ConsoleWrap)

    // public IConsole properties
    STDMETHOD(COMGETTER(Machine))(IMachine **aMachine);
    STDMETHOD(COMGETTER(State))(MachineState_T *aState);
    STDMETHOD(COMGETTER(Guest))(IGuest **aGuest);
    STDMETHOD(COMGETTER(Keyboard))(IKeyboard **aKeyboard);
    STDMETHOD(COMGETTER(Mouse))(IMouse **aMouse);
    STDMETHOD(COMGETTER(Display))(IDisplay **aDisplay);
    STDMETHOD(COMGETTER(Debugger))(IMachineDebugger **aDebugger);
    STDMETHOD(COMGETTER(USBDevices))(ComSafeArrayOut(IUSBDevice *, aUSBDevices));
    STDMETHOD(COMGETTER(RemoteUSBDevices))(ComSafeArrayOut(IHostUSBDevice *, aRemoteUSBDevices));
    STDMETHOD(COMGETTER(SharedFolders))(ComSafeArrayOut(ISharedFolder *, aSharedFolders));
    STDMETHOD(COMGETTER(VRDEServerInfo))(IVRDEServerInfo **aVRDEServerInfo);
    STDMETHOD(COMGETTER(EventSource))(IEventSource **aEventSource);
    STDMETHOD(COMGETTER(AttachedPCIDevices))(ComSafeArrayOut(IPCIDeviceAttachment *, aAttachedPCIDevices));
    STDMETHOD(COMGETTER(UseHostClipboard))(BOOL *aUseHostClipboard);
    STDMETHOD(COMSETTER(UseHostClipboard))(BOOL aUseHostClipboard);
    STDMETHOD(COMGETTER(EmulatedUSB))(IEmulatedUSB **aEmulatedUSB);

    // public IConsole methods
    STDMETHOD(PowerUp)(IProgress **aProgress);
    STDMETHOD(PowerUpPaused)(IProgress **aProgress);
    STDMETHOD(PowerDown)(IProgress **aProgress);
    STDMETHOD(Reset)();
    STDMETHOD(Pause)();
    STDMETHOD(Resume)();
    STDMETHOD(PowerButton)();
    STDMETHOD(SleepButton)();
    STDMETHOD(GetPowerButtonHandled)(BOOL *aHandled);
    STDMETHOD(GetGuestEnteredACPIMode)(BOOL *aEntered);
    STDMETHOD(SaveState)(IProgress **aProgress);
    STDMETHOD(AdoptSavedState)(IN_BSTR aSavedStateFile);
    STDMETHOD(DiscardSavedState)(BOOL aFRemoveFile);
    STDMETHOD(GetDeviceActivity)(DeviceType_T aType,
                                 DeviceActivity_T *aActivity);
    STDMETHOD(AttachUSBDevice)(IN_BSTR aId);
    STDMETHOD(DetachUSBDevice)(IN_BSTR aId,
                               IUSBDevice **aDevice);
    STDMETHOD(FindUSBDeviceByAddress)(IN_BSTR aName,
                                      IUSBDevice **aDevice);
    STDMETHOD(FindUSBDeviceById)(IN_BSTR aId,
                                 IUSBDevice **aDevice);
    STDMETHOD(CreateSharedFolder)(IN_BSTR aName,
                                  IN_BSTR aHostPath,
                                  BOOL aWritable,
                                  BOOL aAutomount);
    STDMETHOD(RemoveSharedFolder)(IN_BSTR aName);
    STDMETHOD(TakeSnapshot)(IN_BSTR aName,
                            IN_BSTR aDescription,
                            IProgress **aProgress);
    STDMETHOD(DeleteSnapshot)(IN_BSTR aId,
                              IProgress **aProgress);
    STDMETHOD(DeleteSnapshotAndAllChildren)(IN_BSTR aId,
                                            IProgress **aProgress);
    STDMETHOD(DeleteSnapshotRange)(IN_BSTR aStartId,
                                   IN_BSTR aEndId,
                                   IProgress **aProgress);
    STDMETHOD(RestoreSnapshot)(ISnapshot *aSnapshot,
                               IProgress **aProgress);
    STDMETHOD(Teleport)(IN_BSTR aHostname,
                        ULONG aTcpport,
                        IN_BSTR aPassword,
                        ULONG aMaxDowntime,
                        IProgress **aProgress);

private:
    // wrapped IConsole properties
    virtual HRESULT getMachine(ComPtr<IMachine> &aMachine) = 0;
    virtual HRESULT getState(MachineState_T *aState) = 0;
    virtual HRESULT getGuest(ComPtr<IGuest> &aGuest) = 0;
    virtual HRESULT getKeyboard(ComPtr<IKeyboard> &aKeyboard) = 0;
    virtual HRESULT getMouse(ComPtr<IMouse> &aMouse) = 0;
    virtual HRESULT getDisplay(ComPtr<IDisplay> &aDisplay) = 0;
    virtual HRESULT getDebugger(ComPtr<IMachineDebugger> &aDebugger) = 0;
    virtual HRESULT getUSBDevices(std::vector<ComPtr<IUSBDevice> > &aUSBDevices) = 0;
    virtual HRESULT getRemoteUSBDevices(std::vector<ComPtr<IHostUSBDevice> > &aRemoteUSBDevices) = 0;
    virtual HRESULT getSharedFolders(std::vector<ComPtr<ISharedFolder> > &aSharedFolders) = 0;
    virtual HRESULT getVRDEServerInfo(ComPtr<IVRDEServerInfo> &aVRDEServerInfo) = 0;
    virtual HRESULT getEventSource(ComPtr<IEventSource> &aEventSource) = 0;
    virtual HRESULT getAttachedPCIDevices(std::vector<ComPtr<IPCIDeviceAttachment> > &aAttachedPCIDevices) = 0;
    virtual HRESULT getUseHostClipboard(BOOL *aUseHostClipboard) = 0;
    virtual HRESULT setUseHostClipboard(BOOL aUseHostClipboard) = 0;
    virtual HRESULT getEmulatedUSB(ComPtr<IEmulatedUSB> &aEmulatedUSB) = 0;

    // wrapped IConsole methods
    virtual HRESULT powerUp(ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT powerUpPaused(ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT powerDown(ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT reset() = 0;
    virtual HRESULT pause() = 0;
    virtual HRESULT resume() = 0;
    virtual HRESULT powerButton() = 0;
    virtual HRESULT sleepButton() = 0;
    virtual HRESULT getPowerButtonHandled(BOOL *aHandled) = 0;
    virtual HRESULT getGuestEnteredACPIMode(BOOL *aEntered) = 0;
    virtual HRESULT saveState(ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT adoptSavedState(const com::Utf8Str &aSavedStateFile) = 0;
    virtual HRESULT discardSavedState(BOOL aFRemoveFile) = 0;
    virtual HRESULT getDeviceActivity(DeviceType_T aType,
                                      DeviceActivity_T *aActivity) = 0;
    virtual HRESULT attachUSBDevice(const com::Guid &aId) = 0;
    virtual HRESULT detachUSBDevice(const com::Guid &aId,
                                    ComPtr<IUSBDevice> &aDevice) = 0;
    virtual HRESULT findUSBDeviceByAddress(const com::Utf8Str &aName,
                                           ComPtr<IUSBDevice> &aDevice) = 0;
    virtual HRESULT findUSBDeviceById(const com::Guid &aId,
                                      ComPtr<IUSBDevice> &aDevice) = 0;
    virtual HRESULT createSharedFolder(const com::Utf8Str &aName,
                                       const com::Utf8Str &aHostPath,
                                       BOOL aWritable,
                                       BOOL aAutomount) = 0;
    virtual HRESULT removeSharedFolder(const com::Utf8Str &aName) = 0;
    virtual HRESULT takeSnapshot(const com::Utf8Str &aName,
                                 const com::Utf8Str &aDescription,
                                 ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT deleteSnapshot(const com::Guid &aId,
                                   ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT deleteSnapshotAndAllChildren(const com::Guid &aId,
                                                 ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT deleteSnapshotRange(const com::Guid &aStartId,
                                        const com::Guid &aEndId,
                                        ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT restoreSnapshot(const ComPtr<ISnapshot> &aSnapshot,
                                    ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT teleport(const com::Utf8Str &aHostname,
                             ULONG aTcpport,
                             const com::Utf8Str &aPassword,
                             ULONG aMaxDowntime,
                             ComPtr<IProgress> &aProgress) = 0;
};

#endif // !ConsoleWrap_H_

// ##### ENDFILE "ConsoleWrap.h"

// ##### BEGINFILE "ConsoleWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IConsole.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_CONSOLE

#include "ConsoleWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(ConsoleWrap)

//
// IConsole properties
//

STDMETHODIMP ConsoleWrap::COMGETTER(Machine)(IMachine **aMachine)
{
    LogRelFlow(("{%p} %s: enter aMachine=%p\n", this, "Console::getMachine", aMachine));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachine);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachine(ComTypeOutConverter<IMachine>(aMachine).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachine=%p hrc=%Rhrc\n", this, "Console::getMachine", *aMachine, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::COMGETTER(State)(MachineState_T *aState)
{
    LogRelFlow(("{%p} %s: enter aState=%p\n", this, "Console::getState", aState));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aState);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getState(aState);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aState=%RU32 hrc=%Rhrc\n", this, "Console::getState", *aState, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::COMGETTER(Guest)(IGuest **aGuest)
{
    LogRelFlow(("{%p} %s: enter aGuest=%p\n", this, "Console::getGuest", aGuest));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGuest);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGuest(ComTypeOutConverter<IGuest>(aGuest).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGuest=%p hrc=%Rhrc\n", this, "Console::getGuest", *aGuest, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::COMGETTER(Keyboard)(IKeyboard **aKeyboard)
{
    LogRelFlow(("{%p} %s: enter aKeyboard=%p\n", this, "Console::getKeyboard", aKeyboard));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aKeyboard);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getKeyboard(ComTypeOutConverter<IKeyboard>(aKeyboard).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aKeyboard=%p hrc=%Rhrc\n", this, "Console::getKeyboard", *aKeyboard, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::COMGETTER(Mouse)(IMouse **aMouse)
{
    LogRelFlow(("{%p} %s: enter aMouse=%p\n", this, "Console::getMouse", aMouse));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMouse);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMouse(ComTypeOutConverter<IMouse>(aMouse).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMouse=%p hrc=%Rhrc\n", this, "Console::getMouse", *aMouse, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::COMGETTER(Display)(IDisplay **aDisplay)
{
    LogRelFlow(("{%p} %s: enter aDisplay=%p\n", this, "Console::getDisplay", aDisplay));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDisplay);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDisplay(ComTypeOutConverter<IDisplay>(aDisplay).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDisplay=%p hrc=%Rhrc\n", this, "Console::getDisplay", *aDisplay, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::COMGETTER(Debugger)(IMachineDebugger **aDebugger)
{
    LogRelFlow(("{%p} %s: enter aDebugger=%p\n", this, "Console::getDebugger", aDebugger));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDebugger);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDebugger(ComTypeOutConverter<IMachineDebugger>(aDebugger).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDebugger=%p hrc=%Rhrc\n", this, "Console::getDebugger", *aDebugger, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::COMGETTER(USBDevices)(ComSafeArrayOut(IUSBDevice *, aUSBDevices))
{
    LogRelFlow(("{%p} %s: enter aUSBDevices=%p\n", this, "Console::getUSBDevices", aUSBDevices));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUSBDevices);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUSBDevices(ArrayComTypeOutConverter<IUSBDevice>(ComSafeArrayOutArg(aUSBDevices)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUSBDevices=%zu hrc=%Rhrc\n", this, "Console::getUSBDevices", ComSafeArraySize(*aUSBDevices), hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::COMGETTER(RemoteUSBDevices)(ComSafeArrayOut(IHostUSBDevice *, aRemoteUSBDevices))
{
    LogRelFlow(("{%p} %s: enter aRemoteUSBDevices=%p\n", this, "Console::getRemoteUSBDevices", aRemoteUSBDevices));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRemoteUSBDevices);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRemoteUSBDevices(ArrayComTypeOutConverter<IHostUSBDevice>(ComSafeArrayOutArg(aRemoteUSBDevices)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRemoteUSBDevices=%zu hrc=%Rhrc\n", this, "Console::getRemoteUSBDevices", ComSafeArraySize(*aRemoteUSBDevices), hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::COMGETTER(SharedFolders)(ComSafeArrayOut(ISharedFolder *, aSharedFolders))
{
    LogRelFlow(("{%p} %s: enter aSharedFolders=%p\n", this, "Console::getSharedFolders", aSharedFolders));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSharedFolders);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSharedFolders(ArrayComTypeOutConverter<ISharedFolder>(ComSafeArrayOutArg(aSharedFolders)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSharedFolders=%zu hrc=%Rhrc\n", this, "Console::getSharedFolders", ComSafeArraySize(*aSharedFolders), hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::COMGETTER(VRDEServerInfo)(IVRDEServerInfo **aVRDEServerInfo)
{
    LogRelFlow(("{%p} %s: enter aVRDEServerInfo=%p\n", this, "Console::getVRDEServerInfo", aVRDEServerInfo));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVRDEServerInfo);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVRDEServerInfo(ComTypeOutConverter<IVRDEServerInfo>(aVRDEServerInfo).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVRDEServerInfo=%p hrc=%Rhrc\n", this, "Console::getVRDEServerInfo", *aVRDEServerInfo, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::COMGETTER(EventSource)(IEventSource **aEventSource)
{
    LogRelFlow(("{%p} %s: enter aEventSource=%p\n", this, "Console::getEventSource", aEventSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEventSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEventSource(ComTypeOutConverter<IEventSource>(aEventSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEventSource=%p hrc=%Rhrc\n", this, "Console::getEventSource", *aEventSource, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::COMGETTER(AttachedPCIDevices)(ComSafeArrayOut(IPCIDeviceAttachment *, aAttachedPCIDevices))
{
    LogRelFlow(("{%p} %s: enter aAttachedPCIDevices=%p\n", this, "Console::getAttachedPCIDevices", aAttachedPCIDevices));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAttachedPCIDevices);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAttachedPCIDevices(ArrayComTypeOutConverter<IPCIDeviceAttachment>(ComSafeArrayOutArg(aAttachedPCIDevices)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAttachedPCIDevices=%zu hrc=%Rhrc\n", this, "Console::getAttachedPCIDevices", ComSafeArraySize(*aAttachedPCIDevices), hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::COMGETTER(UseHostClipboard)(BOOL *aUseHostClipboard)
{
    LogRelFlow(("{%p} %s: enter aUseHostClipboard=%p\n", this, "Console::getUseHostClipboard", aUseHostClipboard));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUseHostClipboard);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUseHostClipboard(aUseHostClipboard);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUseHostClipboard=%RTbool hrc=%Rhrc\n", this, "Console::getUseHostClipboard", *aUseHostClipboard, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::COMSETTER(UseHostClipboard)(BOOL aUseHostClipboard)
{
    LogRelFlow(("{%p} %s: enter aUseHostClipboard=%RTbool\n", this, "Console::setUseHostClipboard", aUseHostClipboard));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setUseHostClipboard(aUseHostClipboard);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Console::setUseHostClipboard", hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::COMGETTER(EmulatedUSB)(IEmulatedUSB **aEmulatedUSB)
{
    LogRelFlow(("{%p} %s: enter aEmulatedUSB=%p\n", this, "Console::getEmulatedUSB", aEmulatedUSB));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEmulatedUSB);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEmulatedUSB(ComTypeOutConverter<IEmulatedUSB>(aEmulatedUSB).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEmulatedUSB=%p hrc=%Rhrc\n", this, "Console::getEmulatedUSB", *aEmulatedUSB, hrc));
    return hrc;
}

//
// IConsole methods
//

STDMETHODIMP ConsoleWrap::PowerUp(IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aProgress=%p\n", this, "Console::powerUp", aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = powerUp(ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Console::powerUp", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::PowerUpPaused(IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aProgress=%p\n", this, "Console::powerUpPaused", aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = powerUpPaused(ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Console::powerUpPaused", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::PowerDown(IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aProgress=%p\n", this, "Console::powerDown", aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = powerDown(ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Console::powerDown", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::Reset()
{
    LogRelFlow(("{%p} %s:enter\n", this, "Console::reset"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = reset();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Console::reset", hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::Pause()
{
    LogRelFlow(("{%p} %s:enter\n", this, "Console::pause"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = pause();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Console::pause", hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::Resume()
{
    LogRelFlow(("{%p} %s:enter\n", this, "Console::resume"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = resume();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Console::resume", hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::PowerButton()
{
    LogRelFlow(("{%p} %s:enter\n", this, "Console::powerButton"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = powerButton();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Console::powerButton", hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::SleepButton()
{
    LogRelFlow(("{%p} %s:enter\n", this, "Console::sleepButton"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = sleepButton();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Console::sleepButton", hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::GetPowerButtonHandled(BOOL *aHandled)
{
    LogRelFlow(("{%p} %s:enter aHandled=%p\n", this, "Console::getPowerButtonHandled", aHandled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHandled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPowerButtonHandled(aHandled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aHandled=%RTbool hrc=%Rhrc\n", this, "Console::getPowerButtonHandled", *aHandled, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::GetGuestEnteredACPIMode(BOOL *aEntered)
{
    LogRelFlow(("{%p} %s:enter aEntered=%p\n", this, "Console::getGuestEnteredACPIMode", aEntered));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEntered);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGuestEnteredACPIMode(aEntered);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aEntered=%RTbool hrc=%Rhrc\n", this, "Console::getGuestEnteredACPIMode", *aEntered, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::SaveState(IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aProgress=%p\n", this, "Console::saveState", aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = saveState(ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Console::saveState", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::AdoptSavedState(IN_BSTR aSavedStateFile)
{
    LogRelFlow(("{%p} %s:enter aSavedStateFile=%ls\n", this, "Console::adoptSavedState", aSavedStateFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = adoptSavedState(BSTRInConverter(aSavedStateFile).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Console::adoptSavedState", hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::DiscardSavedState(BOOL aFRemoveFile)
{
    LogRelFlow(("{%p} %s:enter aFRemoveFile=%RTbool\n", this, "Console::discardSavedState", aFRemoveFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = discardSavedState(aFRemoveFile);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Console::discardSavedState", hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::GetDeviceActivity(DeviceType_T aType,
                                            DeviceActivity_T *aActivity)
{
    LogRelFlow(("{%p} %s:enter aType=%RU32 aActivity=%p\n", this, "Console::getDeviceActivity", aType, aActivity));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aActivity);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDeviceActivity(aType,
                                aActivity);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aActivity=%RU32 hrc=%Rhrc\n", this, "Console::getDeviceActivity", *aActivity, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::AttachUSBDevice(IN_BSTR aId)
{
    LogRelFlow(("{%p} %s:enter aId=%ls\n", this, "Console::attachUSBDevice", aId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = attachUSBDevice(UuidInConverter(aId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Console::attachUSBDevice", hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::DetachUSBDevice(IN_BSTR aId,
                                          IUSBDevice **aDevice)
{
    LogRelFlow(("{%p} %s:enter aId=%ls aDevice=%p\n", this, "Console::detachUSBDevice", aId, aDevice));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDevice);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = detachUSBDevice(UuidInConverter(aId).uuid(),
                              ComTypeOutConverter<IUSBDevice>(aDevice).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aDevice=%p hrc=%Rhrc\n", this, "Console::detachUSBDevice", *aDevice, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::FindUSBDeviceByAddress(IN_BSTR aName,
                                                 IUSBDevice **aDevice)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aDevice=%p\n", this, "Console::findUSBDeviceByAddress", aName, aDevice));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDevice);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = findUSBDeviceByAddress(BSTRInConverter(aName).str(),
                                     ComTypeOutConverter<IUSBDevice>(aDevice).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aDevice=%p hrc=%Rhrc\n", this, "Console::findUSBDeviceByAddress", *aDevice, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::FindUSBDeviceById(IN_BSTR aId,
                                            IUSBDevice **aDevice)
{
    LogRelFlow(("{%p} %s:enter aId=%ls aDevice=%p\n", this, "Console::findUSBDeviceById", aId, aDevice));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDevice);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = findUSBDeviceById(UuidInConverter(aId).uuid(),
                                ComTypeOutConverter<IUSBDevice>(aDevice).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aDevice=%p hrc=%Rhrc\n", this, "Console::findUSBDeviceById", *aDevice, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::CreateSharedFolder(IN_BSTR aName,
                                             IN_BSTR aHostPath,
                                             BOOL aWritable,
                                             BOOL aAutomount)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aHostPath=%ls aWritable=%RTbool aAutomount=%RTbool\n", this, "Console::createSharedFolder", aName, aHostPath, aWritable, aAutomount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = createSharedFolder(BSTRInConverter(aName).str(),
                                 BSTRInConverter(aHostPath).str(),
                                 aWritable,
                                 aAutomount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Console::createSharedFolder", hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::RemoveSharedFolder(IN_BSTR aName)
{
    LogRelFlow(("{%p} %s:enter aName=%ls\n", this, "Console::removeSharedFolder", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = removeSharedFolder(BSTRInConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Console::removeSharedFolder", hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::TakeSnapshot(IN_BSTR aName,
                                       IN_BSTR aDescription,
                                       IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aDescription=%ls aProgress=%p\n", this, "Console::takeSnapshot", aName, aDescription, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = takeSnapshot(BSTRInConverter(aName).str(),
                           BSTRInConverter(aDescription).str(),
                           ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Console::takeSnapshot", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::DeleteSnapshot(IN_BSTR aId,
                                         IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aId=%ls aProgress=%p\n", this, "Console::deleteSnapshot", aId, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = deleteSnapshot(UuidInConverter(aId).uuid(),
                             ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Console::deleteSnapshot", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::DeleteSnapshotAndAllChildren(IN_BSTR aId,
                                                       IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aId=%ls aProgress=%p\n", this, "Console::deleteSnapshotAndAllChildren", aId, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = deleteSnapshotAndAllChildren(UuidInConverter(aId).uuid(),
                                           ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Console::deleteSnapshotAndAllChildren", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::DeleteSnapshotRange(IN_BSTR aStartId,
                                              IN_BSTR aEndId,
                                              IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aStartId=%ls aEndId=%ls aProgress=%p\n", this, "Console::deleteSnapshotRange", aStartId, aEndId, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = deleteSnapshotRange(UuidInConverter(aStartId).uuid(),
                                  UuidInConverter(aEndId).uuid(),
                                  ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Console::deleteSnapshotRange", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::RestoreSnapshot(ISnapshot *aSnapshot,
                                          IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aSnapshot=%p aProgress=%p\n", this, "Console::restoreSnapshot", aSnapshot, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = restoreSnapshot(ComTypeInConverter<ISnapshot>(aSnapshot).ptr(),
                              ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Console::restoreSnapshot", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP ConsoleWrap::Teleport(IN_BSTR aHostname,
                                   ULONG aTcpport,
                                   IN_BSTR aPassword,
                                   ULONG aMaxDowntime,
                                   IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aHostname=%ls aTcpport=%RU32 aPassword=%ls aMaxDowntime=%RU32 aProgress=%p\n", this, "Console::teleport", aHostname, aTcpport, aPassword, aMaxDowntime, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = teleport(BSTRInConverter(aHostname).str(),
                       aTcpport,
                       BSTRInConverter(aPassword).str(),
                       aMaxDowntime,
                       ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Console::teleport", *aProgress, hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(ConsoleWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(ConsoleWrap, IConsole)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "ConsoleWrap.cpp"

// ##### BEGINFILE "HostNetworkInterfaceWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IHostNetworkInterface.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef HostNetworkInterfaceWrap_H_
#define HostNetworkInterfaceWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE HostNetworkInterfaceWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IHostNetworkInterface)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(HostNetworkInterfaceWrap, IHostNetworkInterface)
    DECLARE_NOT_AGGREGATABLE(HostNetworkInterfaceWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(HostNetworkInterfaceWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IHostNetworkInterface)
        COM_INTERFACE_ENTRY2(IDispatch, IHostNetworkInterface)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(HostNetworkInterfaceWrap)

    // public IHostNetworkInterface properties
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(ShortName))(BSTR *aShortName);
    STDMETHOD(COMGETTER(Id))(BSTR *aId);
    STDMETHOD(COMGETTER(NetworkName))(BSTR *aNetworkName);
    STDMETHOD(COMGETTER(DHCPEnabled))(BOOL *aDHCPEnabled);
    STDMETHOD(COMGETTER(IPAddress))(BSTR *aIPAddress);
    STDMETHOD(COMGETTER(NetworkMask))(BSTR *aNetworkMask);
    STDMETHOD(COMGETTER(IPV6Supported))(BOOL *aIPV6Supported);
    STDMETHOD(COMGETTER(IPV6Address))(BSTR *aIPV6Address);
    STDMETHOD(COMGETTER(IPV6NetworkMaskPrefixLength))(ULONG *aIPV6NetworkMaskPrefixLength);
    STDMETHOD(COMGETTER(HardwareAddress))(BSTR *aHardwareAddress);
    STDMETHOD(COMGETTER(MediumType))(HostNetworkInterfaceMediumType_T *aMediumType);
    STDMETHOD(COMGETTER(Status))(HostNetworkInterfaceStatus_T *aStatus);
    STDMETHOD(COMGETTER(InterfaceType))(HostNetworkInterfaceType_T *aInterfaceType);

    // public IHostNetworkInterface methods
    STDMETHOD(EnableStaticIPConfig)(IN_BSTR aIPAddress,
                                    IN_BSTR aNetworkMask);
    STDMETHOD(EnableStaticIPConfigV6)(IN_BSTR aIPV6Address,
                                      ULONG aIPV6NetworkMaskPrefixLength);
    STDMETHOD(EnableDynamicIPConfig)();
    STDMETHOD(DHCPRediscover)();

private:
    // wrapped IHostNetworkInterface properties
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getShortName(com::Utf8Str &aShortName) = 0;
    virtual HRESULT getId(com::Guid &aId) = 0;
    virtual HRESULT getNetworkName(com::Utf8Str &aNetworkName) = 0;
    virtual HRESULT getDHCPEnabled(BOOL *aDHCPEnabled) = 0;
    virtual HRESULT getIPAddress(com::Utf8Str &aIPAddress) = 0;
    virtual HRESULT getNetworkMask(com::Utf8Str &aNetworkMask) = 0;
    virtual HRESULT getIPV6Supported(BOOL *aIPV6Supported) = 0;
    virtual HRESULT getIPV6Address(com::Utf8Str &aIPV6Address) = 0;
    virtual HRESULT getIPV6NetworkMaskPrefixLength(ULONG *aIPV6NetworkMaskPrefixLength) = 0;
    virtual HRESULT getHardwareAddress(com::Utf8Str &aHardwareAddress) = 0;
    virtual HRESULT getMediumType(HostNetworkInterfaceMediumType_T *aMediumType) = 0;
    virtual HRESULT getStatus(HostNetworkInterfaceStatus_T *aStatus) = 0;
    virtual HRESULT getInterfaceType(HostNetworkInterfaceType_T *aInterfaceType) = 0;

    // wrapped IHostNetworkInterface methods
    virtual HRESULT enableStaticIPConfig(const com::Utf8Str &aIPAddress,
                                         const com::Utf8Str &aNetworkMask) = 0;
    virtual HRESULT enableStaticIPConfigV6(const com::Utf8Str &aIPV6Address,
                                           ULONG aIPV6NetworkMaskPrefixLength) = 0;
    virtual HRESULT enableDynamicIPConfig() = 0;
    virtual HRESULT dHCPRediscover() = 0;
};

#endif // !HostNetworkInterfaceWrap_H_

// ##### ENDFILE "HostNetworkInterfaceWrap.h"

// ##### BEGINFILE "HostNetworkInterfaceWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IHostNetworkInterface.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_HOSTNETWORKINTERFACE

#include "HostNetworkInterfaceWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(HostNetworkInterfaceWrap)

//
// IHostNetworkInterface properties
//

STDMETHODIMP HostNetworkInterfaceWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "HostNetworkInterface::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "HostNetworkInterface::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP HostNetworkInterfaceWrap::COMGETTER(ShortName)(BSTR *aShortName)
{
    LogRelFlow(("{%p} %s: enter aShortName=%p\n", this, "HostNetworkInterface::getShortName", aShortName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aShortName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getShortName(BSTROutConverter(aShortName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aShortName=%ls hrc=%Rhrc\n", this, "HostNetworkInterface::getShortName", *aShortName, hrc));
    return hrc;
}

STDMETHODIMP HostNetworkInterfaceWrap::COMGETTER(Id)(BSTR *aId)
{
    LogRelFlow(("{%p} %s: enter aId=%p\n", this, "HostNetworkInterface::getId", aId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getId(UuidOutConverter(aId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aId=%ls hrc=%Rhrc\n", this, "HostNetworkInterface::getId", *aId, hrc));
    return hrc;
}

STDMETHODIMP HostNetworkInterfaceWrap::COMGETTER(NetworkName)(BSTR *aNetworkName)
{
    LogRelFlow(("{%p} %s: enter aNetworkName=%p\n", this, "HostNetworkInterface::getNetworkName", aNetworkName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNetworkName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNetworkName(BSTROutConverter(aNetworkName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNetworkName=%ls hrc=%Rhrc\n", this, "HostNetworkInterface::getNetworkName", *aNetworkName, hrc));
    return hrc;
}

STDMETHODIMP HostNetworkInterfaceWrap::COMGETTER(DHCPEnabled)(BOOL *aDHCPEnabled)
{
    LogRelFlow(("{%p} %s: enter aDHCPEnabled=%p\n", this, "HostNetworkInterface::getDHCPEnabled", aDHCPEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDHCPEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDHCPEnabled(aDHCPEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDHCPEnabled=%RTbool hrc=%Rhrc\n", this, "HostNetworkInterface::getDHCPEnabled", *aDHCPEnabled, hrc));
    return hrc;
}

STDMETHODIMP HostNetworkInterfaceWrap::COMGETTER(IPAddress)(BSTR *aIPAddress)
{
    LogRelFlow(("{%p} %s: enter aIPAddress=%p\n", this, "HostNetworkInterface::getIPAddress", aIPAddress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aIPAddress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getIPAddress(BSTROutConverter(aIPAddress).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aIPAddress=%ls hrc=%Rhrc\n", this, "HostNetworkInterface::getIPAddress", *aIPAddress, hrc));
    return hrc;
}

STDMETHODIMP HostNetworkInterfaceWrap::COMGETTER(NetworkMask)(BSTR *aNetworkMask)
{
    LogRelFlow(("{%p} %s: enter aNetworkMask=%p\n", this, "HostNetworkInterface::getNetworkMask", aNetworkMask));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNetworkMask);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNetworkMask(BSTROutConverter(aNetworkMask).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNetworkMask=%ls hrc=%Rhrc\n", this, "HostNetworkInterface::getNetworkMask", *aNetworkMask, hrc));
    return hrc;
}

STDMETHODIMP HostNetworkInterfaceWrap::COMGETTER(IPV6Supported)(BOOL *aIPV6Supported)
{
    LogRelFlow(("{%p} %s: enter aIPV6Supported=%p\n", this, "HostNetworkInterface::getIPV6Supported", aIPV6Supported));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aIPV6Supported);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getIPV6Supported(aIPV6Supported);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aIPV6Supported=%RTbool hrc=%Rhrc\n", this, "HostNetworkInterface::getIPV6Supported", *aIPV6Supported, hrc));
    return hrc;
}

STDMETHODIMP HostNetworkInterfaceWrap::COMGETTER(IPV6Address)(BSTR *aIPV6Address)
{
    LogRelFlow(("{%p} %s: enter aIPV6Address=%p\n", this, "HostNetworkInterface::getIPV6Address", aIPV6Address));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aIPV6Address);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getIPV6Address(BSTROutConverter(aIPV6Address).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aIPV6Address=%ls hrc=%Rhrc\n", this, "HostNetworkInterface::getIPV6Address", *aIPV6Address, hrc));
    return hrc;
}

STDMETHODIMP HostNetworkInterfaceWrap::COMGETTER(IPV6NetworkMaskPrefixLength)(ULONG *aIPV6NetworkMaskPrefixLength)
{
    LogRelFlow(("{%p} %s: enter aIPV6NetworkMaskPrefixLength=%p\n", this, "HostNetworkInterface::getIPV6NetworkMaskPrefixLength", aIPV6NetworkMaskPrefixLength));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aIPV6NetworkMaskPrefixLength);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getIPV6NetworkMaskPrefixLength(aIPV6NetworkMaskPrefixLength);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aIPV6NetworkMaskPrefixLength=%RU32 hrc=%Rhrc\n", this, "HostNetworkInterface::getIPV6NetworkMaskPrefixLength", *aIPV6NetworkMaskPrefixLength, hrc));
    return hrc;
}

STDMETHODIMP HostNetworkInterfaceWrap::COMGETTER(HardwareAddress)(BSTR *aHardwareAddress)
{
    LogRelFlow(("{%p} %s: enter aHardwareAddress=%p\n", this, "HostNetworkInterface::getHardwareAddress", aHardwareAddress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHardwareAddress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHardwareAddress(BSTROutConverter(aHardwareAddress).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHardwareAddress=%ls hrc=%Rhrc\n", this, "HostNetworkInterface::getHardwareAddress", *aHardwareAddress, hrc));
    return hrc;
}

STDMETHODIMP HostNetworkInterfaceWrap::COMGETTER(MediumType)(HostNetworkInterfaceMediumType_T *aMediumType)
{
    LogRelFlow(("{%p} %s: enter aMediumType=%p\n", this, "HostNetworkInterface::getMediumType", aMediumType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMediumType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMediumType(aMediumType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMediumType=%RU32 hrc=%Rhrc\n", this, "HostNetworkInterface::getMediumType", *aMediumType, hrc));
    return hrc;
}

STDMETHODIMP HostNetworkInterfaceWrap::COMGETTER(Status)(HostNetworkInterfaceStatus_T *aStatus)
{
    LogRelFlow(("{%p} %s: enter aStatus=%p\n", this, "HostNetworkInterface::getStatus", aStatus));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStatus);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getStatus(aStatus);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aStatus=%RU32 hrc=%Rhrc\n", this, "HostNetworkInterface::getStatus", *aStatus, hrc));
    return hrc;
}

STDMETHODIMP HostNetworkInterfaceWrap::COMGETTER(InterfaceType)(HostNetworkInterfaceType_T *aInterfaceType)
{
    LogRelFlow(("{%p} %s: enter aInterfaceType=%p\n", this, "HostNetworkInterface::getInterfaceType", aInterfaceType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aInterfaceType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getInterfaceType(aInterfaceType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aInterfaceType=%RU32 hrc=%Rhrc\n", this, "HostNetworkInterface::getInterfaceType", *aInterfaceType, hrc));
    return hrc;
}

//
// IHostNetworkInterface methods
//

STDMETHODIMP HostNetworkInterfaceWrap::EnableStaticIPConfig(IN_BSTR aIPAddress,
                                                            IN_BSTR aNetworkMask)
{
    LogRelFlow(("{%p} %s:enter aIPAddress=%ls aNetworkMask=%ls\n", this, "HostNetworkInterface::enableStaticIPConfig", aIPAddress, aNetworkMask));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = enableStaticIPConfig(BSTRInConverter(aIPAddress).str(),
                                   BSTRInConverter(aNetworkMask).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "HostNetworkInterface::enableStaticIPConfig", hrc));
    return hrc;
}

STDMETHODIMP HostNetworkInterfaceWrap::EnableStaticIPConfigV6(IN_BSTR aIPV6Address,
                                                              ULONG aIPV6NetworkMaskPrefixLength)
{
    LogRelFlow(("{%p} %s:enter aIPV6Address=%ls aIPV6NetworkMaskPrefixLength=%RU32\n", this, "HostNetworkInterface::enableStaticIPConfigV6", aIPV6Address, aIPV6NetworkMaskPrefixLength));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = enableStaticIPConfigV6(BSTRInConverter(aIPV6Address).str(),
                                     aIPV6NetworkMaskPrefixLength);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "HostNetworkInterface::enableStaticIPConfigV6", hrc));
    return hrc;
}

STDMETHODIMP HostNetworkInterfaceWrap::EnableDynamicIPConfig()
{
    LogRelFlow(("{%p} %s:enter\n", this, "HostNetworkInterface::enableDynamicIPConfig"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = enableDynamicIPConfig();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "HostNetworkInterface::enableDynamicIPConfig", hrc));
    return hrc;
}

STDMETHODIMP HostNetworkInterfaceWrap::DHCPRediscover()
{
    LogRelFlow(("{%p} %s:enter\n", this, "HostNetworkInterface::DHCPRediscover"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = DHCPRediscover();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "HostNetworkInterface::DHCPRediscover", hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(HostNetworkInterfaceWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(HostNetworkInterfaceWrap, IHostNetworkInterface)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "HostNetworkInterfaceWrap.cpp"

// ##### BEGINFILE "HostVideoInputDeviceWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IHostVideoInputDevice.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef HostVideoInputDeviceWrap_H_
#define HostVideoInputDeviceWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE HostVideoInputDeviceWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IHostVideoInputDevice)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(HostVideoInputDeviceWrap, IHostVideoInputDevice)
    DECLARE_NOT_AGGREGATABLE(HostVideoInputDeviceWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(HostVideoInputDeviceWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IHostVideoInputDevice)
        COM_INTERFACE_ENTRY2(IDispatch, IHostVideoInputDevice)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(HostVideoInputDeviceWrap)

    // public IHostVideoInputDevice properties
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(Path))(BSTR *aPath);
    STDMETHOD(COMGETTER(Alias))(BSTR *aAlias);

    // public IHostVideoInputDevice methods

private:
    // wrapped IHostVideoInputDevice properties
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getPath(com::Utf8Str &aPath) = 0;
    virtual HRESULT getAlias(com::Utf8Str &aAlias) = 0;

    // wrapped IHostVideoInputDevice methods
};

#endif // !HostVideoInputDeviceWrap_H_

// ##### ENDFILE "HostVideoInputDeviceWrap.h"

// ##### BEGINFILE "HostVideoInputDeviceWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IHostVideoInputDevice.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_HOSTVIDEOINPUTDEVICE

#include "HostVideoInputDeviceWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(HostVideoInputDeviceWrap)

//
// IHostVideoInputDevice properties
//

STDMETHODIMP HostVideoInputDeviceWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "HostVideoInputDevice::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "HostVideoInputDevice::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP HostVideoInputDeviceWrap::COMGETTER(Path)(BSTR *aPath)
{
    LogRelFlow(("{%p} %s: enter aPath=%p\n", this, "HostVideoInputDevice::getPath", aPath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPath);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPath(BSTROutConverter(aPath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPath=%ls hrc=%Rhrc\n", this, "HostVideoInputDevice::getPath", *aPath, hrc));
    return hrc;
}

STDMETHODIMP HostVideoInputDeviceWrap::COMGETTER(Alias)(BSTR *aAlias)
{
    LogRelFlow(("{%p} %s: enter aAlias=%p\n", this, "HostVideoInputDevice::getAlias", aAlias));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAlias);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAlias(BSTROutConverter(aAlias).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAlias=%ls hrc=%Rhrc\n", this, "HostVideoInputDevice::getAlias", *aAlias, hrc));
    return hrc;
}

//
// IHostVideoInputDevice methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(HostVideoInputDeviceWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(HostVideoInputDeviceWrap, IHostVideoInputDevice)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "HostVideoInputDeviceWrap.cpp"

// ##### BEGINFILE "HostWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IHost.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef HostWrap_H_
#define HostWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE HostWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IHost)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(HostWrap, IHost)
    DECLARE_NOT_AGGREGATABLE(HostWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(HostWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IHost)
        COM_INTERFACE_ENTRY2(IDispatch, IHost)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(HostWrap)

    // public IHost properties
    STDMETHOD(COMGETTER(DVDDrives))(ComSafeArrayOut(IMedium *, aDVDDrives));
    STDMETHOD(COMGETTER(FloppyDrives))(ComSafeArrayOut(IMedium *, aFloppyDrives));
    STDMETHOD(COMGETTER(USBDevices))(ComSafeArrayOut(IHostUSBDevice *, aUSBDevices));
    STDMETHOD(COMGETTER(USBDeviceFilters))(ComSafeArrayOut(IHostUSBDeviceFilter *, aUSBDeviceFilters));
    STDMETHOD(COMGETTER(NetworkInterfaces))(ComSafeArrayOut(IHostNetworkInterface *, aNetworkInterfaces));
    STDMETHOD(COMGETTER(NameServers))(ComSafeArrayOut(BSTR, aNameServers));
    STDMETHOD(COMGETTER(DomainName))(BSTR *aDomainName);
    STDMETHOD(COMGETTER(SearchStrings))(ComSafeArrayOut(BSTR, aSearchStrings));
    STDMETHOD(COMGETTER(ProcessorCount))(ULONG *aProcessorCount);
    STDMETHOD(COMGETTER(ProcessorOnlineCount))(ULONG *aProcessorOnlineCount);
    STDMETHOD(COMGETTER(ProcessorCoreCount))(ULONG *aProcessorCoreCount);
    STDMETHOD(COMGETTER(ProcessorOnlineCoreCount))(ULONG *aProcessorOnlineCoreCount);
    STDMETHOD(COMGETTER(MemorySize))(ULONG *aMemorySize);
    STDMETHOD(COMGETTER(MemoryAvailable))(ULONG *aMemoryAvailable);
    STDMETHOD(COMGETTER(OperatingSystem))(BSTR *aOperatingSystem);
    STDMETHOD(COMGETTER(OSVersion))(BSTR *aOSVersion);
    STDMETHOD(COMGETTER(UTCTime))(LONG64 *aUTCTime);
    STDMETHOD(COMGETTER(Acceleration3DAvailable))(BOOL *aAcceleration3DAvailable);
    STDMETHOD(COMGETTER(VideoInputDevices))(ComSafeArrayOut(IHostVideoInputDevice *, aVideoInputDevices));

    // public IHost methods
    STDMETHOD(GetProcessorSpeed)(ULONG aCpuId,
                                 ULONG *aSpeed);
    STDMETHOD(GetProcessorFeature)(ProcessorFeature_T aFeature,
                                   BOOL *aSupported);
    STDMETHOD(GetProcessorDescription)(ULONG aCpuId,
                                       BSTR *aDescription);
    STDMETHOD(GetProcessorCPUIDLeaf)(ULONG aCpuId,
                                     ULONG aLeaf,
                                     ULONG aSubLeaf,
                                     ULONG *aValEax,
                                     ULONG *aValEbx,
                                     ULONG *aValEcx,
                                     ULONG *aValEdx);
    STDMETHOD(CreateHostOnlyNetworkInterface)(IHostNetworkInterface **aHostInterface,
                                              IProgress **aProgress);
    STDMETHOD(RemoveHostOnlyNetworkInterface)(IN_BSTR aId,
                                              IProgress **aProgress);
    STDMETHOD(CreateUSBDeviceFilter)(IN_BSTR aName,
                                     IHostUSBDeviceFilter **aFilter);
    STDMETHOD(InsertUSBDeviceFilter)(ULONG aPosition,
                                     IHostUSBDeviceFilter *aFilter);
    STDMETHOD(RemoveUSBDeviceFilter)(ULONG aPosition);
    STDMETHOD(FindHostDVDDrive)(IN_BSTR aName,
                                IMedium **aDrive);
    STDMETHOD(FindHostFloppyDrive)(IN_BSTR aName,
                                   IMedium **aDrive);
    STDMETHOD(FindHostNetworkInterfaceByName)(IN_BSTR aName,
                                              IHostNetworkInterface **aNetworkInterface);
    STDMETHOD(FindHostNetworkInterfaceById)(IN_BSTR aId,
                                            IHostNetworkInterface **aNetworkInterface);
    STDMETHOD(FindHostNetworkInterfacesOfType)(HostNetworkInterfaceType_T aType,
                                               ComSafeArrayOut(IHostNetworkInterface *, aNetworkInterfaces));
    STDMETHOD(FindUSBDeviceById)(IN_BSTR aId,
                                 IHostUSBDevice **aDevice);
    STDMETHOD(FindUSBDeviceByAddress)(IN_BSTR aName,
                                      IHostUSBDevice **aDevice);
    STDMETHOD(GenerateMACAddress)(BSTR *aAddress);

private:
    // wrapped IHost properties
    virtual HRESULT getDVDDrives(std::vector<ComPtr<IMedium> > &aDVDDrives) = 0;
    virtual HRESULT getFloppyDrives(std::vector<ComPtr<IMedium> > &aFloppyDrives) = 0;
    virtual HRESULT getUSBDevices(std::vector<ComPtr<IHostUSBDevice> > &aUSBDevices) = 0;
    virtual HRESULT getUSBDeviceFilters(std::vector<ComPtr<IHostUSBDeviceFilter> > &aUSBDeviceFilters) = 0;
    virtual HRESULT getNetworkInterfaces(std::vector<ComPtr<IHostNetworkInterface> > &aNetworkInterfaces) = 0;
    virtual HRESULT getNameServers(std::vector<com::Utf8Str> &aNameServers) = 0;
    virtual HRESULT getDomainName(com::Utf8Str &aDomainName) = 0;
    virtual HRESULT getSearchStrings(std::vector<com::Utf8Str> &aSearchStrings) = 0;
    virtual HRESULT getProcessorCount(ULONG *aProcessorCount) = 0;
    virtual HRESULT getProcessorOnlineCount(ULONG *aProcessorOnlineCount) = 0;
    virtual HRESULT getProcessorCoreCount(ULONG *aProcessorCoreCount) = 0;
    virtual HRESULT getProcessorOnlineCoreCount(ULONG *aProcessorOnlineCoreCount) = 0;
    virtual HRESULT getMemorySize(ULONG *aMemorySize) = 0;
    virtual HRESULT getMemoryAvailable(ULONG *aMemoryAvailable) = 0;
    virtual HRESULT getOperatingSystem(com::Utf8Str &aOperatingSystem) = 0;
    virtual HRESULT getOSVersion(com::Utf8Str &aOSVersion) = 0;
    virtual HRESULT getUTCTime(LONG64 *aUTCTime) = 0;
    virtual HRESULT getAcceleration3DAvailable(BOOL *aAcceleration3DAvailable) = 0;
    virtual HRESULT getVideoInputDevices(std::vector<ComPtr<IHostVideoInputDevice> > &aVideoInputDevices) = 0;

    // wrapped IHost methods
    virtual HRESULT getProcessorSpeed(ULONG aCpuId,
                                      ULONG *aSpeed) = 0;
    virtual HRESULT getProcessorFeature(ProcessorFeature_T aFeature,
                                        BOOL *aSupported) = 0;
    virtual HRESULT getProcessorDescription(ULONG aCpuId,
                                            com::Utf8Str &aDescription) = 0;
    virtual HRESULT getProcessorCPUIDLeaf(ULONG aCpuId,
                                          ULONG aLeaf,
                                          ULONG aSubLeaf,
                                          ULONG *aValEax,
                                          ULONG *aValEbx,
                                          ULONG *aValEcx,
                                          ULONG *aValEdx) = 0;
    virtual HRESULT createHostOnlyNetworkInterface(ComPtr<IHostNetworkInterface> &aHostInterface,
                                                   ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT removeHostOnlyNetworkInterface(const com::Guid &aId,
                                                   ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT createUSBDeviceFilter(const com::Utf8Str &aName,
                                          ComPtr<IHostUSBDeviceFilter> &aFilter) = 0;
    virtual HRESULT insertUSBDeviceFilter(ULONG aPosition,
                                          const ComPtr<IHostUSBDeviceFilter> &aFilter) = 0;
    virtual HRESULT removeUSBDeviceFilter(ULONG aPosition) = 0;
    virtual HRESULT findHostDVDDrive(const com::Utf8Str &aName,
                                     ComPtr<IMedium> &aDrive) = 0;
    virtual HRESULT findHostFloppyDrive(const com::Utf8Str &aName,
                                        ComPtr<IMedium> &aDrive) = 0;
    virtual HRESULT findHostNetworkInterfaceByName(const com::Utf8Str &aName,
                                                   ComPtr<IHostNetworkInterface> &aNetworkInterface) = 0;
    virtual HRESULT findHostNetworkInterfaceById(const com::Guid &aId,
                                                 ComPtr<IHostNetworkInterface> &aNetworkInterface) = 0;
    virtual HRESULT findHostNetworkInterfacesOfType(HostNetworkInterfaceType_T aType,
                                                    std::vector<ComPtr<IHostNetworkInterface> > &aNetworkInterfaces) = 0;
    virtual HRESULT findUSBDeviceById(const com::Guid &aId,
                                      ComPtr<IHostUSBDevice> &aDevice) = 0;
    virtual HRESULT findUSBDeviceByAddress(const com::Utf8Str &aName,
                                           ComPtr<IHostUSBDevice> &aDevice) = 0;
    virtual HRESULT generateMACAddress(com::Utf8Str &aAddress) = 0;
};

#endif // !HostWrap_H_

// ##### ENDFILE "HostWrap.h"

// ##### BEGINFILE "HostWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IHost.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_HOST

#include "HostWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(HostWrap)

//
// IHost properties
//

STDMETHODIMP HostWrap::COMGETTER(DVDDrives)(ComSafeArrayOut(IMedium *, aDVDDrives))
{
    LogRelFlow(("{%p} %s: enter aDVDDrives=%p\n", this, "Host::getDVDDrives", aDVDDrives));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDVDDrives);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDVDDrives(ArrayComTypeOutConverter<IMedium>(ComSafeArrayOutArg(aDVDDrives)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDVDDrives=%zu hrc=%Rhrc\n", this, "Host::getDVDDrives", ComSafeArraySize(*aDVDDrives), hrc));
    return hrc;
}

STDMETHODIMP HostWrap::COMGETTER(FloppyDrives)(ComSafeArrayOut(IMedium *, aFloppyDrives))
{
    LogRelFlow(("{%p} %s: enter aFloppyDrives=%p\n", this, "Host::getFloppyDrives", aFloppyDrives));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFloppyDrives);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFloppyDrives(ArrayComTypeOutConverter<IMedium>(ComSafeArrayOutArg(aFloppyDrives)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFloppyDrives=%zu hrc=%Rhrc\n", this, "Host::getFloppyDrives", ComSafeArraySize(*aFloppyDrives), hrc));
    return hrc;
}

STDMETHODIMP HostWrap::COMGETTER(USBDevices)(ComSafeArrayOut(IHostUSBDevice *, aUSBDevices))
{
    LogRelFlow(("{%p} %s: enter aUSBDevices=%p\n", this, "Host::getUSBDevices", aUSBDevices));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUSBDevices);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUSBDevices(ArrayComTypeOutConverter<IHostUSBDevice>(ComSafeArrayOutArg(aUSBDevices)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUSBDevices=%zu hrc=%Rhrc\n", this, "Host::getUSBDevices", ComSafeArraySize(*aUSBDevices), hrc));
    return hrc;
}

STDMETHODIMP HostWrap::COMGETTER(USBDeviceFilters)(ComSafeArrayOut(IHostUSBDeviceFilter *, aUSBDeviceFilters))
{
    LogRelFlow(("{%p} %s: enter aUSBDeviceFilters=%p\n", this, "Host::getUSBDeviceFilters", aUSBDeviceFilters));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUSBDeviceFilters);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUSBDeviceFilters(ArrayComTypeOutConverter<IHostUSBDeviceFilter>(ComSafeArrayOutArg(aUSBDeviceFilters)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUSBDeviceFilters=%zu hrc=%Rhrc\n", this, "Host::getUSBDeviceFilters", ComSafeArraySize(*aUSBDeviceFilters), hrc));
    return hrc;
}

STDMETHODIMP HostWrap::COMGETTER(NetworkInterfaces)(ComSafeArrayOut(IHostNetworkInterface *, aNetworkInterfaces))
{
    LogRelFlow(("{%p} %s: enter aNetworkInterfaces=%p\n", this, "Host::getNetworkInterfaces", aNetworkInterfaces));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNetworkInterfaces);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNetworkInterfaces(ArrayComTypeOutConverter<IHostNetworkInterface>(ComSafeArrayOutArg(aNetworkInterfaces)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNetworkInterfaces=%zu hrc=%Rhrc\n", this, "Host::getNetworkInterfaces", ComSafeArraySize(*aNetworkInterfaces), hrc));
    return hrc;
}

STDMETHODIMP HostWrap::COMGETTER(NameServers)(ComSafeArrayOut(BSTR, aNameServers))
{
    LogRelFlow(("{%p} %s: enter aNameServers=%p\n", this, "Host::getNameServers", aNameServers));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNameServers);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNameServers(ArrayBSTROutConverter(ComSafeArrayOutArg(aNameServers)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNameServers=%zu hrc=%Rhrc\n", this, "Host::getNameServers", ComSafeArraySize(*aNameServers), hrc));
    return hrc;
}

STDMETHODIMP HostWrap::COMGETTER(DomainName)(BSTR *aDomainName)
{
    LogRelFlow(("{%p} %s: enter aDomainName=%p\n", this, "Host::getDomainName", aDomainName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDomainName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDomainName(BSTROutConverter(aDomainName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDomainName=%ls hrc=%Rhrc\n", this, "Host::getDomainName", *aDomainName, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::COMGETTER(SearchStrings)(ComSafeArrayOut(BSTR, aSearchStrings))
{
    LogRelFlow(("{%p} %s: enter aSearchStrings=%p\n", this, "Host::getSearchStrings", aSearchStrings));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSearchStrings);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSearchStrings(ArrayBSTROutConverter(ComSafeArrayOutArg(aSearchStrings)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSearchStrings=%zu hrc=%Rhrc\n", this, "Host::getSearchStrings", ComSafeArraySize(*aSearchStrings), hrc));
    return hrc;
}

STDMETHODIMP HostWrap::COMGETTER(ProcessorCount)(ULONG *aProcessorCount)
{
    LogRelFlow(("{%p} %s: enter aProcessorCount=%p\n", this, "Host::getProcessorCount", aProcessorCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProcessorCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProcessorCount(aProcessorCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProcessorCount=%RU32 hrc=%Rhrc\n", this, "Host::getProcessorCount", *aProcessorCount, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::COMGETTER(ProcessorOnlineCount)(ULONG *aProcessorOnlineCount)
{
    LogRelFlow(("{%p} %s: enter aProcessorOnlineCount=%p\n", this, "Host::getProcessorOnlineCount", aProcessorOnlineCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProcessorOnlineCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProcessorOnlineCount(aProcessorOnlineCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProcessorOnlineCount=%RU32 hrc=%Rhrc\n", this, "Host::getProcessorOnlineCount", *aProcessorOnlineCount, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::COMGETTER(ProcessorCoreCount)(ULONG *aProcessorCoreCount)
{
    LogRelFlow(("{%p} %s: enter aProcessorCoreCount=%p\n", this, "Host::getProcessorCoreCount", aProcessorCoreCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProcessorCoreCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProcessorCoreCount(aProcessorCoreCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProcessorCoreCount=%RU32 hrc=%Rhrc\n", this, "Host::getProcessorCoreCount", *aProcessorCoreCount, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::COMGETTER(ProcessorOnlineCoreCount)(ULONG *aProcessorOnlineCoreCount)
{
    LogRelFlow(("{%p} %s: enter aProcessorOnlineCoreCount=%p\n", this, "Host::getProcessorOnlineCoreCount", aProcessorOnlineCoreCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProcessorOnlineCoreCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProcessorOnlineCoreCount(aProcessorOnlineCoreCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProcessorOnlineCoreCount=%RU32 hrc=%Rhrc\n", this, "Host::getProcessorOnlineCoreCount", *aProcessorOnlineCoreCount, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::COMGETTER(MemorySize)(ULONG *aMemorySize)
{
    LogRelFlow(("{%p} %s: enter aMemorySize=%p\n", this, "Host::getMemorySize", aMemorySize));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMemorySize);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMemorySize(aMemorySize);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMemorySize=%RU32 hrc=%Rhrc\n", this, "Host::getMemorySize", *aMemorySize, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::COMGETTER(MemoryAvailable)(ULONG *aMemoryAvailable)
{
    LogRelFlow(("{%p} %s: enter aMemoryAvailable=%p\n", this, "Host::getMemoryAvailable", aMemoryAvailable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMemoryAvailable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMemoryAvailable(aMemoryAvailable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMemoryAvailable=%RU32 hrc=%Rhrc\n", this, "Host::getMemoryAvailable", *aMemoryAvailable, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::COMGETTER(OperatingSystem)(BSTR *aOperatingSystem)
{
    LogRelFlow(("{%p} %s: enter aOperatingSystem=%p\n", this, "Host::getOperatingSystem", aOperatingSystem));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOperatingSystem);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOperatingSystem(BSTROutConverter(aOperatingSystem).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOperatingSystem=%ls hrc=%Rhrc\n", this, "Host::getOperatingSystem", *aOperatingSystem, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::COMGETTER(OSVersion)(BSTR *aOSVersion)
{
    LogRelFlow(("{%p} %s: enter aOSVersion=%p\n", this, "Host::getOSVersion", aOSVersion));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOSVersion);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOSVersion(BSTROutConverter(aOSVersion).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOSVersion=%ls hrc=%Rhrc\n", this, "Host::getOSVersion", *aOSVersion, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::COMGETTER(UTCTime)(LONG64 *aUTCTime)
{
    LogRelFlow(("{%p} %s: enter aUTCTime=%p\n", this, "Host::getUTCTime", aUTCTime));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUTCTime);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUTCTime(aUTCTime);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUTCTime=%RI64 hrc=%Rhrc\n", this, "Host::getUTCTime", *aUTCTime, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::COMGETTER(Acceleration3DAvailable)(BOOL *aAcceleration3DAvailable)
{
    LogRelFlow(("{%p} %s: enter aAcceleration3DAvailable=%p\n", this, "Host::getAcceleration3DAvailable", aAcceleration3DAvailable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAcceleration3DAvailable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAcceleration3DAvailable(aAcceleration3DAvailable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAcceleration3DAvailable=%RTbool hrc=%Rhrc\n", this, "Host::getAcceleration3DAvailable", *aAcceleration3DAvailable, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::COMGETTER(VideoInputDevices)(ComSafeArrayOut(IHostVideoInputDevice *, aVideoInputDevices))
{
    LogRelFlow(("{%p} %s: enter aVideoInputDevices=%p\n", this, "Host::getVideoInputDevices", aVideoInputDevices));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVideoInputDevices);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVideoInputDevices(ArrayComTypeOutConverter<IHostVideoInputDevice>(ComSafeArrayOutArg(aVideoInputDevices)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVideoInputDevices=%zu hrc=%Rhrc\n", this, "Host::getVideoInputDevices", ComSafeArraySize(*aVideoInputDevices), hrc));
    return hrc;
}

//
// IHost methods
//

STDMETHODIMP HostWrap::GetProcessorSpeed(ULONG aCpuId,
                                         ULONG *aSpeed)
{
    LogRelFlow(("{%p} %s:enter aCpuId=%RU32 aSpeed=%p\n", this, "Host::getProcessorSpeed", aCpuId, aSpeed));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSpeed);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProcessorSpeed(aCpuId,
                                aSpeed);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aSpeed=%RU32 hrc=%Rhrc\n", this, "Host::getProcessorSpeed", *aSpeed, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::GetProcessorFeature(ProcessorFeature_T aFeature,
                                           BOOL *aSupported)
{
    LogRelFlow(("{%p} %s:enter aFeature=%RU32 aSupported=%p\n", this, "Host::getProcessorFeature", aFeature, aSupported));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSupported);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProcessorFeature(aFeature,
                                  aSupported);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aSupported=%RTbool hrc=%Rhrc\n", this, "Host::getProcessorFeature", *aSupported, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::GetProcessorDescription(ULONG aCpuId,
                                               BSTR *aDescription)
{
    LogRelFlow(("{%p} %s:enter aCpuId=%RU32 aDescription=%p\n", this, "Host::getProcessorDescription", aCpuId, aDescription));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDescription);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProcessorDescription(aCpuId,
                                      BSTROutConverter(aDescription).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aDescription=%ls hrc=%Rhrc\n", this, "Host::getProcessorDescription", *aDescription, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::GetProcessorCPUIDLeaf(ULONG aCpuId,
                                             ULONG aLeaf,
                                             ULONG aSubLeaf,
                                             ULONG *aValEax,
                                             ULONG *aValEbx,
                                             ULONG *aValEcx,
                                             ULONG *aValEdx)
{
    LogRelFlow(("{%p} %s:enter aCpuId=%RU32 aLeaf=%RU32 aSubLeaf=%RU32 aValEax=%p aValEbx=%p aValEcx=%p aValEdx=%p\n", this, "Host::getProcessorCPUIDLeaf", aCpuId, aLeaf, aSubLeaf, aValEax, aValEbx, aValEcx, aValEdx));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aValEax);
        CheckComArgOutPointerValidThrow(aValEbx);
        CheckComArgOutPointerValidThrow(aValEcx);
        CheckComArgOutPointerValidThrow(aValEdx);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProcessorCPUIDLeaf(aCpuId,
                                    aLeaf,
                                    aSubLeaf,
                                    aValEax,
                                    aValEbx,
                                    aValEcx,
                                    aValEdx);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aValEax=%RU32 *aValEbx=%RU32 *aValEcx=%RU32 *aValEdx=%RU32 hrc=%Rhrc\n", this, "Host::getProcessorCPUIDLeaf", *aValEax, *aValEbx, *aValEcx, *aValEdx, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::CreateHostOnlyNetworkInterface(IHostNetworkInterface **aHostInterface,
                                                      IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aHostInterface=%p aProgress=%p\n", this, "Host::createHostOnlyNetworkInterface", aHostInterface, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHostInterface);
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = createHostOnlyNetworkInterface(ComTypeOutConverter<IHostNetworkInterface>(aHostInterface).ptr(),
                                             ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHostInterface=%p aProgress=%p hrc=%Rhrc\n", this, "Host::createHostOnlyNetworkInterface", *aHostInterface, *aProgress, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::RemoveHostOnlyNetworkInterface(IN_BSTR aId,
                                                      IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aId=%ls aProgress=%p\n", this, "Host::removeHostOnlyNetworkInterface", aId, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = removeHostOnlyNetworkInterface(UuidInConverter(aId).uuid(),
                                             ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Host::removeHostOnlyNetworkInterface", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::CreateUSBDeviceFilter(IN_BSTR aName,
                                             IHostUSBDeviceFilter **aFilter)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aFilter=%p\n", this, "Host::createUSBDeviceFilter", aName, aFilter));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFilter);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = createUSBDeviceFilter(BSTRInConverter(aName).str(),
                                    ComTypeOutConverter<IHostUSBDeviceFilter>(aFilter).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aFilter=%p hrc=%Rhrc\n", this, "Host::createUSBDeviceFilter", *aFilter, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::InsertUSBDeviceFilter(ULONG aPosition,
                                             IHostUSBDeviceFilter *aFilter)
{
    LogRelFlow(("{%p} %s:enter aPosition=%RU32 aFilter=%p\n", this, "Host::insertUSBDeviceFilter", aPosition, aFilter));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = insertUSBDeviceFilter(aPosition,
                                    ComTypeInConverter<IHostUSBDeviceFilter>(aFilter).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Host::insertUSBDeviceFilter", hrc));
    return hrc;
}

STDMETHODIMP HostWrap::RemoveUSBDeviceFilter(ULONG aPosition)
{
    LogRelFlow(("{%p} %s:enter aPosition=%RU32\n", this, "Host::removeUSBDeviceFilter", aPosition));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = removeUSBDeviceFilter(aPosition);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Host::removeUSBDeviceFilter", hrc));
    return hrc;
}

STDMETHODIMP HostWrap::FindHostDVDDrive(IN_BSTR aName,
                                        IMedium **aDrive)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aDrive=%p\n", this, "Host::findHostDVDDrive", aName, aDrive));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDrive);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = findHostDVDDrive(BSTRInConverter(aName).str(),
                               ComTypeOutConverter<IMedium>(aDrive).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aDrive=%p hrc=%Rhrc\n", this, "Host::findHostDVDDrive", *aDrive, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::FindHostFloppyDrive(IN_BSTR aName,
                                           IMedium **aDrive)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aDrive=%p\n", this, "Host::findHostFloppyDrive", aName, aDrive));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDrive);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = findHostFloppyDrive(BSTRInConverter(aName).str(),
                                  ComTypeOutConverter<IMedium>(aDrive).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aDrive=%p hrc=%Rhrc\n", this, "Host::findHostFloppyDrive", *aDrive, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::FindHostNetworkInterfaceByName(IN_BSTR aName,
                                                      IHostNetworkInterface **aNetworkInterface)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aNetworkInterface=%p\n", this, "Host::findHostNetworkInterfaceByName", aName, aNetworkInterface));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNetworkInterface);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = findHostNetworkInterfaceByName(BSTRInConverter(aName).str(),
                                             ComTypeOutConverter<IHostNetworkInterface>(aNetworkInterface).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aNetworkInterface=%p hrc=%Rhrc\n", this, "Host::findHostNetworkInterfaceByName", *aNetworkInterface, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::FindHostNetworkInterfaceById(IN_BSTR aId,
                                                    IHostNetworkInterface **aNetworkInterface)
{
    LogRelFlow(("{%p} %s:enter aId=%ls aNetworkInterface=%p\n", this, "Host::findHostNetworkInterfaceById", aId, aNetworkInterface));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNetworkInterface);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = findHostNetworkInterfaceById(UuidInConverter(aId).uuid(),
                                           ComTypeOutConverter<IHostNetworkInterface>(aNetworkInterface).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aNetworkInterface=%p hrc=%Rhrc\n", this, "Host::findHostNetworkInterfaceById", *aNetworkInterface, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::FindHostNetworkInterfacesOfType(HostNetworkInterfaceType_T aType,
                                                       ComSafeArrayOut(IHostNetworkInterface *, aNetworkInterfaces))
{
    LogRelFlow(("{%p} %s:enter aType=%RU32 aNetworkInterfaces=%p\n", this, "Host::findHostNetworkInterfacesOfType", aType, aNetworkInterfaces));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNetworkInterfaces);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = findHostNetworkInterfacesOfType(aType,
                                              ArrayComTypeOutConverter<IHostNetworkInterface>(ComSafeArrayOutArg(aNetworkInterfaces)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aNetworkInterfaces=%zu hrc=%Rhrc\n", this, "Host::findHostNetworkInterfacesOfType", ComSafeArraySize(*aNetworkInterfaces), hrc));
    return hrc;
}

STDMETHODIMP HostWrap::FindUSBDeviceById(IN_BSTR aId,
                                         IHostUSBDevice **aDevice)
{
    LogRelFlow(("{%p} %s:enter aId=%ls aDevice=%p\n", this, "Host::findUSBDeviceById", aId, aDevice));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDevice);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = findUSBDeviceById(UuidInConverter(aId).uuid(),
                                ComTypeOutConverter<IHostUSBDevice>(aDevice).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aDevice=%p hrc=%Rhrc\n", this, "Host::findUSBDeviceById", *aDevice, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::FindUSBDeviceByAddress(IN_BSTR aName,
                                              IHostUSBDevice **aDevice)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aDevice=%p\n", this, "Host::findUSBDeviceByAddress", aName, aDevice));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDevice);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = findUSBDeviceByAddress(BSTRInConverter(aName).str(),
                                     ComTypeOutConverter<IHostUSBDevice>(aDevice).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aDevice=%p hrc=%Rhrc\n", this, "Host::findUSBDeviceByAddress", *aDevice, hrc));
    return hrc;
}

STDMETHODIMP HostWrap::GenerateMACAddress(BSTR *aAddress)
{
    LogRelFlow(("{%p} %s:enter aAddress=%p\n", this, "Host::generateMACAddress", aAddress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAddress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = generateMACAddress(BSTROutConverter(aAddress).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aAddress=%ls hrc=%Rhrc\n", this, "Host::generateMACAddress", *aAddress, hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(HostWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(HostWrap, IHost)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "HostWrap.cpp"

// ##### BEGINFILE "SystemPropertiesWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for ISystemProperties.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef SystemPropertiesWrap_H_
#define SystemPropertiesWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE SystemPropertiesWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(ISystemProperties)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(SystemPropertiesWrap, ISystemProperties)
    DECLARE_NOT_AGGREGATABLE(SystemPropertiesWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(SystemPropertiesWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(ISystemProperties)
        COM_INTERFACE_ENTRY2(IDispatch, ISystemProperties)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(SystemPropertiesWrap)

    // public ISystemProperties properties
    STDMETHOD(COMGETTER(MinGuestRAM))(ULONG *aMinGuestRAM);
    STDMETHOD(COMGETTER(MaxGuestRAM))(ULONG *aMaxGuestRAM);
    STDMETHOD(COMGETTER(MinGuestVRAM))(ULONG *aMinGuestVRAM);
    STDMETHOD(COMGETTER(MaxGuestVRAM))(ULONG *aMaxGuestVRAM);
    STDMETHOD(COMGETTER(MinGuestCPUCount))(ULONG *aMinGuestCPUCount);
    STDMETHOD(COMGETTER(MaxGuestCPUCount))(ULONG *aMaxGuestCPUCount);
    STDMETHOD(COMGETTER(MaxGuestMonitors))(ULONG *aMaxGuestMonitors);
    STDMETHOD(COMGETTER(InfoVDSize))(LONG64 *aInfoVDSize);
    STDMETHOD(COMGETTER(SerialPortCount))(ULONG *aSerialPortCount);
    STDMETHOD(COMGETTER(ParallelPortCount))(ULONG *aParallelPortCount);
    STDMETHOD(COMGETTER(MaxBootPosition))(ULONG *aMaxBootPosition);
    STDMETHOD(COMGETTER(ExclusiveHwVirt))(BOOL *aExclusiveHwVirt);
    STDMETHOD(COMSETTER(ExclusiveHwVirt))(BOOL aExclusiveHwVirt);
    STDMETHOD(COMGETTER(DefaultMachineFolder))(BSTR *aDefaultMachineFolder);
    STDMETHOD(COMSETTER(DefaultMachineFolder))(IN_BSTR aDefaultMachineFolder);
    STDMETHOD(COMGETTER(LoggingLevel))(BSTR *aLoggingLevel);
    STDMETHOD(COMSETTER(LoggingLevel))(IN_BSTR aLoggingLevel);
    STDMETHOD(COMGETTER(MediumFormats))(ComSafeArrayOut(IMediumFormat *, aMediumFormats));
    STDMETHOD(COMGETTER(DefaultHardDiskFormat))(BSTR *aDefaultHardDiskFormat);
    STDMETHOD(COMSETTER(DefaultHardDiskFormat))(IN_BSTR aDefaultHardDiskFormat);
    STDMETHOD(COMGETTER(FreeDiskSpaceWarning))(LONG64 *aFreeDiskSpaceWarning);
    STDMETHOD(COMSETTER(FreeDiskSpaceWarning))(LONG64 aFreeDiskSpaceWarning);
    STDMETHOD(COMGETTER(FreeDiskSpacePercentWarning))(ULONG *aFreeDiskSpacePercentWarning);
    STDMETHOD(COMSETTER(FreeDiskSpacePercentWarning))(ULONG aFreeDiskSpacePercentWarning);
    STDMETHOD(COMGETTER(FreeDiskSpaceError))(LONG64 *aFreeDiskSpaceError);
    STDMETHOD(COMSETTER(FreeDiskSpaceError))(LONG64 aFreeDiskSpaceError);
    STDMETHOD(COMGETTER(FreeDiskSpacePercentError))(ULONG *aFreeDiskSpacePercentError);
    STDMETHOD(COMSETTER(FreeDiskSpacePercentError))(ULONG aFreeDiskSpacePercentError);
    STDMETHOD(COMGETTER(VRDEAuthLibrary))(BSTR *aVRDEAuthLibrary);
    STDMETHOD(COMSETTER(VRDEAuthLibrary))(IN_BSTR aVRDEAuthLibrary);
    STDMETHOD(COMGETTER(WebServiceAuthLibrary))(BSTR *aWebServiceAuthLibrary);
    STDMETHOD(COMSETTER(WebServiceAuthLibrary))(IN_BSTR aWebServiceAuthLibrary);
    STDMETHOD(COMGETTER(DefaultVRDEExtPack))(BSTR *aDefaultVRDEExtPack);
    STDMETHOD(COMSETTER(DefaultVRDEExtPack))(IN_BSTR aDefaultVRDEExtPack);
    STDMETHOD(COMGETTER(LogHistoryCount))(ULONG *aLogHistoryCount);
    STDMETHOD(COMSETTER(LogHistoryCount))(ULONG aLogHistoryCount);
    STDMETHOD(COMGETTER(DefaultAudioDriver))(AudioDriverType_T *aDefaultAudioDriver);
    STDMETHOD(COMGETTER(AutostartDatabasePath))(BSTR *aAutostartDatabasePath);
    STDMETHOD(COMSETTER(AutostartDatabasePath))(IN_BSTR aAutostartDatabasePath);
    STDMETHOD(COMGETTER(DefaultAdditionsISO))(BSTR *aDefaultAdditionsISO);
    STDMETHOD(COMSETTER(DefaultAdditionsISO))(IN_BSTR aDefaultAdditionsISO);
    STDMETHOD(COMGETTER(DefaultFrontend))(BSTR *aDefaultFrontend);
    STDMETHOD(COMSETTER(DefaultFrontend))(IN_BSTR aDefaultFrontend);

    // public ISystemProperties methods
    STDMETHOD(GetMaxNetworkAdapters)(ChipsetType_T aChipset,
                                     ULONG *aMaxNetworkAdapters);
    STDMETHOD(GetMaxNetworkAdaptersOfType)(ChipsetType_T aChipset,
                                           NetworkAttachmentType_T aType,
                                           ULONG *aMaxNetworkAdapters);
    STDMETHOD(GetMaxDevicesPerPortForStorageBus)(StorageBus_T aBus,
                                                 ULONG *aMaxDevicesPerPort);
    STDMETHOD(GetMinPortCountForStorageBus)(StorageBus_T aBus,
                                            ULONG *aMinPortCount);
    STDMETHOD(GetMaxPortCountForStorageBus)(StorageBus_T aBus,
                                            ULONG *aMaxPortCount);
    STDMETHOD(GetMaxInstancesOfStorageBus)(ChipsetType_T aChipset,
                                           StorageBus_T aBus,
                                           ULONG *aMaxInstances);
    STDMETHOD(GetDeviceTypesForStorageBus)(StorageBus_T aBus,
                                           ComSafeArrayOut(DeviceType_T, aDeviceTypes));
    STDMETHOD(GetDefaultIoCacheSettingForStorageController)(StorageControllerType_T aControllerType,
                                                            BOOL *aEnabled);
    STDMETHOD(GetMaxInstancesOfUSBControllerType)(ChipsetType_T aChipset,
                                                  USBControllerType_T aType,
                                                  ULONG *aMaxInstances);

private:
    // wrapped ISystemProperties properties
    virtual HRESULT getMinGuestRAM(ULONG *aMinGuestRAM) = 0;
    virtual HRESULT getMaxGuestRAM(ULONG *aMaxGuestRAM) = 0;
    virtual HRESULT getMinGuestVRAM(ULONG *aMinGuestVRAM) = 0;
    virtual HRESULT getMaxGuestVRAM(ULONG *aMaxGuestVRAM) = 0;
    virtual HRESULT getMinGuestCPUCount(ULONG *aMinGuestCPUCount) = 0;
    virtual HRESULT getMaxGuestCPUCount(ULONG *aMaxGuestCPUCount) = 0;
    virtual HRESULT getMaxGuestMonitors(ULONG *aMaxGuestMonitors) = 0;
    virtual HRESULT getInfoVDSize(LONG64 *aInfoVDSize) = 0;
    virtual HRESULT getSerialPortCount(ULONG *aSerialPortCount) = 0;
    virtual HRESULT getParallelPortCount(ULONG *aParallelPortCount) = 0;
    virtual HRESULT getMaxBootPosition(ULONG *aMaxBootPosition) = 0;
    virtual HRESULT getExclusiveHwVirt(BOOL *aExclusiveHwVirt) = 0;
    virtual HRESULT setExclusiveHwVirt(BOOL aExclusiveHwVirt) = 0;
    virtual HRESULT getDefaultMachineFolder(com::Utf8Str &aDefaultMachineFolder) = 0;
    virtual HRESULT setDefaultMachineFolder(const com::Utf8Str &aDefaultMachineFolder) = 0;
    virtual HRESULT getLoggingLevel(com::Utf8Str &aLoggingLevel) = 0;
    virtual HRESULT setLoggingLevel(const com::Utf8Str &aLoggingLevel) = 0;
    virtual HRESULT getMediumFormats(std::vector<ComPtr<IMediumFormat> > &aMediumFormats) = 0;
    virtual HRESULT getDefaultHardDiskFormat(com::Utf8Str &aDefaultHardDiskFormat) = 0;
    virtual HRESULT setDefaultHardDiskFormat(const com::Utf8Str &aDefaultHardDiskFormat) = 0;
    virtual HRESULT getFreeDiskSpaceWarning(LONG64 *aFreeDiskSpaceWarning) = 0;
    virtual HRESULT setFreeDiskSpaceWarning(LONG64 aFreeDiskSpaceWarning) = 0;
    virtual HRESULT getFreeDiskSpacePercentWarning(ULONG *aFreeDiskSpacePercentWarning) = 0;
    virtual HRESULT setFreeDiskSpacePercentWarning(ULONG aFreeDiskSpacePercentWarning) = 0;
    virtual HRESULT getFreeDiskSpaceError(LONG64 *aFreeDiskSpaceError) = 0;
    virtual HRESULT setFreeDiskSpaceError(LONG64 aFreeDiskSpaceError) = 0;
    virtual HRESULT getFreeDiskSpacePercentError(ULONG *aFreeDiskSpacePercentError) = 0;
    virtual HRESULT setFreeDiskSpacePercentError(ULONG aFreeDiskSpacePercentError) = 0;
    virtual HRESULT getVRDEAuthLibrary(com::Utf8Str &aVRDEAuthLibrary) = 0;
    virtual HRESULT setVRDEAuthLibrary(const com::Utf8Str &aVRDEAuthLibrary) = 0;
    virtual HRESULT getWebServiceAuthLibrary(com::Utf8Str &aWebServiceAuthLibrary) = 0;
    virtual HRESULT setWebServiceAuthLibrary(const com::Utf8Str &aWebServiceAuthLibrary) = 0;
    virtual HRESULT getDefaultVRDEExtPack(com::Utf8Str &aDefaultVRDEExtPack) = 0;
    virtual HRESULT setDefaultVRDEExtPack(const com::Utf8Str &aDefaultVRDEExtPack) = 0;
    virtual HRESULT getLogHistoryCount(ULONG *aLogHistoryCount) = 0;
    virtual HRESULT setLogHistoryCount(ULONG aLogHistoryCount) = 0;
    virtual HRESULT getDefaultAudioDriver(AudioDriverType_T *aDefaultAudioDriver) = 0;
    virtual HRESULT getAutostartDatabasePath(com::Utf8Str &aAutostartDatabasePath) = 0;
    virtual HRESULT setAutostartDatabasePath(const com::Utf8Str &aAutostartDatabasePath) = 0;
    virtual HRESULT getDefaultAdditionsISO(com::Utf8Str &aDefaultAdditionsISO) = 0;
    virtual HRESULT setDefaultAdditionsISO(const com::Utf8Str &aDefaultAdditionsISO) = 0;
    virtual HRESULT getDefaultFrontend(com::Utf8Str &aDefaultFrontend) = 0;
    virtual HRESULT setDefaultFrontend(const com::Utf8Str &aDefaultFrontend) = 0;

    // wrapped ISystemProperties methods
    virtual HRESULT getMaxNetworkAdapters(ChipsetType_T aChipset,
                                          ULONG *aMaxNetworkAdapters) = 0;
    virtual HRESULT getMaxNetworkAdaptersOfType(ChipsetType_T aChipset,
                                                NetworkAttachmentType_T aType,
                                                ULONG *aMaxNetworkAdapters) = 0;
    virtual HRESULT getMaxDevicesPerPortForStorageBus(StorageBus_T aBus,
                                                      ULONG *aMaxDevicesPerPort) = 0;
    virtual HRESULT getMinPortCountForStorageBus(StorageBus_T aBus,
                                                 ULONG *aMinPortCount) = 0;
    virtual HRESULT getMaxPortCountForStorageBus(StorageBus_T aBus,
                                                 ULONG *aMaxPortCount) = 0;
    virtual HRESULT getMaxInstancesOfStorageBus(ChipsetType_T aChipset,
                                                StorageBus_T aBus,
                                                ULONG *aMaxInstances) = 0;
    virtual HRESULT getDeviceTypesForStorageBus(StorageBus_T aBus,
                                                std::vector<DeviceType_T> &aDeviceTypes) = 0;
    virtual HRESULT getDefaultIoCacheSettingForStorageController(StorageControllerType_T aControllerType,
                                                                 BOOL *aEnabled) = 0;
    virtual HRESULT getMaxInstancesOfUSBControllerType(ChipsetType_T aChipset,
                                                       USBControllerType_T aType,
                                                       ULONG *aMaxInstances) = 0;
};

#endif // !SystemPropertiesWrap_H_

// ##### ENDFILE "SystemPropertiesWrap.h"

// ##### BEGINFILE "SystemPropertiesWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for ISystemProperties.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_SYSTEMPROPERTIES

#include "SystemPropertiesWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(SystemPropertiesWrap)

//
// ISystemProperties properties
//

STDMETHODIMP SystemPropertiesWrap::COMGETTER(MinGuestRAM)(ULONG *aMinGuestRAM)
{
    LogRelFlow(("{%p} %s: enter aMinGuestRAM=%p\n", this, "SystemProperties::getMinGuestRAM", aMinGuestRAM));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMinGuestRAM);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMinGuestRAM(aMinGuestRAM);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMinGuestRAM=%RU32 hrc=%Rhrc\n", this, "SystemProperties::getMinGuestRAM", *aMinGuestRAM, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(MaxGuestRAM)(ULONG *aMaxGuestRAM)
{
    LogRelFlow(("{%p} %s: enter aMaxGuestRAM=%p\n", this, "SystemProperties::getMaxGuestRAM", aMaxGuestRAM));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMaxGuestRAM);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMaxGuestRAM(aMaxGuestRAM);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMaxGuestRAM=%RU32 hrc=%Rhrc\n", this, "SystemProperties::getMaxGuestRAM", *aMaxGuestRAM, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(MinGuestVRAM)(ULONG *aMinGuestVRAM)
{
    LogRelFlow(("{%p} %s: enter aMinGuestVRAM=%p\n", this, "SystemProperties::getMinGuestVRAM", aMinGuestVRAM));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMinGuestVRAM);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMinGuestVRAM(aMinGuestVRAM);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMinGuestVRAM=%RU32 hrc=%Rhrc\n", this, "SystemProperties::getMinGuestVRAM", *aMinGuestVRAM, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(MaxGuestVRAM)(ULONG *aMaxGuestVRAM)
{
    LogRelFlow(("{%p} %s: enter aMaxGuestVRAM=%p\n", this, "SystemProperties::getMaxGuestVRAM", aMaxGuestVRAM));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMaxGuestVRAM);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMaxGuestVRAM(aMaxGuestVRAM);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMaxGuestVRAM=%RU32 hrc=%Rhrc\n", this, "SystemProperties::getMaxGuestVRAM", *aMaxGuestVRAM, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(MinGuestCPUCount)(ULONG *aMinGuestCPUCount)
{
    LogRelFlow(("{%p} %s: enter aMinGuestCPUCount=%p\n", this, "SystemProperties::getMinGuestCPUCount", aMinGuestCPUCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMinGuestCPUCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMinGuestCPUCount(aMinGuestCPUCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMinGuestCPUCount=%RU32 hrc=%Rhrc\n", this, "SystemProperties::getMinGuestCPUCount", *aMinGuestCPUCount, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(MaxGuestCPUCount)(ULONG *aMaxGuestCPUCount)
{
    LogRelFlow(("{%p} %s: enter aMaxGuestCPUCount=%p\n", this, "SystemProperties::getMaxGuestCPUCount", aMaxGuestCPUCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMaxGuestCPUCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMaxGuestCPUCount(aMaxGuestCPUCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMaxGuestCPUCount=%RU32 hrc=%Rhrc\n", this, "SystemProperties::getMaxGuestCPUCount", *aMaxGuestCPUCount, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(MaxGuestMonitors)(ULONG *aMaxGuestMonitors)
{
    LogRelFlow(("{%p} %s: enter aMaxGuestMonitors=%p\n", this, "SystemProperties::getMaxGuestMonitors", aMaxGuestMonitors));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMaxGuestMonitors);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMaxGuestMonitors(aMaxGuestMonitors);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMaxGuestMonitors=%RU32 hrc=%Rhrc\n", this, "SystemProperties::getMaxGuestMonitors", *aMaxGuestMonitors, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(InfoVDSize)(LONG64 *aInfoVDSize)
{
    LogRelFlow(("{%p} %s: enter aInfoVDSize=%p\n", this, "SystemProperties::getInfoVDSize", aInfoVDSize));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aInfoVDSize);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getInfoVDSize(aInfoVDSize);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aInfoVDSize=%RI64 hrc=%Rhrc\n", this, "SystemProperties::getInfoVDSize", *aInfoVDSize, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(SerialPortCount)(ULONG *aSerialPortCount)
{
    LogRelFlow(("{%p} %s: enter aSerialPortCount=%p\n", this, "SystemProperties::getSerialPortCount", aSerialPortCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSerialPortCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSerialPortCount(aSerialPortCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSerialPortCount=%RU32 hrc=%Rhrc\n", this, "SystemProperties::getSerialPortCount", *aSerialPortCount, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(ParallelPortCount)(ULONG *aParallelPortCount)
{
    LogRelFlow(("{%p} %s: enter aParallelPortCount=%p\n", this, "SystemProperties::getParallelPortCount", aParallelPortCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aParallelPortCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getParallelPortCount(aParallelPortCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aParallelPortCount=%RU32 hrc=%Rhrc\n", this, "SystemProperties::getParallelPortCount", *aParallelPortCount, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(MaxBootPosition)(ULONG *aMaxBootPosition)
{
    LogRelFlow(("{%p} %s: enter aMaxBootPosition=%p\n", this, "SystemProperties::getMaxBootPosition", aMaxBootPosition));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMaxBootPosition);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMaxBootPosition(aMaxBootPosition);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMaxBootPosition=%RU32 hrc=%Rhrc\n", this, "SystemProperties::getMaxBootPosition", *aMaxBootPosition, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(ExclusiveHwVirt)(BOOL *aExclusiveHwVirt)
{
    LogRelFlow(("{%p} %s: enter aExclusiveHwVirt=%p\n", this, "SystemProperties::getExclusiveHwVirt", aExclusiveHwVirt));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aExclusiveHwVirt);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getExclusiveHwVirt(aExclusiveHwVirt);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aExclusiveHwVirt=%RTbool hrc=%Rhrc\n", this, "SystemProperties::getExclusiveHwVirt", *aExclusiveHwVirt, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMSETTER(ExclusiveHwVirt)(BOOL aExclusiveHwVirt)
{
    LogRelFlow(("{%p} %s: enter aExclusiveHwVirt=%RTbool\n", this, "SystemProperties::setExclusiveHwVirt", aExclusiveHwVirt));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setExclusiveHwVirt(aExclusiveHwVirt);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SystemProperties::setExclusiveHwVirt", hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(DefaultMachineFolder)(BSTR *aDefaultMachineFolder)
{
    LogRelFlow(("{%p} %s: enter aDefaultMachineFolder=%p\n", this, "SystemProperties::getDefaultMachineFolder", aDefaultMachineFolder));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDefaultMachineFolder);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDefaultMachineFolder(BSTROutConverter(aDefaultMachineFolder).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDefaultMachineFolder=%ls hrc=%Rhrc\n", this, "SystemProperties::getDefaultMachineFolder", *aDefaultMachineFolder, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMSETTER(DefaultMachineFolder)(IN_BSTR aDefaultMachineFolder)
{
    LogRelFlow(("{%p} %s: enter aDefaultMachineFolder=%ls\n", this, "SystemProperties::setDefaultMachineFolder", aDefaultMachineFolder));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setDefaultMachineFolder(BSTRInConverter(aDefaultMachineFolder).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SystemProperties::setDefaultMachineFolder", hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(LoggingLevel)(BSTR *aLoggingLevel)
{
    LogRelFlow(("{%p} %s: enter aLoggingLevel=%p\n", this, "SystemProperties::getLoggingLevel", aLoggingLevel));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLoggingLevel);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLoggingLevel(BSTROutConverter(aLoggingLevel).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLoggingLevel=%ls hrc=%Rhrc\n", this, "SystemProperties::getLoggingLevel", *aLoggingLevel, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMSETTER(LoggingLevel)(IN_BSTR aLoggingLevel)
{
    LogRelFlow(("{%p} %s: enter aLoggingLevel=%ls\n", this, "SystemProperties::setLoggingLevel", aLoggingLevel));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setLoggingLevel(BSTRInConverter(aLoggingLevel).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SystemProperties::setLoggingLevel", hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(MediumFormats)(ComSafeArrayOut(IMediumFormat *, aMediumFormats))
{
    LogRelFlow(("{%p} %s: enter aMediumFormats=%p\n", this, "SystemProperties::getMediumFormats", aMediumFormats));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMediumFormats);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMediumFormats(ArrayComTypeOutConverter<IMediumFormat>(ComSafeArrayOutArg(aMediumFormats)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMediumFormats=%zu hrc=%Rhrc\n", this, "SystemProperties::getMediumFormats", ComSafeArraySize(*aMediumFormats), hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(DefaultHardDiskFormat)(BSTR *aDefaultHardDiskFormat)
{
    LogRelFlow(("{%p} %s: enter aDefaultHardDiskFormat=%p\n", this, "SystemProperties::getDefaultHardDiskFormat", aDefaultHardDiskFormat));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDefaultHardDiskFormat);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDefaultHardDiskFormat(BSTROutConverter(aDefaultHardDiskFormat).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDefaultHardDiskFormat=%ls hrc=%Rhrc\n", this, "SystemProperties::getDefaultHardDiskFormat", *aDefaultHardDiskFormat, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMSETTER(DefaultHardDiskFormat)(IN_BSTR aDefaultHardDiskFormat)
{
    LogRelFlow(("{%p} %s: enter aDefaultHardDiskFormat=%ls\n", this, "SystemProperties::setDefaultHardDiskFormat", aDefaultHardDiskFormat));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setDefaultHardDiskFormat(BSTRInConverter(aDefaultHardDiskFormat).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SystemProperties::setDefaultHardDiskFormat", hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(FreeDiskSpaceWarning)(LONG64 *aFreeDiskSpaceWarning)
{
    LogRelFlow(("{%p} %s: enter aFreeDiskSpaceWarning=%p\n", this, "SystemProperties::getFreeDiskSpaceWarning", aFreeDiskSpaceWarning));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFreeDiskSpaceWarning);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFreeDiskSpaceWarning(aFreeDiskSpaceWarning);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFreeDiskSpaceWarning=%RI64 hrc=%Rhrc\n", this, "SystemProperties::getFreeDiskSpaceWarning", *aFreeDiskSpaceWarning, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMSETTER(FreeDiskSpaceWarning)(LONG64 aFreeDiskSpaceWarning)
{
    LogRelFlow(("{%p} %s: enter aFreeDiskSpaceWarning=%RI64\n", this, "SystemProperties::setFreeDiskSpaceWarning", aFreeDiskSpaceWarning));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setFreeDiskSpaceWarning(aFreeDiskSpaceWarning);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SystemProperties::setFreeDiskSpaceWarning", hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(FreeDiskSpacePercentWarning)(ULONG *aFreeDiskSpacePercentWarning)
{
    LogRelFlow(("{%p} %s: enter aFreeDiskSpacePercentWarning=%p\n", this, "SystemProperties::getFreeDiskSpacePercentWarning", aFreeDiskSpacePercentWarning));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFreeDiskSpacePercentWarning);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFreeDiskSpacePercentWarning(aFreeDiskSpacePercentWarning);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFreeDiskSpacePercentWarning=%RU32 hrc=%Rhrc\n", this, "SystemProperties::getFreeDiskSpacePercentWarning", *aFreeDiskSpacePercentWarning, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMSETTER(FreeDiskSpacePercentWarning)(ULONG aFreeDiskSpacePercentWarning)
{
    LogRelFlow(("{%p} %s: enter aFreeDiskSpacePercentWarning=%RU32\n", this, "SystemProperties::setFreeDiskSpacePercentWarning", aFreeDiskSpacePercentWarning));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setFreeDiskSpacePercentWarning(aFreeDiskSpacePercentWarning);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SystemProperties::setFreeDiskSpacePercentWarning", hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(FreeDiskSpaceError)(LONG64 *aFreeDiskSpaceError)
{
    LogRelFlow(("{%p} %s: enter aFreeDiskSpaceError=%p\n", this, "SystemProperties::getFreeDiskSpaceError", aFreeDiskSpaceError));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFreeDiskSpaceError);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFreeDiskSpaceError(aFreeDiskSpaceError);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFreeDiskSpaceError=%RI64 hrc=%Rhrc\n", this, "SystemProperties::getFreeDiskSpaceError", *aFreeDiskSpaceError, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMSETTER(FreeDiskSpaceError)(LONG64 aFreeDiskSpaceError)
{
    LogRelFlow(("{%p} %s: enter aFreeDiskSpaceError=%RI64\n", this, "SystemProperties::setFreeDiskSpaceError", aFreeDiskSpaceError));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setFreeDiskSpaceError(aFreeDiskSpaceError);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SystemProperties::setFreeDiskSpaceError", hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(FreeDiskSpacePercentError)(ULONG *aFreeDiskSpacePercentError)
{
    LogRelFlow(("{%p} %s: enter aFreeDiskSpacePercentError=%p\n", this, "SystemProperties::getFreeDiskSpacePercentError", aFreeDiskSpacePercentError));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFreeDiskSpacePercentError);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFreeDiskSpacePercentError(aFreeDiskSpacePercentError);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFreeDiskSpacePercentError=%RU32 hrc=%Rhrc\n", this, "SystemProperties::getFreeDiskSpacePercentError", *aFreeDiskSpacePercentError, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMSETTER(FreeDiskSpacePercentError)(ULONG aFreeDiskSpacePercentError)
{
    LogRelFlow(("{%p} %s: enter aFreeDiskSpacePercentError=%RU32\n", this, "SystemProperties::setFreeDiskSpacePercentError", aFreeDiskSpacePercentError));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setFreeDiskSpacePercentError(aFreeDiskSpacePercentError);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SystemProperties::setFreeDiskSpacePercentError", hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(VRDEAuthLibrary)(BSTR *aVRDEAuthLibrary)
{
    LogRelFlow(("{%p} %s: enter aVRDEAuthLibrary=%p\n", this, "SystemProperties::getVRDEAuthLibrary", aVRDEAuthLibrary));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVRDEAuthLibrary);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVRDEAuthLibrary(BSTROutConverter(aVRDEAuthLibrary).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVRDEAuthLibrary=%ls hrc=%Rhrc\n", this, "SystemProperties::getVRDEAuthLibrary", *aVRDEAuthLibrary, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMSETTER(VRDEAuthLibrary)(IN_BSTR aVRDEAuthLibrary)
{
    LogRelFlow(("{%p} %s: enter aVRDEAuthLibrary=%ls\n", this, "SystemProperties::setVRDEAuthLibrary", aVRDEAuthLibrary));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setVRDEAuthLibrary(BSTRInConverter(aVRDEAuthLibrary).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SystemProperties::setVRDEAuthLibrary", hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(WebServiceAuthLibrary)(BSTR *aWebServiceAuthLibrary)
{
    LogRelFlow(("{%p} %s: enter aWebServiceAuthLibrary=%p\n", this, "SystemProperties::getWebServiceAuthLibrary", aWebServiceAuthLibrary));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWebServiceAuthLibrary);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWebServiceAuthLibrary(BSTROutConverter(aWebServiceAuthLibrary).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWebServiceAuthLibrary=%ls hrc=%Rhrc\n", this, "SystemProperties::getWebServiceAuthLibrary", *aWebServiceAuthLibrary, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMSETTER(WebServiceAuthLibrary)(IN_BSTR aWebServiceAuthLibrary)
{
    LogRelFlow(("{%p} %s: enter aWebServiceAuthLibrary=%ls\n", this, "SystemProperties::setWebServiceAuthLibrary", aWebServiceAuthLibrary));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setWebServiceAuthLibrary(BSTRInConverter(aWebServiceAuthLibrary).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SystemProperties::setWebServiceAuthLibrary", hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(DefaultVRDEExtPack)(BSTR *aDefaultVRDEExtPack)
{
    LogRelFlow(("{%p} %s: enter aDefaultVRDEExtPack=%p\n", this, "SystemProperties::getDefaultVRDEExtPack", aDefaultVRDEExtPack));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDefaultVRDEExtPack);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDefaultVRDEExtPack(BSTROutConverter(aDefaultVRDEExtPack).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDefaultVRDEExtPack=%ls hrc=%Rhrc\n", this, "SystemProperties::getDefaultVRDEExtPack", *aDefaultVRDEExtPack, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMSETTER(DefaultVRDEExtPack)(IN_BSTR aDefaultVRDEExtPack)
{
    LogRelFlow(("{%p} %s: enter aDefaultVRDEExtPack=%ls\n", this, "SystemProperties::setDefaultVRDEExtPack", aDefaultVRDEExtPack));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setDefaultVRDEExtPack(BSTRInConverter(aDefaultVRDEExtPack).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SystemProperties::setDefaultVRDEExtPack", hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(LogHistoryCount)(ULONG *aLogHistoryCount)
{
    LogRelFlow(("{%p} %s: enter aLogHistoryCount=%p\n", this, "SystemProperties::getLogHistoryCount", aLogHistoryCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLogHistoryCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLogHistoryCount(aLogHistoryCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLogHistoryCount=%RU32 hrc=%Rhrc\n", this, "SystemProperties::getLogHistoryCount", *aLogHistoryCount, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMSETTER(LogHistoryCount)(ULONG aLogHistoryCount)
{
    LogRelFlow(("{%p} %s: enter aLogHistoryCount=%RU32\n", this, "SystemProperties::setLogHistoryCount", aLogHistoryCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setLogHistoryCount(aLogHistoryCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SystemProperties::setLogHistoryCount", hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(DefaultAudioDriver)(AudioDriverType_T *aDefaultAudioDriver)
{
    LogRelFlow(("{%p} %s: enter aDefaultAudioDriver=%p\n", this, "SystemProperties::getDefaultAudioDriver", aDefaultAudioDriver));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDefaultAudioDriver);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDefaultAudioDriver(aDefaultAudioDriver);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDefaultAudioDriver=%RU32 hrc=%Rhrc\n", this, "SystemProperties::getDefaultAudioDriver", *aDefaultAudioDriver, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(AutostartDatabasePath)(BSTR *aAutostartDatabasePath)
{
    LogRelFlow(("{%p} %s: enter aAutostartDatabasePath=%p\n", this, "SystemProperties::getAutostartDatabasePath", aAutostartDatabasePath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAutostartDatabasePath);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAutostartDatabasePath(BSTROutConverter(aAutostartDatabasePath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAutostartDatabasePath=%ls hrc=%Rhrc\n", this, "SystemProperties::getAutostartDatabasePath", *aAutostartDatabasePath, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMSETTER(AutostartDatabasePath)(IN_BSTR aAutostartDatabasePath)
{
    LogRelFlow(("{%p} %s: enter aAutostartDatabasePath=%ls\n", this, "SystemProperties::setAutostartDatabasePath", aAutostartDatabasePath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setAutostartDatabasePath(BSTRInConverter(aAutostartDatabasePath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SystemProperties::setAutostartDatabasePath", hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(DefaultAdditionsISO)(BSTR *aDefaultAdditionsISO)
{
    LogRelFlow(("{%p} %s: enter aDefaultAdditionsISO=%p\n", this, "SystemProperties::getDefaultAdditionsISO", aDefaultAdditionsISO));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDefaultAdditionsISO);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDefaultAdditionsISO(BSTROutConverter(aDefaultAdditionsISO).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDefaultAdditionsISO=%ls hrc=%Rhrc\n", this, "SystemProperties::getDefaultAdditionsISO", *aDefaultAdditionsISO, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMSETTER(DefaultAdditionsISO)(IN_BSTR aDefaultAdditionsISO)
{
    LogRelFlow(("{%p} %s: enter aDefaultAdditionsISO=%ls\n", this, "SystemProperties::setDefaultAdditionsISO", aDefaultAdditionsISO));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setDefaultAdditionsISO(BSTRInConverter(aDefaultAdditionsISO).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SystemProperties::setDefaultAdditionsISO", hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMGETTER(DefaultFrontend)(BSTR *aDefaultFrontend)
{
    LogRelFlow(("{%p} %s: enter aDefaultFrontend=%p\n", this, "SystemProperties::getDefaultFrontend", aDefaultFrontend));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDefaultFrontend);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDefaultFrontend(BSTROutConverter(aDefaultFrontend).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDefaultFrontend=%ls hrc=%Rhrc\n", this, "SystemProperties::getDefaultFrontend", *aDefaultFrontend, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::COMSETTER(DefaultFrontend)(IN_BSTR aDefaultFrontend)
{
    LogRelFlow(("{%p} %s: enter aDefaultFrontend=%ls\n", this, "SystemProperties::setDefaultFrontend", aDefaultFrontend));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setDefaultFrontend(BSTRInConverter(aDefaultFrontend).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SystemProperties::setDefaultFrontend", hrc));
    return hrc;
}

//
// ISystemProperties methods
//

STDMETHODIMP SystemPropertiesWrap::GetMaxNetworkAdapters(ChipsetType_T aChipset,
                                                         ULONG *aMaxNetworkAdapters)
{
    LogRelFlow(("{%p} %s:enter aChipset=%RU32 aMaxNetworkAdapters=%p\n", this, "SystemProperties::getMaxNetworkAdapters", aChipset, aMaxNetworkAdapters));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMaxNetworkAdapters);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMaxNetworkAdapters(aChipset,
                                    aMaxNetworkAdapters);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aMaxNetworkAdapters=%RU32 hrc=%Rhrc\n", this, "SystemProperties::getMaxNetworkAdapters", *aMaxNetworkAdapters, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::GetMaxNetworkAdaptersOfType(ChipsetType_T aChipset,
                                                               NetworkAttachmentType_T aType,
                                                               ULONG *aMaxNetworkAdapters)
{
    LogRelFlow(("{%p} %s:enter aChipset=%RU32 aType=%RU32 aMaxNetworkAdapters=%p\n", this, "SystemProperties::getMaxNetworkAdaptersOfType", aChipset, aType, aMaxNetworkAdapters));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMaxNetworkAdapters);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMaxNetworkAdaptersOfType(aChipset,
                                          aType,
                                          aMaxNetworkAdapters);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aMaxNetworkAdapters=%RU32 hrc=%Rhrc\n", this, "SystemProperties::getMaxNetworkAdaptersOfType", *aMaxNetworkAdapters, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::GetMaxDevicesPerPortForStorageBus(StorageBus_T aBus,
                                                                     ULONG *aMaxDevicesPerPort)
{
    LogRelFlow(("{%p} %s:enter aBus=%RU32 aMaxDevicesPerPort=%p\n", this, "SystemProperties::getMaxDevicesPerPortForStorageBus", aBus, aMaxDevicesPerPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMaxDevicesPerPort);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMaxDevicesPerPortForStorageBus(aBus,
                                                aMaxDevicesPerPort);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aMaxDevicesPerPort=%RU32 hrc=%Rhrc\n", this, "SystemProperties::getMaxDevicesPerPortForStorageBus", *aMaxDevicesPerPort, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::GetMinPortCountForStorageBus(StorageBus_T aBus,
                                                                ULONG *aMinPortCount)
{
    LogRelFlow(("{%p} %s:enter aBus=%RU32 aMinPortCount=%p\n", this, "SystemProperties::getMinPortCountForStorageBus", aBus, aMinPortCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMinPortCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMinPortCountForStorageBus(aBus,
                                           aMinPortCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aMinPortCount=%RU32 hrc=%Rhrc\n", this, "SystemProperties::getMinPortCountForStorageBus", *aMinPortCount, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::GetMaxPortCountForStorageBus(StorageBus_T aBus,
                                                                ULONG *aMaxPortCount)
{
    LogRelFlow(("{%p} %s:enter aBus=%RU32 aMaxPortCount=%p\n", this, "SystemProperties::getMaxPortCountForStorageBus", aBus, aMaxPortCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMaxPortCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMaxPortCountForStorageBus(aBus,
                                           aMaxPortCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aMaxPortCount=%RU32 hrc=%Rhrc\n", this, "SystemProperties::getMaxPortCountForStorageBus", *aMaxPortCount, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::GetMaxInstancesOfStorageBus(ChipsetType_T aChipset,
                                                               StorageBus_T aBus,
                                                               ULONG *aMaxInstances)
{
    LogRelFlow(("{%p} %s:enter aChipset=%RU32 aBus=%RU32 aMaxInstances=%p\n", this, "SystemProperties::getMaxInstancesOfStorageBus", aChipset, aBus, aMaxInstances));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMaxInstances);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMaxInstancesOfStorageBus(aChipset,
                                          aBus,
                                          aMaxInstances);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aMaxInstances=%RU32 hrc=%Rhrc\n", this, "SystemProperties::getMaxInstancesOfStorageBus", *aMaxInstances, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::GetDeviceTypesForStorageBus(StorageBus_T aBus,
                                                               ComSafeArrayOut(DeviceType_T, aDeviceTypes))
{
    LogRelFlow(("{%p} %s:enter aBus=%RU32 aDeviceTypes=%p\n", this, "SystemProperties::getDeviceTypesForStorageBus", aBus, aDeviceTypes));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDeviceTypes);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDeviceTypesForStorageBus(aBus,
                                          ArrayOutConverter<DeviceType_T>(ComSafeArrayOutArg(aDeviceTypes)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aDeviceTypes=%zu hrc=%Rhrc\n", this, "SystemProperties::getDeviceTypesForStorageBus", ComSafeArraySize(*aDeviceTypes), hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::GetDefaultIoCacheSettingForStorageController(StorageControllerType_T aControllerType,
                                                                                BOOL *aEnabled)
{
    LogRelFlow(("{%p} %s:enter aControllerType=%RU32 aEnabled=%p\n", this, "SystemProperties::getDefaultIoCacheSettingForStorageController", aControllerType, aEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDefaultIoCacheSettingForStorageController(aControllerType,
                                                           aEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aEnabled=%RTbool hrc=%Rhrc\n", this, "SystemProperties::getDefaultIoCacheSettingForStorageController", *aEnabled, hrc));
    return hrc;
}

STDMETHODIMP SystemPropertiesWrap::GetMaxInstancesOfUSBControllerType(ChipsetType_T aChipset,
                                                                      USBControllerType_T aType,
                                                                      ULONG *aMaxInstances)
{
    LogRelFlow(("{%p} %s:enter aChipset=%RU32 aType=%RU32 aMaxInstances=%p\n", this, "SystemProperties::getMaxInstancesOfUSBControllerType", aChipset, aType, aMaxInstances));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMaxInstances);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMaxInstancesOfUSBControllerType(aChipset,
                                                 aType,
                                                 aMaxInstances);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aMaxInstances=%RU32 hrc=%Rhrc\n", this, "SystemProperties::getMaxInstancesOfUSBControllerType", *aMaxInstances, hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(SystemPropertiesWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(SystemPropertiesWrap, ISystemProperties)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "SystemPropertiesWrap.cpp"

// ##### BEGINFILE "GuestOSTypeWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestOSType.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestOSTypeWrap_H_
#define GuestOSTypeWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestOSTypeWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestOSType)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestOSTypeWrap, IGuestOSType)
    DECLARE_NOT_AGGREGATABLE(GuestOSTypeWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestOSTypeWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestOSType)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestOSType)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestOSTypeWrap)

    // public IGuestOSType properties
    STDMETHOD(COMGETTER(FamilyId))(BSTR *aFamilyId);
    STDMETHOD(COMGETTER(FamilyDescription))(BSTR *aFamilyDescription);
    STDMETHOD(COMGETTER(Id))(BSTR *aId);
    STDMETHOD(COMGETTER(Description))(BSTR *aDescription);
    STDMETHOD(COMGETTER(Is64Bit))(BOOL *aIs64Bit);
    STDMETHOD(COMGETTER(RecommendedIOAPIC))(BOOL *aRecommendedIOAPIC);
    STDMETHOD(COMGETTER(RecommendedVirtEx))(BOOL *aRecommendedVirtEx);
    STDMETHOD(COMGETTER(RecommendedRAM))(ULONG *aRecommendedRAM);
    STDMETHOD(COMGETTER(RecommendedVRAM))(ULONG *aRecommendedVRAM);
    STDMETHOD(COMGETTER(Recommended2DVideoAcceleration))(BOOL *aRecommended2DVideoAcceleration);
    STDMETHOD(COMGETTER(Recommended3DAcceleration))(BOOL *aRecommended3DAcceleration);
    STDMETHOD(COMGETTER(RecommendedHDD))(LONG64 *aRecommendedHDD);
    STDMETHOD(COMGETTER(AdapterType))(NetworkAdapterType_T *aAdapterType);
    STDMETHOD(COMGETTER(RecommendedPAE))(BOOL *aRecommendedPAE);
    STDMETHOD(COMGETTER(RecommendedDVDStorageController))(StorageControllerType_T *aRecommendedDVDStorageController);
    STDMETHOD(COMGETTER(RecommendedDVDStorageBus))(StorageBus_T *aRecommendedDVDStorageBus);
    STDMETHOD(COMGETTER(RecommendedHDStorageController))(StorageControllerType_T *aRecommendedHDStorageController);
    STDMETHOD(COMGETTER(RecommendedHDStorageBus))(StorageBus_T *aRecommendedHDStorageBus);
    STDMETHOD(COMGETTER(RecommendedFirmware))(FirmwareType_T *aRecommendedFirmware);
    STDMETHOD(COMGETTER(RecommendedUSBHID))(BOOL *aRecommendedUSBHID);
    STDMETHOD(COMGETTER(RecommendedHPET))(BOOL *aRecommendedHPET);
    STDMETHOD(COMGETTER(RecommendedUSBTablet))(BOOL *aRecommendedUSBTablet);
    STDMETHOD(COMGETTER(RecommendedRTCUseUTC))(BOOL *aRecommendedRTCUseUTC);
    STDMETHOD(COMGETTER(RecommendedChipset))(ChipsetType_T *aRecommendedChipset);
    STDMETHOD(COMGETTER(RecommendedAudioController))(AudioControllerType_T *aRecommendedAudioController);
    STDMETHOD(COMGETTER(RecommendedFloppy))(BOOL *aRecommendedFloppy);
    STDMETHOD(COMGETTER(RecommendedUSB))(BOOL *aRecommendedUSB);

    // public IGuestOSType methods

private:
    // wrapped IGuestOSType properties
    virtual HRESULT getFamilyId(com::Utf8Str &aFamilyId) = 0;
    virtual HRESULT getFamilyDescription(com::Utf8Str &aFamilyDescription) = 0;
    virtual HRESULT getId(com::Utf8Str &aId) = 0;
    virtual HRESULT getDescription(com::Utf8Str &aDescription) = 0;
    virtual HRESULT getIs64Bit(BOOL *aIs64Bit) = 0;
    virtual HRESULT getRecommendedIOAPIC(BOOL *aRecommendedIOAPIC) = 0;
    virtual HRESULT getRecommendedVirtEx(BOOL *aRecommendedVirtEx) = 0;
    virtual HRESULT getRecommendedRAM(ULONG *aRecommendedRAM) = 0;
    virtual HRESULT getRecommendedVRAM(ULONG *aRecommendedVRAM) = 0;
    virtual HRESULT getRecommended2DVideoAcceleration(BOOL *aRecommended2DVideoAcceleration) = 0;
    virtual HRESULT getRecommended3DAcceleration(BOOL *aRecommended3DAcceleration) = 0;
    virtual HRESULT getRecommendedHDD(LONG64 *aRecommendedHDD) = 0;
    virtual HRESULT getAdapterType(NetworkAdapterType_T *aAdapterType) = 0;
    virtual HRESULT getRecommendedPAE(BOOL *aRecommendedPAE) = 0;
    virtual HRESULT getRecommendedDVDStorageController(StorageControllerType_T *aRecommendedDVDStorageController) = 0;
    virtual HRESULT getRecommendedDVDStorageBus(StorageBus_T *aRecommendedDVDStorageBus) = 0;
    virtual HRESULT getRecommendedHDStorageController(StorageControllerType_T *aRecommendedHDStorageController) = 0;
    virtual HRESULT getRecommendedHDStorageBus(StorageBus_T *aRecommendedHDStorageBus) = 0;
    virtual HRESULT getRecommendedFirmware(FirmwareType_T *aRecommendedFirmware) = 0;
    virtual HRESULT getRecommendedUSBHID(BOOL *aRecommendedUSBHID) = 0;
    virtual HRESULT getRecommendedHPET(BOOL *aRecommendedHPET) = 0;
    virtual HRESULT getRecommendedUSBTablet(BOOL *aRecommendedUSBTablet) = 0;
    virtual HRESULT getRecommendedRTCUseUTC(BOOL *aRecommendedRTCUseUTC) = 0;
    virtual HRESULT getRecommendedChipset(ChipsetType_T *aRecommendedChipset) = 0;
    virtual HRESULT getRecommendedAudioController(AudioControllerType_T *aRecommendedAudioController) = 0;
    virtual HRESULT getRecommendedFloppy(BOOL *aRecommendedFloppy) = 0;
    virtual HRESULT getRecommendedUSB(BOOL *aRecommendedUSB) = 0;

    // wrapped IGuestOSType methods
};

#endif // !GuestOSTypeWrap_H_

// ##### ENDFILE "GuestOSTypeWrap.h"

// ##### BEGINFILE "GuestOSTypeWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestOSType.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTOSTYPE

#include "GuestOSTypeWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestOSTypeWrap)

//
// IGuestOSType properties
//

STDMETHODIMP GuestOSTypeWrap::COMGETTER(FamilyId)(BSTR *aFamilyId)
{
    LogRelFlow(("{%p} %s: enter aFamilyId=%p\n", this, "GuestOSType::getFamilyId", aFamilyId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFamilyId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFamilyId(BSTROutConverter(aFamilyId).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFamilyId=%ls hrc=%Rhrc\n", this, "GuestOSType::getFamilyId", *aFamilyId, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(FamilyDescription)(BSTR *aFamilyDescription)
{
    LogRelFlow(("{%p} %s: enter aFamilyDescription=%p\n", this, "GuestOSType::getFamilyDescription", aFamilyDescription));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFamilyDescription);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFamilyDescription(BSTROutConverter(aFamilyDescription).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFamilyDescription=%ls hrc=%Rhrc\n", this, "GuestOSType::getFamilyDescription", *aFamilyDescription, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(Id)(BSTR *aId)
{
    LogRelFlow(("{%p} %s: enter aId=%p\n", this, "GuestOSType::getId", aId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getId(BSTROutConverter(aId).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aId=%ls hrc=%Rhrc\n", this, "GuestOSType::getId", *aId, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(Description)(BSTR *aDescription)
{
    LogRelFlow(("{%p} %s: enter aDescription=%p\n", this, "GuestOSType::getDescription", aDescription));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDescription);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDescription(BSTROutConverter(aDescription).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDescription=%ls hrc=%Rhrc\n", this, "GuestOSType::getDescription", *aDescription, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(Is64Bit)(BOOL *aIs64Bit)
{
    LogRelFlow(("{%p} %s: enter aIs64Bit=%p\n", this, "GuestOSType::getIs64Bit", aIs64Bit));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aIs64Bit);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getIs64Bit(aIs64Bit);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aIs64Bit=%RTbool hrc=%Rhrc\n", this, "GuestOSType::getIs64Bit", *aIs64Bit, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(RecommendedIOAPIC)(BOOL *aRecommendedIOAPIC)
{
    LogRelFlow(("{%p} %s: enter aRecommendedIOAPIC=%p\n", this, "GuestOSType::getRecommendedIOAPIC", aRecommendedIOAPIC));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecommendedIOAPIC);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecommendedIOAPIC(aRecommendedIOAPIC);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecommendedIOAPIC=%RTbool hrc=%Rhrc\n", this, "GuestOSType::getRecommendedIOAPIC", *aRecommendedIOAPIC, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(RecommendedVirtEx)(BOOL *aRecommendedVirtEx)
{
    LogRelFlow(("{%p} %s: enter aRecommendedVirtEx=%p\n", this, "GuestOSType::getRecommendedVirtEx", aRecommendedVirtEx));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecommendedVirtEx);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecommendedVirtEx(aRecommendedVirtEx);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecommendedVirtEx=%RTbool hrc=%Rhrc\n", this, "GuestOSType::getRecommendedVirtEx", *aRecommendedVirtEx, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(RecommendedRAM)(ULONG *aRecommendedRAM)
{
    LogRelFlow(("{%p} %s: enter aRecommendedRAM=%p\n", this, "GuestOSType::getRecommendedRAM", aRecommendedRAM));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecommendedRAM);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecommendedRAM(aRecommendedRAM);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecommendedRAM=%RU32 hrc=%Rhrc\n", this, "GuestOSType::getRecommendedRAM", *aRecommendedRAM, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(RecommendedVRAM)(ULONG *aRecommendedVRAM)
{
    LogRelFlow(("{%p} %s: enter aRecommendedVRAM=%p\n", this, "GuestOSType::getRecommendedVRAM", aRecommendedVRAM));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecommendedVRAM);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecommendedVRAM(aRecommendedVRAM);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecommendedVRAM=%RU32 hrc=%Rhrc\n", this, "GuestOSType::getRecommendedVRAM", *aRecommendedVRAM, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(Recommended2DVideoAcceleration)(BOOL *aRecommended2DVideoAcceleration)
{
    LogRelFlow(("{%p} %s: enter aRecommended2DVideoAcceleration=%p\n", this, "GuestOSType::getRecommended2DVideoAcceleration", aRecommended2DVideoAcceleration));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecommended2DVideoAcceleration);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecommended2DVideoAcceleration(aRecommended2DVideoAcceleration);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecommended2DVideoAcceleration=%RTbool hrc=%Rhrc\n", this, "GuestOSType::getRecommended2DVideoAcceleration", *aRecommended2DVideoAcceleration, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(Recommended3DAcceleration)(BOOL *aRecommended3DAcceleration)
{
    LogRelFlow(("{%p} %s: enter aRecommended3DAcceleration=%p\n", this, "GuestOSType::getRecommended3DAcceleration", aRecommended3DAcceleration));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecommended3DAcceleration);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecommended3DAcceleration(aRecommended3DAcceleration);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecommended3DAcceleration=%RTbool hrc=%Rhrc\n", this, "GuestOSType::getRecommended3DAcceleration", *aRecommended3DAcceleration, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(RecommendedHDD)(LONG64 *aRecommendedHDD)
{
    LogRelFlow(("{%p} %s: enter aRecommendedHDD=%p\n", this, "GuestOSType::getRecommendedHDD", aRecommendedHDD));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecommendedHDD);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecommendedHDD(aRecommendedHDD);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecommendedHDD=%RI64 hrc=%Rhrc\n", this, "GuestOSType::getRecommendedHDD", *aRecommendedHDD, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(AdapterType)(NetworkAdapterType_T *aAdapterType)
{
    LogRelFlow(("{%p} %s: enter aAdapterType=%p\n", this, "GuestOSType::getAdapterType", aAdapterType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAdapterType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAdapterType(aAdapterType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAdapterType=%RU32 hrc=%Rhrc\n", this, "GuestOSType::getAdapterType", *aAdapterType, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(RecommendedPAE)(BOOL *aRecommendedPAE)
{
    LogRelFlow(("{%p} %s: enter aRecommendedPAE=%p\n", this, "GuestOSType::getRecommendedPAE", aRecommendedPAE));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecommendedPAE);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecommendedPAE(aRecommendedPAE);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecommendedPAE=%RTbool hrc=%Rhrc\n", this, "GuestOSType::getRecommendedPAE", *aRecommendedPAE, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(RecommendedDVDStorageController)(StorageControllerType_T *aRecommendedDVDStorageController)
{
    LogRelFlow(("{%p} %s: enter aRecommendedDVDStorageController=%p\n", this, "GuestOSType::getRecommendedDVDStorageController", aRecommendedDVDStorageController));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecommendedDVDStorageController);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecommendedDVDStorageController(aRecommendedDVDStorageController);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecommendedDVDStorageController=%RU32 hrc=%Rhrc\n", this, "GuestOSType::getRecommendedDVDStorageController", *aRecommendedDVDStorageController, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(RecommendedDVDStorageBus)(StorageBus_T *aRecommendedDVDStorageBus)
{
    LogRelFlow(("{%p} %s: enter aRecommendedDVDStorageBus=%p\n", this, "GuestOSType::getRecommendedDVDStorageBus", aRecommendedDVDStorageBus));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecommendedDVDStorageBus);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecommendedDVDStorageBus(aRecommendedDVDStorageBus);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecommendedDVDStorageBus=%RU32 hrc=%Rhrc\n", this, "GuestOSType::getRecommendedDVDStorageBus", *aRecommendedDVDStorageBus, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(RecommendedHDStorageController)(StorageControllerType_T *aRecommendedHDStorageController)
{
    LogRelFlow(("{%p} %s: enter aRecommendedHDStorageController=%p\n", this, "GuestOSType::getRecommendedHDStorageController", aRecommendedHDStorageController));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecommendedHDStorageController);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecommendedHDStorageController(aRecommendedHDStorageController);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecommendedHDStorageController=%RU32 hrc=%Rhrc\n", this, "GuestOSType::getRecommendedHDStorageController", *aRecommendedHDStorageController, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(RecommendedHDStorageBus)(StorageBus_T *aRecommendedHDStorageBus)
{
    LogRelFlow(("{%p} %s: enter aRecommendedHDStorageBus=%p\n", this, "GuestOSType::getRecommendedHDStorageBus", aRecommendedHDStorageBus));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecommendedHDStorageBus);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecommendedHDStorageBus(aRecommendedHDStorageBus);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecommendedHDStorageBus=%RU32 hrc=%Rhrc\n", this, "GuestOSType::getRecommendedHDStorageBus", *aRecommendedHDStorageBus, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(RecommendedFirmware)(FirmwareType_T *aRecommendedFirmware)
{
    LogRelFlow(("{%p} %s: enter aRecommendedFirmware=%p\n", this, "GuestOSType::getRecommendedFirmware", aRecommendedFirmware));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecommendedFirmware);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecommendedFirmware(aRecommendedFirmware);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecommendedFirmware=%RU32 hrc=%Rhrc\n", this, "GuestOSType::getRecommendedFirmware", *aRecommendedFirmware, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(RecommendedUSBHID)(BOOL *aRecommendedUSBHID)
{
    LogRelFlow(("{%p} %s: enter aRecommendedUSBHID=%p\n", this, "GuestOSType::getRecommendedUSBHID", aRecommendedUSBHID));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecommendedUSBHID);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecommendedUSBHID(aRecommendedUSBHID);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecommendedUSBHID=%RTbool hrc=%Rhrc\n", this, "GuestOSType::getRecommendedUSBHID", *aRecommendedUSBHID, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(RecommendedHPET)(BOOL *aRecommendedHPET)
{
    LogRelFlow(("{%p} %s: enter aRecommendedHPET=%p\n", this, "GuestOSType::getRecommendedHPET", aRecommendedHPET));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecommendedHPET);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecommendedHPET(aRecommendedHPET);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecommendedHPET=%RTbool hrc=%Rhrc\n", this, "GuestOSType::getRecommendedHPET", *aRecommendedHPET, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(RecommendedUSBTablet)(BOOL *aRecommendedUSBTablet)
{
    LogRelFlow(("{%p} %s: enter aRecommendedUSBTablet=%p\n", this, "GuestOSType::getRecommendedUSBTablet", aRecommendedUSBTablet));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecommendedUSBTablet);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecommendedUSBTablet(aRecommendedUSBTablet);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecommendedUSBTablet=%RTbool hrc=%Rhrc\n", this, "GuestOSType::getRecommendedUSBTablet", *aRecommendedUSBTablet, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(RecommendedRTCUseUTC)(BOOL *aRecommendedRTCUseUTC)
{
    LogRelFlow(("{%p} %s: enter aRecommendedRTCUseUTC=%p\n", this, "GuestOSType::getRecommendedRTCUseUTC", aRecommendedRTCUseUTC));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecommendedRTCUseUTC);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecommendedRTCUseUTC(aRecommendedRTCUseUTC);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecommendedRTCUseUTC=%RTbool hrc=%Rhrc\n", this, "GuestOSType::getRecommendedRTCUseUTC", *aRecommendedRTCUseUTC, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(RecommendedChipset)(ChipsetType_T *aRecommendedChipset)
{
    LogRelFlow(("{%p} %s: enter aRecommendedChipset=%p\n", this, "GuestOSType::getRecommendedChipset", aRecommendedChipset));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecommendedChipset);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecommendedChipset(aRecommendedChipset);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecommendedChipset=%RU32 hrc=%Rhrc\n", this, "GuestOSType::getRecommendedChipset", *aRecommendedChipset, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(RecommendedAudioController)(AudioControllerType_T *aRecommendedAudioController)
{
    LogRelFlow(("{%p} %s: enter aRecommendedAudioController=%p\n", this, "GuestOSType::getRecommendedAudioController", aRecommendedAudioController));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecommendedAudioController);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecommendedAudioController(aRecommendedAudioController);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecommendedAudioController=%RU32 hrc=%Rhrc\n", this, "GuestOSType::getRecommendedAudioController", *aRecommendedAudioController, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(RecommendedFloppy)(BOOL *aRecommendedFloppy)
{
    LogRelFlow(("{%p} %s: enter aRecommendedFloppy=%p\n", this, "GuestOSType::getRecommendedFloppy", aRecommendedFloppy));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecommendedFloppy);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecommendedFloppy(aRecommendedFloppy);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecommendedFloppy=%RTbool hrc=%Rhrc\n", this, "GuestOSType::getRecommendedFloppy", *aRecommendedFloppy, hrc));
    return hrc;
}

STDMETHODIMP GuestOSTypeWrap::COMGETTER(RecommendedUSB)(BOOL *aRecommendedUSB)
{
    LogRelFlow(("{%p} %s: enter aRecommendedUSB=%p\n", this, "GuestOSType::getRecommendedUSB", aRecommendedUSB));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecommendedUSB);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecommendedUSB(aRecommendedUSB);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecommendedUSB=%RTbool hrc=%Rhrc\n", this, "GuestOSType::getRecommendedUSB", *aRecommendedUSB, hrc));
    return hrc;
}

//
// IGuestOSType methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestOSTypeWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(GuestOSTypeWrap, IGuestOSType)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestOSTypeWrap.cpp"

// ##### BEGINFILE "AdditionsFacilityWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IAdditionsFacility.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef AdditionsFacilityWrap_H_
#define AdditionsFacilityWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE AdditionsFacilityWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IAdditionsFacility)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(AdditionsFacilityWrap, IAdditionsFacility)
    DECLARE_NOT_AGGREGATABLE(AdditionsFacilityWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(AdditionsFacilityWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IAdditionsFacility)
        COM_INTERFACE_ENTRY2(IDispatch, IAdditionsFacility)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(AdditionsFacilityWrap)

    // public IAdditionsFacility properties
    STDMETHOD(COMGETTER(ClassType))(AdditionsFacilityClass_T *aClassType);
    STDMETHOD(COMGETTER(LastUpdated))(LONG64 *aLastUpdated);
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(Status))(AdditionsFacilityStatus_T *aStatus);
    STDMETHOD(COMGETTER(Type))(AdditionsFacilityType_T *aType);

    // public IAdditionsFacility methods

private:
    // wrapped IAdditionsFacility properties
    virtual HRESULT getClassType(AdditionsFacilityClass_T *aClassType) = 0;
    virtual HRESULT getLastUpdated(LONG64 *aLastUpdated) = 0;
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getStatus(AdditionsFacilityStatus_T *aStatus) = 0;
    virtual HRESULT getType(AdditionsFacilityType_T *aType) = 0;

    // wrapped IAdditionsFacility methods
};

#endif // !AdditionsFacilityWrap_H_

// ##### ENDFILE "AdditionsFacilityWrap.h"

// ##### BEGINFILE "AdditionsFacilityWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IAdditionsFacility.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_ADDITIONSFACILITY

#include "AdditionsFacilityWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(AdditionsFacilityWrap)

//
// IAdditionsFacility properties
//

STDMETHODIMP AdditionsFacilityWrap::COMGETTER(ClassType)(AdditionsFacilityClass_T *aClassType)
{
    LogRelFlow(("{%p} %s: enter aClassType=%p\n", this, "AdditionsFacility::getClassType", aClassType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aClassType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getClassType(aClassType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aClassType=%RU32 hrc=%Rhrc\n", this, "AdditionsFacility::getClassType", *aClassType, hrc));
    return hrc;
}

STDMETHODIMP AdditionsFacilityWrap::COMGETTER(LastUpdated)(LONG64 *aLastUpdated)
{
    LogRelFlow(("{%p} %s: enter aLastUpdated=%p\n", this, "AdditionsFacility::getLastUpdated", aLastUpdated));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLastUpdated);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLastUpdated(aLastUpdated);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLastUpdated=%RI64 hrc=%Rhrc\n", this, "AdditionsFacility::getLastUpdated", *aLastUpdated, hrc));
    return hrc;
}

STDMETHODIMP AdditionsFacilityWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "AdditionsFacility::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "AdditionsFacility::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP AdditionsFacilityWrap::COMGETTER(Status)(AdditionsFacilityStatus_T *aStatus)
{
    LogRelFlow(("{%p} %s: enter aStatus=%p\n", this, "AdditionsFacility::getStatus", aStatus));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStatus);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getStatus(aStatus);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aStatus=%RU32 hrc=%Rhrc\n", this, "AdditionsFacility::getStatus", *aStatus, hrc));
    return hrc;
}

STDMETHODIMP AdditionsFacilityWrap::COMGETTER(Type)(AdditionsFacilityType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "AdditionsFacility::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "AdditionsFacility::getType", *aType, hrc));
    return hrc;
}

//
// IAdditionsFacility methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(AdditionsFacilityWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(AdditionsFacilityWrap, IAdditionsFacility)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "AdditionsFacilityWrap.cpp"

// ##### BEGINFILE "GuestSessionWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestSession.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestSessionWrap_H_
#define GuestSessionWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestSessionWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestSession)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestSessionWrap, IGuestSession)
    DECLARE_NOT_AGGREGATABLE(GuestSessionWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestSessionWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestSession)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestSession)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestSessionWrap)

    // public IGuestSession properties
    STDMETHOD(COMGETTER(User))(BSTR *aUser);
    STDMETHOD(COMGETTER(Domain))(BSTR *aDomain);
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(Id))(ULONG *aId);
    STDMETHOD(COMGETTER(Timeout))(ULONG *aTimeout);
    STDMETHOD(COMSETTER(Timeout))(ULONG aTimeout);
    STDMETHOD(COMGETTER(ProtocolVersion))(ULONG *aProtocolVersion);
    STDMETHOD(COMGETTER(Status))(GuestSessionStatus_T *aStatus);
    STDMETHOD(COMGETTER(Environment))(ComSafeArrayOut(BSTR, aEnvironment));
    STDMETHOD(COMSETTER(Environment))(ComSafeArrayIn(IN_BSTR, aEnvironment));
    STDMETHOD(COMGETTER(Processes))(ComSafeArrayOut(IGuestProcess *, aProcesses));
    STDMETHOD(COMGETTER(Directories))(ComSafeArrayOut(IGuestDirectory *, aDirectories));
    STDMETHOD(COMGETTER(Files))(ComSafeArrayOut(IGuestFile *, aFiles));
    STDMETHOD(COMGETTER(EventSource))(IEventSource **aEventSource);

    // public IGuestSession methods
    STDMETHOD(Close)();
    STDMETHOD(CopyFrom)(IN_BSTR aSource,
                        IN_BSTR aDest,
                        ComSafeArrayIn(CopyFileFlag_T, aFlags),
                        IProgress **aProgress);
    STDMETHOD(CopyTo)(IN_BSTR aSource,
                      IN_BSTR aDest,
                      ComSafeArrayIn(CopyFileFlag_T, aFlags),
                      IProgress **aProgress);
    STDMETHOD(DirectoryCreate)(IN_BSTR aPath,
                               ULONG aMode,
                               ComSafeArrayIn(DirectoryCreateFlag_T, aFlags));
    STDMETHOD(DirectoryCreateTemp)(IN_BSTR aTemplateName,
                                   ULONG aMode,
                                   IN_BSTR aPath,
                                   BOOL aSecure,
                                   BSTR *aDirectory);
    STDMETHOD(DirectoryExists)(IN_BSTR aPath,
                               BOOL *aExists);
    STDMETHOD(DirectoryOpen)(IN_BSTR aPath,
                             IN_BSTR aFilter,
                             ComSafeArrayIn(DirectoryOpenFlag_T, aFlags),
                             IGuestDirectory **aDirectory);
    STDMETHOD(DirectoryQueryInfo)(IN_BSTR aPath,
                                  IGuestFsObjInfo **aInfo);
    STDMETHOD(DirectoryRemove)(IN_BSTR aPath);
    STDMETHOD(DirectoryRemoveRecursive)(IN_BSTR aPath,
                                        ComSafeArrayIn(DirectoryRemoveRecFlag_T, aFlags),
                                        IProgress **aProgress);
    STDMETHOD(DirectoryRename)(IN_BSTR aSource,
                               IN_BSTR aDest,
                               ComSafeArrayIn(PathRenameFlag_T, aFlags));
    STDMETHOD(DirectorySetACL)(IN_BSTR aPath,
                               IN_BSTR aAcl);
    STDMETHOD(EnvironmentClear)();
    STDMETHOD(EnvironmentGet)(IN_BSTR aName,
                              BSTR *aValue);
    STDMETHOD(EnvironmentSet)(IN_BSTR aName,
                              IN_BSTR aValue);
    STDMETHOD(EnvironmentUnset)(IN_BSTR aName);
    STDMETHOD(FileCreateTemp)(IN_BSTR aTemplateName,
                              ULONG aMode,
                              IN_BSTR aPath,
                              BOOL aSecure,
                              IGuestFile **aFile);
    STDMETHOD(FileExists)(IN_BSTR aPath,
                          BOOL *aExists);
    STDMETHOD(FileRemove)(IN_BSTR aPath);
    STDMETHOD(FileOpen)(IN_BSTR aPath,
                        IN_BSTR aOpenMode,
                        IN_BSTR aDisposition,
                        ULONG aCreationMode,
                        IGuestFile **aFile);
    STDMETHOD(FileOpenEx)(IN_BSTR aPath,
                          IN_BSTR aOpenMode,
                          IN_BSTR aDisposition,
                          IN_BSTR aSharingMode,
                          ULONG aCreationMode,
                          LONG64 aOffset,
                          IGuestFile **aFile);
    STDMETHOD(FileQueryInfo)(IN_BSTR aPath,
                             IGuestFsObjInfo **aInfo);
    STDMETHOD(FileQuerySize)(IN_BSTR aPath,
                             LONG64 *aSize);
    STDMETHOD(FileRename)(IN_BSTR aSource,
                          IN_BSTR aDest,
                          ComSafeArrayIn(PathRenameFlag_T, aFlags));
    STDMETHOD(FileSetACL)(IN_BSTR aFile,
                          IN_BSTR aAcl);
    STDMETHOD(ProcessCreate)(IN_BSTR aCommand,
                             ComSafeArrayIn(IN_BSTR, aArguments),
                             ComSafeArrayIn(IN_BSTR, aEnvironment),
                             ComSafeArrayIn(ProcessCreateFlag_T, aFlags),
                             ULONG aTimeoutMS,
                             IGuestProcess **aGuestProcess);
    STDMETHOD(ProcessCreateEx)(IN_BSTR aCommand,
                               ComSafeArrayIn(IN_BSTR, aArguments),
                               ComSafeArrayIn(IN_BSTR, aEnvironment),
                               ComSafeArrayIn(ProcessCreateFlag_T, aFlags),
                               ULONG aTimeoutMS,
                               ProcessPriority_T aPriority,
                               ComSafeArrayIn(LONG, aAffinity),
                               IGuestProcess **aGuestProcess);
    STDMETHOD(ProcessGet)(ULONG aPid,
                          IGuestProcess **aGuestProcess);
    STDMETHOD(SymlinkCreate)(IN_BSTR aSource,
                             IN_BSTR aTarget,
                             SymlinkType_T aType);
    STDMETHOD(SymlinkExists)(IN_BSTR aSymlink,
                             BOOL *aExists);
    STDMETHOD(SymlinkRead)(IN_BSTR aSymlink,
                           ComSafeArrayIn(SymlinkReadFlag_T, aFlags),
                           BSTR *aTarget);
    STDMETHOD(SymlinkRemoveDirectory)(IN_BSTR aPath);
    STDMETHOD(SymlinkRemoveFile)(IN_BSTR aFile);
    STDMETHOD(WaitFor)(ULONG aWaitFor,
                       ULONG aTimeoutMS,
                       GuestSessionWaitResult_T *aReason);
    STDMETHOD(WaitForArray)(ComSafeArrayIn(GuestSessionWaitForFlag_T, aWaitFor),
                            ULONG aTimeoutMS,
                            GuestSessionWaitResult_T *aReason);

private:
    // wrapped IGuestSession properties
    virtual HRESULT getUser(com::Utf8Str &aUser) = 0;
    virtual HRESULT getDomain(com::Utf8Str &aDomain) = 0;
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getId(ULONG *aId) = 0;
    virtual HRESULT getTimeout(ULONG *aTimeout) = 0;
    virtual HRESULT setTimeout(ULONG aTimeout) = 0;
    virtual HRESULT getProtocolVersion(ULONG *aProtocolVersion) = 0;
    virtual HRESULT getStatus(GuestSessionStatus_T *aStatus) = 0;
    virtual HRESULT getEnvironment(std::vector<com::Utf8Str> &aEnvironment) = 0;
    virtual HRESULT setEnvironment(const std::vector<com::Utf8Str> &aEnvironment) = 0;
    virtual HRESULT getProcesses(std::vector<ComPtr<IGuestProcess> > &aProcesses) = 0;
    virtual HRESULT getDirectories(std::vector<ComPtr<IGuestDirectory> > &aDirectories) = 0;
    virtual HRESULT getFiles(std::vector<ComPtr<IGuestFile> > &aFiles) = 0;
    virtual HRESULT getEventSource(ComPtr<IEventSource> &aEventSource) = 0;

    // wrapped IGuestSession methods
    virtual HRESULT close() = 0;
    virtual HRESULT copyFrom(const com::Utf8Str &aSource,
                             const com::Utf8Str &aDest,
                             const std::vector<CopyFileFlag_T> &aFlags,
                             ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT copyTo(const com::Utf8Str &aSource,
                           const com::Utf8Str &aDest,
                           const std::vector<CopyFileFlag_T> &aFlags,
                           ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT directoryCreate(const com::Utf8Str &aPath,
                                    ULONG aMode,
                                    const std::vector<DirectoryCreateFlag_T> &aFlags) = 0;
    virtual HRESULT directoryCreateTemp(const com::Utf8Str &aTemplateName,
                                        ULONG aMode,
                                        const com::Utf8Str &aPath,
                                        BOOL aSecure,
                                        com::Utf8Str &aDirectory) = 0;
    virtual HRESULT directoryExists(const com::Utf8Str &aPath,
                                    BOOL *aExists) = 0;
    virtual HRESULT directoryOpen(const com::Utf8Str &aPath,
                                  const com::Utf8Str &aFilter,
                                  const std::vector<DirectoryOpenFlag_T> &aFlags,
                                  ComPtr<IGuestDirectory> &aDirectory) = 0;
    virtual HRESULT directoryQueryInfo(const com::Utf8Str &aPath,
                                       ComPtr<IGuestFsObjInfo> &aInfo) = 0;
    virtual HRESULT directoryRemove(const com::Utf8Str &aPath) = 0;
    virtual HRESULT directoryRemoveRecursive(const com::Utf8Str &aPath,
                                             const std::vector<DirectoryRemoveRecFlag_T> &aFlags,
                                             ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT directoryRename(const com::Utf8Str &aSource,
                                    const com::Utf8Str &aDest,
                                    const std::vector<PathRenameFlag_T> &aFlags) = 0;
    virtual HRESULT directorySetACL(const com::Utf8Str &aPath,
                                    const com::Utf8Str &aAcl) = 0;
    virtual HRESULT environmentClear() = 0;
    virtual HRESULT environmentGet(const com::Utf8Str &aName,
                                   com::Utf8Str &aValue) = 0;
    virtual HRESULT environmentSet(const com::Utf8Str &aName,
                                   const com::Utf8Str &aValue) = 0;
    virtual HRESULT environmentUnset(const com::Utf8Str &aName) = 0;
    virtual HRESULT fileCreateTemp(const com::Utf8Str &aTemplateName,
                                   ULONG aMode,
                                   const com::Utf8Str &aPath,
                                   BOOL aSecure,
                                   ComPtr<IGuestFile> &aFile) = 0;
    virtual HRESULT fileExists(const com::Utf8Str &aPath,
                               BOOL *aExists) = 0;
    virtual HRESULT fileRemove(const com::Utf8Str &aPath) = 0;
    virtual HRESULT fileOpen(const com::Utf8Str &aPath,
                             const com::Utf8Str &aOpenMode,
                             const com::Utf8Str &aDisposition,
                             ULONG aCreationMode,
                             ComPtr<IGuestFile> &aFile) = 0;
    virtual HRESULT fileOpenEx(const com::Utf8Str &aPath,
                               const com::Utf8Str &aOpenMode,
                               const com::Utf8Str &aDisposition,
                               const com::Utf8Str &aSharingMode,
                               ULONG aCreationMode,
                               LONG64 aOffset,
                               ComPtr<IGuestFile> &aFile) = 0;
    virtual HRESULT fileQueryInfo(const com::Utf8Str &aPath,
                                  ComPtr<IGuestFsObjInfo> &aInfo) = 0;
    virtual HRESULT fileQuerySize(const com::Utf8Str &aPath,
                                  LONG64 *aSize) = 0;
    virtual HRESULT fileRename(const com::Utf8Str &aSource,
                               const com::Utf8Str &aDest,
                               const std::vector<PathRenameFlag_T> &aFlags) = 0;
    virtual HRESULT fileSetACL(const com::Utf8Str &aFile,
                               const com::Utf8Str &aAcl) = 0;
    virtual HRESULT processCreate(const com::Utf8Str &aCommand,
                                  const std::vector<com::Utf8Str> &aArguments,
                                  const std::vector<com::Utf8Str> &aEnvironment,
                                  const std::vector<ProcessCreateFlag_T> &aFlags,
                                  ULONG aTimeoutMS,
                                  ComPtr<IGuestProcess> &aGuestProcess) = 0;
    virtual HRESULT processCreateEx(const com::Utf8Str &aCommand,
                                    const std::vector<com::Utf8Str> &aArguments,
                                    const std::vector<com::Utf8Str> &aEnvironment,
                                    const std::vector<ProcessCreateFlag_T> &aFlags,
                                    ULONG aTimeoutMS,
                                    ProcessPriority_T aPriority,
                                    const std::vector<LONG> &aAffinity,
                                    ComPtr<IGuestProcess> &aGuestProcess) = 0;
    virtual HRESULT processGet(ULONG aPid,
                               ComPtr<IGuestProcess> &aGuestProcess) = 0;
    virtual HRESULT symlinkCreate(const com::Utf8Str &aSource,
                                  const com::Utf8Str &aTarget,
                                  SymlinkType_T aType) = 0;
    virtual HRESULT symlinkExists(const com::Utf8Str &aSymlink,
                                  BOOL *aExists) = 0;
    virtual HRESULT symlinkRead(const com::Utf8Str &aSymlink,
                                const std::vector<SymlinkReadFlag_T> &aFlags,
                                com::Utf8Str &aTarget) = 0;
    virtual HRESULT symlinkRemoveDirectory(const com::Utf8Str &aPath) = 0;
    virtual HRESULT symlinkRemoveFile(const com::Utf8Str &aFile) = 0;
    virtual HRESULT waitFor(ULONG aWaitFor,
                            ULONG aTimeoutMS,
                            GuestSessionWaitResult_T *aReason) = 0;
    virtual HRESULT waitForArray(const std::vector<GuestSessionWaitForFlag_T> &aWaitFor,
                                 ULONG aTimeoutMS,
                                 GuestSessionWaitResult_T *aReason) = 0;
};

#endif // !GuestSessionWrap_H_

// ##### ENDFILE "GuestSessionWrap.h"

// ##### BEGINFILE "GuestSessionWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestSession.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTSESSION

#include "GuestSessionWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestSessionWrap)

//
// IGuestSession properties
//

STDMETHODIMP GuestSessionWrap::COMGETTER(User)(BSTR *aUser)
{
    LogRelFlow(("{%p} %s: enter aUser=%p\n", this, "GuestSession::getUser", aUser));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUser);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUser(BSTROutConverter(aUser).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUser=%ls hrc=%Rhrc\n", this, "GuestSession::getUser", *aUser, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::COMGETTER(Domain)(BSTR *aDomain)
{
    LogRelFlow(("{%p} %s: enter aDomain=%p\n", this, "GuestSession::getDomain", aDomain));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDomain);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDomain(BSTROutConverter(aDomain).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDomain=%ls hrc=%Rhrc\n", this, "GuestSession::getDomain", *aDomain, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "GuestSession::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "GuestSession::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::COMGETTER(Id)(ULONG *aId)
{
    LogRelFlow(("{%p} %s: enter aId=%p\n", this, "GuestSession::getId", aId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getId(aId);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aId=%RU32 hrc=%Rhrc\n", this, "GuestSession::getId", *aId, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::COMGETTER(Timeout)(ULONG *aTimeout)
{
    LogRelFlow(("{%p} %s: enter aTimeout=%p\n", this, "GuestSession::getTimeout", aTimeout));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aTimeout);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getTimeout(aTimeout);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aTimeout=%RU32 hrc=%Rhrc\n", this, "GuestSession::getTimeout", *aTimeout, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::COMSETTER(Timeout)(ULONG aTimeout)
{
    LogRelFlow(("{%p} %s: enter aTimeout=%RU32\n", this, "GuestSession::setTimeout", aTimeout));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setTimeout(aTimeout);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestSession::setTimeout", hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::COMGETTER(ProtocolVersion)(ULONG *aProtocolVersion)
{
    LogRelFlow(("{%p} %s: enter aProtocolVersion=%p\n", this, "GuestSession::getProtocolVersion", aProtocolVersion));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProtocolVersion);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProtocolVersion(aProtocolVersion);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProtocolVersion=%RU32 hrc=%Rhrc\n", this, "GuestSession::getProtocolVersion", *aProtocolVersion, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::COMGETTER(Status)(GuestSessionStatus_T *aStatus)
{
    LogRelFlow(("{%p} %s: enter aStatus=%p\n", this, "GuestSession::getStatus", aStatus));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStatus);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getStatus(aStatus);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aStatus=%RU32 hrc=%Rhrc\n", this, "GuestSession::getStatus", *aStatus, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::COMGETTER(Environment)(ComSafeArrayOut(BSTR, aEnvironment))
{
    LogRelFlow(("{%p} %s: enter aEnvironment=%p\n", this, "GuestSession::getEnvironment", aEnvironment));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEnvironment);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEnvironment(ArrayBSTROutConverter(ComSafeArrayOutArg(aEnvironment)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEnvironment=%zu hrc=%Rhrc\n", this, "GuestSession::getEnvironment", ComSafeArraySize(*aEnvironment), hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::COMSETTER(Environment)(ComSafeArrayIn(IN_BSTR, aEnvironment))
{
    LogRelFlow(("{%p} %s: enter aEnvironment=%zu\n", this, "GuestSession::setEnvironment", ComSafeArraySize(aEnvironment)));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setEnvironment(ArrayBSTRInConverter(ComSafeArrayInArg(aEnvironment)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestSession::setEnvironment", hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::COMGETTER(Processes)(ComSafeArrayOut(IGuestProcess *, aProcesses))
{
    LogRelFlow(("{%p} %s: enter aProcesses=%p\n", this, "GuestSession::getProcesses", aProcesses));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProcesses);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProcesses(ArrayComTypeOutConverter<IGuestProcess>(ComSafeArrayOutArg(aProcesses)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProcesses=%zu hrc=%Rhrc\n", this, "GuestSession::getProcesses", ComSafeArraySize(*aProcesses), hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::COMGETTER(Directories)(ComSafeArrayOut(IGuestDirectory *, aDirectories))
{
    LogRelFlow(("{%p} %s: enter aDirectories=%p\n", this, "GuestSession::getDirectories", aDirectories));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDirectories);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDirectories(ArrayComTypeOutConverter<IGuestDirectory>(ComSafeArrayOutArg(aDirectories)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDirectories=%zu hrc=%Rhrc\n", this, "GuestSession::getDirectories", ComSafeArraySize(*aDirectories), hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::COMGETTER(Files)(ComSafeArrayOut(IGuestFile *, aFiles))
{
    LogRelFlow(("{%p} %s: enter aFiles=%p\n", this, "GuestSession::getFiles", aFiles));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFiles);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFiles(ArrayComTypeOutConverter<IGuestFile>(ComSafeArrayOutArg(aFiles)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFiles=%zu hrc=%Rhrc\n", this, "GuestSession::getFiles", ComSafeArraySize(*aFiles), hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::COMGETTER(EventSource)(IEventSource **aEventSource)
{
    LogRelFlow(("{%p} %s: enter aEventSource=%p\n", this, "GuestSession::getEventSource", aEventSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEventSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEventSource(ComTypeOutConverter<IEventSource>(aEventSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEventSource=%p hrc=%Rhrc\n", this, "GuestSession::getEventSource", *aEventSource, hrc));
    return hrc;
}

//
// IGuestSession methods
//

STDMETHODIMP GuestSessionWrap::Close()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestSession::close"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = close();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestSession::close", hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::CopyFrom(IN_BSTR aSource,
                                        IN_BSTR aDest,
                                        ComSafeArrayIn(CopyFileFlag_T, aFlags),
                                        IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aSource=%ls aDest=%ls aFlags=%zu aProgress=%p\n", this, "GuestSession::copyFrom", aSource, aDest, aFlags, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = copyFrom(BSTRInConverter(aSource).str(),
                       BSTRInConverter(aDest).str(),
                       ArrayInConverter<CopyFileFlag_T>(ComSafeArrayInArg(aFlags)).array(),
                       ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "GuestSession::copyFrom", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::CopyTo(IN_BSTR aSource,
                                      IN_BSTR aDest,
                                      ComSafeArrayIn(CopyFileFlag_T, aFlags),
                                      IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aSource=%ls aDest=%ls aFlags=%zu aProgress=%p\n", this, "GuestSession::copyTo", aSource, aDest, aFlags, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = copyTo(BSTRInConverter(aSource).str(),
                     BSTRInConverter(aDest).str(),
                     ArrayInConverter<CopyFileFlag_T>(ComSafeArrayInArg(aFlags)).array(),
                     ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "GuestSession::copyTo", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::DirectoryCreate(IN_BSTR aPath,
                                               ULONG aMode,
                                               ComSafeArrayIn(DirectoryCreateFlag_T, aFlags))
{
    LogRelFlow(("{%p} %s:enter aPath=%ls aMode=%RU32 aFlags=%zu\n", this, "GuestSession::directoryCreate", aPath, aMode, aFlags));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = directoryCreate(BSTRInConverter(aPath).str(),
                              aMode,
                              ArrayInConverter<DirectoryCreateFlag_T>(ComSafeArrayInArg(aFlags)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestSession::directoryCreate", hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::DirectoryCreateTemp(IN_BSTR aTemplateName,
                                                   ULONG aMode,
                                                   IN_BSTR aPath,
                                                   BOOL aSecure,
                                                   BSTR *aDirectory)
{
    LogRelFlow(("{%p} %s:enter aTemplateName=%ls aMode=%RU32 aPath=%ls aSecure=%RTbool aDirectory=%p\n", this, "GuestSession::directoryCreateTemp", aTemplateName, aMode, aPath, aSecure, aDirectory));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDirectory);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = directoryCreateTemp(BSTRInConverter(aTemplateName).str(),
                                  aMode,
                                  BSTRInConverter(aPath).str(),
                                  aSecure,
                                  BSTROutConverter(aDirectory).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aDirectory=%ls hrc=%Rhrc\n", this, "GuestSession::directoryCreateTemp", *aDirectory, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::DirectoryExists(IN_BSTR aPath,
                                               BOOL *aExists)
{
    LogRelFlow(("{%p} %s:enter aPath=%ls aExists=%p\n", this, "GuestSession::directoryExists", aPath, aExists));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aExists);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = directoryExists(BSTRInConverter(aPath).str(),
                              aExists);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aExists=%RTbool hrc=%Rhrc\n", this, "GuestSession::directoryExists", *aExists, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::DirectoryOpen(IN_BSTR aPath,
                                             IN_BSTR aFilter,
                                             ComSafeArrayIn(DirectoryOpenFlag_T, aFlags),
                                             IGuestDirectory **aDirectory)
{
    LogRelFlow(("{%p} %s:enter aPath=%ls aFilter=%ls aFlags=%zu aDirectory=%p\n", this, "GuestSession::directoryOpen", aPath, aFilter, aFlags, aDirectory));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDirectory);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = directoryOpen(BSTRInConverter(aPath).str(),
                            BSTRInConverter(aFilter).str(),
                            ArrayInConverter<DirectoryOpenFlag_T>(ComSafeArrayInArg(aFlags)).array(),
                            ComTypeOutConverter<IGuestDirectory>(aDirectory).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aDirectory=%p hrc=%Rhrc\n", this, "GuestSession::directoryOpen", *aDirectory, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::DirectoryQueryInfo(IN_BSTR aPath,
                                                  IGuestFsObjInfo **aInfo)
{
    LogRelFlow(("{%p} %s:enter aPath=%ls aInfo=%p\n", this, "GuestSession::directoryQueryInfo", aPath, aInfo));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aInfo);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = directoryQueryInfo(BSTRInConverter(aPath).str(),
                                 ComTypeOutConverter<IGuestFsObjInfo>(aInfo).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aInfo=%p hrc=%Rhrc\n", this, "GuestSession::directoryQueryInfo", *aInfo, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::DirectoryRemove(IN_BSTR aPath)
{
    LogRelFlow(("{%p} %s:enter aPath=%ls\n", this, "GuestSession::directoryRemove", aPath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = directoryRemove(BSTRInConverter(aPath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestSession::directoryRemove", hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::DirectoryRemoveRecursive(IN_BSTR aPath,
                                                        ComSafeArrayIn(DirectoryRemoveRecFlag_T, aFlags),
                                                        IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aPath=%ls aFlags=%zu aProgress=%p\n", this, "GuestSession::directoryRemoveRecursive", aPath, aFlags, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = directoryRemoveRecursive(BSTRInConverter(aPath).str(),
                                       ArrayInConverter<DirectoryRemoveRecFlag_T>(ComSafeArrayInArg(aFlags)).array(),
                                       ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "GuestSession::directoryRemoveRecursive", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::DirectoryRename(IN_BSTR aSource,
                                               IN_BSTR aDest,
                                               ComSafeArrayIn(PathRenameFlag_T, aFlags))
{
    LogRelFlow(("{%p} %s:enter aSource=%ls aDest=%ls aFlags=%zu\n", this, "GuestSession::directoryRename", aSource, aDest, aFlags));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = directoryRename(BSTRInConverter(aSource).str(),
                              BSTRInConverter(aDest).str(),
                              ArrayInConverter<PathRenameFlag_T>(ComSafeArrayInArg(aFlags)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestSession::directoryRename", hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::DirectorySetACL(IN_BSTR aPath,
                                               IN_BSTR aAcl)
{
    LogRelFlow(("{%p} %s:enter aPath=%ls aAcl=%ls\n", this, "GuestSession::directorySetACL", aPath, aAcl));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = directorySetACL(BSTRInConverter(aPath).str(),
                              BSTRInConverter(aAcl).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestSession::directorySetACL", hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::EnvironmentClear()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestSession::environmentClear"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = environmentClear();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestSession::environmentClear", hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::EnvironmentGet(IN_BSTR aName,
                                              BSTR *aValue)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aValue=%p\n", this, "GuestSession::environmentGet", aName, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aValue);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = environmentGet(BSTRInConverter(aName).str(),
                             BSTROutConverter(aValue).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aValue=%ls hrc=%Rhrc\n", this, "GuestSession::environmentGet", *aValue, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::EnvironmentSet(IN_BSTR aName,
                                              IN_BSTR aValue)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aValue=%ls\n", this, "GuestSession::environmentSet", aName, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = environmentSet(BSTRInConverter(aName).str(),
                             BSTRInConverter(aValue).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestSession::environmentSet", hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::EnvironmentUnset(IN_BSTR aName)
{
    LogRelFlow(("{%p} %s:enter aName=%ls\n", this, "GuestSession::environmentUnset", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = environmentUnset(BSTRInConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestSession::environmentUnset", hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::FileCreateTemp(IN_BSTR aTemplateName,
                                              ULONG aMode,
                                              IN_BSTR aPath,
                                              BOOL aSecure,
                                              IGuestFile **aFile)
{
    LogRelFlow(("{%p} %s:enter aTemplateName=%ls aMode=%RU32 aPath=%ls aSecure=%RTbool aFile=%p\n", this, "GuestSession::fileCreateTemp", aTemplateName, aMode, aPath, aSecure, aFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFile);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = fileCreateTemp(BSTRInConverter(aTemplateName).str(),
                             aMode,
                             BSTRInConverter(aPath).str(),
                             aSecure,
                             ComTypeOutConverter<IGuestFile>(aFile).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aFile=%p hrc=%Rhrc\n", this, "GuestSession::fileCreateTemp", *aFile, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::FileExists(IN_BSTR aPath,
                                          BOOL *aExists)
{
    LogRelFlow(("{%p} %s:enter aPath=%ls aExists=%p\n", this, "GuestSession::fileExists", aPath, aExists));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aExists);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = fileExists(BSTRInConverter(aPath).str(),
                         aExists);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aExists=%RTbool hrc=%Rhrc\n", this, "GuestSession::fileExists", *aExists, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::FileRemove(IN_BSTR aPath)
{
    LogRelFlow(("{%p} %s:enter aPath=%ls\n", this, "GuestSession::fileRemove", aPath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = fileRemove(BSTRInConverter(aPath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestSession::fileRemove", hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::FileOpen(IN_BSTR aPath,
                                        IN_BSTR aOpenMode,
                                        IN_BSTR aDisposition,
                                        ULONG aCreationMode,
                                        IGuestFile **aFile)
{
    LogRelFlow(("{%p} %s:enter aPath=%ls aOpenMode=%ls aDisposition=%ls aCreationMode=%RU32 aFile=%p\n", this, "GuestSession::fileOpen", aPath, aOpenMode, aDisposition, aCreationMode, aFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFile);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = fileOpen(BSTRInConverter(aPath).str(),
                       BSTRInConverter(aOpenMode).str(),
                       BSTRInConverter(aDisposition).str(),
                       aCreationMode,
                       ComTypeOutConverter<IGuestFile>(aFile).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aFile=%p hrc=%Rhrc\n", this, "GuestSession::fileOpen", *aFile, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::FileOpenEx(IN_BSTR aPath,
                                          IN_BSTR aOpenMode,
                                          IN_BSTR aDisposition,
                                          IN_BSTR aSharingMode,
                                          ULONG aCreationMode,
                                          LONG64 aOffset,
                                          IGuestFile **aFile)
{
    LogRelFlow(("{%p} %s:enter aPath=%ls aOpenMode=%ls aDisposition=%ls aSharingMode=%ls aCreationMode=%RU32 aOffset=%RI64 aFile=%p\n", this, "GuestSession::fileOpenEx", aPath, aOpenMode, aDisposition, aSharingMode, aCreationMode, aOffset, aFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFile);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = fileOpenEx(BSTRInConverter(aPath).str(),
                         BSTRInConverter(aOpenMode).str(),
                         BSTRInConverter(aDisposition).str(),
                         BSTRInConverter(aSharingMode).str(),
                         aCreationMode,
                         aOffset,
                         ComTypeOutConverter<IGuestFile>(aFile).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aFile=%p hrc=%Rhrc\n", this, "GuestSession::fileOpenEx", *aFile, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::FileQueryInfo(IN_BSTR aPath,
                                             IGuestFsObjInfo **aInfo)
{
    LogRelFlow(("{%p} %s:enter aPath=%ls aInfo=%p\n", this, "GuestSession::fileQueryInfo", aPath, aInfo));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aInfo);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = fileQueryInfo(BSTRInConverter(aPath).str(),
                            ComTypeOutConverter<IGuestFsObjInfo>(aInfo).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aInfo=%p hrc=%Rhrc\n", this, "GuestSession::fileQueryInfo", *aInfo, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::FileQuerySize(IN_BSTR aPath,
                                             LONG64 *aSize)
{
    LogRelFlow(("{%p} %s:enter aPath=%ls aSize=%p\n", this, "GuestSession::fileQuerySize", aPath, aSize));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSize);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = fileQuerySize(BSTRInConverter(aPath).str(),
                            aSize);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aSize=%RI64 hrc=%Rhrc\n", this, "GuestSession::fileQuerySize", *aSize, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::FileRename(IN_BSTR aSource,
                                          IN_BSTR aDest,
                                          ComSafeArrayIn(PathRenameFlag_T, aFlags))
{
    LogRelFlow(("{%p} %s:enter aSource=%ls aDest=%ls aFlags=%zu\n", this, "GuestSession::fileRename", aSource, aDest, aFlags));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = fileRename(BSTRInConverter(aSource).str(),
                         BSTRInConverter(aDest).str(),
                         ArrayInConverter<PathRenameFlag_T>(ComSafeArrayInArg(aFlags)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestSession::fileRename", hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::FileSetACL(IN_BSTR aFile,
                                          IN_BSTR aAcl)
{
    LogRelFlow(("{%p} %s:enter aFile=%ls aAcl=%ls\n", this, "GuestSession::fileSetACL", aFile, aAcl));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = fileSetACL(BSTRInConverter(aFile).str(),
                         BSTRInConverter(aAcl).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestSession::fileSetACL", hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::ProcessCreate(IN_BSTR aCommand,
                                             ComSafeArrayIn(IN_BSTR, aArguments),
                                             ComSafeArrayIn(IN_BSTR, aEnvironment),
                                             ComSafeArrayIn(ProcessCreateFlag_T, aFlags),
                                             ULONG aTimeoutMS,
                                             IGuestProcess **aGuestProcess)
{
    LogRelFlow(("{%p} %s:enter aCommand=%ls aArguments=%zu aEnvironment=%zu aFlags=%zu aTimeoutMS=%RU32 aGuestProcess=%p\n", this, "GuestSession::processCreate", aCommand, aArguments, aEnvironment, aFlags, aTimeoutMS, aGuestProcess));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGuestProcess);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = processCreate(BSTRInConverter(aCommand).str(),
                            ArrayBSTRInConverter(ComSafeArrayInArg(aArguments)).array(),
                            ArrayBSTRInConverter(ComSafeArrayInArg(aEnvironment)).array(),
                            ArrayInConverter<ProcessCreateFlag_T>(ComSafeArrayInArg(aFlags)).array(),
                            aTimeoutMS,
                            ComTypeOutConverter<IGuestProcess>(aGuestProcess).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aGuestProcess=%p hrc=%Rhrc\n", this, "GuestSession::processCreate", *aGuestProcess, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::ProcessCreateEx(IN_BSTR aCommand,
                                               ComSafeArrayIn(IN_BSTR, aArguments),
                                               ComSafeArrayIn(IN_BSTR, aEnvironment),
                                               ComSafeArrayIn(ProcessCreateFlag_T, aFlags),
                                               ULONG aTimeoutMS,
                                               ProcessPriority_T aPriority,
                                               ComSafeArrayIn(LONG, aAffinity),
                                               IGuestProcess **aGuestProcess)
{
    LogRelFlow(("{%p} %s:enter aCommand=%ls aArguments=%zu aEnvironment=%zu aFlags=%zu aTimeoutMS=%RU32 aPriority=%RU32 aAffinity=%zu aGuestProcess=%p\n", this, "GuestSession::processCreateEx", aCommand, aArguments, aEnvironment, aFlags, aTimeoutMS, aPriority, aAffinity, aGuestProcess));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGuestProcess);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = processCreateEx(BSTRInConverter(aCommand).str(),
                              ArrayBSTRInConverter(ComSafeArrayInArg(aArguments)).array(),
                              ArrayBSTRInConverter(ComSafeArrayInArg(aEnvironment)).array(),
                              ArrayInConverter<ProcessCreateFlag_T>(ComSafeArrayInArg(aFlags)).array(),
                              aTimeoutMS,
                              aPriority,
                              ArrayInConverter<LONG>(ComSafeArrayInArg(aAffinity)).array(),
                              ComTypeOutConverter<IGuestProcess>(aGuestProcess).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aGuestProcess=%p hrc=%Rhrc\n", this, "GuestSession::processCreateEx", *aGuestProcess, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::ProcessGet(ULONG aPid,
                                          IGuestProcess **aGuestProcess)
{
    LogRelFlow(("{%p} %s:enter aPid=%RU32 aGuestProcess=%p\n", this, "GuestSession::processGet", aPid, aGuestProcess));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGuestProcess);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = processGet(aPid,
                         ComTypeOutConverter<IGuestProcess>(aGuestProcess).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aGuestProcess=%p hrc=%Rhrc\n", this, "GuestSession::processGet", *aGuestProcess, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::SymlinkCreate(IN_BSTR aSource,
                                             IN_BSTR aTarget,
                                             SymlinkType_T aType)
{
    LogRelFlow(("{%p} %s:enter aSource=%ls aTarget=%ls aType=%RU32\n", this, "GuestSession::symlinkCreate", aSource, aTarget, aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = symlinkCreate(BSTRInConverter(aSource).str(),
                            BSTRInConverter(aTarget).str(),
                            aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestSession::symlinkCreate", hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::SymlinkExists(IN_BSTR aSymlink,
                                             BOOL *aExists)
{
    LogRelFlow(("{%p} %s:enter aSymlink=%ls aExists=%p\n", this, "GuestSession::symlinkExists", aSymlink, aExists));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aExists);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = symlinkExists(BSTRInConverter(aSymlink).str(),
                            aExists);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aExists=%RTbool hrc=%Rhrc\n", this, "GuestSession::symlinkExists", *aExists, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::SymlinkRead(IN_BSTR aSymlink,
                                           ComSafeArrayIn(SymlinkReadFlag_T, aFlags),
                                           BSTR *aTarget)
{
    LogRelFlow(("{%p} %s:enter aSymlink=%ls aFlags=%zu aTarget=%p\n", this, "GuestSession::symlinkRead", aSymlink, aFlags, aTarget));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aTarget);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = symlinkRead(BSTRInConverter(aSymlink).str(),
                          ArrayInConverter<SymlinkReadFlag_T>(ComSafeArrayInArg(aFlags)).array(),
                          BSTROutConverter(aTarget).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aTarget=%ls hrc=%Rhrc\n", this, "GuestSession::symlinkRead", *aTarget, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::SymlinkRemoveDirectory(IN_BSTR aPath)
{
    LogRelFlow(("{%p} %s:enter aPath=%ls\n", this, "GuestSession::symlinkRemoveDirectory", aPath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = symlinkRemoveDirectory(BSTRInConverter(aPath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestSession::symlinkRemoveDirectory", hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::SymlinkRemoveFile(IN_BSTR aFile)
{
    LogRelFlow(("{%p} %s:enter aFile=%ls\n", this, "GuestSession::symlinkRemoveFile", aFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = symlinkRemoveFile(BSTRInConverter(aFile).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestSession::symlinkRemoveFile", hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::WaitFor(ULONG aWaitFor,
                                       ULONG aTimeoutMS,
                                       GuestSessionWaitResult_T *aReason)
{
    LogRelFlow(("{%p} %s:enter aWaitFor=%RU32 aTimeoutMS=%RU32 aReason=%p\n", this, "GuestSession::waitFor", aWaitFor, aTimeoutMS, aReason));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aReason);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitFor(aWaitFor,
                      aTimeoutMS,
                      aReason);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aReason=%RU32 hrc=%Rhrc\n", this, "GuestSession::waitFor", *aReason, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionWrap::WaitForArray(ComSafeArrayIn(GuestSessionWaitForFlag_T, aWaitFor),
                                            ULONG aTimeoutMS,
                                            GuestSessionWaitResult_T *aReason)
{
    LogRelFlow(("{%p} %s:enter aWaitFor=%zu aTimeoutMS=%RU32 aReason=%p\n", this, "GuestSession::waitForArray", aWaitFor, aTimeoutMS, aReason));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aReason);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitForArray(ArrayInConverter<GuestSessionWaitForFlag_T>(ComSafeArrayInArg(aWaitFor)).array(),
                           aTimeoutMS,
                           aReason);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aReason=%RU32 hrc=%Rhrc\n", this, "GuestSession::waitForArray", *aReason, hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestSessionWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(GuestSessionWrap, IGuestSession)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestSessionWrap.cpp"

// ##### BEGINFILE "ProcessWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IProcess.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef ProcessWrap_H_
#define ProcessWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE ProcessWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IProcess)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(ProcessWrap, IProcess)
    DECLARE_NOT_AGGREGATABLE(ProcessWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(ProcessWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IProcess)
        COM_INTERFACE_ENTRY2(IDispatch, IProcess)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(ProcessWrap)

    // public IProcess properties
    STDMETHOD(COMGETTER(Arguments))(ComSafeArrayOut(BSTR, aArguments));
    STDMETHOD(COMGETTER(Environment))(ComSafeArrayOut(BSTR, aEnvironment));
    STDMETHOD(COMGETTER(EventSource))(IEventSource **aEventSource);
    STDMETHOD(COMGETTER(ExecutablePath))(BSTR *aExecutablePath);
    STDMETHOD(COMGETTER(ExitCode))(LONG *aExitCode);
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(PID))(ULONG *aPID);
    STDMETHOD(COMGETTER(Status))(ProcessStatus_T *aStatus);

    // public IProcess methods
    STDMETHOD(WaitFor)(ULONG aWaitFor,
                       ULONG aTimeoutMS,
                       ProcessWaitResult_T *aReason);
    STDMETHOD(WaitForArray)(ComSafeArrayIn(ProcessWaitForFlag_T, aWaitFor),
                            ULONG aTimeoutMS,
                            ProcessWaitResult_T *aReason);
    STDMETHOD(Read)(ULONG aHandle,
                    ULONG aToRead,
                    ULONG aTimeoutMS,
                    ComSafeArrayOut(BYTE, aData));
    STDMETHOD(Write)(ULONG aHandle,
                     ULONG aFlags,
                     ComSafeArrayIn(BYTE, aData),
                     ULONG aTimeoutMS,
                     ULONG *aWritten);
    STDMETHOD(WriteArray)(ULONG aHandle,
                          ComSafeArrayIn(ProcessInputFlag_T, aFlags),
                          ComSafeArrayIn(BYTE, aData),
                          ULONG aTimeoutMS,
                          ULONG *aWritten);
    STDMETHOD(Terminate)();

private:
    // wrapped IProcess properties
    virtual HRESULT getArguments(std::vector<com::Utf8Str> &aArguments) = 0;
    virtual HRESULT getEnvironment(std::vector<com::Utf8Str> &aEnvironment) = 0;
    virtual HRESULT getEventSource(ComPtr<IEventSource> &aEventSource) = 0;
    virtual HRESULT getExecutablePath(com::Utf8Str &aExecutablePath) = 0;
    virtual HRESULT getExitCode(LONG *aExitCode) = 0;
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getPID(ULONG *aPID) = 0;
    virtual HRESULT getStatus(ProcessStatus_T *aStatus) = 0;

    // wrapped IProcess methods
    virtual HRESULT waitFor(ULONG aWaitFor,
                            ULONG aTimeoutMS,
                            ProcessWaitResult_T *aReason) = 0;
    virtual HRESULT waitForArray(const std::vector<ProcessWaitForFlag_T> &aWaitFor,
                                 ULONG aTimeoutMS,
                                 ProcessWaitResult_T *aReason) = 0;
    virtual HRESULT read(ULONG aHandle,
                         ULONG aToRead,
                         ULONG aTimeoutMS,
                         std::vector<BYTE> &aData) = 0;
    virtual HRESULT write(ULONG aHandle,
                          ULONG aFlags,
                          const std::vector<BYTE> &aData,
                          ULONG aTimeoutMS,
                          ULONG *aWritten) = 0;
    virtual HRESULT writeArray(ULONG aHandle,
                               const std::vector<ProcessInputFlag_T> &aFlags,
                               const std::vector<BYTE> &aData,
                               ULONG aTimeoutMS,
                               ULONG *aWritten) = 0;
    virtual HRESULT terminate() = 0;
};

#endif // !ProcessWrap_H_

// ##### ENDFILE "ProcessWrap.h"

// ##### BEGINFILE "ProcessWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IProcess.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_PROCESS

#include "ProcessWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(ProcessWrap)

//
// IProcess properties
//

STDMETHODIMP ProcessWrap::COMGETTER(Arguments)(ComSafeArrayOut(BSTR, aArguments))
{
    LogRelFlow(("{%p} %s: enter aArguments=%p\n", this, "Process::getArguments", aArguments));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aArguments);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getArguments(ArrayBSTROutConverter(ComSafeArrayOutArg(aArguments)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aArguments=%zu hrc=%Rhrc\n", this, "Process::getArguments", ComSafeArraySize(*aArguments), hrc));
    return hrc;
}

STDMETHODIMP ProcessWrap::COMGETTER(Environment)(ComSafeArrayOut(BSTR, aEnvironment))
{
    LogRelFlow(("{%p} %s: enter aEnvironment=%p\n", this, "Process::getEnvironment", aEnvironment));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEnvironment);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEnvironment(ArrayBSTROutConverter(ComSafeArrayOutArg(aEnvironment)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEnvironment=%zu hrc=%Rhrc\n", this, "Process::getEnvironment", ComSafeArraySize(*aEnvironment), hrc));
    return hrc;
}

STDMETHODIMP ProcessWrap::COMGETTER(EventSource)(IEventSource **aEventSource)
{
    LogRelFlow(("{%p} %s: enter aEventSource=%p\n", this, "Process::getEventSource", aEventSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEventSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEventSource(ComTypeOutConverter<IEventSource>(aEventSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEventSource=%p hrc=%Rhrc\n", this, "Process::getEventSource", *aEventSource, hrc));
    return hrc;
}

STDMETHODIMP ProcessWrap::COMGETTER(ExecutablePath)(BSTR *aExecutablePath)
{
    LogRelFlow(("{%p} %s: enter aExecutablePath=%p\n", this, "Process::getExecutablePath", aExecutablePath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aExecutablePath);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getExecutablePath(BSTROutConverter(aExecutablePath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aExecutablePath=%ls hrc=%Rhrc\n", this, "Process::getExecutablePath", *aExecutablePath, hrc));
    return hrc;
}

STDMETHODIMP ProcessWrap::COMGETTER(ExitCode)(LONG *aExitCode)
{
    LogRelFlow(("{%p} %s: enter aExitCode=%p\n", this, "Process::getExitCode", aExitCode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aExitCode);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getExitCode(aExitCode);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aExitCode=%RI32 hrc=%Rhrc\n", this, "Process::getExitCode", *aExitCode, hrc));
    return hrc;
}

STDMETHODIMP ProcessWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "Process::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "Process::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP ProcessWrap::COMGETTER(PID)(ULONG *aPID)
{
    LogRelFlow(("{%p} %s: enter aPID=%p\n", this, "Process::getPID", aPID));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPID);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPID(aPID);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPID=%RU32 hrc=%Rhrc\n", this, "Process::getPID", *aPID, hrc));
    return hrc;
}

STDMETHODIMP ProcessWrap::COMGETTER(Status)(ProcessStatus_T *aStatus)
{
    LogRelFlow(("{%p} %s: enter aStatus=%p\n", this, "Process::getStatus", aStatus));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStatus);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getStatus(aStatus);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aStatus=%RU32 hrc=%Rhrc\n", this, "Process::getStatus", *aStatus, hrc));
    return hrc;
}

//
// IProcess methods
//

STDMETHODIMP ProcessWrap::WaitFor(ULONG aWaitFor,
                                  ULONG aTimeoutMS,
                                  ProcessWaitResult_T *aReason)
{
    LogRelFlow(("{%p} %s:enter aWaitFor=%RU32 aTimeoutMS=%RU32 aReason=%p\n", this, "Process::waitFor", aWaitFor, aTimeoutMS, aReason));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aReason);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitFor(aWaitFor,
                      aTimeoutMS,
                      aReason);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aReason=%RU32 hrc=%Rhrc\n", this, "Process::waitFor", *aReason, hrc));
    return hrc;
}

STDMETHODIMP ProcessWrap::WaitForArray(ComSafeArrayIn(ProcessWaitForFlag_T, aWaitFor),
                                       ULONG aTimeoutMS,
                                       ProcessWaitResult_T *aReason)
{
    LogRelFlow(("{%p} %s:enter aWaitFor=%zu aTimeoutMS=%RU32 aReason=%p\n", this, "Process::waitForArray", aWaitFor, aTimeoutMS, aReason));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aReason);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitForArray(ArrayInConverter<ProcessWaitForFlag_T>(ComSafeArrayInArg(aWaitFor)).array(),
                           aTimeoutMS,
                           aReason);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aReason=%RU32 hrc=%Rhrc\n", this, "Process::waitForArray", *aReason, hrc));
    return hrc;
}

STDMETHODIMP ProcessWrap::Read(ULONG aHandle,
                               ULONG aToRead,
                               ULONG aTimeoutMS,
                               ComSafeArrayOut(BYTE, aData))
{
    LogRelFlow(("{%p} %s:enter aHandle=%RU32 aToRead=%RU32 aTimeoutMS=%RU32 aData=%p\n", this, "Process::read", aHandle, aToRead, aTimeoutMS, aData));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aData);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = read(aHandle,
                   aToRead,
                   aTimeoutMS,
                   ArrayOutConverter<BYTE>(ComSafeArrayOutArg(aData)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aData=%zu hrc=%Rhrc\n", this, "Process::read", ComSafeArraySize(*aData), hrc));
    return hrc;
}

STDMETHODIMP ProcessWrap::Write(ULONG aHandle,
                                ULONG aFlags,
                                ComSafeArrayIn(BYTE, aData),
                                ULONG aTimeoutMS,
                                ULONG *aWritten)
{
    LogRelFlow(("{%p} %s:enter aHandle=%RU32 aFlags=%RU32 aData=%zu aTimeoutMS=%RU32 aWritten=%p\n", this, "Process::write", aHandle, aFlags, aData, aTimeoutMS, aWritten));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWritten);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = write(aHandle,
                    aFlags,
                    ArrayInConverter<BYTE>(ComSafeArrayInArg(aData)).array(),
                    aTimeoutMS,
                    aWritten);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aWritten=%RU32 hrc=%Rhrc\n", this, "Process::write", *aWritten, hrc));
    return hrc;
}

STDMETHODIMP ProcessWrap::WriteArray(ULONG aHandle,
                                     ComSafeArrayIn(ProcessInputFlag_T, aFlags),
                                     ComSafeArrayIn(BYTE, aData),
                                     ULONG aTimeoutMS,
                                     ULONG *aWritten)
{
    LogRelFlow(("{%p} %s:enter aHandle=%RU32 aFlags=%zu aData=%zu aTimeoutMS=%RU32 aWritten=%p\n", this, "Process::writeArray", aHandle, aFlags, aData, aTimeoutMS, aWritten));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWritten);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = writeArray(aHandle,
                         ArrayInConverter<ProcessInputFlag_T>(ComSafeArrayInArg(aFlags)).array(),
                         ArrayInConverter<BYTE>(ComSafeArrayInArg(aData)).array(),
                         aTimeoutMS,
                         aWritten);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aWritten=%RU32 hrc=%Rhrc\n", this, "Process::writeArray", *aWritten, hrc));
    return hrc;
}

STDMETHODIMP ProcessWrap::Terminate()
{
    LogRelFlow(("{%p} %s:enter\n", this, "Process::terminate"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = terminate();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Process::terminate", hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(ProcessWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(ProcessWrap, IProcess)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "ProcessWrap.cpp"

// ##### BEGINFILE "GuestProcessWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestProcess.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestProcessWrap_H_
#define GuestProcessWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestProcessWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestProcess)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestProcessWrap, IGuestProcess)
    DECLARE_NOT_AGGREGATABLE(GuestProcessWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestProcessWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestProcess)
        COM_INTERFACE_ENTRY(IProcess)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestProcess)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestProcessWrap)

    // public IProcess properties
    STDMETHOD(COMGETTER(Arguments))(ComSafeArrayOut(BSTR, aArguments));
    STDMETHOD(COMGETTER(Environment))(ComSafeArrayOut(BSTR, aEnvironment));
    STDMETHOD(COMGETTER(EventSource))(IEventSource **aEventSource);
    STDMETHOD(COMGETTER(ExecutablePath))(BSTR *aExecutablePath);
    STDMETHOD(COMGETTER(ExitCode))(LONG *aExitCode);
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(PID))(ULONG *aPID);
    STDMETHOD(COMGETTER(Status))(ProcessStatus_T *aStatus);

    // public IGuestProcess properties

    // public IProcess methods
    STDMETHOD(WaitFor)(ULONG aWaitFor,
                       ULONG aTimeoutMS,
                       ProcessWaitResult_T *aReason);
    STDMETHOD(WaitForArray)(ComSafeArrayIn(ProcessWaitForFlag_T, aWaitFor),
                            ULONG aTimeoutMS,
                            ProcessWaitResult_T *aReason);
    STDMETHOD(Read)(ULONG aHandle,
                    ULONG aToRead,
                    ULONG aTimeoutMS,
                    ComSafeArrayOut(BYTE, aData));
    STDMETHOD(Write)(ULONG aHandle,
                     ULONG aFlags,
                     ComSafeArrayIn(BYTE, aData),
                     ULONG aTimeoutMS,
                     ULONG *aWritten);
    STDMETHOD(WriteArray)(ULONG aHandle,
                          ComSafeArrayIn(ProcessInputFlag_T, aFlags),
                          ComSafeArrayIn(BYTE, aData),
                          ULONG aTimeoutMS,
                          ULONG *aWritten);
    STDMETHOD(Terminate)();

    // public IGuestProcess methods

private:
    // wrapped IProcess properties
    virtual HRESULT getArguments(std::vector<com::Utf8Str> &aArguments) = 0;
    virtual HRESULT getEnvironment(std::vector<com::Utf8Str> &aEnvironment) = 0;
    virtual HRESULT getEventSource(ComPtr<IEventSource> &aEventSource) = 0;
    virtual HRESULT getExecutablePath(com::Utf8Str &aExecutablePath) = 0;
    virtual HRESULT getExitCode(LONG *aExitCode) = 0;
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getPID(ULONG *aPID) = 0;
    virtual HRESULT getStatus(ProcessStatus_T *aStatus) = 0;

    // wrapped IGuestProcess properties

    // wrapped IProcess methods
    virtual HRESULT waitFor(ULONG aWaitFor,
                            ULONG aTimeoutMS,
                            ProcessWaitResult_T *aReason) = 0;
    virtual HRESULT waitForArray(const std::vector<ProcessWaitForFlag_T> &aWaitFor,
                                 ULONG aTimeoutMS,
                                 ProcessWaitResult_T *aReason) = 0;
    virtual HRESULT read(ULONG aHandle,
                         ULONG aToRead,
                         ULONG aTimeoutMS,
                         std::vector<BYTE> &aData) = 0;
    virtual HRESULT write(ULONG aHandle,
                          ULONG aFlags,
                          const std::vector<BYTE> &aData,
                          ULONG aTimeoutMS,
                          ULONG *aWritten) = 0;
    virtual HRESULT writeArray(ULONG aHandle,
                               const std::vector<ProcessInputFlag_T> &aFlags,
                               const std::vector<BYTE> &aData,
                               ULONG aTimeoutMS,
                               ULONG *aWritten) = 0;
    virtual HRESULT terminate() = 0;

    // wrapped IGuestProcess methods
};

#endif // !GuestProcessWrap_H_

// ##### ENDFILE "GuestProcessWrap.h"

// ##### BEGINFILE "GuestProcessWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestProcess.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTPROCESS

#include "GuestProcessWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestProcessWrap)

//
// IProcess properties
//

STDMETHODIMP GuestProcessWrap::COMGETTER(Arguments)(ComSafeArrayOut(BSTR, aArguments))
{
    LogRelFlow(("{%p} %s: enter aArguments=%p\n", this, "GuestProcess::getArguments", aArguments));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aArguments);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getArguments(ArrayBSTROutConverter(ComSafeArrayOutArg(aArguments)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aArguments=%zu hrc=%Rhrc\n", this, "GuestProcess::getArguments", ComSafeArraySize(*aArguments), hrc));
    return hrc;
}

STDMETHODIMP GuestProcessWrap::COMGETTER(Environment)(ComSafeArrayOut(BSTR, aEnvironment))
{
    LogRelFlow(("{%p} %s: enter aEnvironment=%p\n", this, "GuestProcess::getEnvironment", aEnvironment));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEnvironment);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEnvironment(ArrayBSTROutConverter(ComSafeArrayOutArg(aEnvironment)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEnvironment=%zu hrc=%Rhrc\n", this, "GuestProcess::getEnvironment", ComSafeArraySize(*aEnvironment), hrc));
    return hrc;
}

STDMETHODIMP GuestProcessWrap::COMGETTER(EventSource)(IEventSource **aEventSource)
{
    LogRelFlow(("{%p} %s: enter aEventSource=%p\n", this, "GuestProcess::getEventSource", aEventSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEventSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEventSource(ComTypeOutConverter<IEventSource>(aEventSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEventSource=%p hrc=%Rhrc\n", this, "GuestProcess::getEventSource", *aEventSource, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessWrap::COMGETTER(ExecutablePath)(BSTR *aExecutablePath)
{
    LogRelFlow(("{%p} %s: enter aExecutablePath=%p\n", this, "GuestProcess::getExecutablePath", aExecutablePath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aExecutablePath);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getExecutablePath(BSTROutConverter(aExecutablePath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aExecutablePath=%ls hrc=%Rhrc\n", this, "GuestProcess::getExecutablePath", *aExecutablePath, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessWrap::COMGETTER(ExitCode)(LONG *aExitCode)
{
    LogRelFlow(("{%p} %s: enter aExitCode=%p\n", this, "GuestProcess::getExitCode", aExitCode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aExitCode);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getExitCode(aExitCode);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aExitCode=%RI32 hrc=%Rhrc\n", this, "GuestProcess::getExitCode", *aExitCode, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "GuestProcess::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "GuestProcess::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessWrap::COMGETTER(PID)(ULONG *aPID)
{
    LogRelFlow(("{%p} %s: enter aPID=%p\n", this, "GuestProcess::getPID", aPID));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPID);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPID(aPID);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPID=%RU32 hrc=%Rhrc\n", this, "GuestProcess::getPID", *aPID, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessWrap::COMGETTER(Status)(ProcessStatus_T *aStatus)
{
    LogRelFlow(("{%p} %s: enter aStatus=%p\n", this, "GuestProcess::getStatus", aStatus));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStatus);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getStatus(aStatus);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aStatus=%RU32 hrc=%Rhrc\n", this, "GuestProcess::getStatus", *aStatus, hrc));
    return hrc;
}

//
// IGuestProcess properties
//

//
// IProcess methods
//

STDMETHODIMP GuestProcessWrap::WaitFor(ULONG aWaitFor,
                                       ULONG aTimeoutMS,
                                       ProcessWaitResult_T *aReason)
{
    LogRelFlow(("{%p} %s:enter aWaitFor=%RU32 aTimeoutMS=%RU32 aReason=%p\n", this, "GuestProcess::waitFor", aWaitFor, aTimeoutMS, aReason));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aReason);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitFor(aWaitFor,
                      aTimeoutMS,
                      aReason);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aReason=%RU32 hrc=%Rhrc\n", this, "GuestProcess::waitFor", *aReason, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessWrap::WaitForArray(ComSafeArrayIn(ProcessWaitForFlag_T, aWaitFor),
                                            ULONG aTimeoutMS,
                                            ProcessWaitResult_T *aReason)
{
    LogRelFlow(("{%p} %s:enter aWaitFor=%zu aTimeoutMS=%RU32 aReason=%p\n", this, "GuestProcess::waitForArray", aWaitFor, aTimeoutMS, aReason));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aReason);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitForArray(ArrayInConverter<ProcessWaitForFlag_T>(ComSafeArrayInArg(aWaitFor)).array(),
                           aTimeoutMS,
                           aReason);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aReason=%RU32 hrc=%Rhrc\n", this, "GuestProcess::waitForArray", *aReason, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessWrap::Read(ULONG aHandle,
                                    ULONG aToRead,
                                    ULONG aTimeoutMS,
                                    ComSafeArrayOut(BYTE, aData))
{
    LogRelFlow(("{%p} %s:enter aHandle=%RU32 aToRead=%RU32 aTimeoutMS=%RU32 aData=%p\n", this, "GuestProcess::read", aHandle, aToRead, aTimeoutMS, aData));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aData);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = read(aHandle,
                   aToRead,
                   aTimeoutMS,
                   ArrayOutConverter<BYTE>(ComSafeArrayOutArg(aData)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aData=%zu hrc=%Rhrc\n", this, "GuestProcess::read", ComSafeArraySize(*aData), hrc));
    return hrc;
}

STDMETHODIMP GuestProcessWrap::Write(ULONG aHandle,
                                     ULONG aFlags,
                                     ComSafeArrayIn(BYTE, aData),
                                     ULONG aTimeoutMS,
                                     ULONG *aWritten)
{
    LogRelFlow(("{%p} %s:enter aHandle=%RU32 aFlags=%RU32 aData=%zu aTimeoutMS=%RU32 aWritten=%p\n", this, "GuestProcess::write", aHandle, aFlags, aData, aTimeoutMS, aWritten));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWritten);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = write(aHandle,
                    aFlags,
                    ArrayInConverter<BYTE>(ComSafeArrayInArg(aData)).array(),
                    aTimeoutMS,
                    aWritten);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aWritten=%RU32 hrc=%Rhrc\n", this, "GuestProcess::write", *aWritten, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessWrap::WriteArray(ULONG aHandle,
                                          ComSafeArrayIn(ProcessInputFlag_T, aFlags),
                                          ComSafeArrayIn(BYTE, aData),
                                          ULONG aTimeoutMS,
                                          ULONG *aWritten)
{
    LogRelFlow(("{%p} %s:enter aHandle=%RU32 aFlags=%zu aData=%zu aTimeoutMS=%RU32 aWritten=%p\n", this, "GuestProcess::writeArray", aHandle, aFlags, aData, aTimeoutMS, aWritten));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWritten);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = writeArray(aHandle,
                         ArrayInConverter<ProcessInputFlag_T>(ComSafeArrayInArg(aFlags)).array(),
                         ArrayInConverter<BYTE>(ComSafeArrayInArg(aData)).array(),
                         aTimeoutMS,
                         aWritten);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aWritten=%RU32 hrc=%Rhrc\n", this, "GuestProcess::writeArray", *aWritten, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessWrap::Terminate()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestProcess::terminate"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = terminate();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestProcess::terminate", hrc));
    return hrc;
}

//
// IGuestProcess methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestProcessWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(GuestProcessWrap, IGuestProcess, IProcess)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestProcessWrap.cpp"

// ##### BEGINFILE "DirectoryWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IDirectory.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef DirectoryWrap_H_
#define DirectoryWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE DirectoryWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IDirectory)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(DirectoryWrap, IDirectory)
    DECLARE_NOT_AGGREGATABLE(DirectoryWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(DirectoryWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IDirectory)
        COM_INTERFACE_ENTRY2(IDispatch, IDirectory)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(DirectoryWrap)

    // public IDirectory properties
    STDMETHOD(COMGETTER(DirectoryName))(BSTR *aDirectoryName);
    STDMETHOD(COMGETTER(Filter))(BSTR *aFilter);

    // public IDirectory methods
    STDMETHOD(Close)();
    STDMETHOD(Read)(IFsObjInfo **aObjInfo);

private:
    // wrapped IDirectory properties
    virtual HRESULT getDirectoryName(com::Utf8Str &aDirectoryName) = 0;
    virtual HRESULT getFilter(com::Utf8Str &aFilter) = 0;

    // wrapped IDirectory methods
    virtual HRESULT close() = 0;
    virtual HRESULT read(ComPtr<IFsObjInfo> &aObjInfo) = 0;
};

#endif // !DirectoryWrap_H_

// ##### ENDFILE "DirectoryWrap.h"

// ##### BEGINFILE "DirectoryWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IDirectory.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_DIRECTORY

#include "DirectoryWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(DirectoryWrap)

//
// IDirectory properties
//

STDMETHODIMP DirectoryWrap::COMGETTER(DirectoryName)(BSTR *aDirectoryName)
{
    LogRelFlow(("{%p} %s: enter aDirectoryName=%p\n", this, "Directory::getDirectoryName", aDirectoryName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDirectoryName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDirectoryName(BSTROutConverter(aDirectoryName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDirectoryName=%ls hrc=%Rhrc\n", this, "Directory::getDirectoryName", *aDirectoryName, hrc));
    return hrc;
}

STDMETHODIMP DirectoryWrap::COMGETTER(Filter)(BSTR *aFilter)
{
    LogRelFlow(("{%p} %s: enter aFilter=%p\n", this, "Directory::getFilter", aFilter));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFilter);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFilter(BSTROutConverter(aFilter).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFilter=%ls hrc=%Rhrc\n", this, "Directory::getFilter", *aFilter, hrc));
    return hrc;
}

//
// IDirectory methods
//

STDMETHODIMP DirectoryWrap::Close()
{
    LogRelFlow(("{%p} %s:enter\n", this, "Directory::close"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = close();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Directory::close", hrc));
    return hrc;
}

STDMETHODIMP DirectoryWrap::Read(IFsObjInfo **aObjInfo)
{
    LogRelFlow(("{%p} %s:enter aObjInfo=%p\n", this, "Directory::read", aObjInfo));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aObjInfo);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = read(ComTypeOutConverter<IFsObjInfo>(aObjInfo).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aObjInfo=%p hrc=%Rhrc\n", this, "Directory::read", *aObjInfo, hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(DirectoryWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(DirectoryWrap, IDirectory)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "DirectoryWrap.cpp"

// ##### BEGINFILE "GuestDirectoryWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestDirectory.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestDirectoryWrap_H_
#define GuestDirectoryWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestDirectoryWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestDirectory)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestDirectoryWrap, IGuestDirectory)
    DECLARE_NOT_AGGREGATABLE(GuestDirectoryWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestDirectoryWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestDirectory)
        COM_INTERFACE_ENTRY(IDirectory)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestDirectory)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestDirectoryWrap)

    // public IDirectory properties
    STDMETHOD(COMGETTER(DirectoryName))(BSTR *aDirectoryName);
    STDMETHOD(COMGETTER(Filter))(BSTR *aFilter);

    // public IGuestDirectory properties

    // public IDirectory methods
    STDMETHOD(Close)();
    STDMETHOD(Read)(IFsObjInfo **aObjInfo);

    // public IGuestDirectory methods

private:
    // wrapped IDirectory properties
    virtual HRESULT getDirectoryName(com::Utf8Str &aDirectoryName) = 0;
    virtual HRESULT getFilter(com::Utf8Str &aFilter) = 0;

    // wrapped IGuestDirectory properties

    // wrapped IDirectory methods
    virtual HRESULT close() = 0;
    virtual HRESULT read(ComPtr<IFsObjInfo> &aObjInfo) = 0;

    // wrapped IGuestDirectory methods
};

#endif // !GuestDirectoryWrap_H_

// ##### ENDFILE "GuestDirectoryWrap.h"

// ##### BEGINFILE "GuestDirectoryWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestDirectory.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTDIRECTORY

#include "GuestDirectoryWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestDirectoryWrap)

//
// IDirectory properties
//

STDMETHODIMP GuestDirectoryWrap::COMGETTER(DirectoryName)(BSTR *aDirectoryName)
{
    LogRelFlow(("{%p} %s: enter aDirectoryName=%p\n", this, "GuestDirectory::getDirectoryName", aDirectoryName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDirectoryName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDirectoryName(BSTROutConverter(aDirectoryName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDirectoryName=%ls hrc=%Rhrc\n", this, "GuestDirectory::getDirectoryName", *aDirectoryName, hrc));
    return hrc;
}

STDMETHODIMP GuestDirectoryWrap::COMGETTER(Filter)(BSTR *aFilter)
{
    LogRelFlow(("{%p} %s: enter aFilter=%p\n", this, "GuestDirectory::getFilter", aFilter));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFilter);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFilter(BSTROutConverter(aFilter).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFilter=%ls hrc=%Rhrc\n", this, "GuestDirectory::getFilter", *aFilter, hrc));
    return hrc;
}

//
// IGuestDirectory properties
//

//
// IDirectory methods
//

STDMETHODIMP GuestDirectoryWrap::Close()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestDirectory::close"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = close();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestDirectory::close", hrc));
    return hrc;
}

STDMETHODIMP GuestDirectoryWrap::Read(IFsObjInfo **aObjInfo)
{
    LogRelFlow(("{%p} %s:enter aObjInfo=%p\n", this, "GuestDirectory::read", aObjInfo));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aObjInfo);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = read(ComTypeOutConverter<IFsObjInfo>(aObjInfo).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aObjInfo=%p hrc=%Rhrc\n", this, "GuestDirectory::read", *aObjInfo, hrc));
    return hrc;
}

//
// IGuestDirectory methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestDirectoryWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(GuestDirectoryWrap, IGuestDirectory, IDirectory)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestDirectoryWrap.cpp"

// ##### BEGINFILE "FileWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IFile.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef FileWrap_H_
#define FileWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE FileWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IFile)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(FileWrap, IFile)
    DECLARE_NOT_AGGREGATABLE(FileWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(FileWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IFile)
        COM_INTERFACE_ENTRY2(IDispatch, IFile)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(FileWrap)

    // public IFile properties
    STDMETHOD(COMGETTER(CreationMode))(ULONG *aCreationMode);
    STDMETHOD(COMGETTER(Disposition))(BSTR *aDisposition);
    STDMETHOD(COMGETTER(EventSource))(IEventSource **aEventSource);
    STDMETHOD(COMGETTER(FileName))(BSTR *aFileName);
    STDMETHOD(COMGETTER(Id))(ULONG *aId);
    STDMETHOD(COMGETTER(InitialSize))(LONG64 *aInitialSize);
    STDMETHOD(COMGETTER(OpenMode))(BSTR *aOpenMode);
    STDMETHOD(COMGETTER(Offset))(LONG64 *aOffset);
    STDMETHOD(COMGETTER(Status))(FileStatus_T *aStatus);

    // public IFile methods
    STDMETHOD(Close)();
    STDMETHOD(QueryInfo)(IFsObjInfo **aObjInfo);
    STDMETHOD(Read)(ULONG aToRead,
                    ULONG aTimeoutMS,
                    ComSafeArrayOut(BYTE, aData));
    STDMETHOD(ReadAt)(LONG64 aOffset,
                      ULONG aToRead,
                      ULONG aTimeoutMS,
                      ComSafeArrayOut(BYTE, aData));
    STDMETHOD(Seek)(LONG64 aOffset,
                    FileSeekType_T aWhence);
    STDMETHOD(SetACL)(IN_BSTR aAcl);
    STDMETHOD(Write)(ComSafeArrayIn(BYTE, aData),
                     ULONG aTimeoutMS,
                     ULONG *aWritten);
    STDMETHOD(WriteAt)(LONG64 aOffset,
                       ComSafeArrayIn(BYTE, aData),
                       ULONG aTimeoutMS,
                       ULONG *aWritten);

private:
    // wrapped IFile properties
    virtual HRESULT getCreationMode(ULONG *aCreationMode) = 0;
    virtual HRESULT getDisposition(com::Utf8Str &aDisposition) = 0;
    virtual HRESULT getEventSource(ComPtr<IEventSource> &aEventSource) = 0;
    virtual HRESULT getFileName(com::Utf8Str &aFileName) = 0;
    virtual HRESULT getId(ULONG *aId) = 0;
    virtual HRESULT getInitialSize(LONG64 *aInitialSize) = 0;
    virtual HRESULT getOpenMode(com::Utf8Str &aOpenMode) = 0;
    virtual HRESULT getOffset(LONG64 *aOffset) = 0;
    virtual HRESULT getStatus(FileStatus_T *aStatus) = 0;

    // wrapped IFile methods
    virtual HRESULT close() = 0;
    virtual HRESULT queryInfo(ComPtr<IFsObjInfo> &aObjInfo) = 0;
    virtual HRESULT read(ULONG aToRead,
                         ULONG aTimeoutMS,
                         std::vector<BYTE> &aData) = 0;
    virtual HRESULT readAt(LONG64 aOffset,
                           ULONG aToRead,
                           ULONG aTimeoutMS,
                           std::vector<BYTE> &aData) = 0;
    virtual HRESULT seek(LONG64 aOffset,
                         FileSeekType_T aWhence) = 0;
    virtual HRESULT setACL(const com::Utf8Str &aAcl) = 0;
    virtual HRESULT write(const std::vector<BYTE> &aData,
                          ULONG aTimeoutMS,
                          ULONG *aWritten) = 0;
    virtual HRESULT writeAt(LONG64 aOffset,
                            const std::vector<BYTE> &aData,
                            ULONG aTimeoutMS,
                            ULONG *aWritten) = 0;
};

#endif // !FileWrap_H_

// ##### ENDFILE "FileWrap.h"

// ##### BEGINFILE "FileWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IFile.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_FILE

#include "FileWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(FileWrap)

//
// IFile properties
//

STDMETHODIMP FileWrap::COMGETTER(CreationMode)(ULONG *aCreationMode)
{
    LogRelFlow(("{%p} %s: enter aCreationMode=%p\n", this, "File::getCreationMode", aCreationMode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCreationMode);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getCreationMode(aCreationMode);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aCreationMode=%RU32 hrc=%Rhrc\n", this, "File::getCreationMode", *aCreationMode, hrc));
    return hrc;
}

STDMETHODIMP FileWrap::COMGETTER(Disposition)(BSTR *aDisposition)
{
    LogRelFlow(("{%p} %s: enter aDisposition=%p\n", this, "File::getDisposition", aDisposition));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDisposition);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDisposition(BSTROutConverter(aDisposition).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDisposition=%ls hrc=%Rhrc\n", this, "File::getDisposition", *aDisposition, hrc));
    return hrc;
}

STDMETHODIMP FileWrap::COMGETTER(EventSource)(IEventSource **aEventSource)
{
    LogRelFlow(("{%p} %s: enter aEventSource=%p\n", this, "File::getEventSource", aEventSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEventSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEventSource(ComTypeOutConverter<IEventSource>(aEventSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEventSource=%p hrc=%Rhrc\n", this, "File::getEventSource", *aEventSource, hrc));
    return hrc;
}

STDMETHODIMP FileWrap::COMGETTER(FileName)(BSTR *aFileName)
{
    LogRelFlow(("{%p} %s: enter aFileName=%p\n", this, "File::getFileName", aFileName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFileName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFileName(BSTROutConverter(aFileName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFileName=%ls hrc=%Rhrc\n", this, "File::getFileName", *aFileName, hrc));
    return hrc;
}

STDMETHODIMP FileWrap::COMGETTER(Id)(ULONG *aId)
{
    LogRelFlow(("{%p} %s: enter aId=%p\n", this, "File::getId", aId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getId(aId);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aId=%RU32 hrc=%Rhrc\n", this, "File::getId", *aId, hrc));
    return hrc;
}

STDMETHODIMP FileWrap::COMGETTER(InitialSize)(LONG64 *aInitialSize)
{
    LogRelFlow(("{%p} %s: enter aInitialSize=%p\n", this, "File::getInitialSize", aInitialSize));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aInitialSize);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getInitialSize(aInitialSize);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aInitialSize=%RI64 hrc=%Rhrc\n", this, "File::getInitialSize", *aInitialSize, hrc));
    return hrc;
}

STDMETHODIMP FileWrap::COMGETTER(OpenMode)(BSTR *aOpenMode)
{
    LogRelFlow(("{%p} %s: enter aOpenMode=%p\n", this, "File::getOpenMode", aOpenMode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOpenMode);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOpenMode(BSTROutConverter(aOpenMode).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOpenMode=%ls hrc=%Rhrc\n", this, "File::getOpenMode", *aOpenMode, hrc));
    return hrc;
}

STDMETHODIMP FileWrap::COMGETTER(Offset)(LONG64 *aOffset)
{
    LogRelFlow(("{%p} %s: enter aOffset=%p\n", this, "File::getOffset", aOffset));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOffset);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOffset(aOffset);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOffset=%RI64 hrc=%Rhrc\n", this, "File::getOffset", *aOffset, hrc));
    return hrc;
}

STDMETHODIMP FileWrap::COMGETTER(Status)(FileStatus_T *aStatus)
{
    LogRelFlow(("{%p} %s: enter aStatus=%p\n", this, "File::getStatus", aStatus));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStatus);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getStatus(aStatus);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aStatus=%RU32 hrc=%Rhrc\n", this, "File::getStatus", *aStatus, hrc));
    return hrc;
}

//
// IFile methods
//

STDMETHODIMP FileWrap::Close()
{
    LogRelFlow(("{%p} %s:enter\n", this, "File::close"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = close();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "File::close", hrc));
    return hrc;
}

STDMETHODIMP FileWrap::QueryInfo(IFsObjInfo **aObjInfo)
{
    LogRelFlow(("{%p} %s:enter aObjInfo=%p\n", this, "File::queryInfo", aObjInfo));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aObjInfo);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = queryInfo(ComTypeOutConverter<IFsObjInfo>(aObjInfo).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aObjInfo=%p hrc=%Rhrc\n", this, "File::queryInfo", *aObjInfo, hrc));
    return hrc;
}

STDMETHODIMP FileWrap::Read(ULONG aToRead,
                            ULONG aTimeoutMS,
                            ComSafeArrayOut(BYTE, aData))
{
    LogRelFlow(("{%p} %s:enter aToRead=%RU32 aTimeoutMS=%RU32 aData=%p\n", this, "File::read", aToRead, aTimeoutMS, aData));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aData);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = read(aToRead,
                   aTimeoutMS,
                   ArrayOutConverter<BYTE>(ComSafeArrayOutArg(aData)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aData=%zu hrc=%Rhrc\n", this, "File::read", ComSafeArraySize(*aData), hrc));
    return hrc;
}

STDMETHODIMP FileWrap::ReadAt(LONG64 aOffset,
                              ULONG aToRead,
                              ULONG aTimeoutMS,
                              ComSafeArrayOut(BYTE, aData))
{
    LogRelFlow(("{%p} %s:enter aOffset=%RI64 aToRead=%RU32 aTimeoutMS=%RU32 aData=%p\n", this, "File::readAt", aOffset, aToRead, aTimeoutMS, aData));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aData);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = readAt(aOffset,
                     aToRead,
                     aTimeoutMS,
                     ArrayOutConverter<BYTE>(ComSafeArrayOutArg(aData)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aData=%zu hrc=%Rhrc\n", this, "File::readAt", ComSafeArraySize(*aData), hrc));
    return hrc;
}

STDMETHODIMP FileWrap::Seek(LONG64 aOffset,
                            FileSeekType_T aWhence)
{
    LogRelFlow(("{%p} %s:enter aOffset=%RI64 aWhence=%RU32\n", this, "File::seek", aOffset, aWhence));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = seek(aOffset,
                   aWhence);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "File::seek", hrc));
    return hrc;
}

STDMETHODIMP FileWrap::SetACL(IN_BSTR aAcl)
{
    LogRelFlow(("{%p} %s:enter aAcl=%ls\n", this, "File::setACL", aAcl));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setACL(BSTRInConverter(aAcl).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "File::setACL", hrc));
    return hrc;
}

STDMETHODIMP FileWrap::Write(ComSafeArrayIn(BYTE, aData),
                             ULONG aTimeoutMS,
                             ULONG *aWritten)
{
    LogRelFlow(("{%p} %s:enter aData=%zu aTimeoutMS=%RU32 aWritten=%p\n", this, "File::write", aData, aTimeoutMS, aWritten));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWritten);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = write(ArrayInConverter<BYTE>(ComSafeArrayInArg(aData)).array(),
                    aTimeoutMS,
                    aWritten);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aWritten=%RU32 hrc=%Rhrc\n", this, "File::write", *aWritten, hrc));
    return hrc;
}

STDMETHODIMP FileWrap::WriteAt(LONG64 aOffset,
                               ComSafeArrayIn(BYTE, aData),
                               ULONG aTimeoutMS,
                               ULONG *aWritten)
{
    LogRelFlow(("{%p} %s:enter aOffset=%RI64 aData=%zu aTimeoutMS=%RU32 aWritten=%p\n", this, "File::writeAt", aOffset, aData, aTimeoutMS, aWritten));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWritten);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = writeAt(aOffset,
                      ArrayInConverter<BYTE>(ComSafeArrayInArg(aData)).array(),
                      aTimeoutMS,
                      aWritten);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aWritten=%RU32 hrc=%Rhrc\n", this, "File::writeAt", *aWritten, hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(FileWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(FileWrap, IFile)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "FileWrap.cpp"

// ##### BEGINFILE "GuestFileWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestFile.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestFileWrap_H_
#define GuestFileWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestFileWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestFile)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestFileWrap, IGuestFile)
    DECLARE_NOT_AGGREGATABLE(GuestFileWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestFileWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestFile)
        COM_INTERFACE_ENTRY(IFile)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestFile)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestFileWrap)

    // public IFile properties
    STDMETHOD(COMGETTER(CreationMode))(ULONG *aCreationMode);
    STDMETHOD(COMGETTER(Disposition))(BSTR *aDisposition);
    STDMETHOD(COMGETTER(EventSource))(IEventSource **aEventSource);
    STDMETHOD(COMGETTER(FileName))(BSTR *aFileName);
    STDMETHOD(COMGETTER(Id))(ULONG *aId);
    STDMETHOD(COMGETTER(InitialSize))(LONG64 *aInitialSize);
    STDMETHOD(COMGETTER(OpenMode))(BSTR *aOpenMode);
    STDMETHOD(COMGETTER(Offset))(LONG64 *aOffset);
    STDMETHOD(COMGETTER(Status))(FileStatus_T *aStatus);

    // public IGuestFile properties

    // public IFile methods
    STDMETHOD(Close)();
    STDMETHOD(QueryInfo)(IFsObjInfo **aObjInfo);
    STDMETHOD(Read)(ULONG aToRead,
                    ULONG aTimeoutMS,
                    ComSafeArrayOut(BYTE, aData));
    STDMETHOD(ReadAt)(LONG64 aOffset,
                      ULONG aToRead,
                      ULONG aTimeoutMS,
                      ComSafeArrayOut(BYTE, aData));
    STDMETHOD(Seek)(LONG64 aOffset,
                    FileSeekType_T aWhence);
    STDMETHOD(SetACL)(IN_BSTR aAcl);
    STDMETHOD(Write)(ComSafeArrayIn(BYTE, aData),
                     ULONG aTimeoutMS,
                     ULONG *aWritten);
    STDMETHOD(WriteAt)(LONG64 aOffset,
                       ComSafeArrayIn(BYTE, aData),
                       ULONG aTimeoutMS,
                       ULONG *aWritten);

    // public IGuestFile methods

private:
    // wrapped IFile properties
    virtual HRESULT getCreationMode(ULONG *aCreationMode) = 0;
    virtual HRESULT getDisposition(com::Utf8Str &aDisposition) = 0;
    virtual HRESULT getEventSource(ComPtr<IEventSource> &aEventSource) = 0;
    virtual HRESULT getFileName(com::Utf8Str &aFileName) = 0;
    virtual HRESULT getId(ULONG *aId) = 0;
    virtual HRESULT getInitialSize(LONG64 *aInitialSize) = 0;
    virtual HRESULT getOpenMode(com::Utf8Str &aOpenMode) = 0;
    virtual HRESULT getOffset(LONG64 *aOffset) = 0;
    virtual HRESULT getStatus(FileStatus_T *aStatus) = 0;

    // wrapped IGuestFile properties

    // wrapped IFile methods
    virtual HRESULT close() = 0;
    virtual HRESULT queryInfo(ComPtr<IFsObjInfo> &aObjInfo) = 0;
    virtual HRESULT read(ULONG aToRead,
                         ULONG aTimeoutMS,
                         std::vector<BYTE> &aData) = 0;
    virtual HRESULT readAt(LONG64 aOffset,
                           ULONG aToRead,
                           ULONG aTimeoutMS,
                           std::vector<BYTE> &aData) = 0;
    virtual HRESULT seek(LONG64 aOffset,
                         FileSeekType_T aWhence) = 0;
    virtual HRESULT setACL(const com::Utf8Str &aAcl) = 0;
    virtual HRESULT write(const std::vector<BYTE> &aData,
                          ULONG aTimeoutMS,
                          ULONG *aWritten) = 0;
    virtual HRESULT writeAt(LONG64 aOffset,
                            const std::vector<BYTE> &aData,
                            ULONG aTimeoutMS,
                            ULONG *aWritten) = 0;

    // wrapped IGuestFile methods
};

#endif // !GuestFileWrap_H_

// ##### ENDFILE "GuestFileWrap.h"

// ##### BEGINFILE "GuestFileWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestFile.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTFILE

#include "GuestFileWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestFileWrap)

//
// IFile properties
//

STDMETHODIMP GuestFileWrap::COMGETTER(CreationMode)(ULONG *aCreationMode)
{
    LogRelFlow(("{%p} %s: enter aCreationMode=%p\n", this, "GuestFile::getCreationMode", aCreationMode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCreationMode);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getCreationMode(aCreationMode);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aCreationMode=%RU32 hrc=%Rhrc\n", this, "GuestFile::getCreationMode", *aCreationMode, hrc));
    return hrc;
}

STDMETHODIMP GuestFileWrap::COMGETTER(Disposition)(BSTR *aDisposition)
{
    LogRelFlow(("{%p} %s: enter aDisposition=%p\n", this, "GuestFile::getDisposition", aDisposition));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDisposition);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDisposition(BSTROutConverter(aDisposition).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDisposition=%ls hrc=%Rhrc\n", this, "GuestFile::getDisposition", *aDisposition, hrc));
    return hrc;
}

STDMETHODIMP GuestFileWrap::COMGETTER(EventSource)(IEventSource **aEventSource)
{
    LogRelFlow(("{%p} %s: enter aEventSource=%p\n", this, "GuestFile::getEventSource", aEventSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEventSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEventSource(ComTypeOutConverter<IEventSource>(aEventSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEventSource=%p hrc=%Rhrc\n", this, "GuestFile::getEventSource", *aEventSource, hrc));
    return hrc;
}

STDMETHODIMP GuestFileWrap::COMGETTER(FileName)(BSTR *aFileName)
{
    LogRelFlow(("{%p} %s: enter aFileName=%p\n", this, "GuestFile::getFileName", aFileName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFileName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFileName(BSTROutConverter(aFileName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFileName=%ls hrc=%Rhrc\n", this, "GuestFile::getFileName", *aFileName, hrc));
    return hrc;
}

STDMETHODIMP GuestFileWrap::COMGETTER(Id)(ULONG *aId)
{
    LogRelFlow(("{%p} %s: enter aId=%p\n", this, "GuestFile::getId", aId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getId(aId);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aId=%RU32 hrc=%Rhrc\n", this, "GuestFile::getId", *aId, hrc));
    return hrc;
}

STDMETHODIMP GuestFileWrap::COMGETTER(InitialSize)(LONG64 *aInitialSize)
{
    LogRelFlow(("{%p} %s: enter aInitialSize=%p\n", this, "GuestFile::getInitialSize", aInitialSize));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aInitialSize);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getInitialSize(aInitialSize);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aInitialSize=%RI64 hrc=%Rhrc\n", this, "GuestFile::getInitialSize", *aInitialSize, hrc));
    return hrc;
}

STDMETHODIMP GuestFileWrap::COMGETTER(OpenMode)(BSTR *aOpenMode)
{
    LogRelFlow(("{%p} %s: enter aOpenMode=%p\n", this, "GuestFile::getOpenMode", aOpenMode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOpenMode);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOpenMode(BSTROutConverter(aOpenMode).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOpenMode=%ls hrc=%Rhrc\n", this, "GuestFile::getOpenMode", *aOpenMode, hrc));
    return hrc;
}

STDMETHODIMP GuestFileWrap::COMGETTER(Offset)(LONG64 *aOffset)
{
    LogRelFlow(("{%p} %s: enter aOffset=%p\n", this, "GuestFile::getOffset", aOffset));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOffset);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOffset(aOffset);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOffset=%RI64 hrc=%Rhrc\n", this, "GuestFile::getOffset", *aOffset, hrc));
    return hrc;
}

STDMETHODIMP GuestFileWrap::COMGETTER(Status)(FileStatus_T *aStatus)
{
    LogRelFlow(("{%p} %s: enter aStatus=%p\n", this, "GuestFile::getStatus", aStatus));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStatus);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getStatus(aStatus);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aStatus=%RU32 hrc=%Rhrc\n", this, "GuestFile::getStatus", *aStatus, hrc));
    return hrc;
}

//
// IGuestFile properties
//

//
// IFile methods
//

STDMETHODIMP GuestFileWrap::Close()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestFile::close"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = close();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestFile::close", hrc));
    return hrc;
}

STDMETHODIMP GuestFileWrap::QueryInfo(IFsObjInfo **aObjInfo)
{
    LogRelFlow(("{%p} %s:enter aObjInfo=%p\n", this, "GuestFile::queryInfo", aObjInfo));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aObjInfo);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = queryInfo(ComTypeOutConverter<IFsObjInfo>(aObjInfo).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aObjInfo=%p hrc=%Rhrc\n", this, "GuestFile::queryInfo", *aObjInfo, hrc));
    return hrc;
}

STDMETHODIMP GuestFileWrap::Read(ULONG aToRead,
                                 ULONG aTimeoutMS,
                                 ComSafeArrayOut(BYTE, aData))
{
    LogRelFlow(("{%p} %s:enter aToRead=%RU32 aTimeoutMS=%RU32 aData=%p\n", this, "GuestFile::read", aToRead, aTimeoutMS, aData));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aData);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = read(aToRead,
                   aTimeoutMS,
                   ArrayOutConverter<BYTE>(ComSafeArrayOutArg(aData)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aData=%zu hrc=%Rhrc\n", this, "GuestFile::read", ComSafeArraySize(*aData), hrc));
    return hrc;
}

STDMETHODIMP GuestFileWrap::ReadAt(LONG64 aOffset,
                                   ULONG aToRead,
                                   ULONG aTimeoutMS,
                                   ComSafeArrayOut(BYTE, aData))
{
    LogRelFlow(("{%p} %s:enter aOffset=%RI64 aToRead=%RU32 aTimeoutMS=%RU32 aData=%p\n", this, "GuestFile::readAt", aOffset, aToRead, aTimeoutMS, aData));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aData);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = readAt(aOffset,
                     aToRead,
                     aTimeoutMS,
                     ArrayOutConverter<BYTE>(ComSafeArrayOutArg(aData)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aData=%zu hrc=%Rhrc\n", this, "GuestFile::readAt", ComSafeArraySize(*aData), hrc));
    return hrc;
}

STDMETHODIMP GuestFileWrap::Seek(LONG64 aOffset,
                                 FileSeekType_T aWhence)
{
    LogRelFlow(("{%p} %s:enter aOffset=%RI64 aWhence=%RU32\n", this, "GuestFile::seek", aOffset, aWhence));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = seek(aOffset,
                   aWhence);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestFile::seek", hrc));
    return hrc;
}

STDMETHODIMP GuestFileWrap::SetACL(IN_BSTR aAcl)
{
    LogRelFlow(("{%p} %s:enter aAcl=%ls\n", this, "GuestFile::setACL", aAcl));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setACL(BSTRInConverter(aAcl).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestFile::setACL", hrc));
    return hrc;
}

STDMETHODIMP GuestFileWrap::Write(ComSafeArrayIn(BYTE, aData),
                                  ULONG aTimeoutMS,
                                  ULONG *aWritten)
{
    LogRelFlow(("{%p} %s:enter aData=%zu aTimeoutMS=%RU32 aWritten=%p\n", this, "GuestFile::write", aData, aTimeoutMS, aWritten));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWritten);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = write(ArrayInConverter<BYTE>(ComSafeArrayInArg(aData)).array(),
                    aTimeoutMS,
                    aWritten);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aWritten=%RU32 hrc=%Rhrc\n", this, "GuestFile::write", *aWritten, hrc));
    return hrc;
}

STDMETHODIMP GuestFileWrap::WriteAt(LONG64 aOffset,
                                    ComSafeArrayIn(BYTE, aData),
                                    ULONG aTimeoutMS,
                                    ULONG *aWritten)
{
    LogRelFlow(("{%p} %s:enter aOffset=%RI64 aData=%zu aTimeoutMS=%RU32 aWritten=%p\n", this, "GuestFile::writeAt", aOffset, aData, aTimeoutMS, aWritten));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWritten);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = writeAt(aOffset,
                      ArrayInConverter<BYTE>(ComSafeArrayInArg(aData)).array(),
                      aTimeoutMS,
                      aWritten);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aWritten=%RU32 hrc=%Rhrc\n", this, "GuestFile::writeAt", *aWritten, hrc));
    return hrc;
}

//
// IGuestFile methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestFileWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(GuestFileWrap, IGuestFile, IFile)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestFileWrap.cpp"

// ##### BEGINFILE "FsObjInfoWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IFsObjInfo.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef FsObjInfoWrap_H_
#define FsObjInfoWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE FsObjInfoWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IFsObjInfo)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(FsObjInfoWrap, IFsObjInfo)
    DECLARE_NOT_AGGREGATABLE(FsObjInfoWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(FsObjInfoWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IFsObjInfo)
        COM_INTERFACE_ENTRY2(IDispatch, IFsObjInfo)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(FsObjInfoWrap)

    // public IFsObjInfo properties
    STDMETHOD(COMGETTER(AccessTime))(LONG64 *aAccessTime);
    STDMETHOD(COMGETTER(AllocatedSize))(LONG64 *aAllocatedSize);
    STDMETHOD(COMGETTER(BirthTime))(LONG64 *aBirthTime);
    STDMETHOD(COMGETTER(ChangeTime))(LONG64 *aChangeTime);
    STDMETHOD(COMGETTER(DeviceNumber))(ULONG *aDeviceNumber);
    STDMETHOD(COMGETTER(FileAttributes))(BSTR *aFileAttributes);
    STDMETHOD(COMGETTER(GenerationId))(ULONG *aGenerationId);
    STDMETHOD(COMGETTER(GID))(ULONG *aGID);
    STDMETHOD(COMGETTER(GroupName))(BSTR *aGroupName);
    STDMETHOD(COMGETTER(HardLinks))(ULONG *aHardLinks);
    STDMETHOD(COMGETTER(ModificationTime))(LONG64 *aModificationTime);
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(NodeId))(LONG64 *aNodeId);
    STDMETHOD(COMGETTER(NodeIdDevice))(ULONG *aNodeIdDevice);
    STDMETHOD(COMGETTER(ObjectSize))(LONG64 *aObjectSize);
    STDMETHOD(COMGETTER(Type))(FsObjType_T *aType);
    STDMETHOD(COMGETTER(UID))(ULONG *aUID);
    STDMETHOD(COMGETTER(UserFlags))(ULONG *aUserFlags);
    STDMETHOD(COMGETTER(UserName))(BSTR *aUserName);

    // public IFsObjInfo methods

private:
    // wrapped IFsObjInfo properties
    virtual HRESULT getAccessTime(LONG64 *aAccessTime) = 0;
    virtual HRESULT getAllocatedSize(LONG64 *aAllocatedSize) = 0;
    virtual HRESULT getBirthTime(LONG64 *aBirthTime) = 0;
    virtual HRESULT getChangeTime(LONG64 *aChangeTime) = 0;
    virtual HRESULT getDeviceNumber(ULONG *aDeviceNumber) = 0;
    virtual HRESULT getFileAttributes(com::Utf8Str &aFileAttributes) = 0;
    virtual HRESULT getGenerationId(ULONG *aGenerationId) = 0;
    virtual HRESULT getGID(ULONG *aGID) = 0;
    virtual HRESULT getGroupName(com::Utf8Str &aGroupName) = 0;
    virtual HRESULT getHardLinks(ULONG *aHardLinks) = 0;
    virtual HRESULT getModificationTime(LONG64 *aModificationTime) = 0;
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getNodeId(LONG64 *aNodeId) = 0;
    virtual HRESULT getNodeIdDevice(ULONG *aNodeIdDevice) = 0;
    virtual HRESULT getObjectSize(LONG64 *aObjectSize) = 0;
    virtual HRESULT getType(FsObjType_T *aType) = 0;
    virtual HRESULT getUID(ULONG *aUID) = 0;
    virtual HRESULT getUserFlags(ULONG *aUserFlags) = 0;
    virtual HRESULT getUserName(com::Utf8Str &aUserName) = 0;

    // wrapped IFsObjInfo methods
};

#endif // !FsObjInfoWrap_H_

// ##### ENDFILE "FsObjInfoWrap.h"

// ##### BEGINFILE "FsObjInfoWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IFsObjInfo.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_FSOBJINFO

#include "FsObjInfoWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(FsObjInfoWrap)

//
// IFsObjInfo properties
//

STDMETHODIMP FsObjInfoWrap::COMGETTER(AccessTime)(LONG64 *aAccessTime)
{
    LogRelFlow(("{%p} %s: enter aAccessTime=%p\n", this, "FsObjInfo::getAccessTime", aAccessTime));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAccessTime);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAccessTime(aAccessTime);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAccessTime=%RI64 hrc=%Rhrc\n", this, "FsObjInfo::getAccessTime", *aAccessTime, hrc));
    return hrc;
}

STDMETHODIMP FsObjInfoWrap::COMGETTER(AllocatedSize)(LONG64 *aAllocatedSize)
{
    LogRelFlow(("{%p} %s: enter aAllocatedSize=%p\n", this, "FsObjInfo::getAllocatedSize", aAllocatedSize));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAllocatedSize);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAllocatedSize(aAllocatedSize);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAllocatedSize=%RI64 hrc=%Rhrc\n", this, "FsObjInfo::getAllocatedSize", *aAllocatedSize, hrc));
    return hrc;
}

STDMETHODIMP FsObjInfoWrap::COMGETTER(BirthTime)(LONG64 *aBirthTime)
{
    LogRelFlow(("{%p} %s: enter aBirthTime=%p\n", this, "FsObjInfo::getBirthTime", aBirthTime));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBirthTime);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBirthTime(aBirthTime);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBirthTime=%RI64 hrc=%Rhrc\n", this, "FsObjInfo::getBirthTime", *aBirthTime, hrc));
    return hrc;
}

STDMETHODIMP FsObjInfoWrap::COMGETTER(ChangeTime)(LONG64 *aChangeTime)
{
    LogRelFlow(("{%p} %s: enter aChangeTime=%p\n", this, "FsObjInfo::getChangeTime", aChangeTime));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aChangeTime);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getChangeTime(aChangeTime);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aChangeTime=%RI64 hrc=%Rhrc\n", this, "FsObjInfo::getChangeTime", *aChangeTime, hrc));
    return hrc;
}

STDMETHODIMP FsObjInfoWrap::COMGETTER(DeviceNumber)(ULONG *aDeviceNumber)
{
    LogRelFlow(("{%p} %s: enter aDeviceNumber=%p\n", this, "FsObjInfo::getDeviceNumber", aDeviceNumber));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDeviceNumber);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDeviceNumber(aDeviceNumber);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDeviceNumber=%RU32 hrc=%Rhrc\n", this, "FsObjInfo::getDeviceNumber", *aDeviceNumber, hrc));
    return hrc;
}

STDMETHODIMP FsObjInfoWrap::COMGETTER(FileAttributes)(BSTR *aFileAttributes)
{
    LogRelFlow(("{%p} %s: enter aFileAttributes=%p\n", this, "FsObjInfo::getFileAttributes", aFileAttributes));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFileAttributes);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFileAttributes(BSTROutConverter(aFileAttributes).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFileAttributes=%ls hrc=%Rhrc\n", this, "FsObjInfo::getFileAttributes", *aFileAttributes, hrc));
    return hrc;
}

STDMETHODIMP FsObjInfoWrap::COMGETTER(GenerationId)(ULONG *aGenerationId)
{
    LogRelFlow(("{%p} %s: enter aGenerationId=%p\n", this, "FsObjInfo::getGenerationId", aGenerationId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGenerationId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGenerationId(aGenerationId);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGenerationId=%RU32 hrc=%Rhrc\n", this, "FsObjInfo::getGenerationId", *aGenerationId, hrc));
    return hrc;
}

STDMETHODIMP FsObjInfoWrap::COMGETTER(GID)(ULONG *aGID)
{
    LogRelFlow(("{%p} %s: enter aGID=%p\n", this, "FsObjInfo::getGID", aGID));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGID);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGID(aGID);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGID=%RU32 hrc=%Rhrc\n", this, "FsObjInfo::getGID", *aGID, hrc));
    return hrc;
}

STDMETHODIMP FsObjInfoWrap::COMGETTER(GroupName)(BSTR *aGroupName)
{
    LogRelFlow(("{%p} %s: enter aGroupName=%p\n", this, "FsObjInfo::getGroupName", aGroupName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGroupName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGroupName(BSTROutConverter(aGroupName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGroupName=%ls hrc=%Rhrc\n", this, "FsObjInfo::getGroupName", *aGroupName, hrc));
    return hrc;
}

STDMETHODIMP FsObjInfoWrap::COMGETTER(HardLinks)(ULONG *aHardLinks)
{
    LogRelFlow(("{%p} %s: enter aHardLinks=%p\n", this, "FsObjInfo::getHardLinks", aHardLinks));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHardLinks);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHardLinks(aHardLinks);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHardLinks=%RU32 hrc=%Rhrc\n", this, "FsObjInfo::getHardLinks", *aHardLinks, hrc));
    return hrc;
}

STDMETHODIMP FsObjInfoWrap::COMGETTER(ModificationTime)(LONG64 *aModificationTime)
{
    LogRelFlow(("{%p} %s: enter aModificationTime=%p\n", this, "FsObjInfo::getModificationTime", aModificationTime));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aModificationTime);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getModificationTime(aModificationTime);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aModificationTime=%RI64 hrc=%Rhrc\n", this, "FsObjInfo::getModificationTime", *aModificationTime, hrc));
    return hrc;
}

STDMETHODIMP FsObjInfoWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "FsObjInfo::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "FsObjInfo::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP FsObjInfoWrap::COMGETTER(NodeId)(LONG64 *aNodeId)
{
    LogRelFlow(("{%p} %s: enter aNodeId=%p\n", this, "FsObjInfo::getNodeId", aNodeId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNodeId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNodeId(aNodeId);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNodeId=%RI64 hrc=%Rhrc\n", this, "FsObjInfo::getNodeId", *aNodeId, hrc));
    return hrc;
}

STDMETHODIMP FsObjInfoWrap::COMGETTER(NodeIdDevice)(ULONG *aNodeIdDevice)
{
    LogRelFlow(("{%p} %s: enter aNodeIdDevice=%p\n", this, "FsObjInfo::getNodeIdDevice", aNodeIdDevice));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNodeIdDevice);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNodeIdDevice(aNodeIdDevice);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNodeIdDevice=%RU32 hrc=%Rhrc\n", this, "FsObjInfo::getNodeIdDevice", *aNodeIdDevice, hrc));
    return hrc;
}

STDMETHODIMP FsObjInfoWrap::COMGETTER(ObjectSize)(LONG64 *aObjectSize)
{
    LogRelFlow(("{%p} %s: enter aObjectSize=%p\n", this, "FsObjInfo::getObjectSize", aObjectSize));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aObjectSize);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getObjectSize(aObjectSize);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aObjectSize=%RI64 hrc=%Rhrc\n", this, "FsObjInfo::getObjectSize", *aObjectSize, hrc));
    return hrc;
}

STDMETHODIMP FsObjInfoWrap::COMGETTER(Type)(FsObjType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "FsObjInfo::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "FsObjInfo::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP FsObjInfoWrap::COMGETTER(UID)(ULONG *aUID)
{
    LogRelFlow(("{%p} %s: enter aUID=%p\n", this, "FsObjInfo::getUID", aUID));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUID);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUID(aUID);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUID=%RU32 hrc=%Rhrc\n", this, "FsObjInfo::getUID", *aUID, hrc));
    return hrc;
}

STDMETHODIMP FsObjInfoWrap::COMGETTER(UserFlags)(ULONG *aUserFlags)
{
    LogRelFlow(("{%p} %s: enter aUserFlags=%p\n", this, "FsObjInfo::getUserFlags", aUserFlags));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUserFlags);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUserFlags(aUserFlags);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUserFlags=%RU32 hrc=%Rhrc\n", this, "FsObjInfo::getUserFlags", *aUserFlags, hrc));
    return hrc;
}

STDMETHODIMP FsObjInfoWrap::COMGETTER(UserName)(BSTR *aUserName)
{
    LogRelFlow(("{%p} %s: enter aUserName=%p\n", this, "FsObjInfo::getUserName", aUserName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUserName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUserName(BSTROutConverter(aUserName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUserName=%ls hrc=%Rhrc\n", this, "FsObjInfo::getUserName", *aUserName, hrc));
    return hrc;
}

//
// IFsObjInfo methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(FsObjInfoWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(FsObjInfoWrap, IFsObjInfo)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "FsObjInfoWrap.cpp"

// ##### BEGINFILE "GuestFsObjInfoWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestFsObjInfo.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestFsObjInfoWrap_H_
#define GuestFsObjInfoWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestFsObjInfoWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestFsObjInfo)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestFsObjInfoWrap, IGuestFsObjInfo)
    DECLARE_NOT_AGGREGATABLE(GuestFsObjInfoWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestFsObjInfoWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestFsObjInfo)
        COM_INTERFACE_ENTRY(IFsObjInfo)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestFsObjInfo)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestFsObjInfoWrap)

    // public IFsObjInfo properties
    STDMETHOD(COMGETTER(AccessTime))(LONG64 *aAccessTime);
    STDMETHOD(COMGETTER(AllocatedSize))(LONG64 *aAllocatedSize);
    STDMETHOD(COMGETTER(BirthTime))(LONG64 *aBirthTime);
    STDMETHOD(COMGETTER(ChangeTime))(LONG64 *aChangeTime);
    STDMETHOD(COMGETTER(DeviceNumber))(ULONG *aDeviceNumber);
    STDMETHOD(COMGETTER(FileAttributes))(BSTR *aFileAttributes);
    STDMETHOD(COMGETTER(GenerationId))(ULONG *aGenerationId);
    STDMETHOD(COMGETTER(GID))(ULONG *aGID);
    STDMETHOD(COMGETTER(GroupName))(BSTR *aGroupName);
    STDMETHOD(COMGETTER(HardLinks))(ULONG *aHardLinks);
    STDMETHOD(COMGETTER(ModificationTime))(LONG64 *aModificationTime);
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(NodeId))(LONG64 *aNodeId);
    STDMETHOD(COMGETTER(NodeIdDevice))(ULONG *aNodeIdDevice);
    STDMETHOD(COMGETTER(ObjectSize))(LONG64 *aObjectSize);
    STDMETHOD(COMGETTER(Type))(FsObjType_T *aType);
    STDMETHOD(COMGETTER(UID))(ULONG *aUID);
    STDMETHOD(COMGETTER(UserFlags))(ULONG *aUserFlags);
    STDMETHOD(COMGETTER(UserName))(BSTR *aUserName);

    // public IGuestFsObjInfo properties

    // public IFsObjInfo methods

    // public IGuestFsObjInfo methods

private:
    // wrapped IFsObjInfo properties
    virtual HRESULT getAccessTime(LONG64 *aAccessTime) = 0;
    virtual HRESULT getAllocatedSize(LONG64 *aAllocatedSize) = 0;
    virtual HRESULT getBirthTime(LONG64 *aBirthTime) = 0;
    virtual HRESULT getChangeTime(LONG64 *aChangeTime) = 0;
    virtual HRESULT getDeviceNumber(ULONG *aDeviceNumber) = 0;
    virtual HRESULT getFileAttributes(com::Utf8Str &aFileAttributes) = 0;
    virtual HRESULT getGenerationId(ULONG *aGenerationId) = 0;
    virtual HRESULT getGID(ULONG *aGID) = 0;
    virtual HRESULT getGroupName(com::Utf8Str &aGroupName) = 0;
    virtual HRESULT getHardLinks(ULONG *aHardLinks) = 0;
    virtual HRESULT getModificationTime(LONG64 *aModificationTime) = 0;
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getNodeId(LONG64 *aNodeId) = 0;
    virtual HRESULT getNodeIdDevice(ULONG *aNodeIdDevice) = 0;
    virtual HRESULT getObjectSize(LONG64 *aObjectSize) = 0;
    virtual HRESULT getType(FsObjType_T *aType) = 0;
    virtual HRESULT getUID(ULONG *aUID) = 0;
    virtual HRESULT getUserFlags(ULONG *aUserFlags) = 0;
    virtual HRESULT getUserName(com::Utf8Str &aUserName) = 0;

    // wrapped IGuestFsObjInfo properties

    // wrapped IFsObjInfo methods

    // wrapped IGuestFsObjInfo methods
};

#endif // !GuestFsObjInfoWrap_H_

// ##### ENDFILE "GuestFsObjInfoWrap.h"

// ##### BEGINFILE "GuestFsObjInfoWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestFsObjInfo.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTFSOBJINFO

#include "GuestFsObjInfoWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestFsObjInfoWrap)

//
// IFsObjInfo properties
//

STDMETHODIMP GuestFsObjInfoWrap::COMGETTER(AccessTime)(LONG64 *aAccessTime)
{
    LogRelFlow(("{%p} %s: enter aAccessTime=%p\n", this, "GuestFsObjInfo::getAccessTime", aAccessTime));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAccessTime);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAccessTime(aAccessTime);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAccessTime=%RI64 hrc=%Rhrc\n", this, "GuestFsObjInfo::getAccessTime", *aAccessTime, hrc));
    return hrc;
}

STDMETHODIMP GuestFsObjInfoWrap::COMGETTER(AllocatedSize)(LONG64 *aAllocatedSize)
{
    LogRelFlow(("{%p} %s: enter aAllocatedSize=%p\n", this, "GuestFsObjInfo::getAllocatedSize", aAllocatedSize));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAllocatedSize);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAllocatedSize(aAllocatedSize);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAllocatedSize=%RI64 hrc=%Rhrc\n", this, "GuestFsObjInfo::getAllocatedSize", *aAllocatedSize, hrc));
    return hrc;
}

STDMETHODIMP GuestFsObjInfoWrap::COMGETTER(BirthTime)(LONG64 *aBirthTime)
{
    LogRelFlow(("{%p} %s: enter aBirthTime=%p\n", this, "GuestFsObjInfo::getBirthTime", aBirthTime));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBirthTime);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBirthTime(aBirthTime);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBirthTime=%RI64 hrc=%Rhrc\n", this, "GuestFsObjInfo::getBirthTime", *aBirthTime, hrc));
    return hrc;
}

STDMETHODIMP GuestFsObjInfoWrap::COMGETTER(ChangeTime)(LONG64 *aChangeTime)
{
    LogRelFlow(("{%p} %s: enter aChangeTime=%p\n", this, "GuestFsObjInfo::getChangeTime", aChangeTime));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aChangeTime);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getChangeTime(aChangeTime);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aChangeTime=%RI64 hrc=%Rhrc\n", this, "GuestFsObjInfo::getChangeTime", *aChangeTime, hrc));
    return hrc;
}

STDMETHODIMP GuestFsObjInfoWrap::COMGETTER(DeviceNumber)(ULONG *aDeviceNumber)
{
    LogRelFlow(("{%p} %s: enter aDeviceNumber=%p\n", this, "GuestFsObjInfo::getDeviceNumber", aDeviceNumber));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDeviceNumber);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDeviceNumber(aDeviceNumber);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDeviceNumber=%RU32 hrc=%Rhrc\n", this, "GuestFsObjInfo::getDeviceNumber", *aDeviceNumber, hrc));
    return hrc;
}

STDMETHODIMP GuestFsObjInfoWrap::COMGETTER(FileAttributes)(BSTR *aFileAttributes)
{
    LogRelFlow(("{%p} %s: enter aFileAttributes=%p\n", this, "GuestFsObjInfo::getFileAttributes", aFileAttributes));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFileAttributes);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFileAttributes(BSTROutConverter(aFileAttributes).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFileAttributes=%ls hrc=%Rhrc\n", this, "GuestFsObjInfo::getFileAttributes", *aFileAttributes, hrc));
    return hrc;
}

STDMETHODIMP GuestFsObjInfoWrap::COMGETTER(GenerationId)(ULONG *aGenerationId)
{
    LogRelFlow(("{%p} %s: enter aGenerationId=%p\n", this, "GuestFsObjInfo::getGenerationId", aGenerationId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGenerationId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGenerationId(aGenerationId);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGenerationId=%RU32 hrc=%Rhrc\n", this, "GuestFsObjInfo::getGenerationId", *aGenerationId, hrc));
    return hrc;
}

STDMETHODIMP GuestFsObjInfoWrap::COMGETTER(GID)(ULONG *aGID)
{
    LogRelFlow(("{%p} %s: enter aGID=%p\n", this, "GuestFsObjInfo::getGID", aGID));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGID);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGID(aGID);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGID=%RU32 hrc=%Rhrc\n", this, "GuestFsObjInfo::getGID", *aGID, hrc));
    return hrc;
}

STDMETHODIMP GuestFsObjInfoWrap::COMGETTER(GroupName)(BSTR *aGroupName)
{
    LogRelFlow(("{%p} %s: enter aGroupName=%p\n", this, "GuestFsObjInfo::getGroupName", aGroupName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGroupName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGroupName(BSTROutConverter(aGroupName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGroupName=%ls hrc=%Rhrc\n", this, "GuestFsObjInfo::getGroupName", *aGroupName, hrc));
    return hrc;
}

STDMETHODIMP GuestFsObjInfoWrap::COMGETTER(HardLinks)(ULONG *aHardLinks)
{
    LogRelFlow(("{%p} %s: enter aHardLinks=%p\n", this, "GuestFsObjInfo::getHardLinks", aHardLinks));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHardLinks);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHardLinks(aHardLinks);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHardLinks=%RU32 hrc=%Rhrc\n", this, "GuestFsObjInfo::getHardLinks", *aHardLinks, hrc));
    return hrc;
}

STDMETHODIMP GuestFsObjInfoWrap::COMGETTER(ModificationTime)(LONG64 *aModificationTime)
{
    LogRelFlow(("{%p} %s: enter aModificationTime=%p\n", this, "GuestFsObjInfo::getModificationTime", aModificationTime));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aModificationTime);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getModificationTime(aModificationTime);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aModificationTime=%RI64 hrc=%Rhrc\n", this, "GuestFsObjInfo::getModificationTime", *aModificationTime, hrc));
    return hrc;
}

STDMETHODIMP GuestFsObjInfoWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "GuestFsObjInfo::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "GuestFsObjInfo::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP GuestFsObjInfoWrap::COMGETTER(NodeId)(LONG64 *aNodeId)
{
    LogRelFlow(("{%p} %s: enter aNodeId=%p\n", this, "GuestFsObjInfo::getNodeId", aNodeId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNodeId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNodeId(aNodeId);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNodeId=%RI64 hrc=%Rhrc\n", this, "GuestFsObjInfo::getNodeId", *aNodeId, hrc));
    return hrc;
}

STDMETHODIMP GuestFsObjInfoWrap::COMGETTER(NodeIdDevice)(ULONG *aNodeIdDevice)
{
    LogRelFlow(("{%p} %s: enter aNodeIdDevice=%p\n", this, "GuestFsObjInfo::getNodeIdDevice", aNodeIdDevice));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNodeIdDevice);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNodeIdDevice(aNodeIdDevice);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNodeIdDevice=%RU32 hrc=%Rhrc\n", this, "GuestFsObjInfo::getNodeIdDevice", *aNodeIdDevice, hrc));
    return hrc;
}

STDMETHODIMP GuestFsObjInfoWrap::COMGETTER(ObjectSize)(LONG64 *aObjectSize)
{
    LogRelFlow(("{%p} %s: enter aObjectSize=%p\n", this, "GuestFsObjInfo::getObjectSize", aObjectSize));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aObjectSize);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getObjectSize(aObjectSize);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aObjectSize=%RI64 hrc=%Rhrc\n", this, "GuestFsObjInfo::getObjectSize", *aObjectSize, hrc));
    return hrc;
}

STDMETHODIMP GuestFsObjInfoWrap::COMGETTER(Type)(FsObjType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestFsObjInfo::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestFsObjInfo::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestFsObjInfoWrap::COMGETTER(UID)(ULONG *aUID)
{
    LogRelFlow(("{%p} %s: enter aUID=%p\n", this, "GuestFsObjInfo::getUID", aUID));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUID);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUID(aUID);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUID=%RU32 hrc=%Rhrc\n", this, "GuestFsObjInfo::getUID", *aUID, hrc));
    return hrc;
}

STDMETHODIMP GuestFsObjInfoWrap::COMGETTER(UserFlags)(ULONG *aUserFlags)
{
    LogRelFlow(("{%p} %s: enter aUserFlags=%p\n", this, "GuestFsObjInfo::getUserFlags", aUserFlags));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUserFlags);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUserFlags(aUserFlags);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUserFlags=%RU32 hrc=%Rhrc\n", this, "GuestFsObjInfo::getUserFlags", *aUserFlags, hrc));
    return hrc;
}

STDMETHODIMP GuestFsObjInfoWrap::COMGETTER(UserName)(BSTR *aUserName)
{
    LogRelFlow(("{%p} %s: enter aUserName=%p\n", this, "GuestFsObjInfo::getUserName", aUserName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUserName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUserName(BSTROutConverter(aUserName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUserName=%ls hrc=%Rhrc\n", this, "GuestFsObjInfo::getUserName", *aUserName, hrc));
    return hrc;
}

//
// IGuestFsObjInfo properties
//

//
// IFsObjInfo methods
//

//
// IGuestFsObjInfo methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestFsObjInfoWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(GuestFsObjInfoWrap, IGuestFsObjInfo, IFsObjInfo)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestFsObjInfoWrap.cpp"

// ##### BEGINFILE "GuestWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuest.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestWrap_H_
#define GuestWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuest)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestWrap, IGuest)
    DECLARE_NOT_AGGREGATABLE(GuestWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuest)
        COM_INTERFACE_ENTRY2(IDispatch, IGuest)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestWrap)

    // public IGuest properties
    STDMETHOD(COMGETTER(OSTypeId))(BSTR *aOSTypeId);
    STDMETHOD(COMGETTER(AdditionsRunLevel))(AdditionsRunLevelType_T *aAdditionsRunLevel);
    STDMETHOD(COMGETTER(AdditionsVersion))(BSTR *aAdditionsVersion);
    STDMETHOD(COMGETTER(AdditionsRevision))(ULONG *aAdditionsRevision);
    STDMETHOD(COMGETTER(EventSource))(IEventSource **aEventSource);
    STDMETHOD(COMGETTER(Facilities))(ComSafeArrayOut(IAdditionsFacility *, aFacilities));
    STDMETHOD(COMGETTER(Sessions))(ComSafeArrayOut(IGuestSession *, aSessions));
    STDMETHOD(COMGETTER(MemoryBalloonSize))(ULONG *aMemoryBalloonSize);
    STDMETHOD(COMSETTER(MemoryBalloonSize))(ULONG aMemoryBalloonSize);
    STDMETHOD(COMGETTER(StatisticsUpdateInterval))(ULONG *aStatisticsUpdateInterval);
    STDMETHOD(COMSETTER(StatisticsUpdateInterval))(ULONG aStatisticsUpdateInterval);

    // public IGuest methods
    STDMETHOD(InternalGetStatistics)(ULONG *aCpuUser,
                                     ULONG *aCpuKernel,
                                     ULONG *aCpuIdle,
                                     ULONG *aMemTotal,
                                     ULONG *aMemFree,
                                     ULONG *aMemBalloon,
                                     ULONG *aMemShared,
                                     ULONG *aMemCache,
                                     ULONG *aPagedTotal,
                                     ULONG *aMemAllocTotal,
                                     ULONG *aMemFreeTotal,
                                     ULONG *aMemBalloonTotal,
                                     ULONG *aMemSharedTotal);
    STDMETHOD(GetFacilityStatus)(AdditionsFacilityType_T aFacility,
                                 LONG64 *aTimestamp,
                                 AdditionsFacilityStatus_T *aStatus);
    STDMETHOD(GetAdditionsStatus)(AdditionsRunLevelType_T aLevel,
                                  BOOL *aActive);
    STDMETHOD(SetCredentials)(IN_BSTR aUserName,
                              IN_BSTR aPassword,
                              IN_BSTR aDomain,
                              BOOL aAllowInteractiveLogon);
    STDMETHOD(DragHGEnter)(ULONG aScreenId,
                           ULONG aY,
                           ULONG aX,
                           DragAndDropAction_T aDefaultAction,
                           ComSafeArrayIn(DragAndDropAction_T, aAllowedActions),
                           ComSafeArrayIn(IN_BSTR, aFormats),
                           DragAndDropAction_T *aResultAction);
    STDMETHOD(DragHGMove)(ULONG aScreenId,
                          ULONG aX,
                          ULONG aY,
                          DragAndDropAction_T aDefaultAction,
                          ComSafeArrayIn(DragAndDropAction_T, aAllowedActions),
                          ComSafeArrayIn(IN_BSTR, aFormats),
                          DragAndDropAction_T *aResultAction);
    STDMETHOD(DragHGLeave)(ULONG aScreenId);
    STDMETHOD(DragHGDrop)(ULONG aScreenId,
                          ULONG aX,
                          ULONG aY,
                          DragAndDropAction_T aDefaultAction,
                          ComSafeArrayIn(DragAndDropAction_T, aAllowedActions),
                          ComSafeArrayIn(IN_BSTR, aFormats),
                          BSTR *aFormat,
                          DragAndDropAction_T *aResultAction);
    STDMETHOD(DragHGPutData)(ULONG aScreenId,
                             IN_BSTR aFormat,
                             ComSafeArrayIn(BYTE, aData),
                             IProgress **aProgress);
    STDMETHOD(DragGHPending)(ULONG aScreenId,
                             ComSafeArrayOut(BSTR, aFormats),
                             ComSafeArrayOut(DragAndDropAction_T, aAllowedActions),
                             DragAndDropAction_T *aDefaultAction);
    STDMETHOD(DragGHDropped)(IN_BSTR aFormat,
                             DragAndDropAction_T aAction,
                             IProgress **aProgress);
    STDMETHOD(DragGHGetData)(ComSafeArrayOut(BYTE, aData));
    STDMETHOD(CreateSession)(IN_BSTR aUser,
                             IN_BSTR aPassword,
                             IN_BSTR aDomain,
                             IN_BSTR aSessionName,
                             IGuestSession **aGuestSession);
    STDMETHOD(FindSession)(IN_BSTR aSessionName,
                           ComSafeArrayOut(IGuestSession *, aSessions));
    STDMETHOD(UpdateGuestAdditions)(IN_BSTR aSource,
                                    ComSafeArrayIn(IN_BSTR, aArguments),
                                    ComSafeArrayIn(AdditionsUpdateFlag_T, aFlags),
                                    IProgress **aProgress);

private:
    // wrapped IGuest properties
    virtual HRESULT getOSTypeId(com::Utf8Str &aOSTypeId) = 0;
    virtual HRESULT getAdditionsRunLevel(AdditionsRunLevelType_T *aAdditionsRunLevel) = 0;
    virtual HRESULT getAdditionsVersion(com::Utf8Str &aAdditionsVersion) = 0;
    virtual HRESULT getAdditionsRevision(ULONG *aAdditionsRevision) = 0;
    virtual HRESULT getEventSource(ComPtr<IEventSource> &aEventSource) = 0;
    virtual HRESULT getFacilities(std::vector<ComPtr<IAdditionsFacility> > &aFacilities) = 0;
    virtual HRESULT getSessions(std::vector<ComPtr<IGuestSession> > &aSessions) = 0;
    virtual HRESULT getMemoryBalloonSize(ULONG *aMemoryBalloonSize) = 0;
    virtual HRESULT setMemoryBalloonSize(ULONG aMemoryBalloonSize) = 0;
    virtual HRESULT getStatisticsUpdateInterval(ULONG *aStatisticsUpdateInterval) = 0;
    virtual HRESULT setStatisticsUpdateInterval(ULONG aStatisticsUpdateInterval) = 0;

    // wrapped IGuest methods
    virtual HRESULT internalGetStatistics(ULONG *aCpuUser,
                                          ULONG *aCpuKernel,
                                          ULONG *aCpuIdle,
                                          ULONG *aMemTotal,
                                          ULONG *aMemFree,
                                          ULONG *aMemBalloon,
                                          ULONG *aMemShared,
                                          ULONG *aMemCache,
                                          ULONG *aPagedTotal,
                                          ULONG *aMemAllocTotal,
                                          ULONG *aMemFreeTotal,
                                          ULONG *aMemBalloonTotal,
                                          ULONG *aMemSharedTotal) = 0;
    virtual HRESULT getFacilityStatus(AdditionsFacilityType_T aFacility,
                                      LONG64 *aTimestamp,
                                      AdditionsFacilityStatus_T *aStatus) = 0;
    virtual HRESULT getAdditionsStatus(AdditionsRunLevelType_T aLevel,
                                       BOOL *aActive) = 0;
    virtual HRESULT setCredentials(const com::Utf8Str &aUserName,
                                   const com::Utf8Str &aPassword,
                                   const com::Utf8Str &aDomain,
                                   BOOL aAllowInteractiveLogon) = 0;
    virtual HRESULT dragHGEnter(ULONG aScreenId,
                                ULONG aY,
                                ULONG aX,
                                DragAndDropAction_T aDefaultAction,
                                const std::vector<DragAndDropAction_T> &aAllowedActions,
                                const std::vector<com::Utf8Str> &aFormats,
                                DragAndDropAction_T *aResultAction) = 0;
    virtual HRESULT dragHGMove(ULONG aScreenId,
                               ULONG aX,
                               ULONG aY,
                               DragAndDropAction_T aDefaultAction,
                               const std::vector<DragAndDropAction_T> &aAllowedActions,
                               const std::vector<com::Utf8Str> &aFormats,
                               DragAndDropAction_T *aResultAction) = 0;
    virtual HRESULT dragHGLeave(ULONG aScreenId) = 0;
    virtual HRESULT dragHGDrop(ULONG aScreenId,
                               ULONG aX,
                               ULONG aY,
                               DragAndDropAction_T aDefaultAction,
                               const std::vector<DragAndDropAction_T> &aAllowedActions,
                               const std::vector<com::Utf8Str> &aFormats,
                               com::Utf8Str &aFormat,
                               DragAndDropAction_T *aResultAction) = 0;
    virtual HRESULT dragHGPutData(ULONG aScreenId,
                                  const com::Utf8Str &aFormat,
                                  const std::vector<BYTE> &aData,
                                  ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT dragGHPending(ULONG aScreenId,
                                  std::vector<com::Utf8Str> &aFormats,
                                  std::vector<DragAndDropAction_T> &aAllowedActions,
                                  DragAndDropAction_T *aDefaultAction) = 0;
    virtual HRESULT dragGHDropped(const com::Utf8Str &aFormat,
                                  DragAndDropAction_T aAction,
                                  ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT dragGHGetData(std::vector<BYTE> &aData) = 0;
    virtual HRESULT createSession(const com::Utf8Str &aUser,
                                  const com::Utf8Str &aPassword,
                                  const com::Utf8Str &aDomain,
                                  const com::Utf8Str &aSessionName,
                                  ComPtr<IGuestSession> &aGuestSession) = 0;
    virtual HRESULT findSession(const com::Utf8Str &aSessionName,
                                std::vector<ComPtr<IGuestSession> > &aSessions) = 0;
    virtual HRESULT updateGuestAdditions(const com::Utf8Str &aSource,
                                         const std::vector<com::Utf8Str> &aArguments,
                                         const std::vector<AdditionsUpdateFlag_T> &aFlags,
                                         ComPtr<IProgress> &aProgress) = 0;
};

#endif // !GuestWrap_H_

// ##### ENDFILE "GuestWrap.h"

// ##### BEGINFILE "GuestWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuest.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUEST

#include "GuestWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestWrap)

//
// IGuest properties
//

STDMETHODIMP GuestWrap::COMGETTER(OSTypeId)(BSTR *aOSTypeId)
{
    LogRelFlow(("{%p} %s: enter aOSTypeId=%p\n", this, "Guest::getOSTypeId", aOSTypeId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOSTypeId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOSTypeId(BSTROutConverter(aOSTypeId).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOSTypeId=%ls hrc=%Rhrc\n", this, "Guest::getOSTypeId", *aOSTypeId, hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::COMGETTER(AdditionsRunLevel)(AdditionsRunLevelType_T *aAdditionsRunLevel)
{
    LogRelFlow(("{%p} %s: enter aAdditionsRunLevel=%p\n", this, "Guest::getAdditionsRunLevel", aAdditionsRunLevel));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAdditionsRunLevel);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAdditionsRunLevel(aAdditionsRunLevel);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAdditionsRunLevel=%RU32 hrc=%Rhrc\n", this, "Guest::getAdditionsRunLevel", *aAdditionsRunLevel, hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::COMGETTER(AdditionsVersion)(BSTR *aAdditionsVersion)
{
    LogRelFlow(("{%p} %s: enter aAdditionsVersion=%p\n", this, "Guest::getAdditionsVersion", aAdditionsVersion));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAdditionsVersion);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAdditionsVersion(BSTROutConverter(aAdditionsVersion).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAdditionsVersion=%ls hrc=%Rhrc\n", this, "Guest::getAdditionsVersion", *aAdditionsVersion, hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::COMGETTER(AdditionsRevision)(ULONG *aAdditionsRevision)
{
    LogRelFlow(("{%p} %s: enter aAdditionsRevision=%p\n", this, "Guest::getAdditionsRevision", aAdditionsRevision));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAdditionsRevision);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAdditionsRevision(aAdditionsRevision);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAdditionsRevision=%RU32 hrc=%Rhrc\n", this, "Guest::getAdditionsRevision", *aAdditionsRevision, hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::COMGETTER(EventSource)(IEventSource **aEventSource)
{
    LogRelFlow(("{%p} %s: enter aEventSource=%p\n", this, "Guest::getEventSource", aEventSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEventSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEventSource(ComTypeOutConverter<IEventSource>(aEventSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEventSource=%p hrc=%Rhrc\n", this, "Guest::getEventSource", *aEventSource, hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::COMGETTER(Facilities)(ComSafeArrayOut(IAdditionsFacility *, aFacilities))
{
    LogRelFlow(("{%p} %s: enter aFacilities=%p\n", this, "Guest::getFacilities", aFacilities));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFacilities);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFacilities(ArrayComTypeOutConverter<IAdditionsFacility>(ComSafeArrayOutArg(aFacilities)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFacilities=%zu hrc=%Rhrc\n", this, "Guest::getFacilities", ComSafeArraySize(*aFacilities), hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::COMGETTER(Sessions)(ComSafeArrayOut(IGuestSession *, aSessions))
{
    LogRelFlow(("{%p} %s: enter aSessions=%p\n", this, "Guest::getSessions", aSessions));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSessions);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSessions(ArrayComTypeOutConverter<IGuestSession>(ComSafeArrayOutArg(aSessions)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSessions=%zu hrc=%Rhrc\n", this, "Guest::getSessions", ComSafeArraySize(*aSessions), hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::COMGETTER(MemoryBalloonSize)(ULONG *aMemoryBalloonSize)
{
    LogRelFlow(("{%p} %s: enter aMemoryBalloonSize=%p\n", this, "Guest::getMemoryBalloonSize", aMemoryBalloonSize));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMemoryBalloonSize);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMemoryBalloonSize(aMemoryBalloonSize);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMemoryBalloonSize=%RU32 hrc=%Rhrc\n", this, "Guest::getMemoryBalloonSize", *aMemoryBalloonSize, hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::COMSETTER(MemoryBalloonSize)(ULONG aMemoryBalloonSize)
{
    LogRelFlow(("{%p} %s: enter aMemoryBalloonSize=%RU32\n", this, "Guest::setMemoryBalloonSize", aMemoryBalloonSize));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setMemoryBalloonSize(aMemoryBalloonSize);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Guest::setMemoryBalloonSize", hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::COMGETTER(StatisticsUpdateInterval)(ULONG *aStatisticsUpdateInterval)
{
    LogRelFlow(("{%p} %s: enter aStatisticsUpdateInterval=%p\n", this, "Guest::getStatisticsUpdateInterval", aStatisticsUpdateInterval));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStatisticsUpdateInterval);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getStatisticsUpdateInterval(aStatisticsUpdateInterval);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aStatisticsUpdateInterval=%RU32 hrc=%Rhrc\n", this, "Guest::getStatisticsUpdateInterval", *aStatisticsUpdateInterval, hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::COMSETTER(StatisticsUpdateInterval)(ULONG aStatisticsUpdateInterval)
{
    LogRelFlow(("{%p} %s: enter aStatisticsUpdateInterval=%RU32\n", this, "Guest::setStatisticsUpdateInterval", aStatisticsUpdateInterval));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setStatisticsUpdateInterval(aStatisticsUpdateInterval);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Guest::setStatisticsUpdateInterval", hrc));
    return hrc;
}

//
// IGuest methods
//

STDMETHODIMP GuestWrap::InternalGetStatistics(ULONG *aCpuUser,
                                              ULONG *aCpuKernel,
                                              ULONG *aCpuIdle,
                                              ULONG *aMemTotal,
                                              ULONG *aMemFree,
                                              ULONG *aMemBalloon,
                                              ULONG *aMemShared,
                                              ULONG *aMemCache,
                                              ULONG *aPagedTotal,
                                              ULONG *aMemAllocTotal,
                                              ULONG *aMemFreeTotal,
                                              ULONG *aMemBalloonTotal,
                                              ULONG *aMemSharedTotal)
{
    LogRelFlow(("{%p} %s:enter aCpuUser=%p aCpuKernel=%p aCpuIdle=%p aMemTotal=%p aMemFree=%p aMemBalloon=%p aMemShared=%p aMemCache=%p aPagedTotal=%p aMemAllocTotal=%p aMemFreeTotal=%p aMemBalloonTotal=%p aMemSharedTotal=%p\n", this, "Guest::internalGetStatistics", aCpuUser, aCpuKernel, aCpuIdle, aMemTotal, aMemFree, aMemBalloon, aMemShared, aMemCache, aPagedTotal, aMemAllocTotal, aMemFreeTotal, aMemBalloonTotal, aMemSharedTotal));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCpuUser);
        CheckComArgOutPointerValidThrow(aCpuKernel);
        CheckComArgOutPointerValidThrow(aCpuIdle);
        CheckComArgOutPointerValidThrow(aMemTotal);
        CheckComArgOutPointerValidThrow(aMemFree);
        CheckComArgOutPointerValidThrow(aMemBalloon);
        CheckComArgOutPointerValidThrow(aMemShared);
        CheckComArgOutPointerValidThrow(aMemCache);
        CheckComArgOutPointerValidThrow(aPagedTotal);
        CheckComArgOutPointerValidThrow(aMemAllocTotal);
        CheckComArgOutPointerValidThrow(aMemFreeTotal);
        CheckComArgOutPointerValidThrow(aMemBalloonTotal);
        CheckComArgOutPointerValidThrow(aMemSharedTotal);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = internalGetStatistics(aCpuUser,
                                    aCpuKernel,
                                    aCpuIdle,
                                    aMemTotal,
                                    aMemFree,
                                    aMemBalloon,
                                    aMemShared,
                                    aMemCache,
                                    aPagedTotal,
                                    aMemAllocTotal,
                                    aMemFreeTotal,
                                    aMemBalloonTotal,
                                    aMemSharedTotal);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aCpuUser=%RU32 *aCpuKernel=%RU32 *aCpuIdle=%RU32 *aMemTotal=%RU32 *aMemFree=%RU32 *aMemBalloon=%RU32 *aMemShared=%RU32 *aMemCache=%RU32 *aPagedTotal=%RU32 *aMemAllocTotal=%RU32 *aMemFreeTotal=%RU32 *aMemBalloonTotal=%RU32 *aMemSharedTotal=%RU32 hrc=%Rhrc\n", this, "Guest::internalGetStatistics", *aCpuUser, *aCpuKernel, *aCpuIdle, *aMemTotal, *aMemFree, *aMemBalloon, *aMemShared, *aMemCache, *aPagedTotal, *aMemAllocTotal, *aMemFreeTotal, *aMemBalloonTotal, *aMemSharedTotal, hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::GetFacilityStatus(AdditionsFacilityType_T aFacility,
                                          LONG64 *aTimestamp,
                                          AdditionsFacilityStatus_T *aStatus)
{
    LogRelFlow(("{%p} %s:enter aFacility=%RU32 aTimestamp=%p aStatus=%p\n", this, "Guest::getFacilityStatus", aFacility, aTimestamp, aStatus));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aTimestamp);
        CheckComArgOutPointerValidThrow(aStatus);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFacilityStatus(aFacility,
                                aTimestamp,
                                aStatus);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aTimestamp=%RI64 aStatus=%RU32 hrc=%Rhrc\n", this, "Guest::getFacilityStatus", *aTimestamp, *aStatus, hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::GetAdditionsStatus(AdditionsRunLevelType_T aLevel,
                                           BOOL *aActive)
{
    LogRelFlow(("{%p} %s:enter aLevel=%RU32 aActive=%p\n", this, "Guest::getAdditionsStatus", aLevel, aActive));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aActive);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAdditionsStatus(aLevel,
                                 aActive);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aActive=%RTbool hrc=%Rhrc\n", this, "Guest::getAdditionsStatus", *aActive, hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::SetCredentials(IN_BSTR aUserName,
                                       IN_BSTR aPassword,
                                       IN_BSTR aDomain,
                                       BOOL aAllowInteractiveLogon)
{
    LogRelFlow(("{%p} %s:enter aUserName=%ls aPassword=%ls aDomain=%ls aAllowInteractiveLogon=%RTbool\n", this, "Guest::setCredentials", aUserName, aPassword, aDomain, aAllowInteractiveLogon));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setCredentials(BSTRInConverter(aUserName).str(),
                             BSTRInConverter(aPassword).str(),
                             BSTRInConverter(aDomain).str(),
                             aAllowInteractiveLogon);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Guest::setCredentials", hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::DragHGEnter(ULONG aScreenId,
                                    ULONG aY,
                                    ULONG aX,
                                    DragAndDropAction_T aDefaultAction,
                                    ComSafeArrayIn(DragAndDropAction_T, aAllowedActions),
                                    ComSafeArrayIn(IN_BSTR, aFormats),
                                    DragAndDropAction_T *aResultAction)
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32 aY=%RU32 aX=%RU32 aDefaultAction=%RU32 aAllowedActions=%zu aFormats=%zu aResultAction=%p\n", this, "Guest::dragHGEnter", aScreenId, aY, aX, aDefaultAction, aAllowedActions, aFormats, aResultAction));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResultAction);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = dragHGEnter(aScreenId,
                          aY,
                          aX,
                          aDefaultAction,
                          ArrayInConverter<DragAndDropAction_T>(ComSafeArrayInArg(aAllowedActions)).array(),
                          ArrayBSTRInConverter(ComSafeArrayInArg(aFormats)).array(),
                          aResultAction);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResultAction=%RU32 hrc=%Rhrc\n", this, "Guest::dragHGEnter", *aResultAction, hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::DragHGMove(ULONG aScreenId,
                                   ULONG aX,
                                   ULONG aY,
                                   DragAndDropAction_T aDefaultAction,
                                   ComSafeArrayIn(DragAndDropAction_T, aAllowedActions),
                                   ComSafeArrayIn(IN_BSTR, aFormats),
                                   DragAndDropAction_T *aResultAction)
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32 aX=%RU32 aY=%RU32 aDefaultAction=%RU32 aAllowedActions=%zu aFormats=%zu aResultAction=%p\n", this, "Guest::dragHGMove", aScreenId, aX, aY, aDefaultAction, aAllowedActions, aFormats, aResultAction));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResultAction);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = dragHGMove(aScreenId,
                         aX,
                         aY,
                         aDefaultAction,
                         ArrayInConverter<DragAndDropAction_T>(ComSafeArrayInArg(aAllowedActions)).array(),
                         ArrayBSTRInConverter(ComSafeArrayInArg(aFormats)).array(),
                         aResultAction);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResultAction=%RU32 hrc=%Rhrc\n", this, "Guest::dragHGMove", *aResultAction, hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::DragHGLeave(ULONG aScreenId)
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32\n", this, "Guest::dragHGLeave", aScreenId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = dragHGLeave(aScreenId);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Guest::dragHGLeave", hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::DragHGDrop(ULONG aScreenId,
                                   ULONG aX,
                                   ULONG aY,
                                   DragAndDropAction_T aDefaultAction,
                                   ComSafeArrayIn(DragAndDropAction_T, aAllowedActions),
                                   ComSafeArrayIn(IN_BSTR, aFormats),
                                   BSTR *aFormat,
                                   DragAndDropAction_T *aResultAction)
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32 aX=%RU32 aY=%RU32 aDefaultAction=%RU32 aAllowedActions=%zu aFormats=%zu aFormat=%p aResultAction=%p\n", this, "Guest::dragHGDrop", aScreenId, aX, aY, aDefaultAction, aAllowedActions, aFormats, aFormat, aResultAction));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFormat);
        CheckComArgOutPointerValidThrow(aResultAction);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = dragHGDrop(aScreenId,
                         aX,
                         aY,
                         aDefaultAction,
                         ArrayInConverter<DragAndDropAction_T>(ComSafeArrayInArg(aAllowedActions)).array(),
                         ArrayBSTRInConverter(ComSafeArrayInArg(aFormats)).array(),
                         BSTROutConverter(aFormat).str(),
                         aResultAction);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFormat=%ls aResultAction=%RU32 hrc=%Rhrc\n", this, "Guest::dragHGDrop", *aFormat, *aResultAction, hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::DragHGPutData(ULONG aScreenId,
                                      IN_BSTR aFormat,
                                      ComSafeArrayIn(BYTE, aData),
                                      IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32 aFormat=%ls aData=%zu aProgress=%p\n", this, "Guest::dragHGPutData", aScreenId, aFormat, aData, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = dragHGPutData(aScreenId,
                            BSTRInConverter(aFormat).str(),
                            ArrayInConverter<BYTE>(ComSafeArrayInArg(aData)).array(),
                            ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Guest::dragHGPutData", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::DragGHPending(ULONG aScreenId,
                                      ComSafeArrayOut(BSTR, aFormats),
                                      ComSafeArrayOut(DragAndDropAction_T, aAllowedActions),
                                      DragAndDropAction_T *aDefaultAction)
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32 aFormats=%p aAllowedActions=%p aDefaultAction=%p\n", this, "Guest::dragGHPending", aScreenId, aFormats, aAllowedActions, aDefaultAction));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFormats);
        CheckComArgOutPointerValidThrow(aAllowedActions);
        CheckComArgOutPointerValidThrow(aDefaultAction);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = dragGHPending(aScreenId,
                            ArrayBSTROutConverter(ComSafeArrayOutArg(aFormats)).array(),
                            ArrayOutConverter<DragAndDropAction_T>(ComSafeArrayOutArg(aAllowedActions)).array(),
                            aDefaultAction);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFormats=%zu *aAllowedActions=%zu aDefaultAction=%RU32 hrc=%Rhrc\n", this, "Guest::dragGHPending", ComSafeArraySize(*aFormats), ComSafeArraySize(*aAllowedActions), *aDefaultAction, hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::DragGHDropped(IN_BSTR aFormat,
                                      DragAndDropAction_T aAction,
                                      IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aFormat=%ls aAction=%RU32 aProgress=%p\n", this, "Guest::dragGHDropped", aFormat, aAction, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = dragGHDropped(BSTRInConverter(aFormat).str(),
                            aAction,
                            ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Guest::dragGHDropped", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::DragGHGetData(ComSafeArrayOut(BYTE, aData))
{
    LogRelFlow(("{%p} %s:enter aData=%p\n", this, "Guest::dragGHGetData", aData));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aData);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = dragGHGetData(ArrayOutConverter<BYTE>(ComSafeArrayOutArg(aData)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aData=%zu hrc=%Rhrc\n", this, "Guest::dragGHGetData", ComSafeArraySize(*aData), hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::CreateSession(IN_BSTR aUser,
                                      IN_BSTR aPassword,
                                      IN_BSTR aDomain,
                                      IN_BSTR aSessionName,
                                      IGuestSession **aGuestSession)
{
    LogRelFlow(("{%p} %s:enter aUser=%ls aPassword=%ls aDomain=%ls aSessionName=%ls aGuestSession=%p\n", this, "Guest::createSession", aUser, aPassword, aDomain, aSessionName, aGuestSession));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGuestSession);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = createSession(BSTRInConverter(aUser).str(),
                            BSTRInConverter(aPassword).str(),
                            BSTRInConverter(aDomain).str(),
                            BSTRInConverter(aSessionName).str(),
                            ComTypeOutConverter<IGuestSession>(aGuestSession).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aGuestSession=%p hrc=%Rhrc\n", this, "Guest::createSession", *aGuestSession, hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::FindSession(IN_BSTR aSessionName,
                                    ComSafeArrayOut(IGuestSession *, aSessions))
{
    LogRelFlow(("{%p} %s:enter aSessionName=%ls aSessions=%p\n", this, "Guest::findSession", aSessionName, aSessions));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSessions);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = findSession(BSTRInConverter(aSessionName).str(),
                          ArrayComTypeOutConverter<IGuestSession>(ComSafeArrayOutArg(aSessions)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aSessions=%zu hrc=%Rhrc\n", this, "Guest::findSession", ComSafeArraySize(*aSessions), hrc));
    return hrc;
}

STDMETHODIMP GuestWrap::UpdateGuestAdditions(IN_BSTR aSource,
                                             ComSafeArrayIn(IN_BSTR, aArguments),
                                             ComSafeArrayIn(AdditionsUpdateFlag_T, aFlags),
                                             IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aSource=%ls aArguments=%zu aFlags=%zu aProgress=%p\n", this, "Guest::updateGuestAdditions", aSource, aArguments, aFlags, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = updateGuestAdditions(BSTRInConverter(aSource).str(),
                                   ArrayBSTRInConverter(ComSafeArrayInArg(aArguments)).array(),
                                   ArrayInConverter<AdditionsUpdateFlag_T>(ComSafeArrayInArg(aFlags)).array(),
                                   ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Guest::updateGuestAdditions", *aProgress, hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(GuestWrap, IGuest)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestWrap.cpp"

// ##### BEGINFILE "ProgressWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IProgress.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef ProgressWrap_H_
#define ProgressWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE ProgressWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IProgress)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(ProgressWrap, IProgress)
    DECLARE_NOT_AGGREGATABLE(ProgressWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(ProgressWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IProgress)
        COM_INTERFACE_ENTRY2(IDispatch, IProgress)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(ProgressWrap)

    // public IProgress properties
    STDMETHOD(COMGETTER(Id))(BSTR *aId);
    STDMETHOD(COMGETTER(Description))(BSTR *aDescription);
    STDMETHOD(COMGETTER(Initiator))(IUnknown **aInitiator);
    STDMETHOD(COMGETTER(Cancelable))(BOOL *aCancelable);
    STDMETHOD(COMGETTER(Percent))(ULONG *aPercent);
    STDMETHOD(COMGETTER(TimeRemaining))(LONG *aTimeRemaining);
    STDMETHOD(COMGETTER(Completed))(BOOL *aCompleted);
    STDMETHOD(COMGETTER(Canceled))(BOOL *aCanceled);
    STDMETHOD(COMGETTER(ResultCode))(LONG *aResultCode);
    STDMETHOD(COMGETTER(ErrorInfo))(IVirtualBoxErrorInfo **aErrorInfo);
    STDMETHOD(COMGETTER(OperationCount))(ULONG *aOperationCount);
    STDMETHOD(COMGETTER(Operation))(ULONG *aOperation);
    STDMETHOD(COMGETTER(OperationDescription))(BSTR *aOperationDescription);
    STDMETHOD(COMGETTER(OperationPercent))(ULONG *aOperationPercent);
    STDMETHOD(COMGETTER(OperationWeight))(ULONG *aOperationWeight);
    STDMETHOD(COMGETTER(Timeout))(ULONG *aTimeout);
    STDMETHOD(COMSETTER(Timeout))(ULONG aTimeout);

    // public IProgress methods
    STDMETHOD(SetCurrentOperationProgress)(ULONG aPercent);
    STDMETHOD(SetNextOperation)(IN_BSTR aNextOperationDescription,
                                ULONG aNextOperationsWeight);
    STDMETHOD(WaitForCompletion)(LONG aTimeout);
    STDMETHOD(WaitForOperationCompletion)(ULONG aOperation,
                                          LONG aTimeout);
    STDMETHOD(WaitForAsyncProgressCompletion)(IProgress *aPProgressAsync);
    STDMETHOD(Cancel)();

private:
    // wrapped IProgress properties
    virtual HRESULT getId(com::Guid &aId) = 0;
    virtual HRESULT getDescription(com::Utf8Str &aDescription) = 0;
    virtual HRESULT getInitiator(ComPtr<IUnknown> &aInitiator) = 0;
    virtual HRESULT getCancelable(BOOL *aCancelable) = 0;
    virtual HRESULT getPercent(ULONG *aPercent) = 0;
    virtual HRESULT getTimeRemaining(LONG *aTimeRemaining) = 0;
    virtual HRESULT getCompleted(BOOL *aCompleted) = 0;
    virtual HRESULT getCanceled(BOOL *aCanceled) = 0;
    virtual HRESULT getResultCode(LONG *aResultCode) = 0;
    virtual HRESULT getErrorInfo(ComPtr<IVirtualBoxErrorInfo> &aErrorInfo) = 0;
    virtual HRESULT getOperationCount(ULONG *aOperationCount) = 0;
    virtual HRESULT getOperation(ULONG *aOperation) = 0;
    virtual HRESULT getOperationDescription(com::Utf8Str &aOperationDescription) = 0;
    virtual HRESULT getOperationPercent(ULONG *aOperationPercent) = 0;
    virtual HRESULT getOperationWeight(ULONG *aOperationWeight) = 0;
    virtual HRESULT getTimeout(ULONG *aTimeout) = 0;
    virtual HRESULT setTimeout(ULONG aTimeout) = 0;

    // wrapped IProgress methods
    virtual HRESULT setCurrentOperationProgress(ULONG aPercent) = 0;
    virtual HRESULT setNextOperation(const com::Utf8Str &aNextOperationDescription,
                                     ULONG aNextOperationsWeight) = 0;
    virtual HRESULT waitForCompletion(LONG aTimeout) = 0;
    virtual HRESULT waitForOperationCompletion(ULONG aOperation,
                                               LONG aTimeout) = 0;
    virtual HRESULT waitForAsyncProgressCompletion(const ComPtr<IProgress> &aPProgressAsync) = 0;
    virtual HRESULT cancel() = 0;
};

#endif // !ProgressWrap_H_

// ##### ENDFILE "ProgressWrap.h"

// ##### BEGINFILE "ProgressWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IProgress.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_PROGRESS

#include "ProgressWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(ProgressWrap)

//
// IProgress properties
//

STDMETHODIMP ProgressWrap::COMGETTER(Id)(BSTR *aId)
{
    LogRelFlow(("{%p} %s: enter aId=%p\n", this, "Progress::getId", aId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getId(UuidOutConverter(aId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aId=%ls hrc=%Rhrc\n", this, "Progress::getId", *aId, hrc));
    return hrc;
}

STDMETHODIMP ProgressWrap::COMGETTER(Description)(BSTR *aDescription)
{
    LogRelFlow(("{%p} %s: enter aDescription=%p\n", this, "Progress::getDescription", aDescription));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDescription);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDescription(BSTROutConverter(aDescription).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDescription=%ls hrc=%Rhrc\n", this, "Progress::getDescription", *aDescription, hrc));
    return hrc;
}

STDMETHODIMP ProgressWrap::COMGETTER(Initiator)(IUnknown **aInitiator)
{
    LogRelFlow(("{%p} %s: enter aInitiator=%p\n", this, "Progress::getInitiator", aInitiator));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aInitiator);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getInitiator(ComTypeOutConverter<IUnknown>(aInitiator).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aInitiator=%p hrc=%Rhrc\n", this, "Progress::getInitiator", *aInitiator, hrc));
    return hrc;
}

STDMETHODIMP ProgressWrap::COMGETTER(Cancelable)(BOOL *aCancelable)
{
    LogRelFlow(("{%p} %s: enter aCancelable=%p\n", this, "Progress::getCancelable", aCancelable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCancelable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getCancelable(aCancelable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aCancelable=%RTbool hrc=%Rhrc\n", this, "Progress::getCancelable", *aCancelable, hrc));
    return hrc;
}

STDMETHODIMP ProgressWrap::COMGETTER(Percent)(ULONG *aPercent)
{
    LogRelFlow(("{%p} %s: enter aPercent=%p\n", this, "Progress::getPercent", aPercent));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPercent);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPercent(aPercent);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPercent=%RU32 hrc=%Rhrc\n", this, "Progress::getPercent", *aPercent, hrc));
    return hrc;
}

STDMETHODIMP ProgressWrap::COMGETTER(TimeRemaining)(LONG *aTimeRemaining)
{
    LogRelFlow(("{%p} %s: enter aTimeRemaining=%p\n", this, "Progress::getTimeRemaining", aTimeRemaining));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aTimeRemaining);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getTimeRemaining(aTimeRemaining);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aTimeRemaining=%RI32 hrc=%Rhrc\n", this, "Progress::getTimeRemaining", *aTimeRemaining, hrc));
    return hrc;
}

STDMETHODIMP ProgressWrap::COMGETTER(Completed)(BOOL *aCompleted)
{
    LogRelFlow(("{%p} %s: enter aCompleted=%p\n", this, "Progress::getCompleted", aCompleted));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCompleted);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getCompleted(aCompleted);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aCompleted=%RTbool hrc=%Rhrc\n", this, "Progress::getCompleted", *aCompleted, hrc));
    return hrc;
}

STDMETHODIMP ProgressWrap::COMGETTER(Canceled)(BOOL *aCanceled)
{
    LogRelFlow(("{%p} %s: enter aCanceled=%p\n", this, "Progress::getCanceled", aCanceled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCanceled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getCanceled(aCanceled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aCanceled=%RTbool hrc=%Rhrc\n", this, "Progress::getCanceled", *aCanceled, hrc));
    return hrc;
}

STDMETHODIMP ProgressWrap::COMGETTER(ResultCode)(LONG *aResultCode)
{
    LogRelFlow(("{%p} %s: enter aResultCode=%p\n", this, "Progress::getResultCode", aResultCode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResultCode);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getResultCode(aResultCode);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aResultCode=%RI32 hrc=%Rhrc\n", this, "Progress::getResultCode", *aResultCode, hrc));
    return hrc;
}

STDMETHODIMP ProgressWrap::COMGETTER(ErrorInfo)(IVirtualBoxErrorInfo **aErrorInfo)
{
    LogRelFlow(("{%p} %s: enter aErrorInfo=%p\n", this, "Progress::getErrorInfo", aErrorInfo));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aErrorInfo);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getErrorInfo(ComTypeOutConverter<IVirtualBoxErrorInfo>(aErrorInfo).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aErrorInfo=%p hrc=%Rhrc\n", this, "Progress::getErrorInfo", *aErrorInfo, hrc));
    return hrc;
}

STDMETHODIMP ProgressWrap::COMGETTER(OperationCount)(ULONG *aOperationCount)
{
    LogRelFlow(("{%p} %s: enter aOperationCount=%p\n", this, "Progress::getOperationCount", aOperationCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOperationCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOperationCount(aOperationCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOperationCount=%RU32 hrc=%Rhrc\n", this, "Progress::getOperationCount", *aOperationCount, hrc));
    return hrc;
}

STDMETHODIMP ProgressWrap::COMGETTER(Operation)(ULONG *aOperation)
{
    LogRelFlow(("{%p} %s: enter aOperation=%p\n", this, "Progress::getOperation", aOperation));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOperation);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOperation(aOperation);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOperation=%RU32 hrc=%Rhrc\n", this, "Progress::getOperation", *aOperation, hrc));
    return hrc;
}

STDMETHODIMP ProgressWrap::COMGETTER(OperationDescription)(BSTR *aOperationDescription)
{
    LogRelFlow(("{%p} %s: enter aOperationDescription=%p\n", this, "Progress::getOperationDescription", aOperationDescription));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOperationDescription);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOperationDescription(BSTROutConverter(aOperationDescription).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOperationDescription=%ls hrc=%Rhrc\n", this, "Progress::getOperationDescription", *aOperationDescription, hrc));
    return hrc;
}

STDMETHODIMP ProgressWrap::COMGETTER(OperationPercent)(ULONG *aOperationPercent)
{
    LogRelFlow(("{%p} %s: enter aOperationPercent=%p\n", this, "Progress::getOperationPercent", aOperationPercent));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOperationPercent);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOperationPercent(aOperationPercent);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOperationPercent=%RU32 hrc=%Rhrc\n", this, "Progress::getOperationPercent", *aOperationPercent, hrc));
    return hrc;
}

STDMETHODIMP ProgressWrap::COMGETTER(OperationWeight)(ULONG *aOperationWeight)
{
    LogRelFlow(("{%p} %s: enter aOperationWeight=%p\n", this, "Progress::getOperationWeight", aOperationWeight));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOperationWeight);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOperationWeight(aOperationWeight);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOperationWeight=%RU32 hrc=%Rhrc\n", this, "Progress::getOperationWeight", *aOperationWeight, hrc));
    return hrc;
}

STDMETHODIMP ProgressWrap::COMGETTER(Timeout)(ULONG *aTimeout)
{
    LogRelFlow(("{%p} %s: enter aTimeout=%p\n", this, "Progress::getTimeout", aTimeout));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aTimeout);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getTimeout(aTimeout);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aTimeout=%RU32 hrc=%Rhrc\n", this, "Progress::getTimeout", *aTimeout, hrc));
    return hrc;
}

STDMETHODIMP ProgressWrap::COMSETTER(Timeout)(ULONG aTimeout)
{
    LogRelFlow(("{%p} %s: enter aTimeout=%RU32\n", this, "Progress::setTimeout", aTimeout));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setTimeout(aTimeout);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Progress::setTimeout", hrc));
    return hrc;
}

//
// IProgress methods
//

STDMETHODIMP ProgressWrap::SetCurrentOperationProgress(ULONG aPercent)
{
    LogRelFlow(("{%p} %s:enter aPercent=%RU32\n", this, "Progress::setCurrentOperationProgress", aPercent));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setCurrentOperationProgress(aPercent);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Progress::setCurrentOperationProgress", hrc));
    return hrc;
}

STDMETHODIMP ProgressWrap::SetNextOperation(IN_BSTR aNextOperationDescription,
                                            ULONG aNextOperationsWeight)
{
    LogRelFlow(("{%p} %s:enter aNextOperationDescription=%ls aNextOperationsWeight=%RU32\n", this, "Progress::setNextOperation", aNextOperationDescription, aNextOperationsWeight));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setNextOperation(BSTRInConverter(aNextOperationDescription).str(),
                               aNextOperationsWeight);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Progress::setNextOperation", hrc));
    return hrc;
}

STDMETHODIMP ProgressWrap::WaitForCompletion(LONG aTimeout)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32\n", this, "Progress::waitForCompletion", aTimeout));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitForCompletion(aTimeout);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Progress::waitForCompletion", hrc));
    return hrc;
}

STDMETHODIMP ProgressWrap::WaitForOperationCompletion(ULONG aOperation,
                                                      LONG aTimeout)
{
    LogRelFlow(("{%p} %s:enter aOperation=%RU32 aTimeout=%RI32\n", this, "Progress::waitForOperationCompletion", aOperation, aTimeout));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitForOperationCompletion(aOperation,
                                         aTimeout);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Progress::waitForOperationCompletion", hrc));
    return hrc;
}

STDMETHODIMP ProgressWrap::WaitForAsyncProgressCompletion(IProgress *aPProgressAsync)
{
    LogRelFlow(("{%p} %s:enter aPProgressAsync=%p\n", this, "Progress::waitForAsyncProgressCompletion", aPProgressAsync));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitForAsyncProgressCompletion(ComTypeInConverter<IProgress>(aPProgressAsync).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Progress::waitForAsyncProgressCompletion", hrc));
    return hrc;
}

STDMETHODIMP ProgressWrap::Cancel()
{
    LogRelFlow(("{%p} %s:enter\n", this, "Progress::cancel"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = cancel();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Progress::cancel", hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(ProgressWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(ProgressWrap, IProgress)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "ProgressWrap.cpp"

// ##### BEGINFILE "SnapshotWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for ISnapshot.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef SnapshotWrap_H_
#define SnapshotWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE SnapshotWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(ISnapshot)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(SnapshotWrap, ISnapshot)
    DECLARE_NOT_AGGREGATABLE(SnapshotWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(SnapshotWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(ISnapshot)
        COM_INTERFACE_ENTRY2(IDispatch, ISnapshot)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(SnapshotWrap)

    // public ISnapshot properties
    STDMETHOD(COMGETTER(Id))(BSTR *aId);
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMSETTER(Name))(IN_BSTR aName);
    STDMETHOD(COMGETTER(Description))(BSTR *aDescription);
    STDMETHOD(COMSETTER(Description))(IN_BSTR aDescription);
    STDMETHOD(COMGETTER(TimeStamp))(LONG64 *aTimeStamp);
    STDMETHOD(COMGETTER(Online))(BOOL *aOnline);
    STDMETHOD(COMGETTER(Machine))(IMachine **aMachine);
    STDMETHOD(COMGETTER(Parent))(ISnapshot **aParent);
    STDMETHOD(COMGETTER(Children))(ComSafeArrayOut(ISnapshot *, aChildren));

    // public ISnapshot methods
    STDMETHOD(GetChildrenCount)(ULONG *aChildrenCount);

private:
    // wrapped ISnapshot properties
    virtual HRESULT getId(com::Guid &aId) = 0;
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT setName(const com::Utf8Str &aName) = 0;
    virtual HRESULT getDescription(com::Utf8Str &aDescription) = 0;
    virtual HRESULT setDescription(const com::Utf8Str &aDescription) = 0;
    virtual HRESULT getTimeStamp(LONG64 *aTimeStamp) = 0;
    virtual HRESULT getOnline(BOOL *aOnline) = 0;
    virtual HRESULT getMachine(ComPtr<IMachine> &aMachine) = 0;
    virtual HRESULT getParent(ComPtr<ISnapshot> &aParent) = 0;
    virtual HRESULT getChildren(std::vector<ComPtr<ISnapshot> > &aChildren) = 0;

    // wrapped ISnapshot methods
    virtual HRESULT getChildrenCount(ULONG *aChildrenCount) = 0;
};

#endif // !SnapshotWrap_H_

// ##### ENDFILE "SnapshotWrap.h"

// ##### BEGINFILE "SnapshotWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for ISnapshot.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_SNAPSHOT

#include "SnapshotWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(SnapshotWrap)

//
// ISnapshot properties
//

STDMETHODIMP SnapshotWrap::COMGETTER(Id)(BSTR *aId)
{
    LogRelFlow(("{%p} %s: enter aId=%p\n", this, "Snapshot::getId", aId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getId(UuidOutConverter(aId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aId=%ls hrc=%Rhrc\n", this, "Snapshot::getId", *aId, hrc));
    return hrc;
}

STDMETHODIMP SnapshotWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "Snapshot::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "Snapshot::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP SnapshotWrap::COMSETTER(Name)(IN_BSTR aName)
{
    LogRelFlow(("{%p} %s: enter aName=%ls\n", this, "Snapshot::setName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setName(BSTRInConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Snapshot::setName", hrc));
    return hrc;
}

STDMETHODIMP SnapshotWrap::COMGETTER(Description)(BSTR *aDescription)
{
    LogRelFlow(("{%p} %s: enter aDescription=%p\n", this, "Snapshot::getDescription", aDescription));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDescription);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDescription(BSTROutConverter(aDescription).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDescription=%ls hrc=%Rhrc\n", this, "Snapshot::getDescription", *aDescription, hrc));
    return hrc;
}

STDMETHODIMP SnapshotWrap::COMSETTER(Description)(IN_BSTR aDescription)
{
    LogRelFlow(("{%p} %s: enter aDescription=%ls\n", this, "Snapshot::setDescription", aDescription));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setDescription(BSTRInConverter(aDescription).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Snapshot::setDescription", hrc));
    return hrc;
}

STDMETHODIMP SnapshotWrap::COMGETTER(TimeStamp)(LONG64 *aTimeStamp)
{
    LogRelFlow(("{%p} %s: enter aTimeStamp=%p\n", this, "Snapshot::getTimeStamp", aTimeStamp));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aTimeStamp);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getTimeStamp(aTimeStamp);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aTimeStamp=%RI64 hrc=%Rhrc\n", this, "Snapshot::getTimeStamp", *aTimeStamp, hrc));
    return hrc;
}

STDMETHODIMP SnapshotWrap::COMGETTER(Online)(BOOL *aOnline)
{
    LogRelFlow(("{%p} %s: enter aOnline=%p\n", this, "Snapshot::getOnline", aOnline));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOnline);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOnline(aOnline);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOnline=%RTbool hrc=%Rhrc\n", this, "Snapshot::getOnline", *aOnline, hrc));
    return hrc;
}

STDMETHODIMP SnapshotWrap::COMGETTER(Machine)(IMachine **aMachine)
{
    LogRelFlow(("{%p} %s: enter aMachine=%p\n", this, "Snapshot::getMachine", aMachine));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachine);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachine(ComTypeOutConverter<IMachine>(aMachine).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachine=%p hrc=%Rhrc\n", this, "Snapshot::getMachine", *aMachine, hrc));
    return hrc;
}

STDMETHODIMP SnapshotWrap::COMGETTER(Parent)(ISnapshot **aParent)
{
    LogRelFlow(("{%p} %s: enter aParent=%p\n", this, "Snapshot::getParent", aParent));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aParent);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getParent(ComTypeOutConverter<ISnapshot>(aParent).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aParent=%p hrc=%Rhrc\n", this, "Snapshot::getParent", *aParent, hrc));
    return hrc;
}

STDMETHODIMP SnapshotWrap::COMGETTER(Children)(ComSafeArrayOut(ISnapshot *, aChildren))
{
    LogRelFlow(("{%p} %s: enter aChildren=%p\n", this, "Snapshot::getChildren", aChildren));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aChildren);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getChildren(ArrayComTypeOutConverter<ISnapshot>(ComSafeArrayOutArg(aChildren)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aChildren=%zu hrc=%Rhrc\n", this, "Snapshot::getChildren", ComSafeArraySize(*aChildren), hrc));
    return hrc;
}

//
// ISnapshot methods
//

STDMETHODIMP SnapshotWrap::GetChildrenCount(ULONG *aChildrenCount)
{
    LogRelFlow(("{%p} %s:enter aChildrenCount=%p\n", this, "Snapshot::getChildrenCount", aChildrenCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aChildrenCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getChildrenCount(aChildrenCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aChildrenCount=%RU32 hrc=%Rhrc\n", this, "Snapshot::getChildrenCount", *aChildrenCount, hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(SnapshotWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(SnapshotWrap, ISnapshot)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "SnapshotWrap.cpp"

// ##### BEGINFILE "MediumAttachmentWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IMediumAttachment.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef MediumAttachmentWrap_H_
#define MediumAttachmentWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE MediumAttachmentWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IMediumAttachment)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(MediumAttachmentWrap, IMediumAttachment)
    DECLARE_NOT_AGGREGATABLE(MediumAttachmentWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(MediumAttachmentWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IMediumAttachment)
        COM_INTERFACE_ENTRY2(IDispatch, IMediumAttachment)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(MediumAttachmentWrap)

    // public IMediumAttachment properties
    STDMETHOD(COMGETTER(Medium))(IMedium **aMedium);
    STDMETHOD(COMGETTER(Controller))(BSTR *aController);
    STDMETHOD(COMGETTER(Port))(LONG *aPort);
    STDMETHOD(COMGETTER(Device))(LONG *aDevice);
    STDMETHOD(COMGETTER(Type))(DeviceType_T *aType);
    STDMETHOD(COMGETTER(Passthrough))(BOOL *aPassthrough);
    STDMETHOD(COMGETTER(TemporaryEject))(BOOL *aTemporaryEject);
    STDMETHOD(COMGETTER(IsEjected))(BOOL *aIsEjected);
    STDMETHOD(COMGETTER(NonRotational))(BOOL *aNonRotational);
    STDMETHOD(COMGETTER(Discard))(BOOL *aDiscard);
    STDMETHOD(COMGETTER(HotPluggable))(BOOL *aHotPluggable);
    STDMETHOD(COMGETTER(BandwidthGroup))(IBandwidthGroup **aBandwidthGroup);

    // public IMediumAttachment methods

private:
    // wrapped IMediumAttachment properties
    virtual HRESULT getMedium(ComPtr<IMedium> &aMedium) = 0;
    virtual HRESULT getController(com::Utf8Str &aController) = 0;
    virtual HRESULT getPort(LONG *aPort) = 0;
    virtual HRESULT getDevice(LONG *aDevice) = 0;
    virtual HRESULT getType(DeviceType_T *aType) = 0;
    virtual HRESULT getPassthrough(BOOL *aPassthrough) = 0;
    virtual HRESULT getTemporaryEject(BOOL *aTemporaryEject) = 0;
    virtual HRESULT getIsEjected(BOOL *aIsEjected) = 0;
    virtual HRESULT getNonRotational(BOOL *aNonRotational) = 0;
    virtual HRESULT getDiscard(BOOL *aDiscard) = 0;
    virtual HRESULT getHotPluggable(BOOL *aHotPluggable) = 0;
    virtual HRESULT getBandwidthGroup(ComPtr<IBandwidthGroup> &aBandwidthGroup) = 0;

    // wrapped IMediumAttachment methods
};

#endif // !MediumAttachmentWrap_H_

// ##### ENDFILE "MediumAttachmentWrap.h"

// ##### BEGINFILE "MediumAttachmentWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IMediumAttachment.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_MEDIUMATTACHMENT

#include "MediumAttachmentWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(MediumAttachmentWrap)

//
// IMediumAttachment properties
//

STDMETHODIMP MediumAttachmentWrap::COMGETTER(Medium)(IMedium **aMedium)
{
    LogRelFlow(("{%p} %s: enter aMedium=%p\n", this, "MediumAttachment::getMedium", aMedium));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMedium);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMedium(ComTypeOutConverter<IMedium>(aMedium).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMedium=%p hrc=%Rhrc\n", this, "MediumAttachment::getMedium", *aMedium, hrc));
    return hrc;
}

STDMETHODIMP MediumAttachmentWrap::COMGETTER(Controller)(BSTR *aController)
{
    LogRelFlow(("{%p} %s: enter aController=%p\n", this, "MediumAttachment::getController", aController));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aController);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getController(BSTROutConverter(aController).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aController=%ls hrc=%Rhrc\n", this, "MediumAttachment::getController", *aController, hrc));
    return hrc;
}

STDMETHODIMP MediumAttachmentWrap::COMGETTER(Port)(LONG *aPort)
{
    LogRelFlow(("{%p} %s: enter aPort=%p\n", this, "MediumAttachment::getPort", aPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPort);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPort(aPort);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPort=%RI32 hrc=%Rhrc\n", this, "MediumAttachment::getPort", *aPort, hrc));
    return hrc;
}

STDMETHODIMP MediumAttachmentWrap::COMGETTER(Device)(LONG *aDevice)
{
    LogRelFlow(("{%p} %s: enter aDevice=%p\n", this, "MediumAttachment::getDevice", aDevice));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDevice);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDevice(aDevice);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDevice=%RI32 hrc=%Rhrc\n", this, "MediumAttachment::getDevice", *aDevice, hrc));
    return hrc;
}

STDMETHODIMP MediumAttachmentWrap::COMGETTER(Type)(DeviceType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "MediumAttachment::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "MediumAttachment::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP MediumAttachmentWrap::COMGETTER(Passthrough)(BOOL *aPassthrough)
{
    LogRelFlow(("{%p} %s: enter aPassthrough=%p\n", this, "MediumAttachment::getPassthrough", aPassthrough));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPassthrough);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPassthrough(aPassthrough);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPassthrough=%RTbool hrc=%Rhrc\n", this, "MediumAttachment::getPassthrough", *aPassthrough, hrc));
    return hrc;
}

STDMETHODIMP MediumAttachmentWrap::COMGETTER(TemporaryEject)(BOOL *aTemporaryEject)
{
    LogRelFlow(("{%p} %s: enter aTemporaryEject=%p\n", this, "MediumAttachment::getTemporaryEject", aTemporaryEject));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aTemporaryEject);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getTemporaryEject(aTemporaryEject);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aTemporaryEject=%RTbool hrc=%Rhrc\n", this, "MediumAttachment::getTemporaryEject", *aTemporaryEject, hrc));
    return hrc;
}

STDMETHODIMP MediumAttachmentWrap::COMGETTER(IsEjected)(BOOL *aIsEjected)
{
    LogRelFlow(("{%p} %s: enter aIsEjected=%p\n", this, "MediumAttachment::getIsEjected", aIsEjected));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aIsEjected);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getIsEjected(aIsEjected);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aIsEjected=%RTbool hrc=%Rhrc\n", this, "MediumAttachment::getIsEjected", *aIsEjected, hrc));
    return hrc;
}

STDMETHODIMP MediumAttachmentWrap::COMGETTER(NonRotational)(BOOL *aNonRotational)
{
    LogRelFlow(("{%p} %s: enter aNonRotational=%p\n", this, "MediumAttachment::getNonRotational", aNonRotational));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNonRotational);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNonRotational(aNonRotational);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNonRotational=%RTbool hrc=%Rhrc\n", this, "MediumAttachment::getNonRotational", *aNonRotational, hrc));
    return hrc;
}

STDMETHODIMP MediumAttachmentWrap::COMGETTER(Discard)(BOOL *aDiscard)
{
    LogRelFlow(("{%p} %s: enter aDiscard=%p\n", this, "MediumAttachment::getDiscard", aDiscard));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDiscard);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDiscard(aDiscard);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDiscard=%RTbool hrc=%Rhrc\n", this, "MediumAttachment::getDiscard", *aDiscard, hrc));
    return hrc;
}

STDMETHODIMP MediumAttachmentWrap::COMGETTER(HotPluggable)(BOOL *aHotPluggable)
{
    LogRelFlow(("{%p} %s: enter aHotPluggable=%p\n", this, "MediumAttachment::getHotPluggable", aHotPluggable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHotPluggable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHotPluggable(aHotPluggable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHotPluggable=%RTbool hrc=%Rhrc\n", this, "MediumAttachment::getHotPluggable", *aHotPluggable, hrc));
    return hrc;
}

STDMETHODIMP MediumAttachmentWrap::COMGETTER(BandwidthGroup)(IBandwidthGroup **aBandwidthGroup)
{
    LogRelFlow(("{%p} %s: enter aBandwidthGroup=%p\n", this, "MediumAttachment::getBandwidthGroup", aBandwidthGroup));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBandwidthGroup);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBandwidthGroup(ComTypeOutConverter<IBandwidthGroup>(aBandwidthGroup).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBandwidthGroup=%p hrc=%Rhrc\n", this, "MediumAttachment::getBandwidthGroup", *aBandwidthGroup, hrc));
    return hrc;
}

//
// IMediumAttachment methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(MediumAttachmentWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(MediumAttachmentWrap, IMediumAttachment)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "MediumAttachmentWrap.cpp"

// ##### BEGINFILE "MediumWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IMedium.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef MediumWrap_H_
#define MediumWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE MediumWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IMedium)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(MediumWrap, IMedium)
    DECLARE_NOT_AGGREGATABLE(MediumWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(MediumWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IMedium)
        COM_INTERFACE_ENTRY2(IDispatch, IMedium)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(MediumWrap)

    // public IMedium properties
    STDMETHOD(COMGETTER(Id))(BSTR *aId);
    STDMETHOD(COMGETTER(Description))(BSTR *aDescription);
    STDMETHOD(COMSETTER(Description))(IN_BSTR aDescription);
    STDMETHOD(COMGETTER(State))(MediumState_T *aState);
    STDMETHOD(COMGETTER(Variant))(ComSafeArrayOut(MediumVariant_T, aVariant));
    STDMETHOD(COMGETTER(Location))(BSTR *aLocation);
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(DeviceType))(DeviceType_T *aDeviceType);
    STDMETHOD(COMGETTER(HostDrive))(BOOL *aHostDrive);
    STDMETHOD(COMGETTER(Size))(LONG64 *aSize);
    STDMETHOD(COMGETTER(Format))(BSTR *aFormat);
    STDMETHOD(COMGETTER(MediumFormat))(IMediumFormat **aMediumFormat);
    STDMETHOD(COMGETTER(Type))(MediumType_T *aType);
    STDMETHOD(COMSETTER(Type))(MediumType_T aType);
    STDMETHOD(COMGETTER(AllowedTypes))(ComSafeArrayOut(MediumType_T, aAllowedTypes));
    STDMETHOD(COMGETTER(Parent))(IMedium **aParent);
    STDMETHOD(COMGETTER(Children))(ComSafeArrayOut(IMedium *, aChildren));
    STDMETHOD(COMGETTER(Base))(IMedium **aBase);
    STDMETHOD(COMGETTER(ReadOnly))(BOOL *aReadOnly);
    STDMETHOD(COMGETTER(LogicalSize))(LONG64 *aLogicalSize);
    STDMETHOD(COMGETTER(AutoReset))(BOOL *aAutoReset);
    STDMETHOD(COMSETTER(AutoReset))(BOOL aAutoReset);
    STDMETHOD(COMGETTER(LastAccessError))(BSTR *aLastAccessError);
    STDMETHOD(COMGETTER(MachineIds))(ComSafeArrayOut(BSTR, aMachineIds));

    // public IMedium methods
    STDMETHOD(SetIds)(BOOL aSetImageId,
                      IN_BSTR aImageId,
                      BOOL aSetParentId,
                      IN_BSTR aParentId);
    STDMETHOD(RefreshState)(MediumState_T *aState);
    STDMETHOD(GetSnapshotIds)(IN_BSTR aMachineId,
                              ComSafeArrayOut(BSTR, aSnapshotIds));
    STDMETHOD(LockRead)(IToken **aToken);
    STDMETHOD(LockWrite)(IToken **aToken);
    STDMETHOD(Close)();
    STDMETHOD(GetProperty)(IN_BSTR aName,
                           BSTR *aValue);
    STDMETHOD(SetProperty)(IN_BSTR aName,
                           IN_BSTR aValue);
    STDMETHOD(GetProperties)(IN_BSTR aNames,
                             ComSafeArrayOut(BSTR, aReturnNames),
                             ComSafeArrayOut(BSTR, aReturnValues));
    STDMETHOD(SetProperties)(ComSafeArrayIn(IN_BSTR, aNames),
                             ComSafeArrayIn(IN_BSTR, aValues));
    STDMETHOD(CreateBaseStorage)(LONG64 aLogicalSize,
                                 ComSafeArrayIn(MediumVariant_T, aVariant),
                                 IProgress **aProgress);
    STDMETHOD(DeleteStorage)(IProgress **aProgress);
    STDMETHOD(CreateDiffStorage)(IMedium *aTarget,
                                 ComSafeArrayIn(MediumVariant_T, aVariant),
                                 IProgress **aProgress);
    STDMETHOD(MergeTo)(IMedium *aTarget,
                       IProgress **aProgress);
    STDMETHOD(CloneTo)(IMedium *aTarget,
                       ComSafeArrayIn(MediumVariant_T, aVariant),
                       IMedium *aParent,
                       IProgress **aProgress);
    STDMETHOD(CloneToBase)(IMedium *aTarget,
                           ComSafeArrayIn(MediumVariant_T, aVariant),
                           IProgress **aProgress);
    STDMETHOD(SetLocation)(IN_BSTR aLocation,
                           IProgress **aProgress);
    STDMETHOD(Compact)(IProgress **aProgress);
    STDMETHOD(Resize)(LONG64 aLogicalSize,
                      IProgress **aProgress);
    STDMETHOD(Reset)(IProgress **aProgress);

private:
    // wrapped IMedium properties
    virtual HRESULT getId(com::Guid &aId) = 0;
    virtual HRESULT getDescription(com::Utf8Str &aDescription) = 0;
    virtual HRESULT setDescription(const com::Utf8Str &aDescription) = 0;
    virtual HRESULT getState(MediumState_T *aState) = 0;
    virtual HRESULT getVariant(std::vector<MediumVariant_T> &aVariant) = 0;
    virtual HRESULT getLocation(com::Utf8Str &aLocation) = 0;
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getDeviceType(DeviceType_T *aDeviceType) = 0;
    virtual HRESULT getHostDrive(BOOL *aHostDrive) = 0;
    virtual HRESULT getSize(LONG64 *aSize) = 0;
    virtual HRESULT getFormat(com::Utf8Str &aFormat) = 0;
    virtual HRESULT getMediumFormat(ComPtr<IMediumFormat> &aMediumFormat) = 0;
    virtual HRESULT getType(MediumType_T *aType) = 0;
    virtual HRESULT setType(MediumType_T aType) = 0;
    virtual HRESULT getAllowedTypes(std::vector<MediumType_T> &aAllowedTypes) = 0;
    virtual HRESULT getParent(ComPtr<IMedium> &aParent) = 0;
    virtual HRESULT getChildren(std::vector<ComPtr<IMedium> > &aChildren) = 0;
    virtual HRESULT getBase(ComPtr<IMedium> &aBase) = 0;
    virtual HRESULT getReadOnly(BOOL *aReadOnly) = 0;
    virtual HRESULT getLogicalSize(LONG64 *aLogicalSize) = 0;
    virtual HRESULT getAutoReset(BOOL *aAutoReset) = 0;
    virtual HRESULT setAutoReset(BOOL aAutoReset) = 0;
    virtual HRESULT getLastAccessError(com::Utf8Str &aLastAccessError) = 0;
    virtual HRESULT getMachineIds(std::vector<com::Guid> &aMachineIds) = 0;

    // wrapped IMedium methods
    virtual HRESULT setIds(BOOL aSetImageId,
                           const com::Guid &aImageId,
                           BOOL aSetParentId,
                           const com::Guid &aParentId) = 0;
    virtual HRESULT refreshState(MediumState_T *aState) = 0;
    virtual HRESULT getSnapshotIds(const com::Guid &aMachineId,
                                   std::vector<com::Guid> &aSnapshotIds) = 0;
    virtual HRESULT lockRead(ComPtr<IToken> &aToken) = 0;
    virtual HRESULT lockWrite(ComPtr<IToken> &aToken) = 0;
    virtual HRESULT close() = 0;
    virtual HRESULT getProperty(const com::Utf8Str &aName,
                                com::Utf8Str &aValue) = 0;
    virtual HRESULT setProperty(const com::Utf8Str &aName,
                                const com::Utf8Str &aValue) = 0;
    virtual HRESULT getProperties(const com::Utf8Str &aNames,
                                  std::vector<com::Utf8Str> &aReturnNames,
                                  std::vector<com::Utf8Str> &aReturnValues) = 0;
    virtual HRESULT setProperties(const std::vector<com::Utf8Str> &aNames,
                                  const std::vector<com::Utf8Str> &aValues) = 0;
    virtual HRESULT createBaseStorage(LONG64 aLogicalSize,
                                      const std::vector<MediumVariant_T> &aVariant,
                                      ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT deleteStorage(ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT createDiffStorage(const ComPtr<IMedium> &aTarget,
                                      const std::vector<MediumVariant_T> &aVariant,
                                      ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT mergeTo(const ComPtr<IMedium> &aTarget,
                            ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT cloneTo(const ComPtr<IMedium> &aTarget,
                            const std::vector<MediumVariant_T> &aVariant,
                            const ComPtr<IMedium> &aParent,
                            ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT cloneToBase(const ComPtr<IMedium> &aTarget,
                                const std::vector<MediumVariant_T> &aVariant,
                                ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT setLocation(const com::Utf8Str &aLocation,
                                ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT compact(ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT resize(LONG64 aLogicalSize,
                           ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT reset(ComPtr<IProgress> &aProgress) = 0;
};

#endif // !MediumWrap_H_

// ##### ENDFILE "MediumWrap.h"

// ##### BEGINFILE "MediumWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IMedium.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_MEDIUM

#include "MediumWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(MediumWrap)

//
// IMedium properties
//

STDMETHODIMP MediumWrap::COMGETTER(Id)(BSTR *aId)
{
    LogRelFlow(("{%p} %s: enter aId=%p\n", this, "Medium::getId", aId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getId(UuidOutConverter(aId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aId=%ls hrc=%Rhrc\n", this, "Medium::getId", *aId, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMGETTER(Description)(BSTR *aDescription)
{
    LogRelFlow(("{%p} %s: enter aDescription=%p\n", this, "Medium::getDescription", aDescription));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDescription);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDescription(BSTROutConverter(aDescription).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDescription=%ls hrc=%Rhrc\n", this, "Medium::getDescription", *aDescription, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMSETTER(Description)(IN_BSTR aDescription)
{
    LogRelFlow(("{%p} %s: enter aDescription=%ls\n", this, "Medium::setDescription", aDescription));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setDescription(BSTRInConverter(aDescription).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Medium::setDescription", hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMGETTER(State)(MediumState_T *aState)
{
    LogRelFlow(("{%p} %s: enter aState=%p\n", this, "Medium::getState", aState));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aState);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getState(aState);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aState=%RU32 hrc=%Rhrc\n", this, "Medium::getState", *aState, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMGETTER(Variant)(ComSafeArrayOut(MediumVariant_T, aVariant))
{
    LogRelFlow(("{%p} %s: enter aVariant=%p\n", this, "Medium::getVariant", aVariant));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVariant);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVariant(ArrayOutConverter<MediumVariant_T>(ComSafeArrayOutArg(aVariant)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVariant=%zu hrc=%Rhrc\n", this, "Medium::getVariant", ComSafeArraySize(*aVariant), hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMGETTER(Location)(BSTR *aLocation)
{
    LogRelFlow(("{%p} %s: enter aLocation=%p\n", this, "Medium::getLocation", aLocation));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLocation);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLocation(BSTROutConverter(aLocation).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLocation=%ls hrc=%Rhrc\n", this, "Medium::getLocation", *aLocation, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "Medium::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "Medium::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMGETTER(DeviceType)(DeviceType_T *aDeviceType)
{
    LogRelFlow(("{%p} %s: enter aDeviceType=%p\n", this, "Medium::getDeviceType", aDeviceType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDeviceType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDeviceType(aDeviceType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDeviceType=%RU32 hrc=%Rhrc\n", this, "Medium::getDeviceType", *aDeviceType, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMGETTER(HostDrive)(BOOL *aHostDrive)
{
    LogRelFlow(("{%p} %s: enter aHostDrive=%p\n", this, "Medium::getHostDrive", aHostDrive));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHostDrive);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHostDrive(aHostDrive);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHostDrive=%RTbool hrc=%Rhrc\n", this, "Medium::getHostDrive", *aHostDrive, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMGETTER(Size)(LONG64 *aSize)
{
    LogRelFlow(("{%p} %s: enter aSize=%p\n", this, "Medium::getSize", aSize));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSize);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSize(aSize);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSize=%RI64 hrc=%Rhrc\n", this, "Medium::getSize", *aSize, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMGETTER(Format)(BSTR *aFormat)
{
    LogRelFlow(("{%p} %s: enter aFormat=%p\n", this, "Medium::getFormat", aFormat));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFormat);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFormat(BSTROutConverter(aFormat).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFormat=%ls hrc=%Rhrc\n", this, "Medium::getFormat", *aFormat, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMGETTER(MediumFormat)(IMediumFormat **aMediumFormat)
{
    LogRelFlow(("{%p} %s: enter aMediumFormat=%p\n", this, "Medium::getMediumFormat", aMediumFormat));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMediumFormat);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMediumFormat(ComTypeOutConverter<IMediumFormat>(aMediumFormat).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMediumFormat=%p hrc=%Rhrc\n", this, "Medium::getMediumFormat", *aMediumFormat, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMGETTER(Type)(MediumType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "Medium::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "Medium::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMSETTER(Type)(MediumType_T aType)
{
    LogRelFlow(("{%p} %s: enter aType=%RU32\n", this, "Medium::setType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Medium::setType", hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMGETTER(AllowedTypes)(ComSafeArrayOut(MediumType_T, aAllowedTypes))
{
    LogRelFlow(("{%p} %s: enter aAllowedTypes=%p\n", this, "Medium::getAllowedTypes", aAllowedTypes));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAllowedTypes);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAllowedTypes(ArrayOutConverter<MediumType_T>(ComSafeArrayOutArg(aAllowedTypes)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAllowedTypes=%zu hrc=%Rhrc\n", this, "Medium::getAllowedTypes", ComSafeArraySize(*aAllowedTypes), hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMGETTER(Parent)(IMedium **aParent)
{
    LogRelFlow(("{%p} %s: enter aParent=%p\n", this, "Medium::getParent", aParent));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aParent);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getParent(ComTypeOutConverter<IMedium>(aParent).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aParent=%p hrc=%Rhrc\n", this, "Medium::getParent", *aParent, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMGETTER(Children)(ComSafeArrayOut(IMedium *, aChildren))
{
    LogRelFlow(("{%p} %s: enter aChildren=%p\n", this, "Medium::getChildren", aChildren));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aChildren);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getChildren(ArrayComTypeOutConverter<IMedium>(ComSafeArrayOutArg(aChildren)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aChildren=%zu hrc=%Rhrc\n", this, "Medium::getChildren", ComSafeArraySize(*aChildren), hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMGETTER(Base)(IMedium **aBase)
{
    LogRelFlow(("{%p} %s: enter aBase=%p\n", this, "Medium::getBase", aBase));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBase);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBase(ComTypeOutConverter<IMedium>(aBase).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBase=%p hrc=%Rhrc\n", this, "Medium::getBase", *aBase, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMGETTER(ReadOnly)(BOOL *aReadOnly)
{
    LogRelFlow(("{%p} %s: enter aReadOnly=%p\n", this, "Medium::getReadOnly", aReadOnly));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aReadOnly);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getReadOnly(aReadOnly);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aReadOnly=%RTbool hrc=%Rhrc\n", this, "Medium::getReadOnly", *aReadOnly, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMGETTER(LogicalSize)(LONG64 *aLogicalSize)
{
    LogRelFlow(("{%p} %s: enter aLogicalSize=%p\n", this, "Medium::getLogicalSize", aLogicalSize));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLogicalSize);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLogicalSize(aLogicalSize);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLogicalSize=%RI64 hrc=%Rhrc\n", this, "Medium::getLogicalSize", *aLogicalSize, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMGETTER(AutoReset)(BOOL *aAutoReset)
{
    LogRelFlow(("{%p} %s: enter aAutoReset=%p\n", this, "Medium::getAutoReset", aAutoReset));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAutoReset);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAutoReset(aAutoReset);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAutoReset=%RTbool hrc=%Rhrc\n", this, "Medium::getAutoReset", *aAutoReset, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMSETTER(AutoReset)(BOOL aAutoReset)
{
    LogRelFlow(("{%p} %s: enter aAutoReset=%RTbool\n", this, "Medium::setAutoReset", aAutoReset));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setAutoReset(aAutoReset);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Medium::setAutoReset", hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMGETTER(LastAccessError)(BSTR *aLastAccessError)
{
    LogRelFlow(("{%p} %s: enter aLastAccessError=%p\n", this, "Medium::getLastAccessError", aLastAccessError));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLastAccessError);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLastAccessError(BSTROutConverter(aLastAccessError).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLastAccessError=%ls hrc=%Rhrc\n", this, "Medium::getLastAccessError", *aLastAccessError, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::COMGETTER(MachineIds)(ComSafeArrayOut(BSTR, aMachineIds))
{
    LogRelFlow(("{%p} %s: enter aMachineIds=%p\n", this, "Medium::getMachineIds", aMachineIds));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachineIds);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachineIds(ArrayUuidOutConverter(ComSafeArrayOutArg(aMachineIds)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachineIds=%zu hrc=%Rhrc\n", this, "Medium::getMachineIds", ComSafeArraySize(*aMachineIds), hrc));
    return hrc;
}

//
// IMedium methods
//

STDMETHODIMP MediumWrap::SetIds(BOOL aSetImageId,
                                IN_BSTR aImageId,
                                BOOL aSetParentId,
                                IN_BSTR aParentId)
{
    LogRelFlow(("{%p} %s:enter aSetImageId=%RTbool aImageId=%ls aSetParentId=%RTbool aParentId=%ls\n", this, "Medium::setIds", aSetImageId, aImageId, aSetParentId, aParentId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setIds(aSetImageId,
                     UuidInConverter(aImageId).uuid(),
                     aSetParentId,
                     UuidInConverter(aParentId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Medium::setIds", hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::RefreshState(MediumState_T *aState)
{
    LogRelFlow(("{%p} %s:enter aState=%p\n", this, "Medium::refreshState", aState));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aState);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = refreshState(aState);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aState=%RU32 hrc=%Rhrc\n", this, "Medium::refreshState", *aState, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::GetSnapshotIds(IN_BSTR aMachineId,
                                        ComSafeArrayOut(BSTR, aSnapshotIds))
{
    LogRelFlow(("{%p} %s:enter aMachineId=%ls aSnapshotIds=%p\n", this, "Medium::getSnapshotIds", aMachineId, aSnapshotIds));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSnapshotIds);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSnapshotIds(UuidInConverter(aMachineId).uuid(),
                             ArrayUuidOutConverter(ComSafeArrayOutArg(aSnapshotIds)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aSnapshotIds=%zu hrc=%Rhrc\n", this, "Medium::getSnapshotIds", ComSafeArraySize(*aSnapshotIds), hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::LockRead(IToken **aToken)
{
    LogRelFlow(("{%p} %s:enter aToken=%p\n", this, "Medium::lockRead", aToken));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aToken);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = lockRead(ComTypeOutConverter<IToken>(aToken).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aToken=%p hrc=%Rhrc\n", this, "Medium::lockRead", *aToken, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::LockWrite(IToken **aToken)
{
    LogRelFlow(("{%p} %s:enter aToken=%p\n", this, "Medium::lockWrite", aToken));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aToken);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = lockWrite(ComTypeOutConverter<IToken>(aToken).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aToken=%p hrc=%Rhrc\n", this, "Medium::lockWrite", *aToken, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::Close()
{
    LogRelFlow(("{%p} %s:enter\n", this, "Medium::close"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = close();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Medium::close", hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::GetProperty(IN_BSTR aName,
                                     BSTR *aValue)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aValue=%p\n", this, "Medium::getProperty", aName, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aValue);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProperty(BSTRInConverter(aName).str(),
                          BSTROutConverter(aValue).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aValue=%ls hrc=%Rhrc\n", this, "Medium::getProperty", *aValue, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::SetProperty(IN_BSTR aName,
                                     IN_BSTR aValue)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aValue=%ls\n", this, "Medium::setProperty", aName, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProperty(BSTRInConverter(aName).str(),
                          BSTRInConverter(aValue).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Medium::setProperty", hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::GetProperties(IN_BSTR aNames,
                                       ComSafeArrayOut(BSTR, aReturnNames),
                                       ComSafeArrayOut(BSTR, aReturnValues))
{
    LogRelFlow(("{%p} %s:enter aNames=%ls aReturnNames=%p aReturnValues=%p\n", this, "Medium::getProperties", aNames, aReturnNames, aReturnValues));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aReturnNames);
        CheckComArgOutPointerValidThrow(aReturnValues);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProperties(BSTRInConverter(aNames).str(),
                            ArrayBSTROutConverter(ComSafeArrayOutArg(aReturnNames)).array(),
                            ArrayBSTROutConverter(ComSafeArrayOutArg(aReturnValues)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aReturnNames=%zu aReturnValues=%zu hrc=%Rhrc\n", this, "Medium::getProperties", ComSafeArraySize(*aReturnNames), ComSafeArraySize(*aReturnValues), hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::SetProperties(ComSafeArrayIn(IN_BSTR, aNames),
                                       ComSafeArrayIn(IN_BSTR, aValues))
{
    LogRelFlow(("{%p} %s:enter aNames=%zu aValues=%zu\n", this, "Medium::setProperties", aNames, aValues));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProperties(ArrayBSTRInConverter(ComSafeArrayInArg(aNames)).array(),
                            ArrayBSTRInConverter(ComSafeArrayInArg(aValues)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Medium::setProperties", hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::CreateBaseStorage(LONG64 aLogicalSize,
                                           ComSafeArrayIn(MediumVariant_T, aVariant),
                                           IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aLogicalSize=%RI64 aVariant=%zu aProgress=%p\n", this, "Medium::createBaseStorage", aLogicalSize, aVariant, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = createBaseStorage(aLogicalSize,
                                ArrayInConverter<MediumVariant_T>(ComSafeArrayInArg(aVariant)).array(),
                                ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Medium::createBaseStorage", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::DeleteStorage(IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aProgress=%p\n", this, "Medium::deleteStorage", aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = deleteStorage(ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Medium::deleteStorage", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::CreateDiffStorage(IMedium *aTarget,
                                           ComSafeArrayIn(MediumVariant_T, aVariant),
                                           IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aTarget=%p aVariant=%zu aProgress=%p\n", this, "Medium::createDiffStorage", aTarget, aVariant, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = createDiffStorage(ComTypeInConverter<IMedium>(aTarget).ptr(),
                                ArrayInConverter<MediumVariant_T>(ComSafeArrayInArg(aVariant)).array(),
                                ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Medium::createDiffStorage", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::MergeTo(IMedium *aTarget,
                                 IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aTarget=%p aProgress=%p\n", this, "Medium::mergeTo", aTarget, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = mergeTo(ComTypeInConverter<IMedium>(aTarget).ptr(),
                      ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Medium::mergeTo", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::CloneTo(IMedium *aTarget,
                                 ComSafeArrayIn(MediumVariant_T, aVariant),
                                 IMedium *aParent,
                                 IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aTarget=%p aVariant=%zu aParent=%p aProgress=%p\n", this, "Medium::cloneTo", aTarget, aVariant, aParent, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = cloneTo(ComTypeInConverter<IMedium>(aTarget).ptr(),
                      ArrayInConverter<MediumVariant_T>(ComSafeArrayInArg(aVariant)).array(),
                      ComTypeInConverter<IMedium>(aParent).ptr(),
                      ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Medium::cloneTo", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::CloneToBase(IMedium *aTarget,
                                     ComSafeArrayIn(MediumVariant_T, aVariant),
                                     IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aTarget=%p aVariant=%zu aProgress=%p\n", this, "Medium::cloneToBase", aTarget, aVariant, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = cloneToBase(ComTypeInConverter<IMedium>(aTarget).ptr(),
                          ArrayInConverter<MediumVariant_T>(ComSafeArrayInArg(aVariant)).array(),
                          ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Medium::cloneToBase", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::SetLocation(IN_BSTR aLocation,
                                     IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aLocation=%ls aProgress=%p\n", this, "Medium::setLocation", aLocation, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setLocation(BSTRInConverter(aLocation).str(),
                          ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Medium::setLocation", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::Compact(IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aProgress=%p\n", this, "Medium::compact", aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = compact(ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Medium::compact", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::Resize(LONG64 aLogicalSize,
                                IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aLogicalSize=%RI64 aProgress=%p\n", this, "Medium::resize", aLogicalSize, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = resize(aLogicalSize,
                     ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Medium::resize", *aProgress, hrc));
    return hrc;
}

STDMETHODIMP MediumWrap::Reset(IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aProgress=%p\n", this, "Medium::reset", aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = reset(ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "Medium::reset", *aProgress, hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(MediumWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(MediumWrap, IMedium)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "MediumWrap.cpp"

// ##### BEGINFILE "MediumFormatWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IMediumFormat.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef MediumFormatWrap_H_
#define MediumFormatWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE MediumFormatWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IMediumFormat)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(MediumFormatWrap, IMediumFormat)
    DECLARE_NOT_AGGREGATABLE(MediumFormatWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(MediumFormatWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IMediumFormat)
        COM_INTERFACE_ENTRY2(IDispatch, IMediumFormat)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(MediumFormatWrap)

    // public IMediumFormat properties
    STDMETHOD(COMGETTER(Id))(BSTR *aId);
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(Capabilities))(ComSafeArrayOut(MediumFormatCapabilities_T, aCapabilities));

    // public IMediumFormat methods
    STDMETHOD(DescribeFileExtensions)(ComSafeArrayOut(BSTR, aExtensions),
                                      ComSafeArrayOut(DeviceType_T, aTypes));
    STDMETHOD(DescribeProperties)(ComSafeArrayOut(BSTR, aNames),
                                  ComSafeArrayOut(BSTR, aDescriptions),
                                  ComSafeArrayOut(DataType_T, aTypes),
                                  ComSafeArrayOut(ULONG, aFlags),
                                  ComSafeArrayOut(BSTR, aDefaults));

private:
    // wrapped IMediumFormat properties
    virtual HRESULT getId(com::Utf8Str &aId) = 0;
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getCapabilities(std::vector<MediumFormatCapabilities_T> &aCapabilities) = 0;

    // wrapped IMediumFormat methods
    virtual HRESULT describeFileExtensions(std::vector<com::Utf8Str> &aExtensions,
                                           std::vector<DeviceType_T> &aTypes) = 0;
    virtual HRESULT describeProperties(std::vector<com::Utf8Str> &aNames,
                                       std::vector<com::Utf8Str> &aDescriptions,
                                       std::vector<DataType_T> &aTypes,
                                       std::vector<ULONG> &aFlags,
                                       std::vector<com::Utf8Str> &aDefaults) = 0;
};

#endif // !MediumFormatWrap_H_

// ##### ENDFILE "MediumFormatWrap.h"

// ##### BEGINFILE "MediumFormatWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IMediumFormat.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_MEDIUMFORMAT

#include "MediumFormatWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(MediumFormatWrap)

//
// IMediumFormat properties
//

STDMETHODIMP MediumFormatWrap::COMGETTER(Id)(BSTR *aId)
{
    LogRelFlow(("{%p} %s: enter aId=%p\n", this, "MediumFormat::getId", aId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getId(BSTROutConverter(aId).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aId=%ls hrc=%Rhrc\n", this, "MediumFormat::getId", *aId, hrc));
    return hrc;
}

STDMETHODIMP MediumFormatWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "MediumFormat::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "MediumFormat::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP MediumFormatWrap::COMGETTER(Capabilities)(ComSafeArrayOut(MediumFormatCapabilities_T, aCapabilities))
{
    LogRelFlow(("{%p} %s: enter aCapabilities=%p\n", this, "MediumFormat::getCapabilities", aCapabilities));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCapabilities);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getCapabilities(ArrayOutConverter<MediumFormatCapabilities_T>(ComSafeArrayOutArg(aCapabilities)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aCapabilities=%zu hrc=%Rhrc\n", this, "MediumFormat::getCapabilities", ComSafeArraySize(*aCapabilities), hrc));
    return hrc;
}

//
// IMediumFormat methods
//

STDMETHODIMP MediumFormatWrap::DescribeFileExtensions(ComSafeArrayOut(BSTR, aExtensions),
                                                      ComSafeArrayOut(DeviceType_T, aTypes))
{
    LogRelFlow(("{%p} %s:enter aExtensions=%p aTypes=%p\n", this, "MediumFormat::describeFileExtensions", aExtensions, aTypes));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aExtensions);
        CheckComArgOutPointerValidThrow(aTypes);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = describeFileExtensions(ArrayBSTROutConverter(ComSafeArrayOutArg(aExtensions)).array(),
                                     ArrayOutConverter<DeviceType_T>(ComSafeArrayOutArg(aTypes)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aExtensions=%zu *aTypes=%zu hrc=%Rhrc\n", this, "MediumFormat::describeFileExtensions", ComSafeArraySize(*aExtensions), ComSafeArraySize(*aTypes), hrc));
    return hrc;
}

STDMETHODIMP MediumFormatWrap::DescribeProperties(ComSafeArrayOut(BSTR, aNames),
                                                  ComSafeArrayOut(BSTR, aDescriptions),
                                                  ComSafeArrayOut(DataType_T, aTypes),
                                                  ComSafeArrayOut(ULONG, aFlags),
                                                  ComSafeArrayOut(BSTR, aDefaults))
{
    LogRelFlow(("{%p} %s:enter aNames=%p aDescriptions=%p aTypes=%p aFlags=%p aDefaults=%p\n", this, "MediumFormat::describeProperties", aNames, aDescriptions, aTypes, aFlags, aDefaults));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNames);
        CheckComArgOutPointerValidThrow(aDescriptions);
        CheckComArgOutPointerValidThrow(aTypes);
        CheckComArgOutPointerValidThrow(aFlags);
        CheckComArgOutPointerValidThrow(aDefaults);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = describeProperties(ArrayBSTROutConverter(ComSafeArrayOutArg(aNames)).array(),
                                 ArrayBSTROutConverter(ComSafeArrayOutArg(aDescriptions)).array(),
                                 ArrayOutConverter<DataType_T>(ComSafeArrayOutArg(aTypes)).array(),
                                 ArrayOutConverter<ULONG>(ComSafeArrayOutArg(aFlags)).array(),
                                 ArrayBSTROutConverter(ComSafeArrayOutArg(aDefaults)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNames=%zu *aDescriptions=%zu *aTypes=%zu *aFlags=%zu *aDefaults=%zu hrc=%Rhrc\n", this, "MediumFormat::describeProperties", ComSafeArraySize(*aNames), ComSafeArraySize(*aDescriptions), ComSafeArraySize(*aTypes), ComSafeArraySize(*aFlags), ComSafeArraySize(*aDefaults), hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(MediumFormatWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(MediumFormatWrap, IMediumFormat)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "MediumFormatWrap.cpp"

// ##### BEGINFILE "TokenWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IToken.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef TokenWrap_H_
#define TokenWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE TokenWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IToken)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(TokenWrap, IToken)
    DECLARE_NOT_AGGREGATABLE(TokenWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(TokenWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IToken)
        COM_INTERFACE_ENTRY2(IDispatch, IToken)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(TokenWrap)

    // public IToken properties

    // public IToken methods
    STDMETHOD(Abandon)();
    STDMETHOD(Dummy)();

private:
    // wrapped IToken properties

    // wrapped IToken methods
    virtual HRESULT abandon(AutoCaller &aAutoCaller) = 0;
    virtual HRESULT dummy() = 0;
};

#endif // !TokenWrap_H_

// ##### ENDFILE "TokenWrap.h"

// ##### BEGINFILE "TokenWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IToken.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_TOKEN

#include "TokenWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(TokenWrap)

//
// IToken properties
//

//
// IToken methods
//

STDMETHODIMP TokenWrap::Abandon()
{
    LogRelFlow(("{%p} %s:enter\n", this, "Token::abandon"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = abandon(autoCaller);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Token::abandon", hrc));
    return hrc;
}

STDMETHODIMP TokenWrap::Dummy()
{
    LogRelFlow(("{%p} %s:enter\n", this, "Token::dummy"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = dummy();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Token::dummy", hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(TokenWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(TokenWrap, IToken)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "TokenWrap.cpp"

// ##### BEGINFILE "KeyboardWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IKeyboard.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef KeyboardWrap_H_
#define KeyboardWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE KeyboardWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IKeyboard)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(KeyboardWrap, IKeyboard)
    DECLARE_NOT_AGGREGATABLE(KeyboardWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(KeyboardWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IKeyboard)
        COM_INTERFACE_ENTRY2(IDispatch, IKeyboard)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(KeyboardWrap)

    // public IKeyboard properties
    STDMETHOD(COMGETTER(EventSource))(IEventSource **aEventSource);

    // public IKeyboard methods
    STDMETHOD(PutScancode)(LONG aScancode);
    STDMETHOD(PutScancodes)(ComSafeArrayIn(LONG, aScancodes),
                            ULONG *aCodesStored);
    STDMETHOD(PutCAD)();

private:
    // wrapped IKeyboard properties
    virtual HRESULT getEventSource(ComPtr<IEventSource> &aEventSource) = 0;

    // wrapped IKeyboard methods
    virtual HRESULT putScancode(LONG aScancode) = 0;
    virtual HRESULT putScancodes(const std::vector<LONG> &aScancodes,
                                 ULONG *aCodesStored) = 0;
    virtual HRESULT putCAD() = 0;
};

#endif // !KeyboardWrap_H_

// ##### ENDFILE "KeyboardWrap.h"

// ##### BEGINFILE "KeyboardWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IKeyboard.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_KEYBOARD

#include "KeyboardWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(KeyboardWrap)

//
// IKeyboard properties
//

STDMETHODIMP KeyboardWrap::COMGETTER(EventSource)(IEventSource **aEventSource)
{
    LogRelFlow(("{%p} %s: enter aEventSource=%p\n", this, "Keyboard::getEventSource", aEventSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEventSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEventSource(ComTypeOutConverter<IEventSource>(aEventSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEventSource=%p hrc=%Rhrc\n", this, "Keyboard::getEventSource", *aEventSource, hrc));
    return hrc;
}

//
// IKeyboard methods
//

STDMETHODIMP KeyboardWrap::PutScancode(LONG aScancode)
{
    LogRelFlow(("{%p} %s:enter aScancode=%RI32\n", this, "Keyboard::putScancode", aScancode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = putScancode(aScancode);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Keyboard::putScancode", hrc));
    return hrc;
}

STDMETHODIMP KeyboardWrap::PutScancodes(ComSafeArrayIn(LONG, aScancodes),
                                        ULONG *aCodesStored)
{
    LogRelFlow(("{%p} %s:enter aScancodes=%zu aCodesStored=%p\n", this, "Keyboard::putScancodes", aScancodes, aCodesStored));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCodesStored);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = putScancodes(ArrayInConverter<LONG>(ComSafeArrayInArg(aScancodes)).array(),
                           aCodesStored);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aCodesStored=%RU32 hrc=%Rhrc\n", this, "Keyboard::putScancodes", *aCodesStored, hrc));
    return hrc;
}

STDMETHODIMP KeyboardWrap::PutCAD()
{
    LogRelFlow(("{%p} %s:enter\n", this, "Keyboard::putCAD"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = putCAD();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Keyboard::putCAD", hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(KeyboardWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(KeyboardWrap, IKeyboard)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "KeyboardWrap.cpp"

// ##### BEGINFILE "MouseWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IMouse.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef MouseWrap_H_
#define MouseWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE MouseWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IMouse)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(MouseWrap, IMouse)
    DECLARE_NOT_AGGREGATABLE(MouseWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(MouseWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IMouse)
        COM_INTERFACE_ENTRY2(IDispatch, IMouse)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(MouseWrap)

    // public IMouse properties
    STDMETHOD(COMGETTER(AbsoluteSupported))(BOOL *aAbsoluteSupported);
    STDMETHOD(COMGETTER(RelativeSupported))(BOOL *aRelativeSupported);
    STDMETHOD(COMGETTER(MultiTouchSupported))(BOOL *aMultiTouchSupported);
    STDMETHOD(COMGETTER(NeedsHostCursor))(BOOL *aNeedsHostCursor);
    STDMETHOD(COMGETTER(EventSource))(IEventSource **aEventSource);

    // public IMouse methods
    STDMETHOD(PutMouseEvent)(LONG aDx,
                             LONG aDy,
                             LONG aDz,
                             LONG aDw,
                             LONG aButtonState);
    STDMETHOD(PutMouseEventAbsolute)(LONG aX,
                                     LONG aY,
                                     LONG aDz,
                                     LONG aDw,
                                     LONG aButtonState);
    STDMETHOD(PutEventMultiTouch)(LONG aCount,
                                  ComSafeArrayIn(LONG64, aContacts),
                                  ULONG aScanTime);
    STDMETHOD(PutEventMultiTouchString)(LONG aCount,
                                        IN_BSTR aContacts,
                                        ULONG aScanTime);

private:
    // wrapped IMouse properties
    virtual HRESULT getAbsoluteSupported(BOOL *aAbsoluteSupported) = 0;
    virtual HRESULT getRelativeSupported(BOOL *aRelativeSupported) = 0;
    virtual HRESULT getMultiTouchSupported(BOOL *aMultiTouchSupported) = 0;
    virtual HRESULT getNeedsHostCursor(BOOL *aNeedsHostCursor) = 0;
    virtual HRESULT getEventSource(ComPtr<IEventSource> &aEventSource) = 0;

    // wrapped IMouse methods
    virtual HRESULT putMouseEvent(LONG aDx,
                                  LONG aDy,
                                  LONG aDz,
                                  LONG aDw,
                                  LONG aButtonState) = 0;
    virtual HRESULT putMouseEventAbsolute(LONG aX,
                                          LONG aY,
                                          LONG aDz,
                                          LONG aDw,
                                          LONG aButtonState) = 0;
    virtual HRESULT putEventMultiTouch(LONG aCount,
                                       const std::vector<LONG64> &aContacts,
                                       ULONG aScanTime) = 0;
    virtual HRESULT putEventMultiTouchString(LONG aCount,
                                             const com::Utf8Str &aContacts,
                                             ULONG aScanTime) = 0;
};

#endif // !MouseWrap_H_

// ##### ENDFILE "MouseWrap.h"

// ##### BEGINFILE "MouseWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IMouse.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_MOUSE

#include "MouseWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(MouseWrap)

//
// IMouse properties
//

STDMETHODIMP MouseWrap::COMGETTER(AbsoluteSupported)(BOOL *aAbsoluteSupported)
{
    LogRelFlow(("{%p} %s: enter aAbsoluteSupported=%p\n", this, "Mouse::getAbsoluteSupported", aAbsoluteSupported));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAbsoluteSupported);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAbsoluteSupported(aAbsoluteSupported);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAbsoluteSupported=%RTbool hrc=%Rhrc\n", this, "Mouse::getAbsoluteSupported", *aAbsoluteSupported, hrc));
    return hrc;
}

STDMETHODIMP MouseWrap::COMGETTER(RelativeSupported)(BOOL *aRelativeSupported)
{
    LogRelFlow(("{%p} %s: enter aRelativeSupported=%p\n", this, "Mouse::getRelativeSupported", aRelativeSupported));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRelativeSupported);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRelativeSupported(aRelativeSupported);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRelativeSupported=%RTbool hrc=%Rhrc\n", this, "Mouse::getRelativeSupported", *aRelativeSupported, hrc));
    return hrc;
}

STDMETHODIMP MouseWrap::COMGETTER(MultiTouchSupported)(BOOL *aMultiTouchSupported)
{
    LogRelFlow(("{%p} %s: enter aMultiTouchSupported=%p\n", this, "Mouse::getMultiTouchSupported", aMultiTouchSupported));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMultiTouchSupported);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMultiTouchSupported(aMultiTouchSupported);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMultiTouchSupported=%RTbool hrc=%Rhrc\n", this, "Mouse::getMultiTouchSupported", *aMultiTouchSupported, hrc));
    return hrc;
}

STDMETHODIMP MouseWrap::COMGETTER(NeedsHostCursor)(BOOL *aNeedsHostCursor)
{
    LogRelFlow(("{%p} %s: enter aNeedsHostCursor=%p\n", this, "Mouse::getNeedsHostCursor", aNeedsHostCursor));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNeedsHostCursor);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNeedsHostCursor(aNeedsHostCursor);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNeedsHostCursor=%RTbool hrc=%Rhrc\n", this, "Mouse::getNeedsHostCursor", *aNeedsHostCursor, hrc));
    return hrc;
}

STDMETHODIMP MouseWrap::COMGETTER(EventSource)(IEventSource **aEventSource)
{
    LogRelFlow(("{%p} %s: enter aEventSource=%p\n", this, "Mouse::getEventSource", aEventSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEventSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEventSource(ComTypeOutConverter<IEventSource>(aEventSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEventSource=%p hrc=%Rhrc\n", this, "Mouse::getEventSource", *aEventSource, hrc));
    return hrc;
}

//
// IMouse methods
//

STDMETHODIMP MouseWrap::PutMouseEvent(LONG aDx,
                                      LONG aDy,
                                      LONG aDz,
                                      LONG aDw,
                                      LONG aButtonState)
{
    LogRelFlow(("{%p} %s:enter aDx=%RI32 aDy=%RI32 aDz=%RI32 aDw=%RI32 aButtonState=%RI32\n", this, "Mouse::putMouseEvent", aDx, aDy, aDz, aDw, aButtonState));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = putMouseEvent(aDx,
                            aDy,
                            aDz,
                            aDw,
                            aButtonState);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Mouse::putMouseEvent", hrc));
    return hrc;
}

STDMETHODIMP MouseWrap::PutMouseEventAbsolute(LONG aX,
                                              LONG aY,
                                              LONG aDz,
                                              LONG aDw,
                                              LONG aButtonState)
{
    LogRelFlow(("{%p} %s:enter aX=%RI32 aY=%RI32 aDz=%RI32 aDw=%RI32 aButtonState=%RI32\n", this, "Mouse::putMouseEventAbsolute", aX, aY, aDz, aDw, aButtonState));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = putMouseEventAbsolute(aX,
                                    aY,
                                    aDz,
                                    aDw,
                                    aButtonState);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Mouse::putMouseEventAbsolute", hrc));
    return hrc;
}

STDMETHODIMP MouseWrap::PutEventMultiTouch(LONG aCount,
                                           ComSafeArrayIn(LONG64, aContacts),
                                           ULONG aScanTime)
{
    LogRelFlow(("{%p} %s:enter aCount=%RI32 aContacts=%zu aScanTime=%RU32\n", this, "Mouse::putEventMultiTouch", aCount, aContacts, aScanTime));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = putEventMultiTouch(aCount,
                                 ArrayInConverter<LONG64>(ComSafeArrayInArg(aContacts)).array(),
                                 aScanTime);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Mouse::putEventMultiTouch", hrc));
    return hrc;
}

STDMETHODIMP MouseWrap::PutEventMultiTouchString(LONG aCount,
                                                 IN_BSTR aContacts,
                                                 ULONG aScanTime)
{
    LogRelFlow(("{%p} %s:enter aCount=%RI32 aContacts=%ls aScanTime=%RU32\n", this, "Mouse::putEventMultiTouchString", aCount, aContacts, aScanTime));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = putEventMultiTouchString(aCount,
                                       BSTRInConverter(aContacts).str(),
                                       aScanTime);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Mouse::putEventMultiTouchString", hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(MouseWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(MouseWrap, IMouse)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "MouseWrap.cpp"

// ##### BEGINFILE "FramebufferWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IFramebuffer.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef FramebufferWrap_H_
#define FramebufferWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE FramebufferWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IFramebuffer)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(FramebufferWrap, IFramebuffer)
    DECLARE_NOT_AGGREGATABLE(FramebufferWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(FramebufferWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IFramebuffer)
        COM_INTERFACE_ENTRY2(IDispatch, IFramebuffer)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(FramebufferWrap)

    // public IFramebuffer properties
    STDMETHOD(COMGETTER(Address))(BYTE *aAddress);
    STDMETHOD(COMGETTER(Width))(ULONG *aWidth);
    STDMETHOD(COMGETTER(Height))(ULONG *aHeight);
    STDMETHOD(COMGETTER(BitsPerPixel))(ULONG *aBitsPerPixel);
    STDMETHOD(COMGETTER(BytesPerLine))(ULONG *aBytesPerLine);
    STDMETHOD(COMGETTER(PixelFormat))(ULONG *aPixelFormat);
    STDMETHOD(COMGETTER(UsesGuestVRAM))(BOOL *aUsesGuestVRAM);
    STDMETHOD(COMGETTER(HeightReduction))(ULONG *aHeightReduction);
    STDMETHOD(COMGETTER(Overlay))(IFramebufferOverlay **aOverlay);
    STDMETHOD(COMGETTER(WinId))(LONG64 *aWinId);

    // public IFramebuffer methods
    STDMETHOD(Lock)();
    STDMETHOD(Unlock)();
    STDMETHOD(NotifyUpdate)(ULONG aX,
                            ULONG aY,
                            ULONG aWidth,
                            ULONG aHeight);
    STDMETHOD(RequestResize)(ULONG aScreenId,
                             ULONG aPixelFormat,
                             BYTE aVRAM,
                             ULONG aBitsPerPixel,
                             ULONG aBytesPerLine,
                             ULONG aWidth,
                             ULONG aHeight,
                             BOOL *aFinished);
    STDMETHOD(VideoModeSupported)(ULONG aWidth,
                                  ULONG aHeight,
                                  ULONG aBpp,
                                  BOOL *aSupported);
    STDMETHOD(GetVisibleRegion)(BYTE aRectangles,
                                ULONG aCount,
                                ULONG *aCountCopied);
    STDMETHOD(SetVisibleRegion)(BYTE aRectangles,
                                ULONG aCount);
    STDMETHOD(ProcessVHWACommand)(BYTE aCommand);
    STDMETHOD(Notify3DEvent)(ULONG aType,
                             BYTE aData);

private:
    // wrapped IFramebuffer properties
    virtual HRESULT getAddress(BYTE *aAddress) = 0;
    virtual HRESULT getWidth(ULONG *aWidth) = 0;
    virtual HRESULT getHeight(ULONG *aHeight) = 0;
    virtual HRESULT getBitsPerPixel(ULONG *aBitsPerPixel) = 0;
    virtual HRESULT getBytesPerLine(ULONG *aBytesPerLine) = 0;
    virtual HRESULT getPixelFormat(ULONG *aPixelFormat) = 0;
    virtual HRESULT getUsesGuestVRAM(BOOL *aUsesGuestVRAM) = 0;
    virtual HRESULT getHeightReduction(ULONG *aHeightReduction) = 0;
    virtual HRESULT getOverlay(ComPtr<IFramebufferOverlay> &aOverlay) = 0;
    virtual HRESULT getWinId(LONG64 *aWinId) = 0;

    // wrapped IFramebuffer methods
    virtual HRESULT lock() = 0;
    virtual HRESULT unlock() = 0;
    virtual HRESULT notifyUpdate(ULONG aX,
                                 ULONG aY,
                                 ULONG aWidth,
                                 ULONG aHeight) = 0;
    virtual HRESULT requestResize(ULONG aScreenId,
                                  ULONG aPixelFormat,
                                  BYTE aVRAM,
                                  ULONG aBitsPerPixel,
                                  ULONG aBytesPerLine,
                                  ULONG aWidth,
                                  ULONG aHeight,
                                  BOOL *aFinished) = 0;
    virtual HRESULT videoModeSupported(ULONG aWidth,
                                       ULONG aHeight,
                                       ULONG aBpp,
                                       BOOL *aSupported) = 0;
    virtual HRESULT getVisibleRegion(BYTE aRectangles,
                                     ULONG aCount,
                                     ULONG *aCountCopied) = 0;
    virtual HRESULT setVisibleRegion(BYTE aRectangles,
                                     ULONG aCount) = 0;
    virtual HRESULT processVHWACommand(BYTE aCommand) = 0;
    virtual HRESULT notify3DEvent(ULONG aType,
                                  BYTE aData) = 0;
};

#endif // !FramebufferWrap_H_

// ##### ENDFILE "FramebufferWrap.h"

// ##### BEGINFILE "FramebufferWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IFramebuffer.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_FRAMEBUFFER

#include "FramebufferWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(FramebufferWrap)

//
// IFramebuffer properties
//

STDMETHODIMP FramebufferWrap::COMGETTER(Address)(BYTE *aAddress)
{
    LogRelFlow(("{%p} %s: enter aAddress=%p\n", this, "Framebuffer::getAddress", aAddress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAddress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAddress(aAddress);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAddress=%RU8 hrc=%Rhrc\n", this, "Framebuffer::getAddress", *aAddress, hrc));
    return hrc;
}

STDMETHODIMP FramebufferWrap::COMGETTER(Width)(ULONG *aWidth)
{
    LogRelFlow(("{%p} %s: enter aWidth=%p\n", this, "Framebuffer::getWidth", aWidth));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWidth);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWidth(aWidth);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWidth=%RU32 hrc=%Rhrc\n", this, "Framebuffer::getWidth", *aWidth, hrc));
    return hrc;
}

STDMETHODIMP FramebufferWrap::COMGETTER(Height)(ULONG *aHeight)
{
    LogRelFlow(("{%p} %s: enter aHeight=%p\n", this, "Framebuffer::getHeight", aHeight));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHeight);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHeight(aHeight);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHeight=%RU32 hrc=%Rhrc\n", this, "Framebuffer::getHeight", *aHeight, hrc));
    return hrc;
}

STDMETHODIMP FramebufferWrap::COMGETTER(BitsPerPixel)(ULONG *aBitsPerPixel)
{
    LogRelFlow(("{%p} %s: enter aBitsPerPixel=%p\n", this, "Framebuffer::getBitsPerPixel", aBitsPerPixel));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBitsPerPixel);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBitsPerPixel(aBitsPerPixel);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBitsPerPixel=%RU32 hrc=%Rhrc\n", this, "Framebuffer::getBitsPerPixel", *aBitsPerPixel, hrc));
    return hrc;
}

STDMETHODIMP FramebufferWrap::COMGETTER(BytesPerLine)(ULONG *aBytesPerLine)
{
    LogRelFlow(("{%p} %s: enter aBytesPerLine=%p\n", this, "Framebuffer::getBytesPerLine", aBytesPerLine));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBytesPerLine);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBytesPerLine(aBytesPerLine);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBytesPerLine=%RU32 hrc=%Rhrc\n", this, "Framebuffer::getBytesPerLine", *aBytesPerLine, hrc));
    return hrc;
}

STDMETHODIMP FramebufferWrap::COMGETTER(PixelFormat)(ULONG *aPixelFormat)
{
    LogRelFlow(("{%p} %s: enter aPixelFormat=%p\n", this, "Framebuffer::getPixelFormat", aPixelFormat));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPixelFormat);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPixelFormat(aPixelFormat);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPixelFormat=%RU32 hrc=%Rhrc\n", this, "Framebuffer::getPixelFormat", *aPixelFormat, hrc));
    return hrc;
}

STDMETHODIMP FramebufferWrap::COMGETTER(UsesGuestVRAM)(BOOL *aUsesGuestVRAM)
{
    LogRelFlow(("{%p} %s: enter aUsesGuestVRAM=%p\n", this, "Framebuffer::getUsesGuestVRAM", aUsesGuestVRAM));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUsesGuestVRAM);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUsesGuestVRAM(aUsesGuestVRAM);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUsesGuestVRAM=%RTbool hrc=%Rhrc\n", this, "Framebuffer::getUsesGuestVRAM", *aUsesGuestVRAM, hrc));
    return hrc;
}

STDMETHODIMP FramebufferWrap::COMGETTER(HeightReduction)(ULONG *aHeightReduction)
{
    LogRelFlow(("{%p} %s: enter aHeightReduction=%p\n", this, "Framebuffer::getHeightReduction", aHeightReduction));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHeightReduction);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHeightReduction(aHeightReduction);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHeightReduction=%RU32 hrc=%Rhrc\n", this, "Framebuffer::getHeightReduction", *aHeightReduction, hrc));
    return hrc;
}

STDMETHODIMP FramebufferWrap::COMGETTER(Overlay)(IFramebufferOverlay **aOverlay)
{
    LogRelFlow(("{%p} %s: enter aOverlay=%p\n", this, "Framebuffer::getOverlay", aOverlay));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOverlay);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOverlay(ComTypeOutConverter<IFramebufferOverlay>(aOverlay).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOverlay=%p hrc=%Rhrc\n", this, "Framebuffer::getOverlay", *aOverlay, hrc));
    return hrc;
}

STDMETHODIMP FramebufferWrap::COMGETTER(WinId)(LONG64 *aWinId)
{
    LogRelFlow(("{%p} %s: enter aWinId=%p\n", this, "Framebuffer::getWinId", aWinId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWinId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWinId(aWinId);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWinId=%RI64 hrc=%Rhrc\n", this, "Framebuffer::getWinId", *aWinId, hrc));
    return hrc;
}

//
// IFramebuffer methods
//

STDMETHODIMP FramebufferWrap::Lock()
{
    LogRelFlow(("{%p} %s:enter\n", this, "Framebuffer::lock"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = lock();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Framebuffer::lock", hrc));
    return hrc;
}

STDMETHODIMP FramebufferWrap::Unlock()
{
    LogRelFlow(("{%p} %s:enter\n", this, "Framebuffer::unlock"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = unlock();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Framebuffer::unlock", hrc));
    return hrc;
}

STDMETHODIMP FramebufferWrap::NotifyUpdate(ULONG aX,
                                           ULONG aY,
                                           ULONG aWidth,
                                           ULONG aHeight)
{
    LogRelFlow(("{%p} %s:enter aX=%RU32 aY=%RU32 aWidth=%RU32 aHeight=%RU32\n", this, "Framebuffer::notifyUpdate", aX, aY, aWidth, aHeight));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = notifyUpdate(aX,
                           aY,
                           aWidth,
                           aHeight);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Framebuffer::notifyUpdate", hrc));
    return hrc;
}

STDMETHODIMP FramebufferWrap::RequestResize(ULONG aScreenId,
                                            ULONG aPixelFormat,
                                            BYTE aVRAM,
                                            ULONG aBitsPerPixel,
                                            ULONG aBytesPerLine,
                                            ULONG aWidth,
                                            ULONG aHeight,
                                            BOOL *aFinished)
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32 aPixelFormat=%RU32 aVRAM=%RU8 aBitsPerPixel=%RU32 aBytesPerLine=%RU32 aWidth=%RU32 aHeight=%RU32 aFinished=%p\n", this, "Framebuffer::requestResize", aScreenId, aPixelFormat, aVRAM, aBitsPerPixel, aBytesPerLine, aWidth, aHeight, aFinished));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFinished);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = requestResize(aScreenId,
                            aPixelFormat,
                            aVRAM,
                            aBitsPerPixel,
                            aBytesPerLine,
                            aWidth,
                            aHeight,
                            aFinished);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aFinished=%RTbool hrc=%Rhrc\n", this, "Framebuffer::requestResize", *aFinished, hrc));
    return hrc;
}

STDMETHODIMP FramebufferWrap::VideoModeSupported(ULONG aWidth,
                                                 ULONG aHeight,
                                                 ULONG aBpp,
                                                 BOOL *aSupported)
{
    LogRelFlow(("{%p} %s:enter aWidth=%RU32 aHeight=%RU32 aBpp=%RU32 aSupported=%p\n", this, "Framebuffer::videoModeSupported", aWidth, aHeight, aBpp, aSupported));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSupported);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = videoModeSupported(aWidth,
                                 aHeight,
                                 aBpp,
                                 aSupported);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aSupported=%RTbool hrc=%Rhrc\n", this, "Framebuffer::videoModeSupported", *aSupported, hrc));
    return hrc;
}

STDMETHODIMP FramebufferWrap::GetVisibleRegion(BYTE aRectangles,
                                               ULONG aCount,
                                               ULONG *aCountCopied)
{
    LogRelFlow(("{%p} %s:enter aRectangles=%RU8 aCount=%RU32 aCountCopied=%p\n", this, "Framebuffer::getVisibleRegion", aRectangles, aCount, aCountCopied));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCountCopied);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVisibleRegion(aRectangles,
                               aCount,
                               aCountCopied);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aCountCopied=%RU32 hrc=%Rhrc\n", this, "Framebuffer::getVisibleRegion", *aCountCopied, hrc));
    return hrc;
}

STDMETHODIMP FramebufferWrap::SetVisibleRegion(BYTE aRectangles,
                                               ULONG aCount)
{
    LogRelFlow(("{%p} %s:enter aRectangles=%RU8 aCount=%RU32\n", this, "Framebuffer::setVisibleRegion", aRectangles, aCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setVisibleRegion(aRectangles,
                               aCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Framebuffer::setVisibleRegion", hrc));
    return hrc;
}

STDMETHODIMP FramebufferWrap::ProcessVHWACommand(BYTE aCommand)
{
    LogRelFlow(("{%p} %s:enter aCommand=%RU8\n", this, "Framebuffer::processVHWACommand", aCommand));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = processVHWACommand(aCommand);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Framebuffer::processVHWACommand", hrc));
    return hrc;
}

STDMETHODIMP FramebufferWrap::Notify3DEvent(ULONG aType,
                                            BYTE aData)
{
    LogRelFlow(("{%p} %s:enter aType=%RU32 aData=%RU8\n", this, "Framebuffer::notify3DEvent", aType, aData));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = notify3DEvent(aType,
                            aData);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Framebuffer::notify3DEvent", hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(FramebufferWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(FramebufferWrap, IFramebuffer)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "FramebufferWrap.cpp"

// ##### BEGINFILE "FramebufferOverlayWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IFramebufferOverlay.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef FramebufferOverlayWrap_H_
#define FramebufferOverlayWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE FramebufferOverlayWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IFramebufferOverlay)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(FramebufferOverlayWrap, IFramebufferOverlay)
    DECLARE_NOT_AGGREGATABLE(FramebufferOverlayWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(FramebufferOverlayWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IFramebufferOverlay)
        COM_INTERFACE_ENTRY(IFramebuffer)
        COM_INTERFACE_ENTRY2(IDispatch, IFramebufferOverlay)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(FramebufferOverlayWrap)

    // public IFramebuffer properties
    STDMETHOD(COMGETTER(Address))(BYTE *aAddress);
    STDMETHOD(COMGETTER(Width))(ULONG *aWidth);
    STDMETHOD(COMGETTER(Height))(ULONG *aHeight);
    STDMETHOD(COMGETTER(BitsPerPixel))(ULONG *aBitsPerPixel);
    STDMETHOD(COMGETTER(BytesPerLine))(ULONG *aBytesPerLine);
    STDMETHOD(COMGETTER(PixelFormat))(ULONG *aPixelFormat);
    STDMETHOD(COMGETTER(UsesGuestVRAM))(BOOL *aUsesGuestVRAM);
    STDMETHOD(COMGETTER(HeightReduction))(ULONG *aHeightReduction);
    STDMETHOD(COMGETTER(Overlay))(IFramebufferOverlay **aOverlay);
    STDMETHOD(COMGETTER(WinId))(LONG64 *aWinId);

    // public IFramebufferOverlay properties
    STDMETHOD(COMGETTER(X))(ULONG *aX);
    STDMETHOD(COMGETTER(Y))(ULONG *aY);
    STDMETHOD(COMGETTER(Visible))(BOOL *aVisible);
    STDMETHOD(COMSETTER(Visible))(BOOL aVisible);
    STDMETHOD(COMGETTER(Alpha))(ULONG *aAlpha);
    STDMETHOD(COMSETTER(Alpha))(ULONG aAlpha);

    // public IFramebuffer methods
    STDMETHOD(Lock)();
    STDMETHOD(Unlock)();
    STDMETHOD(NotifyUpdate)(ULONG aX,
                            ULONG aY,
                            ULONG aWidth,
                            ULONG aHeight);
    STDMETHOD(RequestResize)(ULONG aScreenId,
                             ULONG aPixelFormat,
                             BYTE aVRAM,
                             ULONG aBitsPerPixel,
                             ULONG aBytesPerLine,
                             ULONG aWidth,
                             ULONG aHeight,
                             BOOL *aFinished);
    STDMETHOD(VideoModeSupported)(ULONG aWidth,
                                  ULONG aHeight,
                                  ULONG aBpp,
                                  BOOL *aSupported);
    STDMETHOD(GetVisibleRegion)(BYTE aRectangles,
                                ULONG aCount,
                                ULONG *aCountCopied);
    STDMETHOD(SetVisibleRegion)(BYTE aRectangles,
                                ULONG aCount);
    STDMETHOD(ProcessVHWACommand)(BYTE aCommand);
    STDMETHOD(Notify3DEvent)(ULONG aType,
                             BYTE aData);

    // public IFramebufferOverlay methods
    STDMETHOD(Move)(ULONG aX,
                    ULONG aY);

private:
    // wrapped IFramebuffer properties
    virtual HRESULT getAddress(BYTE *aAddress) = 0;
    virtual HRESULT getWidth(ULONG *aWidth) = 0;
    virtual HRESULT getHeight(ULONG *aHeight) = 0;
    virtual HRESULT getBitsPerPixel(ULONG *aBitsPerPixel) = 0;
    virtual HRESULT getBytesPerLine(ULONG *aBytesPerLine) = 0;
    virtual HRESULT getPixelFormat(ULONG *aPixelFormat) = 0;
    virtual HRESULT getUsesGuestVRAM(BOOL *aUsesGuestVRAM) = 0;
    virtual HRESULT getHeightReduction(ULONG *aHeightReduction) = 0;
    virtual HRESULT getOverlay(ComPtr<IFramebufferOverlay> &aOverlay) = 0;
    virtual HRESULT getWinId(LONG64 *aWinId) = 0;

    // wrapped IFramebufferOverlay properties
    virtual HRESULT getX(ULONG *aX) = 0;
    virtual HRESULT getY(ULONG *aY) = 0;
    virtual HRESULT getVisible(BOOL *aVisible) = 0;
    virtual HRESULT setVisible(BOOL aVisible) = 0;
    virtual HRESULT getAlpha(ULONG *aAlpha) = 0;
    virtual HRESULT setAlpha(ULONG aAlpha) = 0;

    // wrapped IFramebuffer methods
    virtual HRESULT lock() = 0;
    virtual HRESULT unlock() = 0;
    virtual HRESULT notifyUpdate(ULONG aX,
                                 ULONG aY,
                                 ULONG aWidth,
                                 ULONG aHeight) = 0;
    virtual HRESULT requestResize(ULONG aScreenId,
                                  ULONG aPixelFormat,
                                  BYTE aVRAM,
                                  ULONG aBitsPerPixel,
                                  ULONG aBytesPerLine,
                                  ULONG aWidth,
                                  ULONG aHeight,
                                  BOOL *aFinished) = 0;
    virtual HRESULT videoModeSupported(ULONG aWidth,
                                       ULONG aHeight,
                                       ULONG aBpp,
                                       BOOL *aSupported) = 0;
    virtual HRESULT getVisibleRegion(BYTE aRectangles,
                                     ULONG aCount,
                                     ULONG *aCountCopied) = 0;
    virtual HRESULT setVisibleRegion(BYTE aRectangles,
                                     ULONG aCount) = 0;
    virtual HRESULT processVHWACommand(BYTE aCommand) = 0;
    virtual HRESULT notify3DEvent(ULONG aType,
                                  BYTE aData) = 0;

    // wrapped IFramebufferOverlay methods
    virtual HRESULT move(ULONG aX,
                         ULONG aY) = 0;
};

#endif // !FramebufferOverlayWrap_H_

// ##### ENDFILE "FramebufferOverlayWrap.h"

// ##### BEGINFILE "FramebufferOverlayWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IFramebufferOverlay.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_FRAMEBUFFEROVERLAY

#include "FramebufferOverlayWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(FramebufferOverlayWrap)

//
// IFramebuffer properties
//

STDMETHODIMP FramebufferOverlayWrap::COMGETTER(Address)(BYTE *aAddress)
{
    LogRelFlow(("{%p} %s: enter aAddress=%p\n", this, "FramebufferOverlay::getAddress", aAddress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAddress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAddress(aAddress);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAddress=%RU8 hrc=%Rhrc\n", this, "FramebufferOverlay::getAddress", *aAddress, hrc));
    return hrc;
}

STDMETHODIMP FramebufferOverlayWrap::COMGETTER(Width)(ULONG *aWidth)
{
    LogRelFlow(("{%p} %s: enter aWidth=%p\n", this, "FramebufferOverlay::getWidth", aWidth));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWidth);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWidth(aWidth);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWidth=%RU32 hrc=%Rhrc\n", this, "FramebufferOverlay::getWidth", *aWidth, hrc));
    return hrc;
}

STDMETHODIMP FramebufferOverlayWrap::COMGETTER(Height)(ULONG *aHeight)
{
    LogRelFlow(("{%p} %s: enter aHeight=%p\n", this, "FramebufferOverlay::getHeight", aHeight));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHeight);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHeight(aHeight);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHeight=%RU32 hrc=%Rhrc\n", this, "FramebufferOverlay::getHeight", *aHeight, hrc));
    return hrc;
}

STDMETHODIMP FramebufferOverlayWrap::COMGETTER(BitsPerPixel)(ULONG *aBitsPerPixel)
{
    LogRelFlow(("{%p} %s: enter aBitsPerPixel=%p\n", this, "FramebufferOverlay::getBitsPerPixel", aBitsPerPixel));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBitsPerPixel);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBitsPerPixel(aBitsPerPixel);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBitsPerPixel=%RU32 hrc=%Rhrc\n", this, "FramebufferOverlay::getBitsPerPixel", *aBitsPerPixel, hrc));
    return hrc;
}

STDMETHODIMP FramebufferOverlayWrap::COMGETTER(BytesPerLine)(ULONG *aBytesPerLine)
{
    LogRelFlow(("{%p} %s: enter aBytesPerLine=%p\n", this, "FramebufferOverlay::getBytesPerLine", aBytesPerLine));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBytesPerLine);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBytesPerLine(aBytesPerLine);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBytesPerLine=%RU32 hrc=%Rhrc\n", this, "FramebufferOverlay::getBytesPerLine", *aBytesPerLine, hrc));
    return hrc;
}

STDMETHODIMP FramebufferOverlayWrap::COMGETTER(PixelFormat)(ULONG *aPixelFormat)
{
    LogRelFlow(("{%p} %s: enter aPixelFormat=%p\n", this, "FramebufferOverlay::getPixelFormat", aPixelFormat));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPixelFormat);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPixelFormat(aPixelFormat);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPixelFormat=%RU32 hrc=%Rhrc\n", this, "FramebufferOverlay::getPixelFormat", *aPixelFormat, hrc));
    return hrc;
}

STDMETHODIMP FramebufferOverlayWrap::COMGETTER(UsesGuestVRAM)(BOOL *aUsesGuestVRAM)
{
    LogRelFlow(("{%p} %s: enter aUsesGuestVRAM=%p\n", this, "FramebufferOverlay::getUsesGuestVRAM", aUsesGuestVRAM));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUsesGuestVRAM);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUsesGuestVRAM(aUsesGuestVRAM);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUsesGuestVRAM=%RTbool hrc=%Rhrc\n", this, "FramebufferOverlay::getUsesGuestVRAM", *aUsesGuestVRAM, hrc));
    return hrc;
}

STDMETHODIMP FramebufferOverlayWrap::COMGETTER(HeightReduction)(ULONG *aHeightReduction)
{
    LogRelFlow(("{%p} %s: enter aHeightReduction=%p\n", this, "FramebufferOverlay::getHeightReduction", aHeightReduction));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHeightReduction);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHeightReduction(aHeightReduction);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHeightReduction=%RU32 hrc=%Rhrc\n", this, "FramebufferOverlay::getHeightReduction", *aHeightReduction, hrc));
    return hrc;
}

STDMETHODIMP FramebufferOverlayWrap::COMGETTER(Overlay)(IFramebufferOverlay **aOverlay)
{
    LogRelFlow(("{%p} %s: enter aOverlay=%p\n", this, "FramebufferOverlay::getOverlay", aOverlay));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOverlay);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOverlay(ComTypeOutConverter<IFramebufferOverlay>(aOverlay).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOverlay=%p hrc=%Rhrc\n", this, "FramebufferOverlay::getOverlay", *aOverlay, hrc));
    return hrc;
}

STDMETHODIMP FramebufferOverlayWrap::COMGETTER(WinId)(LONG64 *aWinId)
{
    LogRelFlow(("{%p} %s: enter aWinId=%p\n", this, "FramebufferOverlay::getWinId", aWinId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWinId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWinId(aWinId);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWinId=%RI64 hrc=%Rhrc\n", this, "FramebufferOverlay::getWinId", *aWinId, hrc));
    return hrc;
}

//
// IFramebufferOverlay properties
//

STDMETHODIMP FramebufferOverlayWrap::COMGETTER(X)(ULONG *aX)
{
    LogRelFlow(("{%p} %s: enter aX=%p\n", this, "FramebufferOverlay::getX", aX));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aX);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getX(aX);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aX=%RU32 hrc=%Rhrc\n", this, "FramebufferOverlay::getX", *aX, hrc));
    return hrc;
}

STDMETHODIMP FramebufferOverlayWrap::COMGETTER(Y)(ULONG *aY)
{
    LogRelFlow(("{%p} %s: enter aY=%p\n", this, "FramebufferOverlay::getY", aY));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aY);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getY(aY);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aY=%RU32 hrc=%Rhrc\n", this, "FramebufferOverlay::getY", *aY, hrc));
    return hrc;
}

STDMETHODIMP FramebufferOverlayWrap::COMGETTER(Visible)(BOOL *aVisible)
{
    LogRelFlow(("{%p} %s: enter aVisible=%p\n", this, "FramebufferOverlay::getVisible", aVisible));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVisible);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVisible(aVisible);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVisible=%RTbool hrc=%Rhrc\n", this, "FramebufferOverlay::getVisible", *aVisible, hrc));
    return hrc;
}

STDMETHODIMP FramebufferOverlayWrap::COMSETTER(Visible)(BOOL aVisible)
{
    LogRelFlow(("{%p} %s: enter aVisible=%RTbool\n", this, "FramebufferOverlay::setVisible", aVisible));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setVisible(aVisible);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "FramebufferOverlay::setVisible", hrc));
    return hrc;
}

STDMETHODIMP FramebufferOverlayWrap::COMGETTER(Alpha)(ULONG *aAlpha)
{
    LogRelFlow(("{%p} %s: enter aAlpha=%p\n", this, "FramebufferOverlay::getAlpha", aAlpha));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAlpha);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAlpha(aAlpha);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAlpha=%RU32 hrc=%Rhrc\n", this, "FramebufferOverlay::getAlpha", *aAlpha, hrc));
    return hrc;
}

STDMETHODIMP FramebufferOverlayWrap::COMSETTER(Alpha)(ULONG aAlpha)
{
    LogRelFlow(("{%p} %s: enter aAlpha=%RU32\n", this, "FramebufferOverlay::setAlpha", aAlpha));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setAlpha(aAlpha);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "FramebufferOverlay::setAlpha", hrc));
    return hrc;
}

//
// IFramebuffer methods
//

STDMETHODIMP FramebufferOverlayWrap::Lock()
{
    LogRelFlow(("{%p} %s:enter\n", this, "FramebufferOverlay::lock"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = lock();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "FramebufferOverlay::lock", hrc));
    return hrc;
}

STDMETHODIMP FramebufferOverlayWrap::Unlock()
{
    LogRelFlow(("{%p} %s:enter\n", this, "FramebufferOverlay::unlock"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = unlock();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "FramebufferOverlay::unlock", hrc));
    return hrc;
}

STDMETHODIMP FramebufferOverlayWrap::NotifyUpdate(ULONG aX,
                                                  ULONG aY,
                                                  ULONG aWidth,
                                                  ULONG aHeight)
{
    LogRelFlow(("{%p} %s:enter aX=%RU32 aY=%RU32 aWidth=%RU32 aHeight=%RU32\n", this, "FramebufferOverlay::notifyUpdate", aX, aY, aWidth, aHeight));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = notifyUpdate(aX,
                           aY,
                           aWidth,
                           aHeight);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "FramebufferOverlay::notifyUpdate", hrc));
    return hrc;
}

STDMETHODIMP FramebufferOverlayWrap::RequestResize(ULONG aScreenId,
                                                   ULONG aPixelFormat,
                                                   BYTE aVRAM,
                                                   ULONG aBitsPerPixel,
                                                   ULONG aBytesPerLine,
                                                   ULONG aWidth,
                                                   ULONG aHeight,
                                                   BOOL *aFinished)
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32 aPixelFormat=%RU32 aVRAM=%RU8 aBitsPerPixel=%RU32 aBytesPerLine=%RU32 aWidth=%RU32 aHeight=%RU32 aFinished=%p\n", this, "FramebufferOverlay::requestResize", aScreenId, aPixelFormat, aVRAM, aBitsPerPixel, aBytesPerLine, aWidth, aHeight, aFinished));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFinished);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = requestResize(aScreenId,
                            aPixelFormat,
                            aVRAM,
                            aBitsPerPixel,
                            aBytesPerLine,
                            aWidth,
                            aHeight,
                            aFinished);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aFinished=%RTbool hrc=%Rhrc\n", this, "FramebufferOverlay::requestResize", *aFinished, hrc));
    return hrc;
}

STDMETHODIMP FramebufferOverlayWrap::VideoModeSupported(ULONG aWidth,
                                                        ULONG aHeight,
                                                        ULONG aBpp,
                                                        BOOL *aSupported)
{
    LogRelFlow(("{%p} %s:enter aWidth=%RU32 aHeight=%RU32 aBpp=%RU32 aSupported=%p\n", this, "FramebufferOverlay::videoModeSupported", aWidth, aHeight, aBpp, aSupported));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSupported);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = videoModeSupported(aWidth,
                                 aHeight,
                                 aBpp,
                                 aSupported);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aSupported=%RTbool hrc=%Rhrc\n", this, "FramebufferOverlay::videoModeSupported", *aSupported, hrc));
    return hrc;
}

STDMETHODIMP FramebufferOverlayWrap::GetVisibleRegion(BYTE aRectangles,
                                                      ULONG aCount,
                                                      ULONG *aCountCopied)
{
    LogRelFlow(("{%p} %s:enter aRectangles=%RU8 aCount=%RU32 aCountCopied=%p\n", this, "FramebufferOverlay::getVisibleRegion", aRectangles, aCount, aCountCopied));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCountCopied);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVisibleRegion(aRectangles,
                               aCount,
                               aCountCopied);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aCountCopied=%RU32 hrc=%Rhrc\n", this, "FramebufferOverlay::getVisibleRegion", *aCountCopied, hrc));
    return hrc;
}

STDMETHODIMP FramebufferOverlayWrap::SetVisibleRegion(BYTE aRectangles,
                                                      ULONG aCount)
{
    LogRelFlow(("{%p} %s:enter aRectangles=%RU8 aCount=%RU32\n", this, "FramebufferOverlay::setVisibleRegion", aRectangles, aCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setVisibleRegion(aRectangles,
                               aCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "FramebufferOverlay::setVisibleRegion", hrc));
    return hrc;
}

STDMETHODIMP FramebufferOverlayWrap::ProcessVHWACommand(BYTE aCommand)
{
    LogRelFlow(("{%p} %s:enter aCommand=%RU8\n", this, "FramebufferOverlay::processVHWACommand", aCommand));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = processVHWACommand(aCommand);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "FramebufferOverlay::processVHWACommand", hrc));
    return hrc;
}

STDMETHODIMP FramebufferOverlayWrap::Notify3DEvent(ULONG aType,
                                                   BYTE aData)
{
    LogRelFlow(("{%p} %s:enter aType=%RU32 aData=%RU8\n", this, "FramebufferOverlay::notify3DEvent", aType, aData));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = notify3DEvent(aType,
                            aData);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "FramebufferOverlay::notify3DEvent", hrc));
    return hrc;
}

//
// IFramebufferOverlay methods
//

STDMETHODIMP FramebufferOverlayWrap::Move(ULONG aX,
                                          ULONG aY)
{
    LogRelFlow(("{%p} %s:enter aX=%RU32 aY=%RU32\n", this, "FramebufferOverlay::move", aX, aY));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = move(aX,
                   aY);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "FramebufferOverlay::move", hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(FramebufferOverlayWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(FramebufferOverlayWrap, IFramebufferOverlay, IFramebuffer)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "FramebufferOverlayWrap.cpp"

// ##### BEGINFILE "DisplayWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IDisplay.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef DisplayWrap_H_
#define DisplayWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE DisplayWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IDisplay)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(DisplayWrap, IDisplay)
    DECLARE_NOT_AGGREGATABLE(DisplayWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(DisplayWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IDisplay)
        COM_INTERFACE_ENTRY2(IDispatch, IDisplay)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(DisplayWrap)

    // public IDisplay properties

    // public IDisplay methods
    STDMETHOD(GetScreenResolution)(ULONG aScreenId,
                                   ULONG *aWidth,
                                   ULONG *aHeight,
                                   ULONG *aBitsPerPixel,
                                   LONG *aXOrigin,
                                   LONG *aYOrigin);
    STDMETHOD(SetFramebuffer)(ULONG aScreenId,
                              IFramebuffer *aFramebuffer);
    STDMETHOD(GetFramebuffer)(ULONG aScreenId,
                              IFramebuffer **aFramebuffer,
                              LONG *aXOrigin,
                              LONG *aYOrigin);
    STDMETHOD(SetVideoModeHint)(ULONG aDisplay,
                                BOOL aEnabled,
                                BOOL aChangeOrigin,
                                LONG aOriginX,
                                LONG aOriginY,
                                ULONG aWidth,
                                ULONG aHeight,
                                ULONG aBitsPerPixel);
    STDMETHOD(SetSeamlessMode)(BOOL aEnabled);
    STDMETHOD(TakeScreenShot)(ULONG aScreenId,
                              BYTE aAddress,
                              ULONG aWidth,
                              ULONG aHeight);
    STDMETHOD(TakeScreenShotToArray)(ULONG aScreenId,
                                     ULONG aWidth,
                                     ULONG aHeight,
                                     ComSafeArrayOut(BYTE, aScreenData));
    STDMETHOD(TakeScreenShotPNGToArray)(ULONG aScreenId,
                                        ULONG aWidth,
                                        ULONG aHeight,
                                        ComSafeArrayOut(BYTE, aScreenData));
    STDMETHOD(DrawToScreen)(ULONG aScreenId,
                            BYTE aAddress,
                            ULONG aX,
                            ULONG aY,
                            ULONG aWidth,
                            ULONG aHeight);
    STDMETHOD(InvalidateAndUpdate)();
    STDMETHOD(ResizeCompleted)(ULONG aScreenId);
    STDMETHOD(CompleteVHWACommand)(BYTE aCommand);
    STDMETHOD(ViewportChanged)(ULONG aScreenId,
                               ULONG aX,
                               ULONG aY,
                               ULONG aWidth,
                               ULONG aHeight);

private:
    // wrapped IDisplay properties

    // wrapped IDisplay methods
    virtual HRESULT getScreenResolution(ULONG aScreenId,
                                        ULONG *aWidth,
                                        ULONG *aHeight,
                                        ULONG *aBitsPerPixel,
                                        LONG *aXOrigin,
                                        LONG *aYOrigin) = 0;
    virtual HRESULT setFramebuffer(ULONG aScreenId,
                                   const ComPtr<IFramebuffer> &aFramebuffer) = 0;
    virtual HRESULT getFramebuffer(ULONG aScreenId,
                                   ComPtr<IFramebuffer> &aFramebuffer,
                                   LONG *aXOrigin,
                                   LONG *aYOrigin) = 0;
    virtual HRESULT setVideoModeHint(ULONG aDisplay,
                                     BOOL aEnabled,
                                     BOOL aChangeOrigin,
                                     LONG aOriginX,
                                     LONG aOriginY,
                                     ULONG aWidth,
                                     ULONG aHeight,
                                     ULONG aBitsPerPixel) = 0;
    virtual HRESULT setSeamlessMode(BOOL aEnabled) = 0;
    virtual HRESULT takeScreenShot(ULONG aScreenId,
                                   BYTE aAddress,
                                   ULONG aWidth,
                                   ULONG aHeight) = 0;
    virtual HRESULT takeScreenShotToArray(ULONG aScreenId,
                                          ULONG aWidth,
                                          ULONG aHeight,
                                          std::vector<BYTE> &aScreenData) = 0;
    virtual HRESULT takeScreenShotPNGToArray(ULONG aScreenId,
                                             ULONG aWidth,
                                             ULONG aHeight,
                                             std::vector<BYTE> &aScreenData) = 0;
    virtual HRESULT drawToScreen(ULONG aScreenId,
                                 BYTE aAddress,
                                 ULONG aX,
                                 ULONG aY,
                                 ULONG aWidth,
                                 ULONG aHeight) = 0;
    virtual HRESULT invalidateAndUpdate() = 0;
    virtual HRESULT resizeCompleted(ULONG aScreenId) = 0;
    virtual HRESULT completeVHWACommand(BYTE aCommand) = 0;
    virtual HRESULT viewportChanged(ULONG aScreenId,
                                    ULONG aX,
                                    ULONG aY,
                                    ULONG aWidth,
                                    ULONG aHeight) = 0;
};

#endif // !DisplayWrap_H_

// ##### ENDFILE "DisplayWrap.h"

// ##### BEGINFILE "DisplayWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IDisplay.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_DISPLAY

#include "DisplayWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(DisplayWrap)

//
// IDisplay properties
//

//
// IDisplay methods
//

STDMETHODIMP DisplayWrap::GetScreenResolution(ULONG aScreenId,
                                              ULONG *aWidth,
                                              ULONG *aHeight,
                                              ULONG *aBitsPerPixel,
                                              LONG *aXOrigin,
                                              LONG *aYOrigin)
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32 aWidth=%p aHeight=%p aBitsPerPixel=%p aXOrigin=%p aYOrigin=%p\n", this, "Display::getScreenResolution", aScreenId, aWidth, aHeight, aBitsPerPixel, aXOrigin, aYOrigin));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWidth);
        CheckComArgOutPointerValidThrow(aHeight);
        CheckComArgOutPointerValidThrow(aBitsPerPixel);
        CheckComArgOutPointerValidThrow(aXOrigin);
        CheckComArgOutPointerValidThrow(aYOrigin);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getScreenResolution(aScreenId,
                                  aWidth,
                                  aHeight,
                                  aBitsPerPixel,
                                  aXOrigin,
                                  aYOrigin);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWidth=%RU32 *aHeight=%RU32 *aBitsPerPixel=%RU32 *aXOrigin=%RI32 *aYOrigin=%RI32 hrc=%Rhrc\n", this, "Display::getScreenResolution", *aWidth, *aHeight, *aBitsPerPixel, *aXOrigin, *aYOrigin, hrc));
    return hrc;
}

STDMETHODIMP DisplayWrap::SetFramebuffer(ULONG aScreenId,
                                         IFramebuffer *aFramebuffer)
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32 aFramebuffer=%p\n", this, "Display::setFramebuffer", aScreenId, aFramebuffer));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setFramebuffer(aScreenId,
                             ComTypeInConverter<IFramebuffer>(aFramebuffer).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Display::setFramebuffer", hrc));
    return hrc;
}

STDMETHODIMP DisplayWrap::GetFramebuffer(ULONG aScreenId,
                                         IFramebuffer **aFramebuffer,
                                         LONG *aXOrigin,
                                         LONG *aYOrigin)
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32 aFramebuffer=%p aXOrigin=%p aYOrigin=%p\n", this, "Display::getFramebuffer", aScreenId, aFramebuffer, aXOrigin, aYOrigin));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFramebuffer);
        CheckComArgOutPointerValidThrow(aXOrigin);
        CheckComArgOutPointerValidThrow(aYOrigin);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFramebuffer(aScreenId,
                             ComTypeOutConverter<IFramebuffer>(aFramebuffer).ptr(),
                             aXOrigin,
                             aYOrigin);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFramebuffer=%p *aXOrigin=%RI32 *aYOrigin=%RI32 hrc=%Rhrc\n", this, "Display::getFramebuffer", *aFramebuffer, *aXOrigin, *aYOrigin, hrc));
    return hrc;
}

STDMETHODIMP DisplayWrap::SetVideoModeHint(ULONG aDisplay,
                                           BOOL aEnabled,
                                           BOOL aChangeOrigin,
                                           LONG aOriginX,
                                           LONG aOriginY,
                                           ULONG aWidth,
                                           ULONG aHeight,
                                           ULONG aBitsPerPixel)
{
    LogRelFlow(("{%p} %s:enter aDisplay=%RU32 aEnabled=%RTbool aChangeOrigin=%RTbool aOriginX=%RI32 aOriginY=%RI32 aWidth=%RU32 aHeight=%RU32 aBitsPerPixel=%RU32\n", this, "Display::setVideoModeHint", aDisplay, aEnabled, aChangeOrigin, aOriginX, aOriginY, aWidth, aHeight, aBitsPerPixel));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setVideoModeHint(aDisplay,
                               aEnabled,
                               aChangeOrigin,
                               aOriginX,
                               aOriginY,
                               aWidth,
                               aHeight,
                               aBitsPerPixel);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Display::setVideoModeHint", hrc));
    return hrc;
}

STDMETHODIMP DisplayWrap::SetSeamlessMode(BOOL aEnabled)
{
    LogRelFlow(("{%p} %s:enter aEnabled=%RTbool\n", this, "Display::setSeamlessMode", aEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setSeamlessMode(aEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Display::setSeamlessMode", hrc));
    return hrc;
}

STDMETHODIMP DisplayWrap::TakeScreenShot(ULONG aScreenId,
                                         BYTE aAddress,
                                         ULONG aWidth,
                                         ULONG aHeight)
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32 aAddress=%RU8 aWidth=%RU32 aHeight=%RU32\n", this, "Display::takeScreenShot", aScreenId, aAddress, aWidth, aHeight));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = takeScreenShot(aScreenId,
                             aAddress,
                             aWidth,
                             aHeight);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Display::takeScreenShot", hrc));
    return hrc;
}

STDMETHODIMP DisplayWrap::TakeScreenShotToArray(ULONG aScreenId,
                                                ULONG aWidth,
                                                ULONG aHeight,
                                                ComSafeArrayOut(BYTE, aScreenData))
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32 aWidth=%RU32 aHeight=%RU32 aScreenData=%p\n", this, "Display::takeScreenShotToArray", aScreenId, aWidth, aHeight, aScreenData));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aScreenData);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = takeScreenShotToArray(aScreenId,
                                    aWidth,
                                    aHeight,
                                    ArrayOutConverter<BYTE>(ComSafeArrayOutArg(aScreenData)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aScreenData=%zu hrc=%Rhrc\n", this, "Display::takeScreenShotToArray", ComSafeArraySize(*aScreenData), hrc));
    return hrc;
}

STDMETHODIMP DisplayWrap::TakeScreenShotPNGToArray(ULONG aScreenId,
                                                   ULONG aWidth,
                                                   ULONG aHeight,
                                                   ComSafeArrayOut(BYTE, aScreenData))
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32 aWidth=%RU32 aHeight=%RU32 aScreenData=%p\n", this, "Display::takeScreenShotPNGToArray", aScreenId, aWidth, aHeight, aScreenData));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aScreenData);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = takeScreenShotPNGToArray(aScreenId,
                                       aWidth,
                                       aHeight,
                                       ArrayOutConverter<BYTE>(ComSafeArrayOutArg(aScreenData)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aScreenData=%zu hrc=%Rhrc\n", this, "Display::takeScreenShotPNGToArray", ComSafeArraySize(*aScreenData), hrc));
    return hrc;
}

STDMETHODIMP DisplayWrap::DrawToScreen(ULONG aScreenId,
                                       BYTE aAddress,
                                       ULONG aX,
                                       ULONG aY,
                                       ULONG aWidth,
                                       ULONG aHeight)
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32 aAddress=%RU8 aX=%RU32 aY=%RU32 aWidth=%RU32 aHeight=%RU32\n", this, "Display::drawToScreen", aScreenId, aAddress, aX, aY, aWidth, aHeight));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = drawToScreen(aScreenId,
                           aAddress,
                           aX,
                           aY,
                           aWidth,
                           aHeight);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Display::drawToScreen", hrc));
    return hrc;
}

STDMETHODIMP DisplayWrap::InvalidateAndUpdate()
{
    LogRelFlow(("{%p} %s:enter\n", this, "Display::invalidateAndUpdate"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = invalidateAndUpdate();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Display::invalidateAndUpdate", hrc));
    return hrc;
}

STDMETHODIMP DisplayWrap::ResizeCompleted(ULONG aScreenId)
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32\n", this, "Display::resizeCompleted", aScreenId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = resizeCompleted(aScreenId);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Display::resizeCompleted", hrc));
    return hrc;
}

STDMETHODIMP DisplayWrap::CompleteVHWACommand(BYTE aCommand)
{
    LogRelFlow(("{%p} %s:enter aCommand=%RU8\n", this, "Display::completeVHWACommand", aCommand));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = completeVHWACommand(aCommand);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Display::completeVHWACommand", hrc));
    return hrc;
}

STDMETHODIMP DisplayWrap::ViewportChanged(ULONG aScreenId,
                                          ULONG aX,
                                          ULONG aY,
                                          ULONG aWidth,
                                          ULONG aHeight)
{
    LogRelFlow(("{%p} %s:enter aScreenId=%RU32 aX=%RU32 aY=%RU32 aWidth=%RU32 aHeight=%RU32\n", this, "Display::viewportChanged", aScreenId, aX, aY, aWidth, aHeight));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = viewportChanged(aScreenId,
                              aX,
                              aY,
                              aWidth,
                              aHeight);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Display::viewportChanged", hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(DisplayWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(DisplayWrap, IDisplay)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "DisplayWrap.cpp"

// ##### BEGINFILE "NetworkAdapterWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for INetworkAdapter.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef NetworkAdapterWrap_H_
#define NetworkAdapterWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE NetworkAdapterWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(INetworkAdapter)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(NetworkAdapterWrap, INetworkAdapter)
    DECLARE_NOT_AGGREGATABLE(NetworkAdapterWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(NetworkAdapterWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(INetworkAdapter)
        COM_INTERFACE_ENTRY2(IDispatch, INetworkAdapter)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(NetworkAdapterWrap)

    // public INetworkAdapter properties
    STDMETHOD(COMGETTER(AdapterType))(NetworkAdapterType_T *aAdapterType);
    STDMETHOD(COMSETTER(AdapterType))(NetworkAdapterType_T aAdapterType);
    STDMETHOD(COMGETTER(Slot))(ULONG *aSlot);
    STDMETHOD(COMGETTER(Enabled))(BOOL *aEnabled);
    STDMETHOD(COMSETTER(Enabled))(BOOL aEnabled);
    STDMETHOD(COMGETTER(MACAddress))(BSTR *aMACAddress);
    STDMETHOD(COMSETTER(MACAddress))(IN_BSTR aMACAddress);
    STDMETHOD(COMGETTER(AttachmentType))(NetworkAttachmentType_T *aAttachmentType);
    STDMETHOD(COMSETTER(AttachmentType))(NetworkAttachmentType_T aAttachmentType);
    STDMETHOD(COMGETTER(BridgedInterface))(BSTR *aBridgedInterface);
    STDMETHOD(COMSETTER(BridgedInterface))(IN_BSTR aBridgedInterface);
    STDMETHOD(COMGETTER(HostOnlyInterface))(BSTR *aHostOnlyInterface);
    STDMETHOD(COMSETTER(HostOnlyInterface))(IN_BSTR aHostOnlyInterface);
    STDMETHOD(COMGETTER(InternalNetwork))(BSTR *aInternalNetwork);
    STDMETHOD(COMSETTER(InternalNetwork))(IN_BSTR aInternalNetwork);
    STDMETHOD(COMGETTER(NATNetwork))(BSTR *aNATNetwork);
    STDMETHOD(COMSETTER(NATNetwork))(IN_BSTR aNATNetwork);
    STDMETHOD(COMGETTER(GenericDriver))(BSTR *aGenericDriver);
    STDMETHOD(COMSETTER(GenericDriver))(IN_BSTR aGenericDriver);
    STDMETHOD(COMGETTER(CableConnected))(BOOL *aCableConnected);
    STDMETHOD(COMSETTER(CableConnected))(BOOL aCableConnected);
    STDMETHOD(COMGETTER(LineSpeed))(ULONG *aLineSpeed);
    STDMETHOD(COMSETTER(LineSpeed))(ULONG aLineSpeed);
    STDMETHOD(COMGETTER(PromiscModePolicy))(NetworkAdapterPromiscModePolicy_T *aPromiscModePolicy);
    STDMETHOD(COMSETTER(PromiscModePolicy))(NetworkAdapterPromiscModePolicy_T aPromiscModePolicy);
    STDMETHOD(COMGETTER(TraceEnabled))(BOOL *aTraceEnabled);
    STDMETHOD(COMSETTER(TraceEnabled))(BOOL aTraceEnabled);
    STDMETHOD(COMGETTER(TraceFile))(BSTR *aTraceFile);
    STDMETHOD(COMSETTER(TraceFile))(IN_BSTR aTraceFile);
    STDMETHOD(COMGETTER(NATEngine))(INATEngine **aNATEngine);
    STDMETHOD(COMGETTER(BootPriority))(ULONG *aBootPriority);
    STDMETHOD(COMSETTER(BootPriority))(ULONG aBootPriority);
    STDMETHOD(COMGETTER(BandwidthGroup))(IBandwidthGroup **aBandwidthGroup);
    STDMETHOD(COMSETTER(BandwidthGroup))(IBandwidthGroup *aBandwidthGroup);

    // public INetworkAdapter methods
    STDMETHOD(GetProperty)(IN_BSTR aKey,
                           BSTR *aValue);
    STDMETHOD(SetProperty)(IN_BSTR aKey,
                           IN_BSTR aValue);
    STDMETHOD(GetProperties)(IN_BSTR aNames,
                             ComSafeArrayOut(BSTR, aReturnNames),
                             ComSafeArrayOut(BSTR, aReturnValues));

private:
    // wrapped INetworkAdapter properties
    virtual HRESULT getAdapterType(NetworkAdapterType_T *aAdapterType) = 0;
    virtual HRESULT setAdapterType(NetworkAdapterType_T aAdapterType) = 0;
    virtual HRESULT getSlot(ULONG *aSlot) = 0;
    virtual HRESULT getEnabled(BOOL *aEnabled) = 0;
    virtual HRESULT setEnabled(BOOL aEnabled) = 0;
    virtual HRESULT getMACAddress(com::Utf8Str &aMACAddress) = 0;
    virtual HRESULT setMACAddress(const com::Utf8Str &aMACAddress) = 0;
    virtual HRESULT getAttachmentType(NetworkAttachmentType_T *aAttachmentType) = 0;
    virtual HRESULT setAttachmentType(NetworkAttachmentType_T aAttachmentType) = 0;
    virtual HRESULT getBridgedInterface(com::Utf8Str &aBridgedInterface) = 0;
    virtual HRESULT setBridgedInterface(const com::Utf8Str &aBridgedInterface) = 0;
    virtual HRESULT getHostOnlyInterface(com::Utf8Str &aHostOnlyInterface) = 0;
    virtual HRESULT setHostOnlyInterface(const com::Utf8Str &aHostOnlyInterface) = 0;
    virtual HRESULT getInternalNetwork(com::Utf8Str &aInternalNetwork) = 0;
    virtual HRESULT setInternalNetwork(const com::Utf8Str &aInternalNetwork) = 0;
    virtual HRESULT getNATNetwork(com::Utf8Str &aNATNetwork) = 0;
    virtual HRESULT setNATNetwork(const com::Utf8Str &aNATNetwork) = 0;
    virtual HRESULT getGenericDriver(com::Utf8Str &aGenericDriver) = 0;
    virtual HRESULT setGenericDriver(const com::Utf8Str &aGenericDriver) = 0;
    virtual HRESULT getCableConnected(BOOL *aCableConnected) = 0;
    virtual HRESULT setCableConnected(BOOL aCableConnected) = 0;
    virtual HRESULT getLineSpeed(ULONG *aLineSpeed) = 0;
    virtual HRESULT setLineSpeed(ULONG aLineSpeed) = 0;
    virtual HRESULT getPromiscModePolicy(NetworkAdapterPromiscModePolicy_T *aPromiscModePolicy) = 0;
    virtual HRESULT setPromiscModePolicy(NetworkAdapterPromiscModePolicy_T aPromiscModePolicy) = 0;
    virtual HRESULT getTraceEnabled(BOOL *aTraceEnabled) = 0;
    virtual HRESULT setTraceEnabled(BOOL aTraceEnabled) = 0;
    virtual HRESULT getTraceFile(com::Utf8Str &aTraceFile) = 0;
    virtual HRESULT setTraceFile(const com::Utf8Str &aTraceFile) = 0;
    virtual HRESULT getNATEngine(ComPtr<INATEngine> &aNATEngine) = 0;
    virtual HRESULT getBootPriority(ULONG *aBootPriority) = 0;
    virtual HRESULT setBootPriority(ULONG aBootPriority) = 0;
    virtual HRESULT getBandwidthGroup(ComPtr<IBandwidthGroup> &aBandwidthGroup) = 0;
    virtual HRESULT setBandwidthGroup(const ComPtr<IBandwidthGroup> &aBandwidthGroup) = 0;

    // wrapped INetworkAdapter methods
    virtual HRESULT getProperty(const com::Utf8Str &aKey,
                                com::Utf8Str &aValue) = 0;
    virtual HRESULT setProperty(const com::Utf8Str &aKey,
                                const com::Utf8Str &aValue) = 0;
    virtual HRESULT getProperties(const com::Utf8Str &aNames,
                                  std::vector<com::Utf8Str> &aReturnNames,
                                  std::vector<com::Utf8Str> &aReturnValues) = 0;
};

#endif // !NetworkAdapterWrap_H_

// ##### ENDFILE "NetworkAdapterWrap.h"

// ##### BEGINFILE "NetworkAdapterWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for INetworkAdapter.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_NETWORKADAPTER

#include "NetworkAdapterWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(NetworkAdapterWrap)

//
// INetworkAdapter properties
//

STDMETHODIMP NetworkAdapterWrap::COMGETTER(AdapterType)(NetworkAdapterType_T *aAdapterType)
{
    LogRelFlow(("{%p} %s: enter aAdapterType=%p\n", this, "NetworkAdapter::getAdapterType", aAdapterType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAdapterType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAdapterType(aAdapterType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAdapterType=%RU32 hrc=%Rhrc\n", this, "NetworkAdapter::getAdapterType", *aAdapterType, hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMSETTER(AdapterType)(NetworkAdapterType_T aAdapterType)
{
    LogRelFlow(("{%p} %s: enter aAdapterType=%RU32\n", this, "NetworkAdapter::setAdapterType", aAdapterType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setAdapterType(aAdapterType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NetworkAdapter::setAdapterType", hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMGETTER(Slot)(ULONG *aSlot)
{
    LogRelFlow(("{%p} %s: enter aSlot=%p\n", this, "NetworkAdapter::getSlot", aSlot));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSlot);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSlot(aSlot);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSlot=%RU32 hrc=%Rhrc\n", this, "NetworkAdapter::getSlot", *aSlot, hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMGETTER(Enabled)(BOOL *aEnabled)
{
    LogRelFlow(("{%p} %s: enter aEnabled=%p\n", this, "NetworkAdapter::getEnabled", aEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEnabled(aEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEnabled=%RTbool hrc=%Rhrc\n", this, "NetworkAdapter::getEnabled", *aEnabled, hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMSETTER(Enabled)(BOOL aEnabled)
{
    LogRelFlow(("{%p} %s: enter aEnabled=%RTbool\n", this, "NetworkAdapter::setEnabled", aEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setEnabled(aEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NetworkAdapter::setEnabled", hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMGETTER(MACAddress)(BSTR *aMACAddress)
{
    LogRelFlow(("{%p} %s: enter aMACAddress=%p\n", this, "NetworkAdapter::getMACAddress", aMACAddress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMACAddress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMACAddress(BSTROutConverter(aMACAddress).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMACAddress=%ls hrc=%Rhrc\n", this, "NetworkAdapter::getMACAddress", *aMACAddress, hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMSETTER(MACAddress)(IN_BSTR aMACAddress)
{
    LogRelFlow(("{%p} %s: enter aMACAddress=%ls\n", this, "NetworkAdapter::setMACAddress", aMACAddress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setMACAddress(BSTRInConverter(aMACAddress).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NetworkAdapter::setMACAddress", hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMGETTER(AttachmentType)(NetworkAttachmentType_T *aAttachmentType)
{
    LogRelFlow(("{%p} %s: enter aAttachmentType=%p\n", this, "NetworkAdapter::getAttachmentType", aAttachmentType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAttachmentType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAttachmentType(aAttachmentType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAttachmentType=%RU32 hrc=%Rhrc\n", this, "NetworkAdapter::getAttachmentType", *aAttachmentType, hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMSETTER(AttachmentType)(NetworkAttachmentType_T aAttachmentType)
{
    LogRelFlow(("{%p} %s: enter aAttachmentType=%RU32\n", this, "NetworkAdapter::setAttachmentType", aAttachmentType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setAttachmentType(aAttachmentType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NetworkAdapter::setAttachmentType", hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMGETTER(BridgedInterface)(BSTR *aBridgedInterface)
{
    LogRelFlow(("{%p} %s: enter aBridgedInterface=%p\n", this, "NetworkAdapter::getBridgedInterface", aBridgedInterface));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBridgedInterface);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBridgedInterface(BSTROutConverter(aBridgedInterface).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBridgedInterface=%ls hrc=%Rhrc\n", this, "NetworkAdapter::getBridgedInterface", *aBridgedInterface, hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMSETTER(BridgedInterface)(IN_BSTR aBridgedInterface)
{
    LogRelFlow(("{%p} %s: enter aBridgedInterface=%ls\n", this, "NetworkAdapter::setBridgedInterface", aBridgedInterface));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setBridgedInterface(BSTRInConverter(aBridgedInterface).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NetworkAdapter::setBridgedInterface", hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMGETTER(HostOnlyInterface)(BSTR *aHostOnlyInterface)
{
    LogRelFlow(("{%p} %s: enter aHostOnlyInterface=%p\n", this, "NetworkAdapter::getHostOnlyInterface", aHostOnlyInterface));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHostOnlyInterface);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHostOnlyInterface(BSTROutConverter(aHostOnlyInterface).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHostOnlyInterface=%ls hrc=%Rhrc\n", this, "NetworkAdapter::getHostOnlyInterface", *aHostOnlyInterface, hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMSETTER(HostOnlyInterface)(IN_BSTR aHostOnlyInterface)
{
    LogRelFlow(("{%p} %s: enter aHostOnlyInterface=%ls\n", this, "NetworkAdapter::setHostOnlyInterface", aHostOnlyInterface));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setHostOnlyInterface(BSTRInConverter(aHostOnlyInterface).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NetworkAdapter::setHostOnlyInterface", hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMGETTER(InternalNetwork)(BSTR *aInternalNetwork)
{
    LogRelFlow(("{%p} %s: enter aInternalNetwork=%p\n", this, "NetworkAdapter::getInternalNetwork", aInternalNetwork));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aInternalNetwork);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getInternalNetwork(BSTROutConverter(aInternalNetwork).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aInternalNetwork=%ls hrc=%Rhrc\n", this, "NetworkAdapter::getInternalNetwork", *aInternalNetwork, hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMSETTER(InternalNetwork)(IN_BSTR aInternalNetwork)
{
    LogRelFlow(("{%p} %s: enter aInternalNetwork=%ls\n", this, "NetworkAdapter::setInternalNetwork", aInternalNetwork));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setInternalNetwork(BSTRInConverter(aInternalNetwork).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NetworkAdapter::setInternalNetwork", hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMGETTER(NATNetwork)(BSTR *aNATNetwork)
{
    LogRelFlow(("{%p} %s: enter aNATNetwork=%p\n", this, "NetworkAdapter::getNATNetwork", aNATNetwork));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNATNetwork);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNATNetwork(BSTROutConverter(aNATNetwork).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNATNetwork=%ls hrc=%Rhrc\n", this, "NetworkAdapter::getNATNetwork", *aNATNetwork, hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMSETTER(NATNetwork)(IN_BSTR aNATNetwork)
{
    LogRelFlow(("{%p} %s: enter aNATNetwork=%ls\n", this, "NetworkAdapter::setNATNetwork", aNATNetwork));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setNATNetwork(BSTRInConverter(aNATNetwork).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NetworkAdapter::setNATNetwork", hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMGETTER(GenericDriver)(BSTR *aGenericDriver)
{
    LogRelFlow(("{%p} %s: enter aGenericDriver=%p\n", this, "NetworkAdapter::getGenericDriver", aGenericDriver));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGenericDriver);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGenericDriver(BSTROutConverter(aGenericDriver).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGenericDriver=%ls hrc=%Rhrc\n", this, "NetworkAdapter::getGenericDriver", *aGenericDriver, hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMSETTER(GenericDriver)(IN_BSTR aGenericDriver)
{
    LogRelFlow(("{%p} %s: enter aGenericDriver=%ls\n", this, "NetworkAdapter::setGenericDriver", aGenericDriver));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setGenericDriver(BSTRInConverter(aGenericDriver).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NetworkAdapter::setGenericDriver", hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMGETTER(CableConnected)(BOOL *aCableConnected)
{
    LogRelFlow(("{%p} %s: enter aCableConnected=%p\n", this, "NetworkAdapter::getCableConnected", aCableConnected));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCableConnected);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getCableConnected(aCableConnected);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aCableConnected=%RTbool hrc=%Rhrc\n", this, "NetworkAdapter::getCableConnected", *aCableConnected, hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMSETTER(CableConnected)(BOOL aCableConnected)
{
    LogRelFlow(("{%p} %s: enter aCableConnected=%RTbool\n", this, "NetworkAdapter::setCableConnected", aCableConnected));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setCableConnected(aCableConnected);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NetworkAdapter::setCableConnected", hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMGETTER(LineSpeed)(ULONG *aLineSpeed)
{
    LogRelFlow(("{%p} %s: enter aLineSpeed=%p\n", this, "NetworkAdapter::getLineSpeed", aLineSpeed));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLineSpeed);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLineSpeed(aLineSpeed);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLineSpeed=%RU32 hrc=%Rhrc\n", this, "NetworkAdapter::getLineSpeed", *aLineSpeed, hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMSETTER(LineSpeed)(ULONG aLineSpeed)
{
    LogRelFlow(("{%p} %s: enter aLineSpeed=%RU32\n", this, "NetworkAdapter::setLineSpeed", aLineSpeed));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setLineSpeed(aLineSpeed);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NetworkAdapter::setLineSpeed", hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMGETTER(PromiscModePolicy)(NetworkAdapterPromiscModePolicy_T *aPromiscModePolicy)
{
    LogRelFlow(("{%p} %s: enter aPromiscModePolicy=%p\n", this, "NetworkAdapter::getPromiscModePolicy", aPromiscModePolicy));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPromiscModePolicy);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPromiscModePolicy(aPromiscModePolicy);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPromiscModePolicy=%RU32 hrc=%Rhrc\n", this, "NetworkAdapter::getPromiscModePolicy", *aPromiscModePolicy, hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMSETTER(PromiscModePolicy)(NetworkAdapterPromiscModePolicy_T aPromiscModePolicy)
{
    LogRelFlow(("{%p} %s: enter aPromiscModePolicy=%RU32\n", this, "NetworkAdapter::setPromiscModePolicy", aPromiscModePolicy));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setPromiscModePolicy(aPromiscModePolicy);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NetworkAdapter::setPromiscModePolicy", hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMGETTER(TraceEnabled)(BOOL *aTraceEnabled)
{
    LogRelFlow(("{%p} %s: enter aTraceEnabled=%p\n", this, "NetworkAdapter::getTraceEnabled", aTraceEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aTraceEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getTraceEnabled(aTraceEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aTraceEnabled=%RTbool hrc=%Rhrc\n", this, "NetworkAdapter::getTraceEnabled", *aTraceEnabled, hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMSETTER(TraceEnabled)(BOOL aTraceEnabled)
{
    LogRelFlow(("{%p} %s: enter aTraceEnabled=%RTbool\n", this, "NetworkAdapter::setTraceEnabled", aTraceEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setTraceEnabled(aTraceEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NetworkAdapter::setTraceEnabled", hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMGETTER(TraceFile)(BSTR *aTraceFile)
{
    LogRelFlow(("{%p} %s: enter aTraceFile=%p\n", this, "NetworkAdapter::getTraceFile", aTraceFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aTraceFile);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getTraceFile(BSTROutConverter(aTraceFile).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aTraceFile=%ls hrc=%Rhrc\n", this, "NetworkAdapter::getTraceFile", *aTraceFile, hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMSETTER(TraceFile)(IN_BSTR aTraceFile)
{
    LogRelFlow(("{%p} %s: enter aTraceFile=%ls\n", this, "NetworkAdapter::setTraceFile", aTraceFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setTraceFile(BSTRInConverter(aTraceFile).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NetworkAdapter::setTraceFile", hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMGETTER(NATEngine)(INATEngine **aNATEngine)
{
    LogRelFlow(("{%p} %s: enter aNATEngine=%p\n", this, "NetworkAdapter::getNATEngine", aNATEngine));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNATEngine);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNATEngine(ComTypeOutConverter<INATEngine>(aNATEngine).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNATEngine=%p hrc=%Rhrc\n", this, "NetworkAdapter::getNATEngine", *aNATEngine, hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMGETTER(BootPriority)(ULONG *aBootPriority)
{
    LogRelFlow(("{%p} %s: enter aBootPriority=%p\n", this, "NetworkAdapter::getBootPriority", aBootPriority));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBootPriority);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBootPriority(aBootPriority);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBootPriority=%RU32 hrc=%Rhrc\n", this, "NetworkAdapter::getBootPriority", *aBootPriority, hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMSETTER(BootPriority)(ULONG aBootPriority)
{
    LogRelFlow(("{%p} %s: enter aBootPriority=%RU32\n", this, "NetworkAdapter::setBootPriority", aBootPriority));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setBootPriority(aBootPriority);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NetworkAdapter::setBootPriority", hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMGETTER(BandwidthGroup)(IBandwidthGroup **aBandwidthGroup)
{
    LogRelFlow(("{%p} %s: enter aBandwidthGroup=%p\n", this, "NetworkAdapter::getBandwidthGroup", aBandwidthGroup));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBandwidthGroup);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBandwidthGroup(ComTypeOutConverter<IBandwidthGroup>(aBandwidthGroup).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBandwidthGroup=%p hrc=%Rhrc\n", this, "NetworkAdapter::getBandwidthGroup", *aBandwidthGroup, hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::COMSETTER(BandwidthGroup)(IBandwidthGroup *aBandwidthGroup)
{
    LogRelFlow(("{%p} %s: enter aBandwidthGroup=%p\n", this, "NetworkAdapter::setBandwidthGroup", aBandwidthGroup));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setBandwidthGroup(ComTypeInConverter<IBandwidthGroup>(aBandwidthGroup).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NetworkAdapter::setBandwidthGroup", hrc));
    return hrc;
}

//
// INetworkAdapter methods
//

STDMETHODIMP NetworkAdapterWrap::GetProperty(IN_BSTR aKey,
                                             BSTR *aValue)
{
    LogRelFlow(("{%p} %s:enter aKey=%ls aValue=%p\n", this, "NetworkAdapter::getProperty", aKey, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aValue);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProperty(BSTRInConverter(aKey).str(),
                          BSTROutConverter(aValue).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aValue=%ls hrc=%Rhrc\n", this, "NetworkAdapter::getProperty", *aValue, hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::SetProperty(IN_BSTR aKey,
                                             IN_BSTR aValue)
{
    LogRelFlow(("{%p} %s:enter aKey=%ls aValue=%ls\n", this, "NetworkAdapter::setProperty", aKey, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProperty(BSTRInConverter(aKey).str(),
                          BSTRInConverter(aValue).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NetworkAdapter::setProperty", hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterWrap::GetProperties(IN_BSTR aNames,
                                               ComSafeArrayOut(BSTR, aReturnNames),
                                               ComSafeArrayOut(BSTR, aReturnValues))
{
    LogRelFlow(("{%p} %s:enter aNames=%ls aReturnNames=%p aReturnValues=%p\n", this, "NetworkAdapter::getProperties", aNames, aReturnNames, aReturnValues));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aReturnNames);
        CheckComArgOutPointerValidThrow(aReturnValues);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProperties(BSTRInConverter(aNames).str(),
                            ArrayBSTROutConverter(ComSafeArrayOutArg(aReturnNames)).array(),
                            ArrayBSTROutConverter(ComSafeArrayOutArg(aReturnValues)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aReturnNames=%zu aReturnValues=%zu hrc=%Rhrc\n", this, "NetworkAdapter::getProperties", ComSafeArraySize(*aReturnNames), ComSafeArraySize(*aReturnValues), hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(NetworkAdapterWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(NetworkAdapterWrap, INetworkAdapter)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "NetworkAdapterWrap.cpp"

// ##### BEGINFILE "SerialPortWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for ISerialPort.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef SerialPortWrap_H_
#define SerialPortWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE SerialPortWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(ISerialPort)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(SerialPortWrap, ISerialPort)
    DECLARE_NOT_AGGREGATABLE(SerialPortWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(SerialPortWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(ISerialPort)
        COM_INTERFACE_ENTRY2(IDispatch, ISerialPort)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(SerialPortWrap)

    // public ISerialPort properties
    STDMETHOD(COMGETTER(Slot))(ULONG *aSlot);
    STDMETHOD(COMGETTER(Enabled))(BOOL *aEnabled);
    STDMETHOD(COMSETTER(Enabled))(BOOL aEnabled);
    STDMETHOD(COMGETTER(IOBase))(ULONG *aIOBase);
    STDMETHOD(COMSETTER(IOBase))(ULONG aIOBase);
    STDMETHOD(COMGETTER(IRQ))(ULONG *aIRQ);
    STDMETHOD(COMSETTER(IRQ))(ULONG aIRQ);
    STDMETHOD(COMGETTER(HostMode))(PortMode_T *aHostMode);
    STDMETHOD(COMSETTER(HostMode))(PortMode_T aHostMode);
    STDMETHOD(COMGETTER(Server))(BOOL *aServer);
    STDMETHOD(COMSETTER(Server))(BOOL aServer);
    STDMETHOD(COMGETTER(Path))(BSTR *aPath);
    STDMETHOD(COMSETTER(Path))(IN_BSTR aPath);

    // public ISerialPort methods

private:
    // wrapped ISerialPort properties
    virtual HRESULT getSlot(ULONG *aSlot) = 0;
    virtual HRESULT getEnabled(BOOL *aEnabled) = 0;
    virtual HRESULT setEnabled(BOOL aEnabled) = 0;
    virtual HRESULT getIOBase(ULONG *aIOBase) = 0;
    virtual HRESULT setIOBase(ULONG aIOBase) = 0;
    virtual HRESULT getIRQ(ULONG *aIRQ) = 0;
    virtual HRESULT setIRQ(ULONG aIRQ) = 0;
    virtual HRESULT getHostMode(PortMode_T *aHostMode) = 0;
    virtual HRESULT setHostMode(PortMode_T aHostMode) = 0;
    virtual HRESULT getServer(BOOL *aServer) = 0;
    virtual HRESULT setServer(BOOL aServer) = 0;
    virtual HRESULT getPath(com::Utf8Str &aPath) = 0;
    virtual HRESULT setPath(const com::Utf8Str &aPath) = 0;

    // wrapped ISerialPort methods
};

#endif // !SerialPortWrap_H_

// ##### ENDFILE "SerialPortWrap.h"

// ##### BEGINFILE "SerialPortWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for ISerialPort.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_SERIALPORT

#include "SerialPortWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(SerialPortWrap)

//
// ISerialPort properties
//

STDMETHODIMP SerialPortWrap::COMGETTER(Slot)(ULONG *aSlot)
{
    LogRelFlow(("{%p} %s: enter aSlot=%p\n", this, "SerialPort::getSlot", aSlot));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSlot);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSlot(aSlot);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSlot=%RU32 hrc=%Rhrc\n", this, "SerialPort::getSlot", *aSlot, hrc));
    return hrc;
}

STDMETHODIMP SerialPortWrap::COMGETTER(Enabled)(BOOL *aEnabled)
{
    LogRelFlow(("{%p} %s: enter aEnabled=%p\n", this, "SerialPort::getEnabled", aEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEnabled(aEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEnabled=%RTbool hrc=%Rhrc\n", this, "SerialPort::getEnabled", *aEnabled, hrc));
    return hrc;
}

STDMETHODIMP SerialPortWrap::COMSETTER(Enabled)(BOOL aEnabled)
{
    LogRelFlow(("{%p} %s: enter aEnabled=%RTbool\n", this, "SerialPort::setEnabled", aEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setEnabled(aEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SerialPort::setEnabled", hrc));
    return hrc;
}

STDMETHODIMP SerialPortWrap::COMGETTER(IOBase)(ULONG *aIOBase)
{
    LogRelFlow(("{%p} %s: enter aIOBase=%p\n", this, "SerialPort::getIOBase", aIOBase));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aIOBase);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getIOBase(aIOBase);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aIOBase=%RU32 hrc=%Rhrc\n", this, "SerialPort::getIOBase", *aIOBase, hrc));
    return hrc;
}

STDMETHODIMP SerialPortWrap::COMSETTER(IOBase)(ULONG aIOBase)
{
    LogRelFlow(("{%p} %s: enter aIOBase=%RU32\n", this, "SerialPort::setIOBase", aIOBase));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setIOBase(aIOBase);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SerialPort::setIOBase", hrc));
    return hrc;
}

STDMETHODIMP SerialPortWrap::COMGETTER(IRQ)(ULONG *aIRQ)
{
    LogRelFlow(("{%p} %s: enter aIRQ=%p\n", this, "SerialPort::getIRQ", aIRQ));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aIRQ);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getIRQ(aIRQ);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aIRQ=%RU32 hrc=%Rhrc\n", this, "SerialPort::getIRQ", *aIRQ, hrc));
    return hrc;
}

STDMETHODIMP SerialPortWrap::COMSETTER(IRQ)(ULONG aIRQ)
{
    LogRelFlow(("{%p} %s: enter aIRQ=%RU32\n", this, "SerialPort::setIRQ", aIRQ));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setIRQ(aIRQ);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SerialPort::setIRQ", hrc));
    return hrc;
}

STDMETHODIMP SerialPortWrap::COMGETTER(HostMode)(PortMode_T *aHostMode)
{
    LogRelFlow(("{%p} %s: enter aHostMode=%p\n", this, "SerialPort::getHostMode", aHostMode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHostMode);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHostMode(aHostMode);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHostMode=%RU32 hrc=%Rhrc\n", this, "SerialPort::getHostMode", *aHostMode, hrc));
    return hrc;
}

STDMETHODIMP SerialPortWrap::COMSETTER(HostMode)(PortMode_T aHostMode)
{
    LogRelFlow(("{%p} %s: enter aHostMode=%RU32\n", this, "SerialPort::setHostMode", aHostMode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setHostMode(aHostMode);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SerialPort::setHostMode", hrc));
    return hrc;
}

STDMETHODIMP SerialPortWrap::COMGETTER(Server)(BOOL *aServer)
{
    LogRelFlow(("{%p} %s: enter aServer=%p\n", this, "SerialPort::getServer", aServer));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aServer);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getServer(aServer);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aServer=%RTbool hrc=%Rhrc\n", this, "SerialPort::getServer", *aServer, hrc));
    return hrc;
}

STDMETHODIMP SerialPortWrap::COMSETTER(Server)(BOOL aServer)
{
    LogRelFlow(("{%p} %s: enter aServer=%RTbool\n", this, "SerialPort::setServer", aServer));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setServer(aServer);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SerialPort::setServer", hrc));
    return hrc;
}

STDMETHODIMP SerialPortWrap::COMGETTER(Path)(BSTR *aPath)
{
    LogRelFlow(("{%p} %s: enter aPath=%p\n", this, "SerialPort::getPath", aPath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPath);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPath(BSTROutConverter(aPath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPath=%ls hrc=%Rhrc\n", this, "SerialPort::getPath", *aPath, hrc));
    return hrc;
}

STDMETHODIMP SerialPortWrap::COMSETTER(Path)(IN_BSTR aPath)
{
    LogRelFlow(("{%p} %s: enter aPath=%ls\n", this, "SerialPort::setPath", aPath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setPath(BSTRInConverter(aPath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SerialPort::setPath", hrc));
    return hrc;
}

//
// ISerialPort methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(SerialPortWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(SerialPortWrap, ISerialPort)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "SerialPortWrap.cpp"

// ##### BEGINFILE "ParallelPortWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IParallelPort.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef ParallelPortWrap_H_
#define ParallelPortWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE ParallelPortWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IParallelPort)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(ParallelPortWrap, IParallelPort)
    DECLARE_NOT_AGGREGATABLE(ParallelPortWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(ParallelPortWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IParallelPort)
        COM_INTERFACE_ENTRY2(IDispatch, IParallelPort)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(ParallelPortWrap)

    // public IParallelPort properties
    STDMETHOD(COMGETTER(Slot))(ULONG *aSlot);
    STDMETHOD(COMGETTER(Enabled))(BOOL *aEnabled);
    STDMETHOD(COMSETTER(Enabled))(BOOL aEnabled);
    STDMETHOD(COMGETTER(IOBase))(ULONG *aIOBase);
    STDMETHOD(COMSETTER(IOBase))(ULONG aIOBase);
    STDMETHOD(COMGETTER(IRQ))(ULONG *aIRQ);
    STDMETHOD(COMSETTER(IRQ))(ULONG aIRQ);
    STDMETHOD(COMGETTER(Path))(BSTR *aPath);
    STDMETHOD(COMSETTER(Path))(IN_BSTR aPath);

    // public IParallelPort methods

private:
    // wrapped IParallelPort properties
    virtual HRESULT getSlot(ULONG *aSlot) = 0;
    virtual HRESULT getEnabled(BOOL *aEnabled) = 0;
    virtual HRESULT setEnabled(BOOL aEnabled) = 0;
    virtual HRESULT getIOBase(ULONG *aIOBase) = 0;
    virtual HRESULT setIOBase(ULONG aIOBase) = 0;
    virtual HRESULT getIRQ(ULONG *aIRQ) = 0;
    virtual HRESULT setIRQ(ULONG aIRQ) = 0;
    virtual HRESULT getPath(com::Utf8Str &aPath) = 0;
    virtual HRESULT setPath(const com::Utf8Str &aPath) = 0;

    // wrapped IParallelPort methods
};

#endif // !ParallelPortWrap_H_

// ##### ENDFILE "ParallelPortWrap.h"

// ##### BEGINFILE "ParallelPortWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IParallelPort.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_PARALLELPORT

#include "ParallelPortWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(ParallelPortWrap)

//
// IParallelPort properties
//

STDMETHODIMP ParallelPortWrap::COMGETTER(Slot)(ULONG *aSlot)
{
    LogRelFlow(("{%p} %s: enter aSlot=%p\n", this, "ParallelPort::getSlot", aSlot));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSlot);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSlot(aSlot);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSlot=%RU32 hrc=%Rhrc\n", this, "ParallelPort::getSlot", *aSlot, hrc));
    return hrc;
}

STDMETHODIMP ParallelPortWrap::COMGETTER(Enabled)(BOOL *aEnabled)
{
    LogRelFlow(("{%p} %s: enter aEnabled=%p\n", this, "ParallelPort::getEnabled", aEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEnabled(aEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEnabled=%RTbool hrc=%Rhrc\n", this, "ParallelPort::getEnabled", *aEnabled, hrc));
    return hrc;
}

STDMETHODIMP ParallelPortWrap::COMSETTER(Enabled)(BOOL aEnabled)
{
    LogRelFlow(("{%p} %s: enter aEnabled=%RTbool\n", this, "ParallelPort::setEnabled", aEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setEnabled(aEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "ParallelPort::setEnabled", hrc));
    return hrc;
}

STDMETHODIMP ParallelPortWrap::COMGETTER(IOBase)(ULONG *aIOBase)
{
    LogRelFlow(("{%p} %s: enter aIOBase=%p\n", this, "ParallelPort::getIOBase", aIOBase));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aIOBase);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getIOBase(aIOBase);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aIOBase=%RU32 hrc=%Rhrc\n", this, "ParallelPort::getIOBase", *aIOBase, hrc));
    return hrc;
}

STDMETHODIMP ParallelPortWrap::COMSETTER(IOBase)(ULONG aIOBase)
{
    LogRelFlow(("{%p} %s: enter aIOBase=%RU32\n", this, "ParallelPort::setIOBase", aIOBase));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setIOBase(aIOBase);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "ParallelPort::setIOBase", hrc));
    return hrc;
}

STDMETHODIMP ParallelPortWrap::COMGETTER(IRQ)(ULONG *aIRQ)
{
    LogRelFlow(("{%p} %s: enter aIRQ=%p\n", this, "ParallelPort::getIRQ", aIRQ));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aIRQ);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getIRQ(aIRQ);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aIRQ=%RU32 hrc=%Rhrc\n", this, "ParallelPort::getIRQ", *aIRQ, hrc));
    return hrc;
}

STDMETHODIMP ParallelPortWrap::COMSETTER(IRQ)(ULONG aIRQ)
{
    LogRelFlow(("{%p} %s: enter aIRQ=%RU32\n", this, "ParallelPort::setIRQ", aIRQ));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setIRQ(aIRQ);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "ParallelPort::setIRQ", hrc));
    return hrc;
}

STDMETHODIMP ParallelPortWrap::COMGETTER(Path)(BSTR *aPath)
{
    LogRelFlow(("{%p} %s: enter aPath=%p\n", this, "ParallelPort::getPath", aPath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPath);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPath(BSTROutConverter(aPath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPath=%ls hrc=%Rhrc\n", this, "ParallelPort::getPath", *aPath, hrc));
    return hrc;
}

STDMETHODIMP ParallelPortWrap::COMSETTER(Path)(IN_BSTR aPath)
{
    LogRelFlow(("{%p} %s: enter aPath=%ls\n", this, "ParallelPort::setPath", aPath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setPath(BSTRInConverter(aPath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "ParallelPort::setPath", hrc));
    return hrc;
}

//
// IParallelPort methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(ParallelPortWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(ParallelPortWrap, IParallelPort)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "ParallelPortWrap.cpp"

// ##### BEGINFILE "MachineDebuggerWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IMachineDebugger.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef MachineDebuggerWrap_H_
#define MachineDebuggerWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE MachineDebuggerWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IMachineDebugger)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(MachineDebuggerWrap, IMachineDebugger)
    DECLARE_NOT_AGGREGATABLE(MachineDebuggerWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(MachineDebuggerWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IMachineDebugger)
        COM_INTERFACE_ENTRY2(IDispatch, IMachineDebugger)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(MachineDebuggerWrap)

    // public IMachineDebugger properties
    STDMETHOD(COMGETTER(SingleStep))(BOOL *aSingleStep);
    STDMETHOD(COMSETTER(SingleStep))(BOOL aSingleStep);
    STDMETHOD(COMGETTER(RecompileUser))(BOOL *aRecompileUser);
    STDMETHOD(COMSETTER(RecompileUser))(BOOL aRecompileUser);
    STDMETHOD(COMGETTER(RecompileSupervisor))(BOOL *aRecompileSupervisor);
    STDMETHOD(COMSETTER(RecompileSupervisor))(BOOL aRecompileSupervisor);
    STDMETHOD(COMGETTER(ExecuteAllInIEM))(BOOL *aExecuteAllInIEM);
    STDMETHOD(COMSETTER(ExecuteAllInIEM))(BOOL aExecuteAllInIEM);
    STDMETHOD(COMGETTER(PATMEnabled))(BOOL *aPATMEnabled);
    STDMETHOD(COMSETTER(PATMEnabled))(BOOL aPATMEnabled);
    STDMETHOD(COMGETTER(CSAMEnabled))(BOOL *aCSAMEnabled);
    STDMETHOD(COMSETTER(CSAMEnabled))(BOOL aCSAMEnabled);
    STDMETHOD(COMGETTER(LogEnabled))(BOOL *aLogEnabled);
    STDMETHOD(COMSETTER(LogEnabled))(BOOL aLogEnabled);
    STDMETHOD(COMGETTER(LogDbgFlags))(BSTR *aLogDbgFlags);
    STDMETHOD(COMGETTER(LogDbgGroups))(BSTR *aLogDbgGroups);
    STDMETHOD(COMGETTER(LogDbgDestinations))(BSTR *aLogDbgDestinations);
    STDMETHOD(COMGETTER(LogRelFlags))(BSTR *aLogRelFlags);
    STDMETHOD(COMGETTER(LogRelGroups))(BSTR *aLogRelGroups);
    STDMETHOD(COMGETTER(LogRelDestinations))(BSTR *aLogRelDestinations);
    STDMETHOD(COMGETTER(HWVirtExEnabled))(BOOL *aHWVirtExEnabled);
    STDMETHOD(COMGETTER(HWVirtExNestedPagingEnabled))(BOOL *aHWVirtExNestedPagingEnabled);
    STDMETHOD(COMGETTER(HWVirtExVPIDEnabled))(BOOL *aHWVirtExVPIDEnabled);
    STDMETHOD(COMGETTER(HWVirtExUXEnabled))(BOOL *aHWVirtExUXEnabled);
    STDMETHOD(COMGETTER(OSName))(BSTR *aOSName);
    STDMETHOD(COMGETTER(OSVersion))(BSTR *aOSVersion);
    STDMETHOD(COMGETTER(PAEEnabled))(BOOL *aPAEEnabled);
    STDMETHOD(COMGETTER(VirtualTimeRate))(ULONG *aVirtualTimeRate);
    STDMETHOD(COMSETTER(VirtualTimeRate))(ULONG aVirtualTimeRate);
    STDMETHOD(COMGETTER(VM))(LONG64 *aVM);

    // public IMachineDebugger methods
    STDMETHOD(DumpGuestCore)(IN_BSTR aFilename,
                             IN_BSTR aCompression);
    STDMETHOD(DumpHostProcessCore)(IN_BSTR aFilename,
                                   IN_BSTR aCompression);
    STDMETHOD(Info)(IN_BSTR aName,
                    IN_BSTR aArgs,
                    BSTR *aInfo);
    STDMETHOD(InjectNMI)();
    STDMETHOD(ModifyLogGroups)(IN_BSTR aSettings);
    STDMETHOD(ModifyLogFlags)(IN_BSTR aSettings);
    STDMETHOD(ModifyLogDestinations)(IN_BSTR aSettings);
    STDMETHOD(ReadPhysicalMemory)(LONG64 aAddress,
                                  ULONG aSize,
                                  ComSafeArrayOut(BYTE, aBytes));
    STDMETHOD(WritePhysicalMemory)(LONG64 aAddress,
                                   ULONG aSize,
                                   ComSafeArrayIn(BYTE, aBytes));
    STDMETHOD(ReadVirtualMemory)(ULONG aCpuId,
                                 LONG64 aAddress,
                                 ULONG aSize,
                                 ComSafeArrayOut(BYTE, aBytes));
    STDMETHOD(WriteVirtualMemory)(ULONG aCpuId,
                                  LONG64 aAddress,
                                  ULONG aSize,
                                  ComSafeArrayIn(BYTE, aBytes));
    STDMETHOD(DetectOS)(BSTR *aOs);
    STDMETHOD(GetRegister)(ULONG aCpuId,
                           IN_BSTR aName,
                           BSTR *aValue);
    STDMETHOD(GetRegisters)(ULONG aCpuId,
                            ComSafeArrayOut(BSTR, aNames),
                            ComSafeArrayOut(BSTR, aValues));
    STDMETHOD(SetRegister)(ULONG aCpuId,
                           IN_BSTR aName,
                           IN_BSTR aValue);
    STDMETHOD(SetRegisters)(ULONG aCpuId,
                            ComSafeArrayIn(IN_BSTR, aNames),
                            ComSafeArrayIn(IN_BSTR, aValues));
    STDMETHOD(DumpGuestStack)(ULONG aCpuId,
                              BSTR *aStack);
    STDMETHOD(ResetStats)(IN_BSTR aPattern);
    STDMETHOD(DumpStats)(IN_BSTR aPattern);
    STDMETHOD(GetStats)(IN_BSTR aPattern,
                        BOOL aWithDescriptions,
                        BSTR *aStats);

private:
    // wrapped IMachineDebugger properties
    virtual HRESULT getSingleStep(BOOL *aSingleStep) = 0;
    virtual HRESULT setSingleStep(BOOL aSingleStep) = 0;
    virtual HRESULT getRecompileUser(BOOL *aRecompileUser) = 0;
    virtual HRESULT setRecompileUser(BOOL aRecompileUser) = 0;
    virtual HRESULT getRecompileSupervisor(BOOL *aRecompileSupervisor) = 0;
    virtual HRESULT setRecompileSupervisor(BOOL aRecompileSupervisor) = 0;
    virtual HRESULT getExecuteAllInIEM(BOOL *aExecuteAllInIEM) = 0;
    virtual HRESULT setExecuteAllInIEM(BOOL aExecuteAllInIEM) = 0;
    virtual HRESULT getPATMEnabled(BOOL *aPATMEnabled) = 0;
    virtual HRESULT setPATMEnabled(BOOL aPATMEnabled) = 0;
    virtual HRESULT getCSAMEnabled(BOOL *aCSAMEnabled) = 0;
    virtual HRESULT setCSAMEnabled(BOOL aCSAMEnabled) = 0;
    virtual HRESULT getLogEnabled(BOOL *aLogEnabled) = 0;
    virtual HRESULT setLogEnabled(BOOL aLogEnabled) = 0;
    virtual HRESULT getLogDbgFlags(com::Utf8Str &aLogDbgFlags) = 0;
    virtual HRESULT getLogDbgGroups(com::Utf8Str &aLogDbgGroups) = 0;
    virtual HRESULT getLogDbgDestinations(com::Utf8Str &aLogDbgDestinations) = 0;
    virtual HRESULT getLogRelFlags(com::Utf8Str &aLogRelFlags) = 0;
    virtual HRESULT getLogRelGroups(com::Utf8Str &aLogRelGroups) = 0;
    virtual HRESULT getLogRelDestinations(com::Utf8Str &aLogRelDestinations) = 0;
    virtual HRESULT getHWVirtExEnabled(BOOL *aHWVirtExEnabled) = 0;
    virtual HRESULT getHWVirtExNestedPagingEnabled(BOOL *aHWVirtExNestedPagingEnabled) = 0;
    virtual HRESULT getHWVirtExVPIDEnabled(BOOL *aHWVirtExVPIDEnabled) = 0;
    virtual HRESULT getHWVirtExUXEnabled(BOOL *aHWVirtExUXEnabled) = 0;
    virtual HRESULT getOSName(com::Utf8Str &aOSName) = 0;
    virtual HRESULT getOSVersion(com::Utf8Str &aOSVersion) = 0;
    virtual HRESULT getPAEEnabled(BOOL *aPAEEnabled) = 0;
    virtual HRESULT getVirtualTimeRate(ULONG *aVirtualTimeRate) = 0;
    virtual HRESULT setVirtualTimeRate(ULONG aVirtualTimeRate) = 0;
    virtual HRESULT getVM(LONG64 *aVM) = 0;

    // wrapped IMachineDebugger methods
    virtual HRESULT dumpGuestCore(const com::Utf8Str &aFilename,
                                  const com::Utf8Str &aCompression) = 0;
    virtual HRESULT dumpHostProcessCore(const com::Utf8Str &aFilename,
                                        const com::Utf8Str &aCompression) = 0;
    virtual HRESULT info(const com::Utf8Str &aName,
                         const com::Utf8Str &aArgs,
                         com::Utf8Str &aInfo) = 0;
    virtual HRESULT injectNMI() = 0;
    virtual HRESULT modifyLogGroups(const com::Utf8Str &aSettings) = 0;
    virtual HRESULT modifyLogFlags(const com::Utf8Str &aSettings) = 0;
    virtual HRESULT modifyLogDestinations(const com::Utf8Str &aSettings) = 0;
    virtual HRESULT readPhysicalMemory(LONG64 aAddress,
                                       ULONG aSize,
                                       std::vector<BYTE> &aBytes) = 0;
    virtual HRESULT writePhysicalMemory(LONG64 aAddress,
                                        ULONG aSize,
                                        const std::vector<BYTE> &aBytes) = 0;
    virtual HRESULT readVirtualMemory(ULONG aCpuId,
                                      LONG64 aAddress,
                                      ULONG aSize,
                                      std::vector<BYTE> &aBytes) = 0;
    virtual HRESULT writeVirtualMemory(ULONG aCpuId,
                                       LONG64 aAddress,
                                       ULONG aSize,
                                       const std::vector<BYTE> &aBytes) = 0;
    virtual HRESULT detectOS(com::Utf8Str &aOs) = 0;
    virtual HRESULT getRegister(ULONG aCpuId,
                                const com::Utf8Str &aName,
                                com::Utf8Str &aValue) = 0;
    virtual HRESULT getRegisters(ULONG aCpuId,
                                 std::vector<com::Utf8Str> &aNames,
                                 std::vector<com::Utf8Str> &aValues) = 0;
    virtual HRESULT setRegister(ULONG aCpuId,
                                const com::Utf8Str &aName,
                                const com::Utf8Str &aValue) = 0;
    virtual HRESULT setRegisters(ULONG aCpuId,
                                 const std::vector<com::Utf8Str> &aNames,
                                 const std::vector<com::Utf8Str> &aValues) = 0;
    virtual HRESULT dumpGuestStack(ULONG aCpuId,
                                   com::Utf8Str &aStack) = 0;
    virtual HRESULT resetStats(const com::Utf8Str &aPattern) = 0;
    virtual HRESULT dumpStats(const com::Utf8Str &aPattern) = 0;
    virtual HRESULT getStats(const com::Utf8Str &aPattern,
                             BOOL aWithDescriptions,
                             com::Utf8Str &aStats) = 0;
};

#endif // !MachineDebuggerWrap_H_

// ##### ENDFILE "MachineDebuggerWrap.h"

// ##### BEGINFILE "MachineDebuggerWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IMachineDebugger.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_MACHINEDEBUGGER

#include "MachineDebuggerWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(MachineDebuggerWrap)

//
// IMachineDebugger properties
//

STDMETHODIMP MachineDebuggerWrap::COMGETTER(SingleStep)(BOOL *aSingleStep)
{
    LogRelFlow(("{%p} %s: enter aSingleStep=%p\n", this, "MachineDebugger::getSingleStep", aSingleStep));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSingleStep);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSingleStep(aSingleStep);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSingleStep=%RTbool hrc=%Rhrc\n", this, "MachineDebugger::getSingleStep", *aSingleStep, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMSETTER(SingleStep)(BOOL aSingleStep)
{
    LogRelFlow(("{%p} %s: enter aSingleStep=%RTbool\n", this, "MachineDebugger::setSingleStep", aSingleStep));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setSingleStep(aSingleStep);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineDebugger::setSingleStep", hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMGETTER(RecompileUser)(BOOL *aRecompileUser)
{
    LogRelFlow(("{%p} %s: enter aRecompileUser=%p\n", this, "MachineDebugger::getRecompileUser", aRecompileUser));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecompileUser);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecompileUser(aRecompileUser);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecompileUser=%RTbool hrc=%Rhrc\n", this, "MachineDebugger::getRecompileUser", *aRecompileUser, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMSETTER(RecompileUser)(BOOL aRecompileUser)
{
    LogRelFlow(("{%p} %s: enter aRecompileUser=%RTbool\n", this, "MachineDebugger::setRecompileUser", aRecompileUser));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setRecompileUser(aRecompileUser);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineDebugger::setRecompileUser", hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMGETTER(RecompileSupervisor)(BOOL *aRecompileSupervisor)
{
    LogRelFlow(("{%p} %s: enter aRecompileSupervisor=%p\n", this, "MachineDebugger::getRecompileSupervisor", aRecompileSupervisor));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRecompileSupervisor);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRecompileSupervisor(aRecompileSupervisor);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRecompileSupervisor=%RTbool hrc=%Rhrc\n", this, "MachineDebugger::getRecompileSupervisor", *aRecompileSupervisor, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMSETTER(RecompileSupervisor)(BOOL aRecompileSupervisor)
{
    LogRelFlow(("{%p} %s: enter aRecompileSupervisor=%RTbool\n", this, "MachineDebugger::setRecompileSupervisor", aRecompileSupervisor));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setRecompileSupervisor(aRecompileSupervisor);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineDebugger::setRecompileSupervisor", hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMGETTER(ExecuteAllInIEM)(BOOL *aExecuteAllInIEM)
{
    LogRelFlow(("{%p} %s: enter aExecuteAllInIEM=%p\n", this, "MachineDebugger::getExecuteAllInIEM", aExecuteAllInIEM));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aExecuteAllInIEM);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getExecuteAllInIEM(aExecuteAllInIEM);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aExecuteAllInIEM=%RTbool hrc=%Rhrc\n", this, "MachineDebugger::getExecuteAllInIEM", *aExecuteAllInIEM, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMSETTER(ExecuteAllInIEM)(BOOL aExecuteAllInIEM)
{
    LogRelFlow(("{%p} %s: enter aExecuteAllInIEM=%RTbool\n", this, "MachineDebugger::setExecuteAllInIEM", aExecuteAllInIEM));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setExecuteAllInIEM(aExecuteAllInIEM);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineDebugger::setExecuteAllInIEM", hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMGETTER(PATMEnabled)(BOOL *aPATMEnabled)
{
    LogRelFlow(("{%p} %s: enter aPATMEnabled=%p\n", this, "MachineDebugger::getPATMEnabled", aPATMEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPATMEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPATMEnabled(aPATMEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPATMEnabled=%RTbool hrc=%Rhrc\n", this, "MachineDebugger::getPATMEnabled", *aPATMEnabled, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMSETTER(PATMEnabled)(BOOL aPATMEnabled)
{
    LogRelFlow(("{%p} %s: enter aPATMEnabled=%RTbool\n", this, "MachineDebugger::setPATMEnabled", aPATMEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setPATMEnabled(aPATMEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineDebugger::setPATMEnabled", hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMGETTER(CSAMEnabled)(BOOL *aCSAMEnabled)
{
    LogRelFlow(("{%p} %s: enter aCSAMEnabled=%p\n", this, "MachineDebugger::getCSAMEnabled", aCSAMEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCSAMEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getCSAMEnabled(aCSAMEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aCSAMEnabled=%RTbool hrc=%Rhrc\n", this, "MachineDebugger::getCSAMEnabled", *aCSAMEnabled, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMSETTER(CSAMEnabled)(BOOL aCSAMEnabled)
{
    LogRelFlow(("{%p} %s: enter aCSAMEnabled=%RTbool\n", this, "MachineDebugger::setCSAMEnabled", aCSAMEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setCSAMEnabled(aCSAMEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineDebugger::setCSAMEnabled", hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMGETTER(LogEnabled)(BOOL *aLogEnabled)
{
    LogRelFlow(("{%p} %s: enter aLogEnabled=%p\n", this, "MachineDebugger::getLogEnabled", aLogEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLogEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLogEnabled(aLogEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLogEnabled=%RTbool hrc=%Rhrc\n", this, "MachineDebugger::getLogEnabled", *aLogEnabled, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMSETTER(LogEnabled)(BOOL aLogEnabled)
{
    LogRelFlow(("{%p} %s: enter aLogEnabled=%RTbool\n", this, "MachineDebugger::setLogEnabled", aLogEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setLogEnabled(aLogEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineDebugger::setLogEnabled", hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMGETTER(LogDbgFlags)(BSTR *aLogDbgFlags)
{
    LogRelFlow(("{%p} %s: enter aLogDbgFlags=%p\n", this, "MachineDebugger::getLogDbgFlags", aLogDbgFlags));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLogDbgFlags);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLogDbgFlags(BSTROutConverter(aLogDbgFlags).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLogDbgFlags=%ls hrc=%Rhrc\n", this, "MachineDebugger::getLogDbgFlags", *aLogDbgFlags, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMGETTER(LogDbgGroups)(BSTR *aLogDbgGroups)
{
    LogRelFlow(("{%p} %s: enter aLogDbgGroups=%p\n", this, "MachineDebugger::getLogDbgGroups", aLogDbgGroups));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLogDbgGroups);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLogDbgGroups(BSTROutConverter(aLogDbgGroups).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLogDbgGroups=%ls hrc=%Rhrc\n", this, "MachineDebugger::getLogDbgGroups", *aLogDbgGroups, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMGETTER(LogDbgDestinations)(BSTR *aLogDbgDestinations)
{
    LogRelFlow(("{%p} %s: enter aLogDbgDestinations=%p\n", this, "MachineDebugger::getLogDbgDestinations", aLogDbgDestinations));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLogDbgDestinations);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLogDbgDestinations(BSTROutConverter(aLogDbgDestinations).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLogDbgDestinations=%ls hrc=%Rhrc\n", this, "MachineDebugger::getLogDbgDestinations", *aLogDbgDestinations, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMGETTER(LogRelFlags)(BSTR *aLogRelFlags)
{
    LogRelFlow(("{%p} %s: enter aLogRelFlags=%p\n", this, "MachineDebugger::getLogRelFlags", aLogRelFlags));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLogRelFlags);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLogRelFlags(BSTROutConverter(aLogRelFlags).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLogRelFlags=%ls hrc=%Rhrc\n", this, "MachineDebugger::getLogRelFlags", *aLogRelFlags, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMGETTER(LogRelGroups)(BSTR *aLogRelGroups)
{
    LogRelFlow(("{%p} %s: enter aLogRelGroups=%p\n", this, "MachineDebugger::getLogRelGroups", aLogRelGroups));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLogRelGroups);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLogRelGroups(BSTROutConverter(aLogRelGroups).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLogRelGroups=%ls hrc=%Rhrc\n", this, "MachineDebugger::getLogRelGroups", *aLogRelGroups, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMGETTER(LogRelDestinations)(BSTR *aLogRelDestinations)
{
    LogRelFlow(("{%p} %s: enter aLogRelDestinations=%p\n", this, "MachineDebugger::getLogRelDestinations", aLogRelDestinations));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLogRelDestinations);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLogRelDestinations(BSTROutConverter(aLogRelDestinations).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLogRelDestinations=%ls hrc=%Rhrc\n", this, "MachineDebugger::getLogRelDestinations", *aLogRelDestinations, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMGETTER(HWVirtExEnabled)(BOOL *aHWVirtExEnabled)
{
    LogRelFlow(("{%p} %s: enter aHWVirtExEnabled=%p\n", this, "MachineDebugger::getHWVirtExEnabled", aHWVirtExEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHWVirtExEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHWVirtExEnabled(aHWVirtExEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHWVirtExEnabled=%RTbool hrc=%Rhrc\n", this, "MachineDebugger::getHWVirtExEnabled", *aHWVirtExEnabled, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMGETTER(HWVirtExNestedPagingEnabled)(BOOL *aHWVirtExNestedPagingEnabled)
{
    LogRelFlow(("{%p} %s: enter aHWVirtExNestedPagingEnabled=%p\n", this, "MachineDebugger::getHWVirtExNestedPagingEnabled", aHWVirtExNestedPagingEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHWVirtExNestedPagingEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHWVirtExNestedPagingEnabled(aHWVirtExNestedPagingEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHWVirtExNestedPagingEnabled=%RTbool hrc=%Rhrc\n", this, "MachineDebugger::getHWVirtExNestedPagingEnabled", *aHWVirtExNestedPagingEnabled, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMGETTER(HWVirtExVPIDEnabled)(BOOL *aHWVirtExVPIDEnabled)
{
    LogRelFlow(("{%p} %s: enter aHWVirtExVPIDEnabled=%p\n", this, "MachineDebugger::getHWVirtExVPIDEnabled", aHWVirtExVPIDEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHWVirtExVPIDEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHWVirtExVPIDEnabled(aHWVirtExVPIDEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHWVirtExVPIDEnabled=%RTbool hrc=%Rhrc\n", this, "MachineDebugger::getHWVirtExVPIDEnabled", *aHWVirtExVPIDEnabled, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMGETTER(HWVirtExUXEnabled)(BOOL *aHWVirtExUXEnabled)
{
    LogRelFlow(("{%p} %s: enter aHWVirtExUXEnabled=%p\n", this, "MachineDebugger::getHWVirtExUXEnabled", aHWVirtExUXEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHWVirtExUXEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHWVirtExUXEnabled(aHWVirtExUXEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHWVirtExUXEnabled=%RTbool hrc=%Rhrc\n", this, "MachineDebugger::getHWVirtExUXEnabled", *aHWVirtExUXEnabled, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMGETTER(OSName)(BSTR *aOSName)
{
    LogRelFlow(("{%p} %s: enter aOSName=%p\n", this, "MachineDebugger::getOSName", aOSName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOSName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOSName(BSTROutConverter(aOSName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOSName=%ls hrc=%Rhrc\n", this, "MachineDebugger::getOSName", *aOSName, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMGETTER(OSVersion)(BSTR *aOSVersion)
{
    LogRelFlow(("{%p} %s: enter aOSVersion=%p\n", this, "MachineDebugger::getOSVersion", aOSVersion));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOSVersion);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOSVersion(BSTROutConverter(aOSVersion).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOSVersion=%ls hrc=%Rhrc\n", this, "MachineDebugger::getOSVersion", *aOSVersion, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMGETTER(PAEEnabled)(BOOL *aPAEEnabled)
{
    LogRelFlow(("{%p} %s: enter aPAEEnabled=%p\n", this, "MachineDebugger::getPAEEnabled", aPAEEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPAEEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPAEEnabled(aPAEEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPAEEnabled=%RTbool hrc=%Rhrc\n", this, "MachineDebugger::getPAEEnabled", *aPAEEnabled, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMGETTER(VirtualTimeRate)(ULONG *aVirtualTimeRate)
{
    LogRelFlow(("{%p} %s: enter aVirtualTimeRate=%p\n", this, "MachineDebugger::getVirtualTimeRate", aVirtualTimeRate));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVirtualTimeRate);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVirtualTimeRate(aVirtualTimeRate);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVirtualTimeRate=%RU32 hrc=%Rhrc\n", this, "MachineDebugger::getVirtualTimeRate", *aVirtualTimeRate, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMSETTER(VirtualTimeRate)(ULONG aVirtualTimeRate)
{
    LogRelFlow(("{%p} %s: enter aVirtualTimeRate=%RU32\n", this, "MachineDebugger::setVirtualTimeRate", aVirtualTimeRate));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setVirtualTimeRate(aVirtualTimeRate);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineDebugger::setVirtualTimeRate", hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::COMGETTER(VM)(LONG64 *aVM)
{
    LogRelFlow(("{%p} %s: enter aVM=%p\n", this, "MachineDebugger::getVM", aVM));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVM);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVM(aVM);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVM=%RI64 hrc=%Rhrc\n", this, "MachineDebugger::getVM", *aVM, hrc));
    return hrc;
}

//
// IMachineDebugger methods
//

STDMETHODIMP MachineDebuggerWrap::DumpGuestCore(IN_BSTR aFilename,
                                                IN_BSTR aCompression)
{
    LogRelFlow(("{%p} %s:enter aFilename=%ls aCompression=%ls\n", this, "MachineDebugger::dumpGuestCore", aFilename, aCompression));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = dumpGuestCore(BSTRInConverter(aFilename).str(),
                            BSTRInConverter(aCompression).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineDebugger::dumpGuestCore", hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::DumpHostProcessCore(IN_BSTR aFilename,
                                                      IN_BSTR aCompression)
{
    LogRelFlow(("{%p} %s:enter aFilename=%ls aCompression=%ls\n", this, "MachineDebugger::dumpHostProcessCore", aFilename, aCompression));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = dumpHostProcessCore(BSTRInConverter(aFilename).str(),
                                  BSTRInConverter(aCompression).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineDebugger::dumpHostProcessCore", hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::Info(IN_BSTR aName,
                                       IN_BSTR aArgs,
                                       BSTR *aInfo)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aArgs=%ls aInfo=%p\n", this, "MachineDebugger::info", aName, aArgs, aInfo));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aInfo);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = info(BSTRInConverter(aName).str(),
                   BSTRInConverter(aArgs).str(),
                   BSTROutConverter(aInfo).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aInfo=%ls hrc=%Rhrc\n", this, "MachineDebugger::info", *aInfo, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::InjectNMI()
{
    LogRelFlow(("{%p} %s:enter\n", this, "MachineDebugger::injectNMI"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = injectNMI();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineDebugger::injectNMI", hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::ModifyLogGroups(IN_BSTR aSettings)
{
    LogRelFlow(("{%p} %s:enter aSettings=%ls\n", this, "MachineDebugger::modifyLogGroups", aSettings));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = modifyLogGroups(BSTRInConverter(aSettings).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineDebugger::modifyLogGroups", hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::ModifyLogFlags(IN_BSTR aSettings)
{
    LogRelFlow(("{%p} %s:enter aSettings=%ls\n", this, "MachineDebugger::modifyLogFlags", aSettings));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = modifyLogFlags(BSTRInConverter(aSettings).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineDebugger::modifyLogFlags", hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::ModifyLogDestinations(IN_BSTR aSettings)
{
    LogRelFlow(("{%p} %s:enter aSettings=%ls\n", this, "MachineDebugger::modifyLogDestinations", aSettings));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = modifyLogDestinations(BSTRInConverter(aSettings).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineDebugger::modifyLogDestinations", hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::ReadPhysicalMemory(LONG64 aAddress,
                                                     ULONG aSize,
                                                     ComSafeArrayOut(BYTE, aBytes))
{
    LogRelFlow(("{%p} %s:enter aAddress=%RI64 aSize=%RU32 aBytes=%p\n", this, "MachineDebugger::readPhysicalMemory", aAddress, aSize, aBytes));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBytes);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = readPhysicalMemory(aAddress,
                                 aSize,
                                 ArrayOutConverter<BYTE>(ComSafeArrayOutArg(aBytes)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aBytes=%zu hrc=%Rhrc\n", this, "MachineDebugger::readPhysicalMemory", ComSafeArraySize(*aBytes), hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::WritePhysicalMemory(LONG64 aAddress,
                                                      ULONG aSize,
                                                      ComSafeArrayIn(BYTE, aBytes))
{
    LogRelFlow(("{%p} %s:enter aAddress=%RI64 aSize=%RU32 aBytes=%zu\n", this, "MachineDebugger::writePhysicalMemory", aAddress, aSize, aBytes));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = writePhysicalMemory(aAddress,
                                  aSize,
                                  ArrayInConverter<BYTE>(ComSafeArrayInArg(aBytes)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineDebugger::writePhysicalMemory", hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::ReadVirtualMemory(ULONG aCpuId,
                                                    LONG64 aAddress,
                                                    ULONG aSize,
                                                    ComSafeArrayOut(BYTE, aBytes))
{
    LogRelFlow(("{%p} %s:enter aCpuId=%RU32 aAddress=%RI64 aSize=%RU32 aBytes=%p\n", this, "MachineDebugger::readVirtualMemory", aCpuId, aAddress, aSize, aBytes));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBytes);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = readVirtualMemory(aCpuId,
                                aAddress,
                                aSize,
                                ArrayOutConverter<BYTE>(ComSafeArrayOutArg(aBytes)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aBytes=%zu hrc=%Rhrc\n", this, "MachineDebugger::readVirtualMemory", ComSafeArraySize(*aBytes), hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::WriteVirtualMemory(ULONG aCpuId,
                                                     LONG64 aAddress,
                                                     ULONG aSize,
                                                     ComSafeArrayIn(BYTE, aBytes))
{
    LogRelFlow(("{%p} %s:enter aCpuId=%RU32 aAddress=%RI64 aSize=%RU32 aBytes=%zu\n", this, "MachineDebugger::writeVirtualMemory", aCpuId, aAddress, aSize, aBytes));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = writeVirtualMemory(aCpuId,
                                 aAddress,
                                 aSize,
                                 ArrayInConverter<BYTE>(ComSafeArrayInArg(aBytes)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineDebugger::writeVirtualMemory", hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::DetectOS(BSTR *aOs)
{
    LogRelFlow(("{%p} %s:enter aOs=%p\n", this, "MachineDebugger::detectOS", aOs));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOs);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = detectOS(BSTROutConverter(aOs).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aOs=%ls hrc=%Rhrc\n", this, "MachineDebugger::detectOS", *aOs, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::GetRegister(ULONG aCpuId,
                                              IN_BSTR aName,
                                              BSTR *aValue)
{
    LogRelFlow(("{%p} %s:enter aCpuId=%RU32 aName=%ls aValue=%p\n", this, "MachineDebugger::getRegister", aCpuId, aName, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aValue);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRegister(aCpuId,
                          BSTRInConverter(aName).str(),
                          BSTROutConverter(aValue).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aValue=%ls hrc=%Rhrc\n", this, "MachineDebugger::getRegister", *aValue, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::GetRegisters(ULONG aCpuId,
                                               ComSafeArrayOut(BSTR, aNames),
                                               ComSafeArrayOut(BSTR, aValues))
{
    LogRelFlow(("{%p} %s:enter aCpuId=%RU32 aNames=%p aValues=%p\n", this, "MachineDebugger::getRegisters", aCpuId, aNames, aValues));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNames);
        CheckComArgOutPointerValidThrow(aValues);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRegisters(aCpuId,
                           ArrayBSTROutConverter(ComSafeArrayOutArg(aNames)).array(),
                           ArrayBSTROutConverter(ComSafeArrayOutArg(aValues)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNames=%zu *aValues=%zu hrc=%Rhrc\n", this, "MachineDebugger::getRegisters", ComSafeArraySize(*aNames), ComSafeArraySize(*aValues), hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::SetRegister(ULONG aCpuId,
                                              IN_BSTR aName,
                                              IN_BSTR aValue)
{
    LogRelFlow(("{%p} %s:enter aCpuId=%RU32 aName=%ls aValue=%ls\n", this, "MachineDebugger::setRegister", aCpuId, aName, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setRegister(aCpuId,
                          BSTRInConverter(aName).str(),
                          BSTRInConverter(aValue).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineDebugger::setRegister", hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::SetRegisters(ULONG aCpuId,
                                               ComSafeArrayIn(IN_BSTR, aNames),
                                               ComSafeArrayIn(IN_BSTR, aValues))
{
    LogRelFlow(("{%p} %s:enter aCpuId=%RU32 aNames=%zu aValues=%zu\n", this, "MachineDebugger::setRegisters", aCpuId, aNames, aValues));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setRegisters(aCpuId,
                           ArrayBSTRInConverter(ComSafeArrayInArg(aNames)).array(),
                           ArrayBSTRInConverter(ComSafeArrayInArg(aValues)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineDebugger::setRegisters", hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::DumpGuestStack(ULONG aCpuId,
                                                 BSTR *aStack)
{
    LogRelFlow(("{%p} %s:enter aCpuId=%RU32 aStack=%p\n", this, "MachineDebugger::dumpGuestStack", aCpuId, aStack));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStack);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = dumpGuestStack(aCpuId,
                             BSTROutConverter(aStack).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aStack=%ls hrc=%Rhrc\n", this, "MachineDebugger::dumpGuestStack", *aStack, hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::ResetStats(IN_BSTR aPattern)
{
    LogRelFlow(("{%p} %s:enter aPattern=%ls\n", this, "MachineDebugger::resetStats", aPattern));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = resetStats(BSTRInConverter(aPattern).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineDebugger::resetStats", hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::DumpStats(IN_BSTR aPattern)
{
    LogRelFlow(("{%p} %s:enter aPattern=%ls\n", this, "MachineDebugger::dumpStats", aPattern));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = dumpStats(BSTRInConverter(aPattern).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineDebugger::dumpStats", hrc));
    return hrc;
}

STDMETHODIMP MachineDebuggerWrap::GetStats(IN_BSTR aPattern,
                                           BOOL aWithDescriptions,
                                           BSTR *aStats)
{
    LogRelFlow(("{%p} %s:enter aPattern=%ls aWithDescriptions=%RTbool aStats=%p\n", this, "MachineDebugger::getStats", aPattern, aWithDescriptions, aStats));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStats);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getStats(BSTRInConverter(aPattern).str(),
                       aWithDescriptions,
                       BSTROutConverter(aStats).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aStats=%ls hrc=%Rhrc\n", this, "MachineDebugger::getStats", *aStats, hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(MachineDebuggerWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(MachineDebuggerWrap, IMachineDebugger)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "MachineDebuggerWrap.cpp"

// ##### BEGINFILE "USBDeviceFiltersWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IUSBDeviceFilters.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef USBDeviceFiltersWrap_H_
#define USBDeviceFiltersWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE USBDeviceFiltersWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IUSBDeviceFilters)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(USBDeviceFiltersWrap, IUSBDeviceFilters)
    DECLARE_NOT_AGGREGATABLE(USBDeviceFiltersWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(USBDeviceFiltersWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IUSBDeviceFilters)
        COM_INTERFACE_ENTRY2(IDispatch, IUSBDeviceFilters)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(USBDeviceFiltersWrap)

    // public IUSBDeviceFilters properties
    STDMETHOD(COMGETTER(DeviceFilters))(ComSafeArrayOut(IUSBDeviceFilter *, aDeviceFilters));

    // public IUSBDeviceFilters methods
    STDMETHOD(CreateDeviceFilter)(IN_BSTR aName,
                                  IUSBDeviceFilter **aFilter);
    STDMETHOD(InsertDeviceFilter)(ULONG aPosition,
                                  IUSBDeviceFilter *aFilter);
    STDMETHOD(RemoveDeviceFilter)(ULONG aPosition,
                                  IUSBDeviceFilter **aFilter);

private:
    // wrapped IUSBDeviceFilters properties
    virtual HRESULT getDeviceFilters(std::vector<ComPtr<IUSBDeviceFilter> > &aDeviceFilters) = 0;

    // wrapped IUSBDeviceFilters methods
    virtual HRESULT createDeviceFilter(const com::Utf8Str &aName,
                                       ComPtr<IUSBDeviceFilter> &aFilter) = 0;
    virtual HRESULT insertDeviceFilter(ULONG aPosition,
                                       const ComPtr<IUSBDeviceFilter> &aFilter) = 0;
    virtual HRESULT removeDeviceFilter(ULONG aPosition,
                                       ComPtr<IUSBDeviceFilter> &aFilter) = 0;
};

#endif // !USBDeviceFiltersWrap_H_

// ##### ENDFILE "USBDeviceFiltersWrap.h"

// ##### BEGINFILE "USBDeviceFiltersWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IUSBDeviceFilters.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_USBDEVICEFILTERS

#include "USBDeviceFiltersWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(USBDeviceFiltersWrap)

//
// IUSBDeviceFilters properties
//

STDMETHODIMP USBDeviceFiltersWrap::COMGETTER(DeviceFilters)(ComSafeArrayOut(IUSBDeviceFilter *, aDeviceFilters))
{
    LogRelFlow(("{%p} %s: enter aDeviceFilters=%p\n", this, "USBDeviceFilters::getDeviceFilters", aDeviceFilters));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDeviceFilters);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDeviceFilters(ArrayComTypeOutConverter<IUSBDeviceFilter>(ComSafeArrayOutArg(aDeviceFilters)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDeviceFilters=%zu hrc=%Rhrc\n", this, "USBDeviceFilters::getDeviceFilters", ComSafeArraySize(*aDeviceFilters), hrc));
    return hrc;
}

//
// IUSBDeviceFilters methods
//

STDMETHODIMP USBDeviceFiltersWrap::CreateDeviceFilter(IN_BSTR aName,
                                                      IUSBDeviceFilter **aFilter)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aFilter=%p\n", this, "USBDeviceFilters::createDeviceFilter", aName, aFilter));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFilter);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = createDeviceFilter(BSTRInConverter(aName).str(),
                                 ComTypeOutConverter<IUSBDeviceFilter>(aFilter).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aFilter=%p hrc=%Rhrc\n", this, "USBDeviceFilters::createDeviceFilter", *aFilter, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFiltersWrap::InsertDeviceFilter(ULONG aPosition,
                                                      IUSBDeviceFilter *aFilter)
{
    LogRelFlow(("{%p} %s:enter aPosition=%RU32 aFilter=%p\n", this, "USBDeviceFilters::insertDeviceFilter", aPosition, aFilter));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = insertDeviceFilter(aPosition,
                                 ComTypeInConverter<IUSBDeviceFilter>(aFilter).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "USBDeviceFilters::insertDeviceFilter", hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFiltersWrap::RemoveDeviceFilter(ULONG aPosition,
                                                      IUSBDeviceFilter **aFilter)
{
    LogRelFlow(("{%p} %s:enter aPosition=%RU32 aFilter=%p\n", this, "USBDeviceFilters::removeDeviceFilter", aPosition, aFilter));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFilter);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = removeDeviceFilter(aPosition,
                                 ComTypeOutConverter<IUSBDeviceFilter>(aFilter).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aFilter=%p hrc=%Rhrc\n", this, "USBDeviceFilters::removeDeviceFilter", *aFilter, hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(USBDeviceFiltersWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(USBDeviceFiltersWrap, IUSBDeviceFilters)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "USBDeviceFiltersWrap.cpp"

// ##### BEGINFILE "USBControllerWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IUSBController.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef USBControllerWrap_H_
#define USBControllerWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE USBControllerWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IUSBController)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(USBControllerWrap, IUSBController)
    DECLARE_NOT_AGGREGATABLE(USBControllerWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(USBControllerWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IUSBController)
        COM_INTERFACE_ENTRY2(IDispatch, IUSBController)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(USBControllerWrap)

    // public IUSBController properties
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(Type))(USBControllerType_T *aType);
    STDMETHOD(COMGETTER(USBStandard))(USHORT *aUSBStandard);

    // public IUSBController methods

private:
    // wrapped IUSBController properties
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getType(USBControllerType_T *aType) = 0;
    virtual HRESULT getUSBStandard(USHORT *aUSBStandard) = 0;

    // wrapped IUSBController methods
};

#endif // !USBControllerWrap_H_

// ##### ENDFILE "USBControllerWrap.h"

// ##### BEGINFILE "USBControllerWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IUSBController.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_USBCONTROLLER

#include "USBControllerWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(USBControllerWrap)

//
// IUSBController properties
//

STDMETHODIMP USBControllerWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "USBController::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "USBController::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP USBControllerWrap::COMGETTER(Type)(USBControllerType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "USBController::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "USBController::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP USBControllerWrap::COMGETTER(USBStandard)(USHORT *aUSBStandard)
{
    LogRelFlow(("{%p} %s: enter aUSBStandard=%p\n", this, "USBController::getUSBStandard", aUSBStandard));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUSBStandard);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUSBStandard(aUSBStandard);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUSBStandard=%RU16 hrc=%Rhrc\n", this, "USBController::getUSBStandard", *aUSBStandard, hrc));
    return hrc;
}

//
// IUSBController methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(USBControllerWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(USBControllerWrap, IUSBController)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "USBControllerWrap.cpp"

// ##### BEGINFILE "USBDeviceWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IUSBDevice.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef USBDeviceWrap_H_
#define USBDeviceWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE USBDeviceWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IUSBDevice)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(USBDeviceWrap, IUSBDevice)
    DECLARE_NOT_AGGREGATABLE(USBDeviceWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(USBDeviceWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IUSBDevice)
        COM_INTERFACE_ENTRY2(IDispatch, IUSBDevice)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(USBDeviceWrap)

    // public IUSBDevice properties
    STDMETHOD(COMGETTER(Id))(BSTR *aId);
    STDMETHOD(COMGETTER(VendorId))(USHORT *aVendorId);
    STDMETHOD(COMGETTER(ProductId))(USHORT *aProductId);
    STDMETHOD(COMGETTER(Revision))(USHORT *aRevision);
    STDMETHOD(COMGETTER(Manufacturer))(BSTR *aManufacturer);
    STDMETHOD(COMGETTER(Product))(BSTR *aProduct);
    STDMETHOD(COMGETTER(SerialNumber))(BSTR *aSerialNumber);
    STDMETHOD(COMGETTER(Address))(BSTR *aAddress);
    STDMETHOD(COMGETTER(Port))(USHORT *aPort);
    STDMETHOD(COMGETTER(Version))(USHORT *aVersion);
    STDMETHOD(COMGETTER(PortVersion))(USHORT *aPortVersion);
    STDMETHOD(COMGETTER(Remote))(BOOL *aRemote);

    // public IUSBDevice methods

private:
    // wrapped IUSBDevice properties
    virtual HRESULT getId(com::Guid &aId) = 0;
    virtual HRESULT getVendorId(USHORT *aVendorId) = 0;
    virtual HRESULT getProductId(USHORT *aProductId) = 0;
    virtual HRESULT getRevision(USHORT *aRevision) = 0;
    virtual HRESULT getManufacturer(com::Utf8Str &aManufacturer) = 0;
    virtual HRESULT getProduct(com::Utf8Str &aProduct) = 0;
    virtual HRESULT getSerialNumber(com::Utf8Str &aSerialNumber) = 0;
    virtual HRESULT getAddress(com::Utf8Str &aAddress) = 0;
    virtual HRESULT getPort(USHORT *aPort) = 0;
    virtual HRESULT getVersion(USHORT *aVersion) = 0;
    virtual HRESULT getPortVersion(USHORT *aPortVersion) = 0;
    virtual HRESULT getRemote(BOOL *aRemote) = 0;

    // wrapped IUSBDevice methods
};

#endif // !USBDeviceWrap_H_

// ##### ENDFILE "USBDeviceWrap.h"

// ##### BEGINFILE "USBDeviceWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IUSBDevice.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_USBDEVICE

#include "USBDeviceWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(USBDeviceWrap)

//
// IUSBDevice properties
//

STDMETHODIMP USBDeviceWrap::COMGETTER(Id)(BSTR *aId)
{
    LogRelFlow(("{%p} %s: enter aId=%p\n", this, "USBDevice::getId", aId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getId(UuidOutConverter(aId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aId=%ls hrc=%Rhrc\n", this, "USBDevice::getId", *aId, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceWrap::COMGETTER(VendorId)(USHORT *aVendorId)
{
    LogRelFlow(("{%p} %s: enter aVendorId=%p\n", this, "USBDevice::getVendorId", aVendorId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVendorId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVendorId(aVendorId);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVendorId=%RU16 hrc=%Rhrc\n", this, "USBDevice::getVendorId", *aVendorId, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceWrap::COMGETTER(ProductId)(USHORT *aProductId)
{
    LogRelFlow(("{%p} %s: enter aProductId=%p\n", this, "USBDevice::getProductId", aProductId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProductId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProductId(aProductId);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProductId=%RU16 hrc=%Rhrc\n", this, "USBDevice::getProductId", *aProductId, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceWrap::COMGETTER(Revision)(USHORT *aRevision)
{
    LogRelFlow(("{%p} %s: enter aRevision=%p\n", this, "USBDevice::getRevision", aRevision));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRevision);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRevision(aRevision);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRevision=%RU16 hrc=%Rhrc\n", this, "USBDevice::getRevision", *aRevision, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceWrap::COMGETTER(Manufacturer)(BSTR *aManufacturer)
{
    LogRelFlow(("{%p} %s: enter aManufacturer=%p\n", this, "USBDevice::getManufacturer", aManufacturer));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aManufacturer);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getManufacturer(BSTROutConverter(aManufacturer).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aManufacturer=%ls hrc=%Rhrc\n", this, "USBDevice::getManufacturer", *aManufacturer, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceWrap::COMGETTER(Product)(BSTR *aProduct)
{
    LogRelFlow(("{%p} %s: enter aProduct=%p\n", this, "USBDevice::getProduct", aProduct));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProduct);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProduct(BSTROutConverter(aProduct).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProduct=%ls hrc=%Rhrc\n", this, "USBDevice::getProduct", *aProduct, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceWrap::COMGETTER(SerialNumber)(BSTR *aSerialNumber)
{
    LogRelFlow(("{%p} %s: enter aSerialNumber=%p\n", this, "USBDevice::getSerialNumber", aSerialNumber));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSerialNumber);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSerialNumber(BSTROutConverter(aSerialNumber).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSerialNumber=%ls hrc=%Rhrc\n", this, "USBDevice::getSerialNumber", *aSerialNumber, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceWrap::COMGETTER(Address)(BSTR *aAddress)
{
    LogRelFlow(("{%p} %s: enter aAddress=%p\n", this, "USBDevice::getAddress", aAddress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAddress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAddress(BSTROutConverter(aAddress).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAddress=%ls hrc=%Rhrc\n", this, "USBDevice::getAddress", *aAddress, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceWrap::COMGETTER(Port)(USHORT *aPort)
{
    LogRelFlow(("{%p} %s: enter aPort=%p\n", this, "USBDevice::getPort", aPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPort);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPort(aPort);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPort=%RU16 hrc=%Rhrc\n", this, "USBDevice::getPort", *aPort, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceWrap::COMGETTER(Version)(USHORT *aVersion)
{
    LogRelFlow(("{%p} %s: enter aVersion=%p\n", this, "USBDevice::getVersion", aVersion));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVersion);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVersion(aVersion);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVersion=%RU16 hrc=%Rhrc\n", this, "USBDevice::getVersion", *aVersion, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceWrap::COMGETTER(PortVersion)(USHORT *aPortVersion)
{
    LogRelFlow(("{%p} %s: enter aPortVersion=%p\n", this, "USBDevice::getPortVersion", aPortVersion));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPortVersion);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPortVersion(aPortVersion);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPortVersion=%RU16 hrc=%Rhrc\n", this, "USBDevice::getPortVersion", *aPortVersion, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceWrap::COMGETTER(Remote)(BOOL *aRemote)
{
    LogRelFlow(("{%p} %s: enter aRemote=%p\n", this, "USBDevice::getRemote", aRemote));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRemote);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRemote(aRemote);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRemote=%RTbool hrc=%Rhrc\n", this, "USBDevice::getRemote", *aRemote, hrc));
    return hrc;
}

//
// IUSBDevice methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(USBDeviceWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(USBDeviceWrap, IUSBDevice)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "USBDeviceWrap.cpp"

// ##### BEGINFILE "USBDeviceFilterWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IUSBDeviceFilter.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef USBDeviceFilterWrap_H_
#define USBDeviceFilterWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE USBDeviceFilterWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IUSBDeviceFilter)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(USBDeviceFilterWrap, IUSBDeviceFilter)
    DECLARE_NOT_AGGREGATABLE(USBDeviceFilterWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(USBDeviceFilterWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IUSBDeviceFilter)
        COM_INTERFACE_ENTRY2(IDispatch, IUSBDeviceFilter)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(USBDeviceFilterWrap)

    // public IUSBDeviceFilter properties
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMSETTER(Name))(IN_BSTR aName);
    STDMETHOD(COMGETTER(Active))(BOOL *aActive);
    STDMETHOD(COMSETTER(Active))(BOOL aActive);
    STDMETHOD(COMGETTER(VendorId))(BSTR *aVendorId);
    STDMETHOD(COMSETTER(VendorId))(IN_BSTR aVendorId);
    STDMETHOD(COMGETTER(ProductId))(BSTR *aProductId);
    STDMETHOD(COMSETTER(ProductId))(IN_BSTR aProductId);
    STDMETHOD(COMGETTER(Revision))(BSTR *aRevision);
    STDMETHOD(COMSETTER(Revision))(IN_BSTR aRevision);
    STDMETHOD(COMGETTER(Manufacturer))(BSTR *aManufacturer);
    STDMETHOD(COMSETTER(Manufacturer))(IN_BSTR aManufacturer);
    STDMETHOD(COMGETTER(Product))(BSTR *aProduct);
    STDMETHOD(COMSETTER(Product))(IN_BSTR aProduct);
    STDMETHOD(COMGETTER(SerialNumber))(BSTR *aSerialNumber);
    STDMETHOD(COMSETTER(SerialNumber))(IN_BSTR aSerialNumber);
    STDMETHOD(COMGETTER(Port))(BSTR *aPort);
    STDMETHOD(COMSETTER(Port))(IN_BSTR aPort);
    STDMETHOD(COMGETTER(Remote))(BSTR *aRemote);
    STDMETHOD(COMSETTER(Remote))(IN_BSTR aRemote);
    STDMETHOD(COMGETTER(MaskedInterfaces))(ULONG *aMaskedInterfaces);
    STDMETHOD(COMSETTER(MaskedInterfaces))(ULONG aMaskedInterfaces);

    // public IUSBDeviceFilter methods

private:
    // wrapped IUSBDeviceFilter properties
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT setName(const com::Utf8Str &aName) = 0;
    virtual HRESULT getActive(BOOL *aActive) = 0;
    virtual HRESULT setActive(BOOL aActive) = 0;
    virtual HRESULT getVendorId(com::Utf8Str &aVendorId) = 0;
    virtual HRESULT setVendorId(const com::Utf8Str &aVendorId) = 0;
    virtual HRESULT getProductId(com::Utf8Str &aProductId) = 0;
    virtual HRESULT setProductId(const com::Utf8Str &aProductId) = 0;
    virtual HRESULT getRevision(com::Utf8Str &aRevision) = 0;
    virtual HRESULT setRevision(const com::Utf8Str &aRevision) = 0;
    virtual HRESULT getManufacturer(com::Utf8Str &aManufacturer) = 0;
    virtual HRESULT setManufacturer(const com::Utf8Str &aManufacturer) = 0;
    virtual HRESULT getProduct(com::Utf8Str &aProduct) = 0;
    virtual HRESULT setProduct(const com::Utf8Str &aProduct) = 0;
    virtual HRESULT getSerialNumber(com::Utf8Str &aSerialNumber) = 0;
    virtual HRESULT setSerialNumber(const com::Utf8Str &aSerialNumber) = 0;
    virtual HRESULT getPort(com::Utf8Str &aPort) = 0;
    virtual HRESULT setPort(const com::Utf8Str &aPort) = 0;
    virtual HRESULT getRemote(com::Utf8Str &aRemote) = 0;
    virtual HRESULT setRemote(const com::Utf8Str &aRemote) = 0;
    virtual HRESULT getMaskedInterfaces(ULONG *aMaskedInterfaces) = 0;
    virtual HRESULT setMaskedInterfaces(ULONG aMaskedInterfaces) = 0;

    // wrapped IUSBDeviceFilter methods
};

#endif // !USBDeviceFilterWrap_H_

// ##### ENDFILE "USBDeviceFilterWrap.h"

// ##### BEGINFILE "USBDeviceFilterWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IUSBDeviceFilter.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_USBDEVICEFILTER

#include "USBDeviceFilterWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(USBDeviceFilterWrap)

//
// IUSBDeviceFilter properties
//

STDMETHODIMP USBDeviceFilterWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "USBDeviceFilter::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "USBDeviceFilter::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFilterWrap::COMSETTER(Name)(IN_BSTR aName)
{
    LogRelFlow(("{%p} %s: enter aName=%ls\n", this, "USBDeviceFilter::setName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setName(BSTRInConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "USBDeviceFilter::setName", hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFilterWrap::COMGETTER(Active)(BOOL *aActive)
{
    LogRelFlow(("{%p} %s: enter aActive=%p\n", this, "USBDeviceFilter::getActive", aActive));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aActive);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getActive(aActive);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aActive=%RTbool hrc=%Rhrc\n", this, "USBDeviceFilter::getActive", *aActive, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFilterWrap::COMSETTER(Active)(BOOL aActive)
{
    LogRelFlow(("{%p} %s: enter aActive=%RTbool\n", this, "USBDeviceFilter::setActive", aActive));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setActive(aActive);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "USBDeviceFilter::setActive", hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFilterWrap::COMGETTER(VendorId)(BSTR *aVendorId)
{
    LogRelFlow(("{%p} %s: enter aVendorId=%p\n", this, "USBDeviceFilter::getVendorId", aVendorId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVendorId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVendorId(BSTROutConverter(aVendorId).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVendorId=%ls hrc=%Rhrc\n", this, "USBDeviceFilter::getVendorId", *aVendorId, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFilterWrap::COMSETTER(VendorId)(IN_BSTR aVendorId)
{
    LogRelFlow(("{%p} %s: enter aVendorId=%ls\n", this, "USBDeviceFilter::setVendorId", aVendorId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setVendorId(BSTRInConverter(aVendorId).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "USBDeviceFilter::setVendorId", hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFilterWrap::COMGETTER(ProductId)(BSTR *aProductId)
{
    LogRelFlow(("{%p} %s: enter aProductId=%p\n", this, "USBDeviceFilter::getProductId", aProductId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProductId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProductId(BSTROutConverter(aProductId).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProductId=%ls hrc=%Rhrc\n", this, "USBDeviceFilter::getProductId", *aProductId, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFilterWrap::COMSETTER(ProductId)(IN_BSTR aProductId)
{
    LogRelFlow(("{%p} %s: enter aProductId=%ls\n", this, "USBDeviceFilter::setProductId", aProductId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProductId(BSTRInConverter(aProductId).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "USBDeviceFilter::setProductId", hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFilterWrap::COMGETTER(Revision)(BSTR *aRevision)
{
    LogRelFlow(("{%p} %s: enter aRevision=%p\n", this, "USBDeviceFilter::getRevision", aRevision));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRevision);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRevision(BSTROutConverter(aRevision).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRevision=%ls hrc=%Rhrc\n", this, "USBDeviceFilter::getRevision", *aRevision, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFilterWrap::COMSETTER(Revision)(IN_BSTR aRevision)
{
    LogRelFlow(("{%p} %s: enter aRevision=%ls\n", this, "USBDeviceFilter::setRevision", aRevision));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setRevision(BSTRInConverter(aRevision).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "USBDeviceFilter::setRevision", hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFilterWrap::COMGETTER(Manufacturer)(BSTR *aManufacturer)
{
    LogRelFlow(("{%p} %s: enter aManufacturer=%p\n", this, "USBDeviceFilter::getManufacturer", aManufacturer));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aManufacturer);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getManufacturer(BSTROutConverter(aManufacturer).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aManufacturer=%ls hrc=%Rhrc\n", this, "USBDeviceFilter::getManufacturer", *aManufacturer, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFilterWrap::COMSETTER(Manufacturer)(IN_BSTR aManufacturer)
{
    LogRelFlow(("{%p} %s: enter aManufacturer=%ls\n", this, "USBDeviceFilter::setManufacturer", aManufacturer));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setManufacturer(BSTRInConverter(aManufacturer).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "USBDeviceFilter::setManufacturer", hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFilterWrap::COMGETTER(Product)(BSTR *aProduct)
{
    LogRelFlow(("{%p} %s: enter aProduct=%p\n", this, "USBDeviceFilter::getProduct", aProduct));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProduct);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProduct(BSTROutConverter(aProduct).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProduct=%ls hrc=%Rhrc\n", this, "USBDeviceFilter::getProduct", *aProduct, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFilterWrap::COMSETTER(Product)(IN_BSTR aProduct)
{
    LogRelFlow(("{%p} %s: enter aProduct=%ls\n", this, "USBDeviceFilter::setProduct", aProduct));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProduct(BSTRInConverter(aProduct).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "USBDeviceFilter::setProduct", hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFilterWrap::COMGETTER(SerialNumber)(BSTR *aSerialNumber)
{
    LogRelFlow(("{%p} %s: enter aSerialNumber=%p\n", this, "USBDeviceFilter::getSerialNumber", aSerialNumber));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSerialNumber);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSerialNumber(BSTROutConverter(aSerialNumber).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSerialNumber=%ls hrc=%Rhrc\n", this, "USBDeviceFilter::getSerialNumber", *aSerialNumber, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFilterWrap::COMSETTER(SerialNumber)(IN_BSTR aSerialNumber)
{
    LogRelFlow(("{%p} %s: enter aSerialNumber=%ls\n", this, "USBDeviceFilter::setSerialNumber", aSerialNumber));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setSerialNumber(BSTRInConverter(aSerialNumber).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "USBDeviceFilter::setSerialNumber", hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFilterWrap::COMGETTER(Port)(BSTR *aPort)
{
    LogRelFlow(("{%p} %s: enter aPort=%p\n", this, "USBDeviceFilter::getPort", aPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPort);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPort(BSTROutConverter(aPort).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPort=%ls hrc=%Rhrc\n", this, "USBDeviceFilter::getPort", *aPort, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFilterWrap::COMSETTER(Port)(IN_BSTR aPort)
{
    LogRelFlow(("{%p} %s: enter aPort=%ls\n", this, "USBDeviceFilter::setPort", aPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setPort(BSTRInConverter(aPort).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "USBDeviceFilter::setPort", hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFilterWrap::COMGETTER(Remote)(BSTR *aRemote)
{
    LogRelFlow(("{%p} %s: enter aRemote=%p\n", this, "USBDeviceFilter::getRemote", aRemote));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRemote);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRemote(BSTROutConverter(aRemote).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRemote=%ls hrc=%Rhrc\n", this, "USBDeviceFilter::getRemote", *aRemote, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFilterWrap::COMSETTER(Remote)(IN_BSTR aRemote)
{
    LogRelFlow(("{%p} %s: enter aRemote=%ls\n", this, "USBDeviceFilter::setRemote", aRemote));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setRemote(BSTRInConverter(aRemote).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "USBDeviceFilter::setRemote", hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFilterWrap::COMGETTER(MaskedInterfaces)(ULONG *aMaskedInterfaces)
{
    LogRelFlow(("{%p} %s: enter aMaskedInterfaces=%p\n", this, "USBDeviceFilter::getMaskedInterfaces", aMaskedInterfaces));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMaskedInterfaces);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMaskedInterfaces(aMaskedInterfaces);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMaskedInterfaces=%RU32 hrc=%Rhrc\n", this, "USBDeviceFilter::getMaskedInterfaces", *aMaskedInterfaces, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceFilterWrap::COMSETTER(MaskedInterfaces)(ULONG aMaskedInterfaces)
{
    LogRelFlow(("{%p} %s: enter aMaskedInterfaces=%RU32\n", this, "USBDeviceFilter::setMaskedInterfaces", aMaskedInterfaces));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setMaskedInterfaces(aMaskedInterfaces);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "USBDeviceFilter::setMaskedInterfaces", hrc));
    return hrc;
}

//
// IUSBDeviceFilter methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(USBDeviceFilterWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(USBDeviceFilterWrap, IUSBDeviceFilter)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "USBDeviceFilterWrap.cpp"

// ##### BEGINFILE "HostUSBDeviceWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IHostUSBDevice.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef HostUSBDeviceWrap_H_
#define HostUSBDeviceWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE HostUSBDeviceWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IHostUSBDevice)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(HostUSBDeviceWrap, IHostUSBDevice)
    DECLARE_NOT_AGGREGATABLE(HostUSBDeviceWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(HostUSBDeviceWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IHostUSBDevice)
        COM_INTERFACE_ENTRY(IUSBDevice)
        COM_INTERFACE_ENTRY2(IDispatch, IHostUSBDevice)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(HostUSBDeviceWrap)

    // public IUSBDevice properties
    STDMETHOD(COMGETTER(Id))(BSTR *aId);
    STDMETHOD(COMGETTER(VendorId))(USHORT *aVendorId);
    STDMETHOD(COMGETTER(ProductId))(USHORT *aProductId);
    STDMETHOD(COMGETTER(Revision))(USHORT *aRevision);
    STDMETHOD(COMGETTER(Manufacturer))(BSTR *aManufacturer);
    STDMETHOD(COMGETTER(Product))(BSTR *aProduct);
    STDMETHOD(COMGETTER(SerialNumber))(BSTR *aSerialNumber);
    STDMETHOD(COMGETTER(Address))(BSTR *aAddress);
    STDMETHOD(COMGETTER(Port))(USHORT *aPort);
    STDMETHOD(COMGETTER(Version))(USHORT *aVersion);
    STDMETHOD(COMGETTER(PortVersion))(USHORT *aPortVersion);
    STDMETHOD(COMGETTER(Remote))(BOOL *aRemote);

    // public IHostUSBDevice properties
    STDMETHOD(COMGETTER(State))(USBDeviceState_T *aState);

    // public IUSBDevice methods

    // public IHostUSBDevice methods

private:
    // wrapped IUSBDevice properties
    virtual HRESULT getId(com::Guid &aId) = 0;
    virtual HRESULT getVendorId(USHORT *aVendorId) = 0;
    virtual HRESULT getProductId(USHORT *aProductId) = 0;
    virtual HRESULT getRevision(USHORT *aRevision) = 0;
    virtual HRESULT getManufacturer(com::Utf8Str &aManufacturer) = 0;
    virtual HRESULT getProduct(com::Utf8Str &aProduct) = 0;
    virtual HRESULT getSerialNumber(com::Utf8Str &aSerialNumber) = 0;
    virtual HRESULT getAddress(com::Utf8Str &aAddress) = 0;
    virtual HRESULT getPort(USHORT *aPort) = 0;
    virtual HRESULT getVersion(USHORT *aVersion) = 0;
    virtual HRESULT getPortVersion(USHORT *aPortVersion) = 0;
    virtual HRESULT getRemote(BOOL *aRemote) = 0;

    // wrapped IHostUSBDevice properties
    virtual HRESULT getState(USBDeviceState_T *aState) = 0;

    // wrapped IUSBDevice methods

    // wrapped IHostUSBDevice methods
};

#endif // !HostUSBDeviceWrap_H_

// ##### ENDFILE "HostUSBDeviceWrap.h"

// ##### BEGINFILE "HostUSBDeviceWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IHostUSBDevice.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_HOSTUSBDEVICE

#include "HostUSBDeviceWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(HostUSBDeviceWrap)

//
// IUSBDevice properties
//

STDMETHODIMP HostUSBDeviceWrap::COMGETTER(Id)(BSTR *aId)
{
    LogRelFlow(("{%p} %s: enter aId=%p\n", this, "HostUSBDevice::getId", aId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getId(UuidOutConverter(aId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aId=%ls hrc=%Rhrc\n", this, "HostUSBDevice::getId", *aId, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceWrap::COMGETTER(VendorId)(USHORT *aVendorId)
{
    LogRelFlow(("{%p} %s: enter aVendorId=%p\n", this, "HostUSBDevice::getVendorId", aVendorId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVendorId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVendorId(aVendorId);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVendorId=%RU16 hrc=%Rhrc\n", this, "HostUSBDevice::getVendorId", *aVendorId, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceWrap::COMGETTER(ProductId)(USHORT *aProductId)
{
    LogRelFlow(("{%p} %s: enter aProductId=%p\n", this, "HostUSBDevice::getProductId", aProductId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProductId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProductId(aProductId);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProductId=%RU16 hrc=%Rhrc\n", this, "HostUSBDevice::getProductId", *aProductId, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceWrap::COMGETTER(Revision)(USHORT *aRevision)
{
    LogRelFlow(("{%p} %s: enter aRevision=%p\n", this, "HostUSBDevice::getRevision", aRevision));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRevision);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRevision(aRevision);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRevision=%RU16 hrc=%Rhrc\n", this, "HostUSBDevice::getRevision", *aRevision, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceWrap::COMGETTER(Manufacturer)(BSTR *aManufacturer)
{
    LogRelFlow(("{%p} %s: enter aManufacturer=%p\n", this, "HostUSBDevice::getManufacturer", aManufacturer));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aManufacturer);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getManufacturer(BSTROutConverter(aManufacturer).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aManufacturer=%ls hrc=%Rhrc\n", this, "HostUSBDevice::getManufacturer", *aManufacturer, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceWrap::COMGETTER(Product)(BSTR *aProduct)
{
    LogRelFlow(("{%p} %s: enter aProduct=%p\n", this, "HostUSBDevice::getProduct", aProduct));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProduct);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProduct(BSTROutConverter(aProduct).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProduct=%ls hrc=%Rhrc\n", this, "HostUSBDevice::getProduct", *aProduct, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceWrap::COMGETTER(SerialNumber)(BSTR *aSerialNumber)
{
    LogRelFlow(("{%p} %s: enter aSerialNumber=%p\n", this, "HostUSBDevice::getSerialNumber", aSerialNumber));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSerialNumber);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSerialNumber(BSTROutConverter(aSerialNumber).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSerialNumber=%ls hrc=%Rhrc\n", this, "HostUSBDevice::getSerialNumber", *aSerialNumber, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceWrap::COMGETTER(Address)(BSTR *aAddress)
{
    LogRelFlow(("{%p} %s: enter aAddress=%p\n", this, "HostUSBDevice::getAddress", aAddress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAddress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAddress(BSTROutConverter(aAddress).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAddress=%ls hrc=%Rhrc\n", this, "HostUSBDevice::getAddress", *aAddress, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceWrap::COMGETTER(Port)(USHORT *aPort)
{
    LogRelFlow(("{%p} %s: enter aPort=%p\n", this, "HostUSBDevice::getPort", aPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPort);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPort(aPort);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPort=%RU16 hrc=%Rhrc\n", this, "HostUSBDevice::getPort", *aPort, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceWrap::COMGETTER(Version)(USHORT *aVersion)
{
    LogRelFlow(("{%p} %s: enter aVersion=%p\n", this, "HostUSBDevice::getVersion", aVersion));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVersion);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVersion(aVersion);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVersion=%RU16 hrc=%Rhrc\n", this, "HostUSBDevice::getVersion", *aVersion, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceWrap::COMGETTER(PortVersion)(USHORT *aPortVersion)
{
    LogRelFlow(("{%p} %s: enter aPortVersion=%p\n", this, "HostUSBDevice::getPortVersion", aPortVersion));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPortVersion);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPortVersion(aPortVersion);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPortVersion=%RU16 hrc=%Rhrc\n", this, "HostUSBDevice::getPortVersion", *aPortVersion, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceWrap::COMGETTER(Remote)(BOOL *aRemote)
{
    LogRelFlow(("{%p} %s: enter aRemote=%p\n", this, "HostUSBDevice::getRemote", aRemote));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRemote);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRemote(aRemote);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRemote=%RTbool hrc=%Rhrc\n", this, "HostUSBDevice::getRemote", *aRemote, hrc));
    return hrc;
}

//
// IHostUSBDevice properties
//

STDMETHODIMP HostUSBDeviceWrap::COMGETTER(State)(USBDeviceState_T *aState)
{
    LogRelFlow(("{%p} %s: enter aState=%p\n", this, "HostUSBDevice::getState", aState));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aState);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getState(aState);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aState=%RU32 hrc=%Rhrc\n", this, "HostUSBDevice::getState", *aState, hrc));
    return hrc;
}

//
// IUSBDevice methods
//

//
// IHostUSBDevice methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(HostUSBDeviceWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(HostUSBDeviceWrap, IHostUSBDevice, IUSBDevice)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "HostUSBDeviceWrap.cpp"

// ##### BEGINFILE "HostUSBDeviceFilterWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IHostUSBDeviceFilter.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef HostUSBDeviceFilterWrap_H_
#define HostUSBDeviceFilterWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE HostUSBDeviceFilterWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IHostUSBDeviceFilter)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(HostUSBDeviceFilterWrap, IHostUSBDeviceFilter)
    DECLARE_NOT_AGGREGATABLE(HostUSBDeviceFilterWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(HostUSBDeviceFilterWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IHostUSBDeviceFilter)
        COM_INTERFACE_ENTRY(IUSBDeviceFilter)
        COM_INTERFACE_ENTRY2(IDispatch, IHostUSBDeviceFilter)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(HostUSBDeviceFilterWrap)

    // public IUSBDeviceFilter properties
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMSETTER(Name))(IN_BSTR aName);
    STDMETHOD(COMGETTER(Active))(BOOL *aActive);
    STDMETHOD(COMSETTER(Active))(BOOL aActive);
    STDMETHOD(COMGETTER(VendorId))(BSTR *aVendorId);
    STDMETHOD(COMSETTER(VendorId))(IN_BSTR aVendorId);
    STDMETHOD(COMGETTER(ProductId))(BSTR *aProductId);
    STDMETHOD(COMSETTER(ProductId))(IN_BSTR aProductId);
    STDMETHOD(COMGETTER(Revision))(BSTR *aRevision);
    STDMETHOD(COMSETTER(Revision))(IN_BSTR aRevision);
    STDMETHOD(COMGETTER(Manufacturer))(BSTR *aManufacturer);
    STDMETHOD(COMSETTER(Manufacturer))(IN_BSTR aManufacturer);
    STDMETHOD(COMGETTER(Product))(BSTR *aProduct);
    STDMETHOD(COMSETTER(Product))(IN_BSTR aProduct);
    STDMETHOD(COMGETTER(SerialNumber))(BSTR *aSerialNumber);
    STDMETHOD(COMSETTER(SerialNumber))(IN_BSTR aSerialNumber);
    STDMETHOD(COMGETTER(Port))(BSTR *aPort);
    STDMETHOD(COMSETTER(Port))(IN_BSTR aPort);
    STDMETHOD(COMGETTER(Remote))(BSTR *aRemote);
    STDMETHOD(COMSETTER(Remote))(IN_BSTR aRemote);
    STDMETHOD(COMGETTER(MaskedInterfaces))(ULONG *aMaskedInterfaces);
    STDMETHOD(COMSETTER(MaskedInterfaces))(ULONG aMaskedInterfaces);

    // public IHostUSBDeviceFilter properties
    STDMETHOD(COMGETTER(Action))(USBDeviceFilterAction_T *aAction);
    STDMETHOD(COMSETTER(Action))(USBDeviceFilterAction_T aAction);

    // public IUSBDeviceFilter methods

    // public IHostUSBDeviceFilter methods

private:
    // wrapped IUSBDeviceFilter properties
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT setName(const com::Utf8Str &aName) = 0;
    virtual HRESULT getActive(BOOL *aActive) = 0;
    virtual HRESULT setActive(BOOL aActive) = 0;
    virtual HRESULT getVendorId(com::Utf8Str &aVendorId) = 0;
    virtual HRESULT setVendorId(const com::Utf8Str &aVendorId) = 0;
    virtual HRESULT getProductId(com::Utf8Str &aProductId) = 0;
    virtual HRESULT setProductId(const com::Utf8Str &aProductId) = 0;
    virtual HRESULT getRevision(com::Utf8Str &aRevision) = 0;
    virtual HRESULT setRevision(const com::Utf8Str &aRevision) = 0;
    virtual HRESULT getManufacturer(com::Utf8Str &aManufacturer) = 0;
    virtual HRESULT setManufacturer(const com::Utf8Str &aManufacturer) = 0;
    virtual HRESULT getProduct(com::Utf8Str &aProduct) = 0;
    virtual HRESULT setProduct(const com::Utf8Str &aProduct) = 0;
    virtual HRESULT getSerialNumber(com::Utf8Str &aSerialNumber) = 0;
    virtual HRESULT setSerialNumber(const com::Utf8Str &aSerialNumber) = 0;
    virtual HRESULT getPort(com::Utf8Str &aPort) = 0;
    virtual HRESULT setPort(const com::Utf8Str &aPort) = 0;
    virtual HRESULT getRemote(com::Utf8Str &aRemote) = 0;
    virtual HRESULT setRemote(const com::Utf8Str &aRemote) = 0;
    virtual HRESULT getMaskedInterfaces(ULONG *aMaskedInterfaces) = 0;
    virtual HRESULT setMaskedInterfaces(ULONG aMaskedInterfaces) = 0;

    // wrapped IHostUSBDeviceFilter properties
    virtual HRESULT getAction(USBDeviceFilterAction_T *aAction) = 0;
    virtual HRESULT setAction(USBDeviceFilterAction_T aAction) = 0;

    // wrapped IUSBDeviceFilter methods

    // wrapped IHostUSBDeviceFilter methods
};

#endif // !HostUSBDeviceFilterWrap_H_

// ##### ENDFILE "HostUSBDeviceFilterWrap.h"

// ##### BEGINFILE "HostUSBDeviceFilterWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IHostUSBDeviceFilter.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_HOSTUSBDEVICEFILTER

#include "HostUSBDeviceFilterWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(HostUSBDeviceFilterWrap)

//
// IUSBDeviceFilter properties
//

STDMETHODIMP HostUSBDeviceFilterWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "HostUSBDeviceFilter::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "HostUSBDeviceFilter::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceFilterWrap::COMSETTER(Name)(IN_BSTR aName)
{
    LogRelFlow(("{%p} %s: enter aName=%ls\n", this, "HostUSBDeviceFilter::setName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setName(BSTRInConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "HostUSBDeviceFilter::setName", hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceFilterWrap::COMGETTER(Active)(BOOL *aActive)
{
    LogRelFlow(("{%p} %s: enter aActive=%p\n", this, "HostUSBDeviceFilter::getActive", aActive));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aActive);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getActive(aActive);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aActive=%RTbool hrc=%Rhrc\n", this, "HostUSBDeviceFilter::getActive", *aActive, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceFilterWrap::COMSETTER(Active)(BOOL aActive)
{
    LogRelFlow(("{%p} %s: enter aActive=%RTbool\n", this, "HostUSBDeviceFilter::setActive", aActive));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setActive(aActive);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "HostUSBDeviceFilter::setActive", hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceFilterWrap::COMGETTER(VendorId)(BSTR *aVendorId)
{
    LogRelFlow(("{%p} %s: enter aVendorId=%p\n", this, "HostUSBDeviceFilter::getVendorId", aVendorId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVendorId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVendorId(BSTROutConverter(aVendorId).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVendorId=%ls hrc=%Rhrc\n", this, "HostUSBDeviceFilter::getVendorId", *aVendorId, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceFilterWrap::COMSETTER(VendorId)(IN_BSTR aVendorId)
{
    LogRelFlow(("{%p} %s: enter aVendorId=%ls\n", this, "HostUSBDeviceFilter::setVendorId", aVendorId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setVendorId(BSTRInConverter(aVendorId).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "HostUSBDeviceFilter::setVendorId", hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceFilterWrap::COMGETTER(ProductId)(BSTR *aProductId)
{
    LogRelFlow(("{%p} %s: enter aProductId=%p\n", this, "HostUSBDeviceFilter::getProductId", aProductId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProductId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProductId(BSTROutConverter(aProductId).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProductId=%ls hrc=%Rhrc\n", this, "HostUSBDeviceFilter::getProductId", *aProductId, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceFilterWrap::COMSETTER(ProductId)(IN_BSTR aProductId)
{
    LogRelFlow(("{%p} %s: enter aProductId=%ls\n", this, "HostUSBDeviceFilter::setProductId", aProductId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProductId(BSTRInConverter(aProductId).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "HostUSBDeviceFilter::setProductId", hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceFilterWrap::COMGETTER(Revision)(BSTR *aRevision)
{
    LogRelFlow(("{%p} %s: enter aRevision=%p\n", this, "HostUSBDeviceFilter::getRevision", aRevision));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRevision);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRevision(BSTROutConverter(aRevision).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRevision=%ls hrc=%Rhrc\n", this, "HostUSBDeviceFilter::getRevision", *aRevision, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceFilterWrap::COMSETTER(Revision)(IN_BSTR aRevision)
{
    LogRelFlow(("{%p} %s: enter aRevision=%ls\n", this, "HostUSBDeviceFilter::setRevision", aRevision));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setRevision(BSTRInConverter(aRevision).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "HostUSBDeviceFilter::setRevision", hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceFilterWrap::COMGETTER(Manufacturer)(BSTR *aManufacturer)
{
    LogRelFlow(("{%p} %s: enter aManufacturer=%p\n", this, "HostUSBDeviceFilter::getManufacturer", aManufacturer));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aManufacturer);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getManufacturer(BSTROutConverter(aManufacturer).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aManufacturer=%ls hrc=%Rhrc\n", this, "HostUSBDeviceFilter::getManufacturer", *aManufacturer, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceFilterWrap::COMSETTER(Manufacturer)(IN_BSTR aManufacturer)
{
    LogRelFlow(("{%p} %s: enter aManufacturer=%ls\n", this, "HostUSBDeviceFilter::setManufacturer", aManufacturer));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setManufacturer(BSTRInConverter(aManufacturer).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "HostUSBDeviceFilter::setManufacturer", hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceFilterWrap::COMGETTER(Product)(BSTR *aProduct)
{
    LogRelFlow(("{%p} %s: enter aProduct=%p\n", this, "HostUSBDeviceFilter::getProduct", aProduct));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProduct);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProduct(BSTROutConverter(aProduct).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProduct=%ls hrc=%Rhrc\n", this, "HostUSBDeviceFilter::getProduct", *aProduct, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceFilterWrap::COMSETTER(Product)(IN_BSTR aProduct)
{
    LogRelFlow(("{%p} %s: enter aProduct=%ls\n", this, "HostUSBDeviceFilter::setProduct", aProduct));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProduct(BSTRInConverter(aProduct).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "HostUSBDeviceFilter::setProduct", hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceFilterWrap::COMGETTER(SerialNumber)(BSTR *aSerialNumber)
{
    LogRelFlow(("{%p} %s: enter aSerialNumber=%p\n", this, "HostUSBDeviceFilter::getSerialNumber", aSerialNumber));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSerialNumber);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSerialNumber(BSTROutConverter(aSerialNumber).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSerialNumber=%ls hrc=%Rhrc\n", this, "HostUSBDeviceFilter::getSerialNumber", *aSerialNumber, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceFilterWrap::COMSETTER(SerialNumber)(IN_BSTR aSerialNumber)
{
    LogRelFlow(("{%p} %s: enter aSerialNumber=%ls\n", this, "HostUSBDeviceFilter::setSerialNumber", aSerialNumber));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setSerialNumber(BSTRInConverter(aSerialNumber).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "HostUSBDeviceFilter::setSerialNumber", hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceFilterWrap::COMGETTER(Port)(BSTR *aPort)
{
    LogRelFlow(("{%p} %s: enter aPort=%p\n", this, "HostUSBDeviceFilter::getPort", aPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPort);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPort(BSTROutConverter(aPort).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPort=%ls hrc=%Rhrc\n", this, "HostUSBDeviceFilter::getPort", *aPort, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceFilterWrap::COMSETTER(Port)(IN_BSTR aPort)
{
    LogRelFlow(("{%p} %s: enter aPort=%ls\n", this, "HostUSBDeviceFilter::setPort", aPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setPort(BSTRInConverter(aPort).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "HostUSBDeviceFilter::setPort", hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceFilterWrap::COMGETTER(Remote)(BSTR *aRemote)
{
    LogRelFlow(("{%p} %s: enter aRemote=%p\n", this, "HostUSBDeviceFilter::getRemote", aRemote));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRemote);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRemote(BSTROutConverter(aRemote).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRemote=%ls hrc=%Rhrc\n", this, "HostUSBDeviceFilter::getRemote", *aRemote, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceFilterWrap::COMSETTER(Remote)(IN_BSTR aRemote)
{
    LogRelFlow(("{%p} %s: enter aRemote=%ls\n", this, "HostUSBDeviceFilter::setRemote", aRemote));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setRemote(BSTRInConverter(aRemote).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "HostUSBDeviceFilter::setRemote", hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceFilterWrap::COMGETTER(MaskedInterfaces)(ULONG *aMaskedInterfaces)
{
    LogRelFlow(("{%p} %s: enter aMaskedInterfaces=%p\n", this, "HostUSBDeviceFilter::getMaskedInterfaces", aMaskedInterfaces));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMaskedInterfaces);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMaskedInterfaces(aMaskedInterfaces);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMaskedInterfaces=%RU32 hrc=%Rhrc\n", this, "HostUSBDeviceFilter::getMaskedInterfaces", *aMaskedInterfaces, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceFilterWrap::COMSETTER(MaskedInterfaces)(ULONG aMaskedInterfaces)
{
    LogRelFlow(("{%p} %s: enter aMaskedInterfaces=%RU32\n", this, "HostUSBDeviceFilter::setMaskedInterfaces", aMaskedInterfaces));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setMaskedInterfaces(aMaskedInterfaces);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "HostUSBDeviceFilter::setMaskedInterfaces", hrc));
    return hrc;
}

//
// IHostUSBDeviceFilter properties
//

STDMETHODIMP HostUSBDeviceFilterWrap::COMGETTER(Action)(USBDeviceFilterAction_T *aAction)
{
    LogRelFlow(("{%p} %s: enter aAction=%p\n", this, "HostUSBDeviceFilter::getAction", aAction));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAction);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAction(aAction);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAction=%RU32 hrc=%Rhrc\n", this, "HostUSBDeviceFilter::getAction", *aAction, hrc));
    return hrc;
}

STDMETHODIMP HostUSBDeviceFilterWrap::COMSETTER(Action)(USBDeviceFilterAction_T aAction)
{
    LogRelFlow(("{%p} %s: enter aAction=%RU32\n", this, "HostUSBDeviceFilter::setAction", aAction));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setAction(aAction);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "HostUSBDeviceFilter::setAction", hrc));
    return hrc;
}

//
// IUSBDeviceFilter methods
//

//
// IHostUSBDeviceFilter methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(HostUSBDeviceFilterWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(HostUSBDeviceFilterWrap, IHostUSBDeviceFilter, IUSBDeviceFilter)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "HostUSBDeviceFilterWrap.cpp"

// ##### BEGINFILE "AudioAdapterWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IAudioAdapter.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef AudioAdapterWrap_H_
#define AudioAdapterWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE AudioAdapterWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IAudioAdapter)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(AudioAdapterWrap, IAudioAdapter)
    DECLARE_NOT_AGGREGATABLE(AudioAdapterWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(AudioAdapterWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IAudioAdapter)
        COM_INTERFACE_ENTRY2(IDispatch, IAudioAdapter)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(AudioAdapterWrap)

    // public IAudioAdapter properties
    STDMETHOD(COMGETTER(Enabled))(BOOL *aEnabled);
    STDMETHOD(COMSETTER(Enabled))(BOOL aEnabled);
    STDMETHOD(COMGETTER(AudioController))(AudioControllerType_T *aAudioController);
    STDMETHOD(COMSETTER(AudioController))(AudioControllerType_T aAudioController);
    STDMETHOD(COMGETTER(AudioDriver))(AudioDriverType_T *aAudioDriver);
    STDMETHOD(COMSETTER(AudioDriver))(AudioDriverType_T aAudioDriver);

    // public IAudioAdapter methods

private:
    // wrapped IAudioAdapter properties
    virtual HRESULT getEnabled(BOOL *aEnabled) = 0;
    virtual HRESULT setEnabled(BOOL aEnabled) = 0;
    virtual HRESULT getAudioController(AudioControllerType_T *aAudioController) = 0;
    virtual HRESULT setAudioController(AudioControllerType_T aAudioController) = 0;
    virtual HRESULT getAudioDriver(AudioDriverType_T *aAudioDriver) = 0;
    virtual HRESULT setAudioDriver(AudioDriverType_T aAudioDriver) = 0;

    // wrapped IAudioAdapter methods
};

#endif // !AudioAdapterWrap_H_

// ##### ENDFILE "AudioAdapterWrap.h"

// ##### BEGINFILE "AudioAdapterWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IAudioAdapter.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_AUDIOADAPTER

#include "AudioAdapterWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(AudioAdapterWrap)

//
// IAudioAdapter properties
//

STDMETHODIMP AudioAdapterWrap::COMGETTER(Enabled)(BOOL *aEnabled)
{
    LogRelFlow(("{%p} %s: enter aEnabled=%p\n", this, "AudioAdapter::getEnabled", aEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEnabled(aEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEnabled=%RTbool hrc=%Rhrc\n", this, "AudioAdapter::getEnabled", *aEnabled, hrc));
    return hrc;
}

STDMETHODIMP AudioAdapterWrap::COMSETTER(Enabled)(BOOL aEnabled)
{
    LogRelFlow(("{%p} %s: enter aEnabled=%RTbool\n", this, "AudioAdapter::setEnabled", aEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setEnabled(aEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "AudioAdapter::setEnabled", hrc));
    return hrc;
}

STDMETHODIMP AudioAdapterWrap::COMGETTER(AudioController)(AudioControllerType_T *aAudioController)
{
    LogRelFlow(("{%p} %s: enter aAudioController=%p\n", this, "AudioAdapter::getAudioController", aAudioController));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAudioController);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAudioController(aAudioController);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAudioController=%RU32 hrc=%Rhrc\n", this, "AudioAdapter::getAudioController", *aAudioController, hrc));
    return hrc;
}

STDMETHODIMP AudioAdapterWrap::COMSETTER(AudioController)(AudioControllerType_T aAudioController)
{
    LogRelFlow(("{%p} %s: enter aAudioController=%RU32\n", this, "AudioAdapter::setAudioController", aAudioController));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setAudioController(aAudioController);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "AudioAdapter::setAudioController", hrc));
    return hrc;
}

STDMETHODIMP AudioAdapterWrap::COMGETTER(AudioDriver)(AudioDriverType_T *aAudioDriver)
{
    LogRelFlow(("{%p} %s: enter aAudioDriver=%p\n", this, "AudioAdapter::getAudioDriver", aAudioDriver));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAudioDriver);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAudioDriver(aAudioDriver);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAudioDriver=%RU32 hrc=%Rhrc\n", this, "AudioAdapter::getAudioDriver", *aAudioDriver, hrc));
    return hrc;
}

STDMETHODIMP AudioAdapterWrap::COMSETTER(AudioDriver)(AudioDriverType_T aAudioDriver)
{
    LogRelFlow(("{%p} %s: enter aAudioDriver=%RU32\n", this, "AudioAdapter::setAudioDriver", aAudioDriver));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setAudioDriver(aAudioDriver);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "AudioAdapter::setAudioDriver", hrc));
    return hrc;
}

//
// IAudioAdapter methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(AudioAdapterWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(AudioAdapterWrap, IAudioAdapter)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "AudioAdapterWrap.cpp"

// ##### BEGINFILE "VRDEServerWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IVRDEServer.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef VRDEServerWrap_H_
#define VRDEServerWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE VRDEServerWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IVRDEServer)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(VRDEServerWrap, IVRDEServer)
    DECLARE_NOT_AGGREGATABLE(VRDEServerWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(VRDEServerWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IVRDEServer)
        COM_INTERFACE_ENTRY2(IDispatch, IVRDEServer)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(VRDEServerWrap)

    // public IVRDEServer properties
    STDMETHOD(COMGETTER(Enabled))(BOOL *aEnabled);
    STDMETHOD(COMSETTER(Enabled))(BOOL aEnabled);
    STDMETHOD(COMGETTER(AuthType))(AuthType_T *aAuthType);
    STDMETHOD(COMSETTER(AuthType))(AuthType_T aAuthType);
    STDMETHOD(COMGETTER(AuthTimeout))(ULONG *aAuthTimeout);
    STDMETHOD(COMSETTER(AuthTimeout))(ULONG aAuthTimeout);
    STDMETHOD(COMGETTER(AllowMultiConnection))(BOOL *aAllowMultiConnection);
    STDMETHOD(COMSETTER(AllowMultiConnection))(BOOL aAllowMultiConnection);
    STDMETHOD(COMGETTER(ReuseSingleConnection))(BOOL *aReuseSingleConnection);
    STDMETHOD(COMSETTER(ReuseSingleConnection))(BOOL aReuseSingleConnection);
    STDMETHOD(COMGETTER(VRDEExtPack))(BSTR *aVRDEExtPack);
    STDMETHOD(COMSETTER(VRDEExtPack))(IN_BSTR aVRDEExtPack);
    STDMETHOD(COMGETTER(AuthLibrary))(BSTR *aAuthLibrary);
    STDMETHOD(COMSETTER(AuthLibrary))(IN_BSTR aAuthLibrary);
    STDMETHOD(COMGETTER(VRDEProperties))(ComSafeArrayOut(BSTR, aVRDEProperties));

    // public IVRDEServer methods
    STDMETHOD(SetVRDEProperty)(IN_BSTR aKey,
                               IN_BSTR aValue);
    STDMETHOD(GetVRDEProperty)(IN_BSTR aKey,
                               BSTR *aValue);

private:
    // wrapped IVRDEServer properties
    virtual HRESULT getEnabled(BOOL *aEnabled) = 0;
    virtual HRESULT setEnabled(BOOL aEnabled) = 0;
    virtual HRESULT getAuthType(AuthType_T *aAuthType) = 0;
    virtual HRESULT setAuthType(AuthType_T aAuthType) = 0;
    virtual HRESULT getAuthTimeout(ULONG *aAuthTimeout) = 0;
    virtual HRESULT setAuthTimeout(ULONG aAuthTimeout) = 0;
    virtual HRESULT getAllowMultiConnection(BOOL *aAllowMultiConnection) = 0;
    virtual HRESULT setAllowMultiConnection(BOOL aAllowMultiConnection) = 0;
    virtual HRESULT getReuseSingleConnection(BOOL *aReuseSingleConnection) = 0;
    virtual HRESULT setReuseSingleConnection(BOOL aReuseSingleConnection) = 0;
    virtual HRESULT getVRDEExtPack(com::Utf8Str &aVRDEExtPack) = 0;
    virtual HRESULT setVRDEExtPack(const com::Utf8Str &aVRDEExtPack) = 0;
    virtual HRESULT getAuthLibrary(com::Utf8Str &aAuthLibrary) = 0;
    virtual HRESULT setAuthLibrary(const com::Utf8Str &aAuthLibrary) = 0;
    virtual HRESULT getVRDEProperties(std::vector<com::Utf8Str> &aVRDEProperties) = 0;

    // wrapped IVRDEServer methods
    virtual HRESULT setVRDEProperty(const com::Utf8Str &aKey,
                                    const com::Utf8Str &aValue) = 0;
    virtual HRESULT getVRDEProperty(const com::Utf8Str &aKey,
                                    com::Utf8Str &aValue) = 0;
};

#endif // !VRDEServerWrap_H_

// ##### ENDFILE "VRDEServerWrap.h"

// ##### BEGINFILE "VRDEServerWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IVRDEServer.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_VRDESERVER

#include "VRDEServerWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(VRDEServerWrap)

//
// IVRDEServer properties
//

STDMETHODIMP VRDEServerWrap::COMGETTER(Enabled)(BOOL *aEnabled)
{
    LogRelFlow(("{%p} %s: enter aEnabled=%p\n", this, "VRDEServer::getEnabled", aEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEnabled(aEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEnabled=%RTbool hrc=%Rhrc\n", this, "VRDEServer::getEnabled", *aEnabled, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerWrap::COMSETTER(Enabled)(BOOL aEnabled)
{
    LogRelFlow(("{%p} %s: enter aEnabled=%RTbool\n", this, "VRDEServer::setEnabled", aEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setEnabled(aEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VRDEServer::setEnabled", hrc));
    return hrc;
}

STDMETHODIMP VRDEServerWrap::COMGETTER(AuthType)(AuthType_T *aAuthType)
{
    LogRelFlow(("{%p} %s: enter aAuthType=%p\n", this, "VRDEServer::getAuthType", aAuthType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAuthType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAuthType(aAuthType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAuthType=%RU32 hrc=%Rhrc\n", this, "VRDEServer::getAuthType", *aAuthType, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerWrap::COMSETTER(AuthType)(AuthType_T aAuthType)
{
    LogRelFlow(("{%p} %s: enter aAuthType=%RU32\n", this, "VRDEServer::setAuthType", aAuthType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setAuthType(aAuthType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VRDEServer::setAuthType", hrc));
    return hrc;
}

STDMETHODIMP VRDEServerWrap::COMGETTER(AuthTimeout)(ULONG *aAuthTimeout)
{
    LogRelFlow(("{%p} %s: enter aAuthTimeout=%p\n", this, "VRDEServer::getAuthTimeout", aAuthTimeout));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAuthTimeout);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAuthTimeout(aAuthTimeout);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAuthTimeout=%RU32 hrc=%Rhrc\n", this, "VRDEServer::getAuthTimeout", *aAuthTimeout, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerWrap::COMSETTER(AuthTimeout)(ULONG aAuthTimeout)
{
    LogRelFlow(("{%p} %s: enter aAuthTimeout=%RU32\n", this, "VRDEServer::setAuthTimeout", aAuthTimeout));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setAuthTimeout(aAuthTimeout);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VRDEServer::setAuthTimeout", hrc));
    return hrc;
}

STDMETHODIMP VRDEServerWrap::COMGETTER(AllowMultiConnection)(BOOL *aAllowMultiConnection)
{
    LogRelFlow(("{%p} %s: enter aAllowMultiConnection=%p\n", this, "VRDEServer::getAllowMultiConnection", aAllowMultiConnection));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAllowMultiConnection);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAllowMultiConnection(aAllowMultiConnection);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAllowMultiConnection=%RTbool hrc=%Rhrc\n", this, "VRDEServer::getAllowMultiConnection", *aAllowMultiConnection, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerWrap::COMSETTER(AllowMultiConnection)(BOOL aAllowMultiConnection)
{
    LogRelFlow(("{%p} %s: enter aAllowMultiConnection=%RTbool\n", this, "VRDEServer::setAllowMultiConnection", aAllowMultiConnection));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setAllowMultiConnection(aAllowMultiConnection);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VRDEServer::setAllowMultiConnection", hrc));
    return hrc;
}

STDMETHODIMP VRDEServerWrap::COMGETTER(ReuseSingleConnection)(BOOL *aReuseSingleConnection)
{
    LogRelFlow(("{%p} %s: enter aReuseSingleConnection=%p\n", this, "VRDEServer::getReuseSingleConnection", aReuseSingleConnection));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aReuseSingleConnection);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getReuseSingleConnection(aReuseSingleConnection);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aReuseSingleConnection=%RTbool hrc=%Rhrc\n", this, "VRDEServer::getReuseSingleConnection", *aReuseSingleConnection, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerWrap::COMSETTER(ReuseSingleConnection)(BOOL aReuseSingleConnection)
{
    LogRelFlow(("{%p} %s: enter aReuseSingleConnection=%RTbool\n", this, "VRDEServer::setReuseSingleConnection", aReuseSingleConnection));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setReuseSingleConnection(aReuseSingleConnection);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VRDEServer::setReuseSingleConnection", hrc));
    return hrc;
}

STDMETHODIMP VRDEServerWrap::COMGETTER(VRDEExtPack)(BSTR *aVRDEExtPack)
{
    LogRelFlow(("{%p} %s: enter aVRDEExtPack=%p\n", this, "VRDEServer::getVRDEExtPack", aVRDEExtPack));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVRDEExtPack);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVRDEExtPack(BSTROutConverter(aVRDEExtPack).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVRDEExtPack=%ls hrc=%Rhrc\n", this, "VRDEServer::getVRDEExtPack", *aVRDEExtPack, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerWrap::COMSETTER(VRDEExtPack)(IN_BSTR aVRDEExtPack)
{
    LogRelFlow(("{%p} %s: enter aVRDEExtPack=%ls\n", this, "VRDEServer::setVRDEExtPack", aVRDEExtPack));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setVRDEExtPack(BSTRInConverter(aVRDEExtPack).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VRDEServer::setVRDEExtPack", hrc));
    return hrc;
}

STDMETHODIMP VRDEServerWrap::COMGETTER(AuthLibrary)(BSTR *aAuthLibrary)
{
    LogRelFlow(("{%p} %s: enter aAuthLibrary=%p\n", this, "VRDEServer::getAuthLibrary", aAuthLibrary));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAuthLibrary);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAuthLibrary(BSTROutConverter(aAuthLibrary).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAuthLibrary=%ls hrc=%Rhrc\n", this, "VRDEServer::getAuthLibrary", *aAuthLibrary, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerWrap::COMSETTER(AuthLibrary)(IN_BSTR aAuthLibrary)
{
    LogRelFlow(("{%p} %s: enter aAuthLibrary=%ls\n", this, "VRDEServer::setAuthLibrary", aAuthLibrary));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setAuthLibrary(BSTRInConverter(aAuthLibrary).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VRDEServer::setAuthLibrary", hrc));
    return hrc;
}

STDMETHODIMP VRDEServerWrap::COMGETTER(VRDEProperties)(ComSafeArrayOut(BSTR, aVRDEProperties))
{
    LogRelFlow(("{%p} %s: enter aVRDEProperties=%p\n", this, "VRDEServer::getVRDEProperties", aVRDEProperties));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVRDEProperties);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVRDEProperties(ArrayBSTROutConverter(ComSafeArrayOutArg(aVRDEProperties)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVRDEProperties=%zu hrc=%Rhrc\n", this, "VRDEServer::getVRDEProperties", ComSafeArraySize(*aVRDEProperties), hrc));
    return hrc;
}

//
// IVRDEServer methods
//

STDMETHODIMP VRDEServerWrap::SetVRDEProperty(IN_BSTR aKey,
                                             IN_BSTR aValue)
{
    LogRelFlow(("{%p} %s:enter aKey=%ls aValue=%ls\n", this, "VRDEServer::setVRDEProperty", aKey, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setVRDEProperty(BSTRInConverter(aKey).str(),
                              BSTRInConverter(aValue).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VRDEServer::setVRDEProperty", hrc));
    return hrc;
}

STDMETHODIMP VRDEServerWrap::GetVRDEProperty(IN_BSTR aKey,
                                             BSTR *aValue)
{
    LogRelFlow(("{%p} %s:enter aKey=%ls aValue=%p\n", this, "VRDEServer::getVRDEProperty", aKey, aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aValue);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVRDEProperty(BSTRInConverter(aKey).str(),
                              BSTROutConverter(aValue).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aValue=%ls hrc=%Rhrc\n", this, "VRDEServer::getVRDEProperty", *aValue, hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(VRDEServerWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(VRDEServerWrap, IVRDEServer)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "VRDEServerWrap.cpp"

// ##### BEGINFILE "SharedFolderWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for ISharedFolder.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef SharedFolderWrap_H_
#define SharedFolderWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE SharedFolderWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(ISharedFolder)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(SharedFolderWrap, ISharedFolder)
    DECLARE_NOT_AGGREGATABLE(SharedFolderWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(SharedFolderWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(ISharedFolder)
        COM_INTERFACE_ENTRY2(IDispatch, ISharedFolder)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(SharedFolderWrap)

    // public ISharedFolder properties
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(HostPath))(BSTR *aHostPath);
    STDMETHOD(COMGETTER(Accessible))(BOOL *aAccessible);
    STDMETHOD(COMGETTER(Writable))(BOOL *aWritable);
    STDMETHOD(COMGETTER(AutoMount))(BOOL *aAutoMount);
    STDMETHOD(COMGETTER(LastAccessError))(BSTR *aLastAccessError);

    // public ISharedFolder methods

private:
    // wrapped ISharedFolder properties
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getHostPath(com::Utf8Str &aHostPath) = 0;
    virtual HRESULT getAccessible(BOOL *aAccessible) = 0;
    virtual HRESULT getWritable(BOOL *aWritable) = 0;
    virtual HRESULT getAutoMount(BOOL *aAutoMount) = 0;
    virtual HRESULT getLastAccessError(com::Utf8Str &aLastAccessError) = 0;

    // wrapped ISharedFolder methods
};

#endif // !SharedFolderWrap_H_

// ##### ENDFILE "SharedFolderWrap.h"

// ##### BEGINFILE "SharedFolderWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for ISharedFolder.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_SHAREDFOLDER

#include "SharedFolderWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(SharedFolderWrap)

//
// ISharedFolder properties
//

STDMETHODIMP SharedFolderWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "SharedFolder::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "SharedFolder::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP SharedFolderWrap::COMGETTER(HostPath)(BSTR *aHostPath)
{
    LogRelFlow(("{%p} %s: enter aHostPath=%p\n", this, "SharedFolder::getHostPath", aHostPath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHostPath);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHostPath(BSTROutConverter(aHostPath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHostPath=%ls hrc=%Rhrc\n", this, "SharedFolder::getHostPath", *aHostPath, hrc));
    return hrc;
}

STDMETHODIMP SharedFolderWrap::COMGETTER(Accessible)(BOOL *aAccessible)
{
    LogRelFlow(("{%p} %s: enter aAccessible=%p\n", this, "SharedFolder::getAccessible", aAccessible));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAccessible);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAccessible(aAccessible);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAccessible=%RTbool hrc=%Rhrc\n", this, "SharedFolder::getAccessible", *aAccessible, hrc));
    return hrc;
}

STDMETHODIMP SharedFolderWrap::COMGETTER(Writable)(BOOL *aWritable)
{
    LogRelFlow(("{%p} %s: enter aWritable=%p\n", this, "SharedFolder::getWritable", aWritable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWritable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWritable(aWritable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWritable=%RTbool hrc=%Rhrc\n", this, "SharedFolder::getWritable", *aWritable, hrc));
    return hrc;
}

STDMETHODIMP SharedFolderWrap::COMGETTER(AutoMount)(BOOL *aAutoMount)
{
    LogRelFlow(("{%p} %s: enter aAutoMount=%p\n", this, "SharedFolder::getAutoMount", aAutoMount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAutoMount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAutoMount(aAutoMount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAutoMount=%RTbool hrc=%Rhrc\n", this, "SharedFolder::getAutoMount", *aAutoMount, hrc));
    return hrc;
}

STDMETHODIMP SharedFolderWrap::COMGETTER(LastAccessError)(BSTR *aLastAccessError)
{
    LogRelFlow(("{%p} %s: enter aLastAccessError=%p\n", this, "SharedFolder::getLastAccessError", aLastAccessError));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLastAccessError);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLastAccessError(BSTROutConverter(aLastAccessError).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLastAccessError=%ls hrc=%Rhrc\n", this, "SharedFolder::getLastAccessError", *aLastAccessError, hrc));
    return hrc;
}

//
// ISharedFolder methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(SharedFolderWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(SharedFolderWrap, ISharedFolder)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "SharedFolderWrap.cpp"

// ##### BEGINFILE "InternalSessionControlWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IInternalSessionControl.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef InternalSessionControlWrap_H_
#define InternalSessionControlWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE InternalSessionControlWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IInternalSessionControl)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(InternalSessionControlWrap, IInternalSessionControl)
    DECLARE_NOT_AGGREGATABLE(InternalSessionControlWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(InternalSessionControlWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IInternalSessionControl)
        COM_INTERFACE_ENTRY2(IDispatch, IInternalSessionControl)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(InternalSessionControlWrap)

    // public IInternalSessionControl properties

    // public IInternalSessionControl methods
    STDMETHOD(GetPID)(ULONG *aPid);
    STDMETHOD(GetRemoteConsole)(IConsole **aConsole);
    STDMETHOD(AssignRemoteMachine)(IMachine *aMachine,
                                   IConsole *aConsole);
    STDMETHOD(UpdateMachineState)(MachineState_T aMachineState);
    STDMETHOD(Uninitialize)();
    STDMETHOD(OnNetworkAdapterChange)(INetworkAdapter *aNetworkAdapter,
                                      BOOL aChangeAdapter);
    STDMETHOD(OnSerialPortChange)(ISerialPort *aSerialPort);
    STDMETHOD(OnParallelPortChange)(IParallelPort *aParallelPort);
    STDMETHOD(OnStorageControllerChange)();
    STDMETHOD(OnMediumChange)(IMediumAttachment *aMediumAttachment,
                              BOOL aForce);
    STDMETHOD(OnStorageDeviceChange)(IMediumAttachment *aMediumAttachment,
                                     BOOL aRemove,
                                     BOOL aSilent);
    STDMETHOD(OnClipboardModeChange)(ClipboardMode_T aClipboardMode);
    STDMETHOD(OnDragAndDropModeChange)(DragAndDropMode_T aDragAndDropMode);
    STDMETHOD(OnCPUChange)(ULONG aCpu,
                           BOOL aAdd);
    STDMETHOD(OnCPUExecutionCapChange)(ULONG aExecutionCap);
    STDMETHOD(OnVRDEServerChange)(BOOL aRestart);
    STDMETHOD(OnVideoCaptureChange)();
    STDMETHOD(OnUSBControllerChange)();
    STDMETHOD(OnSharedFolderChange)(BOOL aGlobal);
    STDMETHOD(OnUSBDeviceAttach)(IUSBDevice *aDevice,
                                 IVirtualBoxErrorInfo *aError,
                                 ULONG aMaskedInterfaces);
    STDMETHOD(OnUSBDeviceDetach)(IN_BSTR aId,
                                 IVirtualBoxErrorInfo *aError);
    STDMETHOD(OnShowWindow)(BOOL aCheck,
                            BOOL *aCanShow,
                            LONG64 *aWinId);
    STDMETHOD(OnBandwidthGroupChange)(IBandwidthGroup *aBandwidthGroup);
    STDMETHOD(AccessGuestProperty)(IN_BSTR aName,
                                   IN_BSTR aValue,
                                   IN_BSTR aFlags,
                                   BOOL aIsSetter,
                                   BSTR *aRetValue,
                                   LONG64 *aRetTimestamp,
                                   BSTR *aRetFlags);
    STDMETHOD(EnumerateGuestProperties)(IN_BSTR aPatterns,
                                        ComSafeArrayOut(BSTR, aKeys),
                                        ComSafeArrayOut(BSTR, aValues),
                                        ComSafeArrayOut(LONG64, aTimestamps),
                                        ComSafeArrayOut(BSTR, aFlags));
    STDMETHOD(OnlineMergeMedium)(IMediumAttachment *aMediumAttachment,
                                 ULONG aSourceIdx,
                                 ULONG aTargetIdx,
                                 IProgress *aProgress);
    STDMETHOD(EnableVMMStatistics)(BOOL aEnable);
    STDMETHOD(PauseWithReason)(Reason_T aReason);
    STDMETHOD(ResumeWithReason)(Reason_T aReason);
    STDMETHOD(SaveStateWithReason)(Reason_T aReason,
                                   IProgress **aProgress);

private:
    // wrapped IInternalSessionControl properties

    // wrapped IInternalSessionControl methods
    virtual HRESULT getPID(ULONG *aPid) = 0;
    virtual HRESULT getRemoteConsole(ComPtr<IConsole> &aConsole) = 0;
    virtual HRESULT assignRemoteMachine(const ComPtr<IMachine> &aMachine,
                                        const ComPtr<IConsole> &aConsole) = 0;
    virtual HRESULT updateMachineState(MachineState_T aMachineState) = 0;
    virtual HRESULT uninitialize() = 0;
    virtual HRESULT onNetworkAdapterChange(const ComPtr<INetworkAdapter> &aNetworkAdapter,
                                           BOOL aChangeAdapter) = 0;
    virtual HRESULT onSerialPortChange(const ComPtr<ISerialPort> &aSerialPort) = 0;
    virtual HRESULT onParallelPortChange(const ComPtr<IParallelPort> &aParallelPort) = 0;
    virtual HRESULT onStorageControllerChange() = 0;
    virtual HRESULT onMediumChange(const ComPtr<IMediumAttachment> &aMediumAttachment,
                                   BOOL aForce) = 0;
    virtual HRESULT onStorageDeviceChange(const ComPtr<IMediumAttachment> &aMediumAttachment,
                                          BOOL aRemove,
                                          BOOL aSilent) = 0;
    virtual HRESULT onClipboardModeChange(ClipboardMode_T aClipboardMode) = 0;
    virtual HRESULT onDragAndDropModeChange(DragAndDropMode_T aDragAndDropMode) = 0;
    virtual HRESULT onCPUChange(ULONG aCpu,
                                BOOL aAdd) = 0;
    virtual HRESULT onCPUExecutionCapChange(ULONG aExecutionCap) = 0;
    virtual HRESULT onVRDEServerChange(BOOL aRestart) = 0;
    virtual HRESULT onVideoCaptureChange() = 0;
    virtual HRESULT onUSBControllerChange() = 0;
    virtual HRESULT onSharedFolderChange(BOOL aGlobal) = 0;
    virtual HRESULT onUSBDeviceAttach(const ComPtr<IUSBDevice> &aDevice,
                                      const ComPtr<IVirtualBoxErrorInfo> &aError,
                                      ULONG aMaskedInterfaces) = 0;
    virtual HRESULT onUSBDeviceDetach(const com::Guid &aId,
                                      const ComPtr<IVirtualBoxErrorInfo> &aError) = 0;
    virtual HRESULT onShowWindow(BOOL aCheck,
                                 BOOL *aCanShow,
                                 LONG64 *aWinId) = 0;
    virtual HRESULT onBandwidthGroupChange(const ComPtr<IBandwidthGroup> &aBandwidthGroup) = 0;
    virtual HRESULT accessGuestProperty(const com::Utf8Str &aName,
                                        const com::Utf8Str &aValue,
                                        const com::Utf8Str &aFlags,
                                        BOOL aIsSetter,
                                        com::Utf8Str &aRetValue,
                                        LONG64 *aRetTimestamp,
                                        com::Utf8Str &aRetFlags) = 0;
    virtual HRESULT enumerateGuestProperties(const com::Utf8Str &aPatterns,
                                             std::vector<com::Utf8Str> &aKeys,
                                             std::vector<com::Utf8Str> &aValues,
                                             std::vector<LONG64> &aTimestamps,
                                             std::vector<com::Utf8Str> &aFlags) = 0;
    virtual HRESULT onlineMergeMedium(const ComPtr<IMediumAttachment> &aMediumAttachment,
                                      ULONG aSourceIdx,
                                      ULONG aTargetIdx,
                                      const ComPtr<IProgress> &aProgress) = 0;
    virtual HRESULT enableVMMStatistics(BOOL aEnable) = 0;
    virtual HRESULT pauseWithReason(Reason_T aReason) = 0;
    virtual HRESULT resumeWithReason(Reason_T aReason) = 0;
    virtual HRESULT saveStateWithReason(Reason_T aReason,
                                        ComPtr<IProgress> &aProgress) = 0;
};

#endif // !InternalSessionControlWrap_H_

// ##### ENDFILE "InternalSessionControlWrap.h"

// ##### BEGINFILE "InternalSessionControlWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IInternalSessionControl.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_INTERNALSESSIONCONTROL

#include "InternalSessionControlWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(InternalSessionControlWrap)

//
// IInternalSessionControl properties
//

//
// IInternalSessionControl methods
//

STDMETHODIMP InternalSessionControlWrap::GetPID(ULONG *aPid)
{
    LogRelFlow(("{%p} %s:enter aPid=%p\n", this, "InternalSessionControl::getPID", aPid));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPid);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPID(aPid);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aPid=%RU32 hrc=%Rhrc\n", this, "InternalSessionControl::getPID", *aPid, hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::GetRemoteConsole(IConsole **aConsole)
{
    LogRelFlow(("{%p} %s:enter aConsole=%p\n", this, "InternalSessionControl::getRemoteConsole", aConsole));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aConsole);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRemoteConsole(ComTypeOutConverter<IConsole>(aConsole).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aConsole=%p hrc=%Rhrc\n", this, "InternalSessionControl::getRemoteConsole", *aConsole, hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::AssignRemoteMachine(IMachine *aMachine,
                                                             IConsole *aConsole)
{
    LogRelFlow(("{%p} %s:enter aMachine=%p aConsole=%p\n", this, "InternalSessionControl::assignRemoteMachine", aMachine, aConsole));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = assignRemoteMachine(ComTypeInConverter<IMachine>(aMachine).ptr(),
                                  ComTypeInConverter<IConsole>(aConsole).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::assignRemoteMachine", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::UpdateMachineState(MachineState_T aMachineState)
{
    LogRelFlow(("{%p} %s:enter aMachineState=%RU32\n", this, "InternalSessionControl::updateMachineState", aMachineState));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = updateMachineState(aMachineState);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::updateMachineState", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::Uninitialize()
{
    LogRelFlow(("{%p} %s:enter\n", this, "InternalSessionControl::uninitialize"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = uninitialize();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::uninitialize", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::OnNetworkAdapterChange(INetworkAdapter *aNetworkAdapter,
                                                                BOOL aChangeAdapter)
{
    LogRelFlow(("{%p} %s:enter aNetworkAdapter=%p aChangeAdapter=%RTbool\n", this, "InternalSessionControl::onNetworkAdapterChange", aNetworkAdapter, aChangeAdapter));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = onNetworkAdapterChange(ComTypeInConverter<INetworkAdapter>(aNetworkAdapter).ptr(),
                                     aChangeAdapter);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::onNetworkAdapterChange", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::OnSerialPortChange(ISerialPort *aSerialPort)
{
    LogRelFlow(("{%p} %s:enter aSerialPort=%p\n", this, "InternalSessionControl::onSerialPortChange", aSerialPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = onSerialPortChange(ComTypeInConverter<ISerialPort>(aSerialPort).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::onSerialPortChange", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::OnParallelPortChange(IParallelPort *aParallelPort)
{
    LogRelFlow(("{%p} %s:enter aParallelPort=%p\n", this, "InternalSessionControl::onParallelPortChange", aParallelPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = onParallelPortChange(ComTypeInConverter<IParallelPort>(aParallelPort).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::onParallelPortChange", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::OnStorageControllerChange()
{
    LogRelFlow(("{%p} %s:enter\n", this, "InternalSessionControl::onStorageControllerChange"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = onStorageControllerChange();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::onStorageControllerChange", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::OnMediumChange(IMediumAttachment *aMediumAttachment,
                                                        BOOL aForce)
{
    LogRelFlow(("{%p} %s:enter aMediumAttachment=%p aForce=%RTbool\n", this, "InternalSessionControl::onMediumChange", aMediumAttachment, aForce));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = onMediumChange(ComTypeInConverter<IMediumAttachment>(aMediumAttachment).ptr(),
                             aForce);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::onMediumChange", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::OnStorageDeviceChange(IMediumAttachment *aMediumAttachment,
                                                               BOOL aRemove,
                                                               BOOL aSilent)
{
    LogRelFlow(("{%p} %s:enter aMediumAttachment=%p aRemove=%RTbool aSilent=%RTbool\n", this, "InternalSessionControl::onStorageDeviceChange", aMediumAttachment, aRemove, aSilent));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = onStorageDeviceChange(ComTypeInConverter<IMediumAttachment>(aMediumAttachment).ptr(),
                                    aRemove,
                                    aSilent);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::onStorageDeviceChange", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::OnClipboardModeChange(ClipboardMode_T aClipboardMode)
{
    LogRelFlow(("{%p} %s:enter aClipboardMode=%RU32\n", this, "InternalSessionControl::onClipboardModeChange", aClipboardMode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = onClipboardModeChange(aClipboardMode);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::onClipboardModeChange", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::OnDragAndDropModeChange(DragAndDropMode_T aDragAndDropMode)
{
    LogRelFlow(("{%p} %s:enter aDragAndDropMode=%RU32\n", this, "InternalSessionControl::onDragAndDropModeChange", aDragAndDropMode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = onDragAndDropModeChange(aDragAndDropMode);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::onDragAndDropModeChange", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::OnCPUChange(ULONG aCpu,
                                                     BOOL aAdd)
{
    LogRelFlow(("{%p} %s:enter aCpu=%RU32 aAdd=%RTbool\n", this, "InternalSessionControl::onCPUChange", aCpu, aAdd));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = onCPUChange(aCpu,
                          aAdd);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::onCPUChange", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::OnCPUExecutionCapChange(ULONG aExecutionCap)
{
    LogRelFlow(("{%p} %s:enter aExecutionCap=%RU32\n", this, "InternalSessionControl::onCPUExecutionCapChange", aExecutionCap));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = onCPUExecutionCapChange(aExecutionCap);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::onCPUExecutionCapChange", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::OnVRDEServerChange(BOOL aRestart)
{
    LogRelFlow(("{%p} %s:enter aRestart=%RTbool\n", this, "InternalSessionControl::onVRDEServerChange", aRestart));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = onVRDEServerChange(aRestart);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::onVRDEServerChange", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::OnVideoCaptureChange()
{
    LogRelFlow(("{%p} %s:enter\n", this, "InternalSessionControl::onVideoCaptureChange"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = onVideoCaptureChange();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::onVideoCaptureChange", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::OnUSBControllerChange()
{
    LogRelFlow(("{%p} %s:enter\n", this, "InternalSessionControl::onUSBControllerChange"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = onUSBControllerChange();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::onUSBControllerChange", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::OnSharedFolderChange(BOOL aGlobal)
{
    LogRelFlow(("{%p} %s:enter aGlobal=%RTbool\n", this, "InternalSessionControl::onSharedFolderChange", aGlobal));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = onSharedFolderChange(aGlobal);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::onSharedFolderChange", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::OnUSBDeviceAttach(IUSBDevice *aDevice,
                                                           IVirtualBoxErrorInfo *aError,
                                                           ULONG aMaskedInterfaces)
{
    LogRelFlow(("{%p} %s:enter aDevice=%p aError=%p aMaskedInterfaces=%RU32\n", this, "InternalSessionControl::onUSBDeviceAttach", aDevice, aError, aMaskedInterfaces));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = onUSBDeviceAttach(ComTypeInConverter<IUSBDevice>(aDevice).ptr(),
                                ComTypeInConverter<IVirtualBoxErrorInfo>(aError).ptr(),
                                aMaskedInterfaces);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::onUSBDeviceAttach", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::OnUSBDeviceDetach(IN_BSTR aId,
                                                           IVirtualBoxErrorInfo *aError)
{
    LogRelFlow(("{%p} %s:enter aId=%ls aError=%p\n", this, "InternalSessionControl::onUSBDeviceDetach", aId, aError));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = onUSBDeviceDetach(UuidInConverter(aId).uuid(),
                                ComTypeInConverter<IVirtualBoxErrorInfo>(aError).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::onUSBDeviceDetach", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::OnShowWindow(BOOL aCheck,
                                                      BOOL *aCanShow,
                                                      LONG64 *aWinId)
{
    LogRelFlow(("{%p} %s:enter aCheck=%RTbool aCanShow=%p aWinId=%p\n", this, "InternalSessionControl::onShowWindow", aCheck, aCanShow, aWinId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCanShow);
        CheckComArgOutPointerValidThrow(aWinId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = onShowWindow(aCheck,
                           aCanShow,
                           aWinId);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aCanShow=%RTbool *aWinId=%RI64 hrc=%Rhrc\n", this, "InternalSessionControl::onShowWindow", *aCanShow, *aWinId, hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::OnBandwidthGroupChange(IBandwidthGroup *aBandwidthGroup)
{
    LogRelFlow(("{%p} %s:enter aBandwidthGroup=%p\n", this, "InternalSessionControl::onBandwidthGroupChange", aBandwidthGroup));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = onBandwidthGroupChange(ComTypeInConverter<IBandwidthGroup>(aBandwidthGroup).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::onBandwidthGroupChange", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::AccessGuestProperty(IN_BSTR aName,
                                                             IN_BSTR aValue,
                                                             IN_BSTR aFlags,
                                                             BOOL aIsSetter,
                                                             BSTR *aRetValue,
                                                             LONG64 *aRetTimestamp,
                                                             BSTR *aRetFlags)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aValue=%ls aFlags=%ls aIsSetter=%RTbool aRetValue=%p aRetTimestamp=%p aRetFlags=%p\n", this, "InternalSessionControl::accessGuestProperty", aName, aValue, aFlags, aIsSetter, aRetValue, aRetTimestamp, aRetFlags));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRetValue);
        CheckComArgOutPointerValidThrow(aRetTimestamp);
        CheckComArgOutPointerValidThrow(aRetFlags);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = accessGuestProperty(BSTRInConverter(aName).str(),
                                  BSTRInConverter(aValue).str(),
                                  BSTRInConverter(aFlags).str(),
                                  aIsSetter,
                                  BSTROutConverter(aRetValue).str(),
                                  aRetTimestamp,
                                  BSTROutConverter(aRetFlags).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRetValue=%ls *aRetTimestamp=%RI64 *aRetFlags=%ls hrc=%Rhrc\n", this, "InternalSessionControl::accessGuestProperty", *aRetValue, *aRetTimestamp, *aRetFlags, hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::EnumerateGuestProperties(IN_BSTR aPatterns,
                                                                  ComSafeArrayOut(BSTR, aKeys),
                                                                  ComSafeArrayOut(BSTR, aValues),
                                                                  ComSafeArrayOut(LONG64, aTimestamps),
                                                                  ComSafeArrayOut(BSTR, aFlags))
{
    LogRelFlow(("{%p} %s:enter aPatterns=%ls aKeys=%p aValues=%p aTimestamps=%p aFlags=%p\n", this, "InternalSessionControl::enumerateGuestProperties", aPatterns, aKeys, aValues, aTimestamps, aFlags));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aKeys);
        CheckComArgOutPointerValidThrow(aValues);
        CheckComArgOutPointerValidThrow(aTimestamps);
        CheckComArgOutPointerValidThrow(aFlags);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = enumerateGuestProperties(BSTRInConverter(aPatterns).str(),
                                       ArrayBSTROutConverter(ComSafeArrayOutArg(aKeys)).array(),
                                       ArrayBSTROutConverter(ComSafeArrayOutArg(aValues)).array(),
                                       ArrayOutConverter<LONG64>(ComSafeArrayOutArg(aTimestamps)).array(),
                                       ArrayBSTROutConverter(ComSafeArrayOutArg(aFlags)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aKeys=%zu *aValues=%zu *aTimestamps=%zu *aFlags=%zu hrc=%Rhrc\n", this, "InternalSessionControl::enumerateGuestProperties", ComSafeArraySize(*aKeys), ComSafeArraySize(*aValues), ComSafeArraySize(*aTimestamps), ComSafeArraySize(*aFlags), hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::OnlineMergeMedium(IMediumAttachment *aMediumAttachment,
                                                           ULONG aSourceIdx,
                                                           ULONG aTargetIdx,
                                                           IProgress *aProgress)
{
    LogRelFlow(("{%p} %s:enter aMediumAttachment=%p aSourceIdx=%RU32 aTargetIdx=%RU32 aProgress=%p\n", this, "InternalSessionControl::onlineMergeMedium", aMediumAttachment, aSourceIdx, aTargetIdx, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = onlineMergeMedium(ComTypeInConverter<IMediumAttachment>(aMediumAttachment).ptr(),
                                aSourceIdx,
                                aTargetIdx,
                                ComTypeInConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::onlineMergeMedium", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::EnableVMMStatistics(BOOL aEnable)
{
    LogRelFlow(("{%p} %s:enter aEnable=%RTbool\n", this, "InternalSessionControl::enableVMMStatistics", aEnable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = enableVMMStatistics(aEnable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::enableVMMStatistics", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::PauseWithReason(Reason_T aReason)
{
    LogRelFlow(("{%p} %s:enter aReason=%RU32\n", this, "InternalSessionControl::pauseWithReason", aReason));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = pauseWithReason(aReason);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::pauseWithReason", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::ResumeWithReason(Reason_T aReason)
{
    LogRelFlow(("{%p} %s:enter aReason=%RU32\n", this, "InternalSessionControl::resumeWithReason", aReason));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = resumeWithReason(aReason);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "InternalSessionControl::resumeWithReason", hrc));
    return hrc;
}

STDMETHODIMP InternalSessionControlWrap::SaveStateWithReason(Reason_T aReason,
                                                             IProgress **aProgress)
{
    LogRelFlow(("{%p} %s:enter aReason=%RU32 aProgress=%p\n", this, "InternalSessionControl::saveStateWithReason", aReason, aProgress));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgress);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = saveStateWithReason(aReason,
                                  ComTypeOutConverter<IProgress>(aProgress).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgress=%p hrc=%Rhrc\n", this, "InternalSessionControl::saveStateWithReason", *aProgress, hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(InternalSessionControlWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(InternalSessionControlWrap, IInternalSessionControl)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "InternalSessionControlWrap.cpp"

// ##### BEGINFILE "SessionWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for ISession.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef SessionWrap_H_
#define SessionWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE SessionWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(ISession)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(SessionWrap, ISession)
    DECLARE_NOT_AGGREGATABLE(SessionWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(SessionWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(ISession)
        COM_INTERFACE_ENTRY2(IDispatch, ISession)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(SessionWrap)

    // public ISession properties
    STDMETHOD(COMGETTER(State))(SessionState_T *aState);
    STDMETHOD(COMGETTER(Type))(SessionType_T *aType);
    STDMETHOD(COMGETTER(Machine))(IMachine **aMachine);
    STDMETHOD(COMGETTER(Console))(IConsole **aConsole);

    // public ISession methods
    STDMETHOD(UnlockMachine)();

private:
    // wrapped ISession properties
    virtual HRESULT getState(SessionState_T *aState) = 0;
    virtual HRESULT getType(SessionType_T *aType) = 0;
    virtual HRESULT getMachine(ComPtr<IMachine> &aMachine) = 0;
    virtual HRESULT getConsole(ComPtr<IConsole> &aConsole) = 0;

    // wrapped ISession methods
    virtual HRESULT unlockMachine() = 0;
};

#endif // !SessionWrap_H_

// ##### ENDFILE "SessionWrap.h"

// ##### BEGINFILE "SessionWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for ISession.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_SESSION

#include "SessionWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(SessionWrap)

//
// ISession properties
//

STDMETHODIMP SessionWrap::COMGETTER(State)(SessionState_T *aState)
{
    LogRelFlow(("{%p} %s: enter aState=%p\n", this, "Session::getState", aState));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aState);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getState(aState);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aState=%RU32 hrc=%Rhrc\n", this, "Session::getState", *aState, hrc));
    return hrc;
}

STDMETHODIMP SessionWrap::COMGETTER(Type)(SessionType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "Session::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "Session::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP SessionWrap::COMGETTER(Machine)(IMachine **aMachine)
{
    LogRelFlow(("{%p} %s: enter aMachine=%p\n", this, "Session::getMachine", aMachine));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachine);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachine(ComTypeOutConverter<IMachine>(aMachine).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachine=%p hrc=%Rhrc\n", this, "Session::getMachine", *aMachine, hrc));
    return hrc;
}

STDMETHODIMP SessionWrap::COMGETTER(Console)(IConsole **aConsole)
{
    LogRelFlow(("{%p} %s: enter aConsole=%p\n", this, "Session::getConsole", aConsole));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aConsole);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getConsole(ComTypeOutConverter<IConsole>(aConsole).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aConsole=%p hrc=%Rhrc\n", this, "Session::getConsole", *aConsole, hrc));
    return hrc;
}

//
// ISession methods
//

STDMETHODIMP SessionWrap::UnlockMachine()
{
    LogRelFlow(("{%p} %s:enter\n", this, "Session::unlockMachine"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = unlockMachine();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Session::unlockMachine", hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(SessionWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(SessionWrap, ISession)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "SessionWrap.cpp"

// ##### BEGINFILE "StorageControllerWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IStorageController.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef StorageControllerWrap_H_
#define StorageControllerWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE StorageControllerWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IStorageController)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(StorageControllerWrap, IStorageController)
    DECLARE_NOT_AGGREGATABLE(StorageControllerWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(StorageControllerWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IStorageController)
        COM_INTERFACE_ENTRY2(IDispatch, IStorageController)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(StorageControllerWrap)

    // public IStorageController properties
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(MaxDevicesPerPortCount))(ULONG *aMaxDevicesPerPortCount);
    STDMETHOD(COMGETTER(MinPortCount))(ULONG *aMinPortCount);
    STDMETHOD(COMGETTER(MaxPortCount))(ULONG *aMaxPortCount);
    STDMETHOD(COMGETTER(Instance))(ULONG *aInstance);
    STDMETHOD(COMSETTER(Instance))(ULONG aInstance);
    STDMETHOD(COMGETTER(PortCount))(ULONG *aPortCount);
    STDMETHOD(COMSETTER(PortCount))(ULONG aPortCount);
    STDMETHOD(COMGETTER(Bus))(StorageBus_T *aBus);
    STDMETHOD(COMGETTER(ControllerType))(StorageControllerType_T *aControllerType);
    STDMETHOD(COMSETTER(ControllerType))(StorageControllerType_T aControllerType);
    STDMETHOD(COMGETTER(UseHostIOCache))(BOOL *aUseHostIOCache);
    STDMETHOD(COMSETTER(UseHostIOCache))(BOOL aUseHostIOCache);
    STDMETHOD(COMGETTER(Bootable))(BOOL *aBootable);

    // public IStorageController methods

private:
    // wrapped IStorageController properties
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getMaxDevicesPerPortCount(ULONG *aMaxDevicesPerPortCount) = 0;
    virtual HRESULT getMinPortCount(ULONG *aMinPortCount) = 0;
    virtual HRESULT getMaxPortCount(ULONG *aMaxPortCount) = 0;
    virtual HRESULT getInstance(ULONG *aInstance) = 0;
    virtual HRESULT setInstance(ULONG aInstance) = 0;
    virtual HRESULT getPortCount(ULONG *aPortCount) = 0;
    virtual HRESULT setPortCount(ULONG aPortCount) = 0;
    virtual HRESULT getBus(StorageBus_T *aBus) = 0;
    virtual HRESULT getControllerType(StorageControllerType_T *aControllerType) = 0;
    virtual HRESULT setControllerType(StorageControllerType_T aControllerType) = 0;
    virtual HRESULT getUseHostIOCache(BOOL *aUseHostIOCache) = 0;
    virtual HRESULT setUseHostIOCache(BOOL aUseHostIOCache) = 0;
    virtual HRESULT getBootable(BOOL *aBootable) = 0;

    // wrapped IStorageController methods
};

#endif // !StorageControllerWrap_H_

// ##### ENDFILE "StorageControllerWrap.h"

// ##### BEGINFILE "StorageControllerWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IStorageController.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_STORAGECONTROLLER

#include "StorageControllerWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(StorageControllerWrap)

//
// IStorageController properties
//

STDMETHODIMP StorageControllerWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "StorageController::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "StorageController::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP StorageControllerWrap::COMGETTER(MaxDevicesPerPortCount)(ULONG *aMaxDevicesPerPortCount)
{
    LogRelFlow(("{%p} %s: enter aMaxDevicesPerPortCount=%p\n", this, "StorageController::getMaxDevicesPerPortCount", aMaxDevicesPerPortCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMaxDevicesPerPortCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMaxDevicesPerPortCount(aMaxDevicesPerPortCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMaxDevicesPerPortCount=%RU32 hrc=%Rhrc\n", this, "StorageController::getMaxDevicesPerPortCount", *aMaxDevicesPerPortCount, hrc));
    return hrc;
}

STDMETHODIMP StorageControllerWrap::COMGETTER(MinPortCount)(ULONG *aMinPortCount)
{
    LogRelFlow(("{%p} %s: enter aMinPortCount=%p\n", this, "StorageController::getMinPortCount", aMinPortCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMinPortCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMinPortCount(aMinPortCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMinPortCount=%RU32 hrc=%Rhrc\n", this, "StorageController::getMinPortCount", *aMinPortCount, hrc));
    return hrc;
}

STDMETHODIMP StorageControllerWrap::COMGETTER(MaxPortCount)(ULONG *aMaxPortCount)
{
    LogRelFlow(("{%p} %s: enter aMaxPortCount=%p\n", this, "StorageController::getMaxPortCount", aMaxPortCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMaxPortCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMaxPortCount(aMaxPortCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMaxPortCount=%RU32 hrc=%Rhrc\n", this, "StorageController::getMaxPortCount", *aMaxPortCount, hrc));
    return hrc;
}

STDMETHODIMP StorageControllerWrap::COMGETTER(Instance)(ULONG *aInstance)
{
    LogRelFlow(("{%p} %s: enter aInstance=%p\n", this, "StorageController::getInstance", aInstance));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aInstance);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getInstance(aInstance);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aInstance=%RU32 hrc=%Rhrc\n", this, "StorageController::getInstance", *aInstance, hrc));
    return hrc;
}

STDMETHODIMP StorageControllerWrap::COMSETTER(Instance)(ULONG aInstance)
{
    LogRelFlow(("{%p} %s: enter aInstance=%RU32\n", this, "StorageController::setInstance", aInstance));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setInstance(aInstance);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "StorageController::setInstance", hrc));
    return hrc;
}

STDMETHODIMP StorageControllerWrap::COMGETTER(PortCount)(ULONG *aPortCount)
{
    LogRelFlow(("{%p} %s: enter aPortCount=%p\n", this, "StorageController::getPortCount", aPortCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPortCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPortCount(aPortCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPortCount=%RU32 hrc=%Rhrc\n", this, "StorageController::getPortCount", *aPortCount, hrc));
    return hrc;
}

STDMETHODIMP StorageControllerWrap::COMSETTER(PortCount)(ULONG aPortCount)
{
    LogRelFlow(("{%p} %s: enter aPortCount=%RU32\n", this, "StorageController::setPortCount", aPortCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setPortCount(aPortCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "StorageController::setPortCount", hrc));
    return hrc;
}

STDMETHODIMP StorageControllerWrap::COMGETTER(Bus)(StorageBus_T *aBus)
{
    LogRelFlow(("{%p} %s: enter aBus=%p\n", this, "StorageController::getBus", aBus));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBus);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBus(aBus);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBus=%RU32 hrc=%Rhrc\n", this, "StorageController::getBus", *aBus, hrc));
    return hrc;
}

STDMETHODIMP StorageControllerWrap::COMGETTER(ControllerType)(StorageControllerType_T *aControllerType)
{
    LogRelFlow(("{%p} %s: enter aControllerType=%p\n", this, "StorageController::getControllerType", aControllerType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aControllerType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getControllerType(aControllerType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aControllerType=%RU32 hrc=%Rhrc\n", this, "StorageController::getControllerType", *aControllerType, hrc));
    return hrc;
}

STDMETHODIMP StorageControllerWrap::COMSETTER(ControllerType)(StorageControllerType_T aControllerType)
{
    LogRelFlow(("{%p} %s: enter aControllerType=%RU32\n", this, "StorageController::setControllerType", aControllerType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setControllerType(aControllerType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "StorageController::setControllerType", hrc));
    return hrc;
}

STDMETHODIMP StorageControllerWrap::COMGETTER(UseHostIOCache)(BOOL *aUseHostIOCache)
{
    LogRelFlow(("{%p} %s: enter aUseHostIOCache=%p\n", this, "StorageController::getUseHostIOCache", aUseHostIOCache));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUseHostIOCache);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUseHostIOCache(aUseHostIOCache);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUseHostIOCache=%RTbool hrc=%Rhrc\n", this, "StorageController::getUseHostIOCache", *aUseHostIOCache, hrc));
    return hrc;
}

STDMETHODIMP StorageControllerWrap::COMSETTER(UseHostIOCache)(BOOL aUseHostIOCache)
{
    LogRelFlow(("{%p} %s: enter aUseHostIOCache=%RTbool\n", this, "StorageController::setUseHostIOCache", aUseHostIOCache));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setUseHostIOCache(aUseHostIOCache);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "StorageController::setUseHostIOCache", hrc));
    return hrc;
}

STDMETHODIMP StorageControllerWrap::COMGETTER(Bootable)(BOOL *aBootable)
{
    LogRelFlow(("{%p} %s: enter aBootable=%p\n", this, "StorageController::getBootable", aBootable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBootable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBootable(aBootable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBootable=%RTbool hrc=%Rhrc\n", this, "StorageController::getBootable", *aBootable, hrc));
    return hrc;
}

//
// IStorageController methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(StorageControllerWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(StorageControllerWrap, IStorageController)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "StorageControllerWrap.cpp"

// ##### BEGINFILE "PerformanceMetricWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IPerformanceMetric.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef PerformanceMetricWrap_H_
#define PerformanceMetricWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE PerformanceMetricWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IPerformanceMetric)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(PerformanceMetricWrap, IPerformanceMetric)
    DECLARE_NOT_AGGREGATABLE(PerformanceMetricWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(PerformanceMetricWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IPerformanceMetric)
        COM_INTERFACE_ENTRY2(IDispatch, IPerformanceMetric)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(PerformanceMetricWrap)

    // public IPerformanceMetric properties
    STDMETHOD(COMGETTER(MetricName))(BSTR *aMetricName);
    STDMETHOD(COMGETTER(Object))(IUnknown **aObject);
    STDMETHOD(COMGETTER(Description))(BSTR *aDescription);
    STDMETHOD(COMGETTER(Period))(ULONG *aPeriod);
    STDMETHOD(COMGETTER(Count))(ULONG *aCount);
    STDMETHOD(COMGETTER(Unit))(BSTR *aUnit);
    STDMETHOD(COMGETTER(MinimumValue))(LONG *aMinimumValue);
    STDMETHOD(COMGETTER(MaximumValue))(LONG *aMaximumValue);

    // public IPerformanceMetric methods

private:
    // wrapped IPerformanceMetric properties
    virtual HRESULT getMetricName(com::Utf8Str &aMetricName) = 0;
    virtual HRESULT getObject(ComPtr<IUnknown> &aObject) = 0;
    virtual HRESULT getDescription(com::Utf8Str &aDescription) = 0;
    virtual HRESULT getPeriod(ULONG *aPeriod) = 0;
    virtual HRESULT getCount(ULONG *aCount) = 0;
    virtual HRESULT getUnit(com::Utf8Str &aUnit) = 0;
    virtual HRESULT getMinimumValue(LONG *aMinimumValue) = 0;
    virtual HRESULT getMaximumValue(LONG *aMaximumValue) = 0;

    // wrapped IPerformanceMetric methods
};

#endif // !PerformanceMetricWrap_H_

// ##### ENDFILE "PerformanceMetricWrap.h"

// ##### BEGINFILE "PerformanceMetricWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IPerformanceMetric.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_PERFORMANCEMETRIC

#include "PerformanceMetricWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(PerformanceMetricWrap)

//
// IPerformanceMetric properties
//

STDMETHODIMP PerformanceMetricWrap::COMGETTER(MetricName)(BSTR *aMetricName)
{
    LogRelFlow(("{%p} %s: enter aMetricName=%p\n", this, "PerformanceMetric::getMetricName", aMetricName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMetricName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMetricName(BSTROutConverter(aMetricName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMetricName=%ls hrc=%Rhrc\n", this, "PerformanceMetric::getMetricName", *aMetricName, hrc));
    return hrc;
}

STDMETHODIMP PerformanceMetricWrap::COMGETTER(Object)(IUnknown **aObject)
{
    LogRelFlow(("{%p} %s: enter aObject=%p\n", this, "PerformanceMetric::getObject", aObject));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aObject);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getObject(ComTypeOutConverter<IUnknown>(aObject).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aObject=%p hrc=%Rhrc\n", this, "PerformanceMetric::getObject", *aObject, hrc));
    return hrc;
}

STDMETHODIMP PerformanceMetricWrap::COMGETTER(Description)(BSTR *aDescription)
{
    LogRelFlow(("{%p} %s: enter aDescription=%p\n", this, "PerformanceMetric::getDescription", aDescription));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDescription);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDescription(BSTROutConverter(aDescription).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDescription=%ls hrc=%Rhrc\n", this, "PerformanceMetric::getDescription", *aDescription, hrc));
    return hrc;
}

STDMETHODIMP PerformanceMetricWrap::COMGETTER(Period)(ULONG *aPeriod)
{
    LogRelFlow(("{%p} %s: enter aPeriod=%p\n", this, "PerformanceMetric::getPeriod", aPeriod));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPeriod);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPeriod(aPeriod);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPeriod=%RU32 hrc=%Rhrc\n", this, "PerformanceMetric::getPeriod", *aPeriod, hrc));
    return hrc;
}

STDMETHODIMP PerformanceMetricWrap::COMGETTER(Count)(ULONG *aCount)
{
    LogRelFlow(("{%p} %s: enter aCount=%p\n", this, "PerformanceMetric::getCount", aCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getCount(aCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aCount=%RU32 hrc=%Rhrc\n", this, "PerformanceMetric::getCount", *aCount, hrc));
    return hrc;
}

STDMETHODIMP PerformanceMetricWrap::COMGETTER(Unit)(BSTR *aUnit)
{
    LogRelFlow(("{%p} %s: enter aUnit=%p\n", this, "PerformanceMetric::getUnit", aUnit));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUnit);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUnit(BSTROutConverter(aUnit).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUnit=%ls hrc=%Rhrc\n", this, "PerformanceMetric::getUnit", *aUnit, hrc));
    return hrc;
}

STDMETHODIMP PerformanceMetricWrap::COMGETTER(MinimumValue)(LONG *aMinimumValue)
{
    LogRelFlow(("{%p} %s: enter aMinimumValue=%p\n", this, "PerformanceMetric::getMinimumValue", aMinimumValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMinimumValue);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMinimumValue(aMinimumValue);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMinimumValue=%RI32 hrc=%Rhrc\n", this, "PerformanceMetric::getMinimumValue", *aMinimumValue, hrc));
    return hrc;
}

STDMETHODIMP PerformanceMetricWrap::COMGETTER(MaximumValue)(LONG *aMaximumValue)
{
    LogRelFlow(("{%p} %s: enter aMaximumValue=%p\n", this, "PerformanceMetric::getMaximumValue", aMaximumValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMaximumValue);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMaximumValue(aMaximumValue);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMaximumValue=%RI32 hrc=%Rhrc\n", this, "PerformanceMetric::getMaximumValue", *aMaximumValue, hrc));
    return hrc;
}

//
// IPerformanceMetric methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(PerformanceMetricWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(PerformanceMetricWrap, IPerformanceMetric)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "PerformanceMetricWrap.cpp"

// ##### BEGINFILE "PerformanceCollectorWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IPerformanceCollector.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef PerformanceCollectorWrap_H_
#define PerformanceCollectorWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE PerformanceCollectorWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IPerformanceCollector)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(PerformanceCollectorWrap, IPerformanceCollector)
    DECLARE_NOT_AGGREGATABLE(PerformanceCollectorWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(PerformanceCollectorWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IPerformanceCollector)
        COM_INTERFACE_ENTRY2(IDispatch, IPerformanceCollector)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(PerformanceCollectorWrap)

    // public IPerformanceCollector properties
    STDMETHOD(COMGETTER(MetricNames))(ComSafeArrayOut(BSTR, aMetricNames));

    // public IPerformanceCollector methods
    STDMETHOD(GetMetrics)(ComSafeArrayIn(IN_BSTR, aMetricNames),
                          ComSafeArrayIn(IUnknown *, aObjects),
                          ComSafeArrayOut(IPerformanceMetric *, aMetrics));
    STDMETHOD(SetupMetrics)(ComSafeArrayIn(IN_BSTR, aMetricNames),
                            ComSafeArrayIn(IUnknown *, aObjects),
                            ULONG aPeriod,
                            ULONG aCount,
                            ComSafeArrayOut(IPerformanceMetric *, aAffectedMetrics));
    STDMETHOD(EnableMetrics)(ComSafeArrayIn(IN_BSTR, aMetricNames),
                             ComSafeArrayIn(IUnknown *, aObjects),
                             ComSafeArrayOut(IPerformanceMetric *, aAffectedMetrics));
    STDMETHOD(DisableMetrics)(ComSafeArrayIn(IN_BSTR, aMetricNames),
                              ComSafeArrayIn(IUnknown *, aObjects),
                              ComSafeArrayOut(IPerformanceMetric *, aAffectedMetrics));
    STDMETHOD(QueryMetricsData)(ComSafeArrayIn(IN_BSTR, aMetricNames),
                                ComSafeArrayIn(IUnknown *, aObjects),
                                ComSafeArrayOut(BSTR, aReturnMetricNames),
                                ComSafeArrayOut(IUnknown *, aReturnObjects),
                                ComSafeArrayOut(BSTR, aReturnUnits),
                                ComSafeArrayOut(ULONG, aReturnScales),
                                ComSafeArrayOut(ULONG, aReturnSequenceNumbers),
                                ComSafeArrayOut(ULONG, aReturnDataIndices),
                                ComSafeArrayOut(ULONG, aReturnDataLengths),
                                ComSafeArrayOut(LONG, aReturnData));

private:
    // wrapped IPerformanceCollector properties
    virtual HRESULT getMetricNames(std::vector<com::Utf8Str> &aMetricNames) = 0;

    // wrapped IPerformanceCollector methods
    virtual HRESULT getMetrics(const std::vector<com::Utf8Str> &aMetricNames,
                               const std::vector<ComPtr<IUnknown> > &aObjects,
                               std::vector<ComPtr<IPerformanceMetric> > &aMetrics) = 0;
    virtual HRESULT setupMetrics(const std::vector<com::Utf8Str> &aMetricNames,
                                 const std::vector<ComPtr<IUnknown> > &aObjects,
                                 ULONG aPeriod,
                                 ULONG aCount,
                                 std::vector<ComPtr<IPerformanceMetric> > &aAffectedMetrics) = 0;
    virtual HRESULT enableMetrics(const std::vector<com::Utf8Str> &aMetricNames,
                                  const std::vector<ComPtr<IUnknown> > &aObjects,
                                  std::vector<ComPtr<IPerformanceMetric> > &aAffectedMetrics) = 0;
    virtual HRESULT disableMetrics(const std::vector<com::Utf8Str> &aMetricNames,
                                   const std::vector<ComPtr<IUnknown> > &aObjects,
                                   std::vector<ComPtr<IPerformanceMetric> > &aAffectedMetrics) = 0;
    virtual HRESULT queryMetricsData(const std::vector<com::Utf8Str> &aMetricNames,
                                     const std::vector<ComPtr<IUnknown> > &aObjects,
                                     std::vector<com::Utf8Str> &aReturnMetricNames,
                                     std::vector<ComPtr<IUnknown> > &aReturnObjects,
                                     std::vector<com::Utf8Str> &aReturnUnits,
                                     std::vector<ULONG> &aReturnScales,
                                     std::vector<ULONG> &aReturnSequenceNumbers,
                                     std::vector<ULONG> &aReturnDataIndices,
                                     std::vector<ULONG> &aReturnDataLengths,
                                     std::vector<LONG> &aReturnData) = 0;
};

#endif // !PerformanceCollectorWrap_H_

// ##### ENDFILE "PerformanceCollectorWrap.h"

// ##### BEGINFILE "PerformanceCollectorWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IPerformanceCollector.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_PERFORMANCECOLLECTOR

#include "PerformanceCollectorWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(PerformanceCollectorWrap)

//
// IPerformanceCollector properties
//

STDMETHODIMP PerformanceCollectorWrap::COMGETTER(MetricNames)(ComSafeArrayOut(BSTR, aMetricNames))
{
    LogRelFlow(("{%p} %s: enter aMetricNames=%p\n", this, "PerformanceCollector::getMetricNames", aMetricNames));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMetricNames);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMetricNames(ArrayBSTROutConverter(ComSafeArrayOutArg(aMetricNames)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMetricNames=%zu hrc=%Rhrc\n", this, "PerformanceCollector::getMetricNames", ComSafeArraySize(*aMetricNames), hrc));
    return hrc;
}

//
// IPerformanceCollector methods
//

STDMETHODIMP PerformanceCollectorWrap::GetMetrics(ComSafeArrayIn(IN_BSTR, aMetricNames),
                                                  ComSafeArrayIn(IUnknown *, aObjects),
                                                  ComSafeArrayOut(IPerformanceMetric *, aMetrics))
{
    LogRelFlow(("{%p} %s:enter aMetricNames=%zu aObjects=%zu aMetrics=%p\n", this, "PerformanceCollector::getMetrics", aMetricNames, aObjects, aMetrics));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMetrics);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMetrics(ArrayBSTRInConverter(ComSafeArrayInArg(aMetricNames)).array(),
                         ArrayComTypeInConverter<IUnknown>(ComSafeArrayInArg(aObjects)).array(),
                         ArrayComTypeOutConverter<IPerformanceMetric>(ComSafeArrayOutArg(aMetrics)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aMetrics=%zu hrc=%Rhrc\n", this, "PerformanceCollector::getMetrics", ComSafeArraySize(*aMetrics), hrc));
    return hrc;
}

STDMETHODIMP PerformanceCollectorWrap::SetupMetrics(ComSafeArrayIn(IN_BSTR, aMetricNames),
                                                    ComSafeArrayIn(IUnknown *, aObjects),
                                                    ULONG aPeriod,
                                                    ULONG aCount,
                                                    ComSafeArrayOut(IPerformanceMetric *, aAffectedMetrics))
{
    LogRelFlow(("{%p} %s:enter aMetricNames=%zu aObjects=%zu aPeriod=%RU32 aCount=%RU32 aAffectedMetrics=%p\n", this, "PerformanceCollector::setupMetrics", aMetricNames, aObjects, aPeriod, aCount, aAffectedMetrics));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAffectedMetrics);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setupMetrics(ArrayBSTRInConverter(ComSafeArrayInArg(aMetricNames)).array(),
                           ArrayComTypeInConverter<IUnknown>(ComSafeArrayInArg(aObjects)).array(),
                           aPeriod,
                           aCount,
                           ArrayComTypeOutConverter<IPerformanceMetric>(ComSafeArrayOutArg(aAffectedMetrics)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aAffectedMetrics=%zu hrc=%Rhrc\n", this, "PerformanceCollector::setupMetrics", ComSafeArraySize(*aAffectedMetrics), hrc));
    return hrc;
}

STDMETHODIMP PerformanceCollectorWrap::EnableMetrics(ComSafeArrayIn(IN_BSTR, aMetricNames),
                                                     ComSafeArrayIn(IUnknown *, aObjects),
                                                     ComSafeArrayOut(IPerformanceMetric *, aAffectedMetrics))
{
    LogRelFlow(("{%p} %s:enter aMetricNames=%zu aObjects=%zu aAffectedMetrics=%p\n", this, "PerformanceCollector::enableMetrics", aMetricNames, aObjects, aAffectedMetrics));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAffectedMetrics);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = enableMetrics(ArrayBSTRInConverter(ComSafeArrayInArg(aMetricNames)).array(),
                            ArrayComTypeInConverter<IUnknown>(ComSafeArrayInArg(aObjects)).array(),
                            ArrayComTypeOutConverter<IPerformanceMetric>(ComSafeArrayOutArg(aAffectedMetrics)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aAffectedMetrics=%zu hrc=%Rhrc\n", this, "PerformanceCollector::enableMetrics", ComSafeArraySize(*aAffectedMetrics), hrc));
    return hrc;
}

STDMETHODIMP PerformanceCollectorWrap::DisableMetrics(ComSafeArrayIn(IN_BSTR, aMetricNames),
                                                      ComSafeArrayIn(IUnknown *, aObjects),
                                                      ComSafeArrayOut(IPerformanceMetric *, aAffectedMetrics))
{
    LogRelFlow(("{%p} %s:enter aMetricNames=%zu aObjects=%zu aAffectedMetrics=%p\n", this, "PerformanceCollector::disableMetrics", aMetricNames, aObjects, aAffectedMetrics));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAffectedMetrics);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = disableMetrics(ArrayBSTRInConverter(ComSafeArrayInArg(aMetricNames)).array(),
                             ArrayComTypeInConverter<IUnknown>(ComSafeArrayInArg(aObjects)).array(),
                             ArrayComTypeOutConverter<IPerformanceMetric>(ComSafeArrayOutArg(aAffectedMetrics)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aAffectedMetrics=%zu hrc=%Rhrc\n", this, "PerformanceCollector::disableMetrics", ComSafeArraySize(*aAffectedMetrics), hrc));
    return hrc;
}

STDMETHODIMP PerformanceCollectorWrap::QueryMetricsData(ComSafeArrayIn(IN_BSTR, aMetricNames),
                                                        ComSafeArrayIn(IUnknown *, aObjects),
                                                        ComSafeArrayOut(BSTR, aReturnMetricNames),
                                                        ComSafeArrayOut(IUnknown *, aReturnObjects),
                                                        ComSafeArrayOut(BSTR, aReturnUnits),
                                                        ComSafeArrayOut(ULONG, aReturnScales),
                                                        ComSafeArrayOut(ULONG, aReturnSequenceNumbers),
                                                        ComSafeArrayOut(ULONG, aReturnDataIndices),
                                                        ComSafeArrayOut(ULONG, aReturnDataLengths),
                                                        ComSafeArrayOut(LONG, aReturnData))
{
    LogRelFlow(("{%p} %s:enter aMetricNames=%zu aObjects=%zu aReturnMetricNames=%p aReturnObjects=%p aReturnUnits=%p aReturnScales=%p aReturnSequenceNumbers=%p aReturnDataIndices=%p aReturnDataLengths=%p aReturnData=%p\n", this, "PerformanceCollector::queryMetricsData", aMetricNames, aObjects, aReturnMetricNames, aReturnObjects, aReturnUnits, aReturnScales, aReturnSequenceNumbers, aReturnDataIndices, aReturnDataLengths, aReturnData));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aReturnMetricNames);
        CheckComArgOutPointerValidThrow(aReturnObjects);
        CheckComArgOutPointerValidThrow(aReturnUnits);
        CheckComArgOutPointerValidThrow(aReturnScales);
        CheckComArgOutPointerValidThrow(aReturnSequenceNumbers);
        CheckComArgOutPointerValidThrow(aReturnDataIndices);
        CheckComArgOutPointerValidThrow(aReturnDataLengths);
        CheckComArgOutPointerValidThrow(aReturnData);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = queryMetricsData(ArrayBSTRInConverter(ComSafeArrayInArg(aMetricNames)).array(),
                               ArrayComTypeInConverter<IUnknown>(ComSafeArrayInArg(aObjects)).array(),
                               ArrayBSTROutConverter(ComSafeArrayOutArg(aReturnMetricNames)).array(),
                               ArrayComTypeOutConverter<IUnknown>(ComSafeArrayOutArg(aReturnObjects)).array(),
                               ArrayBSTROutConverter(ComSafeArrayOutArg(aReturnUnits)).array(),
                               ArrayOutConverter<ULONG>(ComSafeArrayOutArg(aReturnScales)).array(),
                               ArrayOutConverter<ULONG>(ComSafeArrayOutArg(aReturnSequenceNumbers)).array(),
                               ArrayOutConverter<ULONG>(ComSafeArrayOutArg(aReturnDataIndices)).array(),
                               ArrayOutConverter<ULONG>(ComSafeArrayOutArg(aReturnDataLengths)).array(),
                               ArrayOutConverter<LONG>(ComSafeArrayOutArg(aReturnData)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aReturnMetricNames=%zu *aReturnObjects=%zu *aReturnUnits=%zu *aReturnScales=%zu *aReturnSequenceNumbers=%zu *aReturnDataIndices=%zu *aReturnDataLengths=%zu aReturnData=%zu hrc=%Rhrc\n", this, "PerformanceCollector::queryMetricsData", ComSafeArraySize(*aReturnMetricNames), ComSafeArraySize(*aReturnObjects), ComSafeArraySize(*aReturnUnits), ComSafeArraySize(*aReturnScales), ComSafeArraySize(*aReturnSequenceNumbers), ComSafeArraySize(*aReturnDataIndices), ComSafeArraySize(*aReturnDataLengths), ComSafeArraySize(*aReturnData), hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(PerformanceCollectorWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(PerformanceCollectorWrap, IPerformanceCollector)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "PerformanceCollectorWrap.cpp"

// ##### BEGINFILE "NATEngineWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for INATEngine.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef NATEngineWrap_H_
#define NATEngineWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE NATEngineWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(INATEngine)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(NATEngineWrap, INATEngine)
    DECLARE_NOT_AGGREGATABLE(NATEngineWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(NATEngineWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(INATEngine)
        COM_INTERFACE_ENTRY2(IDispatch, INATEngine)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(NATEngineWrap)

    // public INATEngine properties
    STDMETHOD(COMGETTER(Network))(BSTR *aNetwork);
    STDMETHOD(COMSETTER(Network))(IN_BSTR aNetwork);
    STDMETHOD(COMGETTER(HostIP))(BSTR *aHostIP);
    STDMETHOD(COMSETTER(HostIP))(IN_BSTR aHostIP);
    STDMETHOD(COMGETTER(TFTPPrefix))(BSTR *aTFTPPrefix);
    STDMETHOD(COMSETTER(TFTPPrefix))(IN_BSTR aTFTPPrefix);
    STDMETHOD(COMGETTER(TFTPBootFile))(BSTR *aTFTPBootFile);
    STDMETHOD(COMSETTER(TFTPBootFile))(IN_BSTR aTFTPBootFile);
    STDMETHOD(COMGETTER(TFTPNextServer))(BSTR *aTFTPNextServer);
    STDMETHOD(COMSETTER(TFTPNextServer))(IN_BSTR aTFTPNextServer);
    STDMETHOD(COMGETTER(AliasMode))(ULONG *aAliasMode);
    STDMETHOD(COMSETTER(AliasMode))(ULONG aAliasMode);
    STDMETHOD(COMGETTER(DNSPassDomain))(BOOL *aDNSPassDomain);
    STDMETHOD(COMSETTER(DNSPassDomain))(BOOL aDNSPassDomain);
    STDMETHOD(COMGETTER(DNSProxy))(BOOL *aDNSProxy);
    STDMETHOD(COMSETTER(DNSProxy))(BOOL aDNSProxy);
    STDMETHOD(COMGETTER(DNSUseHostResolver))(BOOL *aDNSUseHostResolver);
    STDMETHOD(COMSETTER(DNSUseHostResolver))(BOOL aDNSUseHostResolver);
    STDMETHOD(COMGETTER(Redirects))(ComSafeArrayOut(BSTR, aRedirects));

    // public INATEngine methods
    STDMETHOD(SetNetworkSettings)(ULONG aMtu,
                                  ULONG aSockSnd,
                                  ULONG aSockRcv,
                                  ULONG aTcpWndSnd,
                                  ULONG aTcpWndRcv);
    STDMETHOD(GetNetworkSettings)(ULONG *aMtu,
                                  ULONG *aSockSnd,
                                  ULONG *aSockRcv,
                                  ULONG *aTcpWndSnd,
                                  ULONG *aTcpWndRcv);
    STDMETHOD(AddRedirect)(IN_BSTR aName,
                           NATProtocol_T aProto,
                           IN_BSTR aHostIP,
                           USHORT aHostPort,
                           IN_BSTR aGuestIP,
                           USHORT aGuestPort);
    STDMETHOD(RemoveRedirect)(IN_BSTR aName);

private:
    // wrapped INATEngine properties
    virtual HRESULT getNetwork(com::Utf8Str &aNetwork) = 0;
    virtual HRESULT setNetwork(const com::Utf8Str &aNetwork) = 0;
    virtual HRESULT getHostIP(com::Utf8Str &aHostIP) = 0;
    virtual HRESULT setHostIP(const com::Utf8Str &aHostIP) = 0;
    virtual HRESULT getTFTPPrefix(com::Utf8Str &aTFTPPrefix) = 0;
    virtual HRESULT setTFTPPrefix(const com::Utf8Str &aTFTPPrefix) = 0;
    virtual HRESULT getTFTPBootFile(com::Utf8Str &aTFTPBootFile) = 0;
    virtual HRESULT setTFTPBootFile(const com::Utf8Str &aTFTPBootFile) = 0;
    virtual HRESULT getTFTPNextServer(com::Utf8Str &aTFTPNextServer) = 0;
    virtual HRESULT setTFTPNextServer(const com::Utf8Str &aTFTPNextServer) = 0;
    virtual HRESULT getAliasMode(ULONG *aAliasMode) = 0;
    virtual HRESULT setAliasMode(ULONG aAliasMode) = 0;
    virtual HRESULT getDNSPassDomain(BOOL *aDNSPassDomain) = 0;
    virtual HRESULT setDNSPassDomain(BOOL aDNSPassDomain) = 0;
    virtual HRESULT getDNSProxy(BOOL *aDNSProxy) = 0;
    virtual HRESULT setDNSProxy(BOOL aDNSProxy) = 0;
    virtual HRESULT getDNSUseHostResolver(BOOL *aDNSUseHostResolver) = 0;
    virtual HRESULT setDNSUseHostResolver(BOOL aDNSUseHostResolver) = 0;
    virtual HRESULT getRedirects(std::vector<com::Utf8Str> &aRedirects) = 0;

    // wrapped INATEngine methods
    virtual HRESULT setNetworkSettings(ULONG aMtu,
                                       ULONG aSockSnd,
                                       ULONG aSockRcv,
                                       ULONG aTcpWndSnd,
                                       ULONG aTcpWndRcv) = 0;
    virtual HRESULT getNetworkSettings(ULONG *aMtu,
                                       ULONG *aSockSnd,
                                       ULONG *aSockRcv,
                                       ULONG *aTcpWndSnd,
                                       ULONG *aTcpWndRcv) = 0;
    virtual HRESULT addRedirect(const com::Utf8Str &aName,
                                NATProtocol_T aProto,
                                const com::Utf8Str &aHostIP,
                                USHORT aHostPort,
                                const com::Utf8Str &aGuestIP,
                                USHORT aGuestPort) = 0;
    virtual HRESULT removeRedirect(const com::Utf8Str &aName) = 0;
};

#endif // !NATEngineWrap_H_

// ##### ENDFILE "NATEngineWrap.h"

// ##### BEGINFILE "NATEngineWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for INATEngine.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_NATENGINE

#include "NATEngineWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(NATEngineWrap)

//
// INATEngine properties
//

STDMETHODIMP NATEngineWrap::COMGETTER(Network)(BSTR *aNetwork)
{
    LogRelFlow(("{%p} %s: enter aNetwork=%p\n", this, "NATEngine::getNetwork", aNetwork));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNetwork);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNetwork(BSTROutConverter(aNetwork).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNetwork=%ls hrc=%Rhrc\n", this, "NATEngine::getNetwork", *aNetwork, hrc));
    return hrc;
}

STDMETHODIMP NATEngineWrap::COMSETTER(Network)(IN_BSTR aNetwork)
{
    LogRelFlow(("{%p} %s: enter aNetwork=%ls\n", this, "NATEngine::setNetwork", aNetwork));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setNetwork(BSTRInConverter(aNetwork).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATEngine::setNetwork", hrc));
    return hrc;
}

STDMETHODIMP NATEngineWrap::COMGETTER(HostIP)(BSTR *aHostIP)
{
    LogRelFlow(("{%p} %s: enter aHostIP=%p\n", this, "NATEngine::getHostIP", aHostIP));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHostIP);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHostIP(BSTROutConverter(aHostIP).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHostIP=%ls hrc=%Rhrc\n", this, "NATEngine::getHostIP", *aHostIP, hrc));
    return hrc;
}

STDMETHODIMP NATEngineWrap::COMSETTER(HostIP)(IN_BSTR aHostIP)
{
    LogRelFlow(("{%p} %s: enter aHostIP=%ls\n", this, "NATEngine::setHostIP", aHostIP));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setHostIP(BSTRInConverter(aHostIP).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATEngine::setHostIP", hrc));
    return hrc;
}

STDMETHODIMP NATEngineWrap::COMGETTER(TFTPPrefix)(BSTR *aTFTPPrefix)
{
    LogRelFlow(("{%p} %s: enter aTFTPPrefix=%p\n", this, "NATEngine::getTFTPPrefix", aTFTPPrefix));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aTFTPPrefix);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getTFTPPrefix(BSTROutConverter(aTFTPPrefix).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aTFTPPrefix=%ls hrc=%Rhrc\n", this, "NATEngine::getTFTPPrefix", *aTFTPPrefix, hrc));
    return hrc;
}

STDMETHODIMP NATEngineWrap::COMSETTER(TFTPPrefix)(IN_BSTR aTFTPPrefix)
{
    LogRelFlow(("{%p} %s: enter aTFTPPrefix=%ls\n", this, "NATEngine::setTFTPPrefix", aTFTPPrefix));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setTFTPPrefix(BSTRInConverter(aTFTPPrefix).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATEngine::setTFTPPrefix", hrc));
    return hrc;
}

STDMETHODIMP NATEngineWrap::COMGETTER(TFTPBootFile)(BSTR *aTFTPBootFile)
{
    LogRelFlow(("{%p} %s: enter aTFTPBootFile=%p\n", this, "NATEngine::getTFTPBootFile", aTFTPBootFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aTFTPBootFile);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getTFTPBootFile(BSTROutConverter(aTFTPBootFile).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aTFTPBootFile=%ls hrc=%Rhrc\n", this, "NATEngine::getTFTPBootFile", *aTFTPBootFile, hrc));
    return hrc;
}

STDMETHODIMP NATEngineWrap::COMSETTER(TFTPBootFile)(IN_BSTR aTFTPBootFile)
{
    LogRelFlow(("{%p} %s: enter aTFTPBootFile=%ls\n", this, "NATEngine::setTFTPBootFile", aTFTPBootFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setTFTPBootFile(BSTRInConverter(aTFTPBootFile).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATEngine::setTFTPBootFile", hrc));
    return hrc;
}

STDMETHODIMP NATEngineWrap::COMGETTER(TFTPNextServer)(BSTR *aTFTPNextServer)
{
    LogRelFlow(("{%p} %s: enter aTFTPNextServer=%p\n", this, "NATEngine::getTFTPNextServer", aTFTPNextServer));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aTFTPNextServer);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getTFTPNextServer(BSTROutConverter(aTFTPNextServer).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aTFTPNextServer=%ls hrc=%Rhrc\n", this, "NATEngine::getTFTPNextServer", *aTFTPNextServer, hrc));
    return hrc;
}

STDMETHODIMP NATEngineWrap::COMSETTER(TFTPNextServer)(IN_BSTR aTFTPNextServer)
{
    LogRelFlow(("{%p} %s: enter aTFTPNextServer=%ls\n", this, "NATEngine::setTFTPNextServer", aTFTPNextServer));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setTFTPNextServer(BSTRInConverter(aTFTPNextServer).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATEngine::setTFTPNextServer", hrc));
    return hrc;
}

STDMETHODIMP NATEngineWrap::COMGETTER(AliasMode)(ULONG *aAliasMode)
{
    LogRelFlow(("{%p} %s: enter aAliasMode=%p\n", this, "NATEngine::getAliasMode", aAliasMode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAliasMode);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAliasMode(aAliasMode);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAliasMode=%RU32 hrc=%Rhrc\n", this, "NATEngine::getAliasMode", *aAliasMode, hrc));
    return hrc;
}

STDMETHODIMP NATEngineWrap::COMSETTER(AliasMode)(ULONG aAliasMode)
{
    LogRelFlow(("{%p} %s: enter aAliasMode=%RU32\n", this, "NATEngine::setAliasMode", aAliasMode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setAliasMode(aAliasMode);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATEngine::setAliasMode", hrc));
    return hrc;
}

STDMETHODIMP NATEngineWrap::COMGETTER(DNSPassDomain)(BOOL *aDNSPassDomain)
{
    LogRelFlow(("{%p} %s: enter aDNSPassDomain=%p\n", this, "NATEngine::getDNSPassDomain", aDNSPassDomain));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDNSPassDomain);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDNSPassDomain(aDNSPassDomain);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDNSPassDomain=%RTbool hrc=%Rhrc\n", this, "NATEngine::getDNSPassDomain", *aDNSPassDomain, hrc));
    return hrc;
}

STDMETHODIMP NATEngineWrap::COMSETTER(DNSPassDomain)(BOOL aDNSPassDomain)
{
    LogRelFlow(("{%p} %s: enter aDNSPassDomain=%RTbool\n", this, "NATEngine::setDNSPassDomain", aDNSPassDomain));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setDNSPassDomain(aDNSPassDomain);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATEngine::setDNSPassDomain", hrc));
    return hrc;
}

STDMETHODIMP NATEngineWrap::COMGETTER(DNSProxy)(BOOL *aDNSProxy)
{
    LogRelFlow(("{%p} %s: enter aDNSProxy=%p\n", this, "NATEngine::getDNSProxy", aDNSProxy));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDNSProxy);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDNSProxy(aDNSProxy);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDNSProxy=%RTbool hrc=%Rhrc\n", this, "NATEngine::getDNSProxy", *aDNSProxy, hrc));
    return hrc;
}

STDMETHODIMP NATEngineWrap::COMSETTER(DNSProxy)(BOOL aDNSProxy)
{
    LogRelFlow(("{%p} %s: enter aDNSProxy=%RTbool\n", this, "NATEngine::setDNSProxy", aDNSProxy));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setDNSProxy(aDNSProxy);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATEngine::setDNSProxy", hrc));
    return hrc;
}

STDMETHODIMP NATEngineWrap::COMGETTER(DNSUseHostResolver)(BOOL *aDNSUseHostResolver)
{
    LogRelFlow(("{%p} %s: enter aDNSUseHostResolver=%p\n", this, "NATEngine::getDNSUseHostResolver", aDNSUseHostResolver));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDNSUseHostResolver);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDNSUseHostResolver(aDNSUseHostResolver);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDNSUseHostResolver=%RTbool hrc=%Rhrc\n", this, "NATEngine::getDNSUseHostResolver", *aDNSUseHostResolver, hrc));
    return hrc;
}

STDMETHODIMP NATEngineWrap::COMSETTER(DNSUseHostResolver)(BOOL aDNSUseHostResolver)
{
    LogRelFlow(("{%p} %s: enter aDNSUseHostResolver=%RTbool\n", this, "NATEngine::setDNSUseHostResolver", aDNSUseHostResolver));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setDNSUseHostResolver(aDNSUseHostResolver);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATEngine::setDNSUseHostResolver", hrc));
    return hrc;
}

STDMETHODIMP NATEngineWrap::COMGETTER(Redirects)(ComSafeArrayOut(BSTR, aRedirects))
{
    LogRelFlow(("{%p} %s: enter aRedirects=%p\n", this, "NATEngine::getRedirects", aRedirects));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRedirects);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRedirects(ArrayBSTROutConverter(ComSafeArrayOutArg(aRedirects)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRedirects=%zu hrc=%Rhrc\n", this, "NATEngine::getRedirects", ComSafeArraySize(*aRedirects), hrc));
    return hrc;
}

//
// INATEngine methods
//

STDMETHODIMP NATEngineWrap::SetNetworkSettings(ULONG aMtu,
                                               ULONG aSockSnd,
                                               ULONG aSockRcv,
                                               ULONG aTcpWndSnd,
                                               ULONG aTcpWndRcv)
{
    LogRelFlow(("{%p} %s:enter aMtu=%RU32 aSockSnd=%RU32 aSockRcv=%RU32 aTcpWndSnd=%RU32 aTcpWndRcv=%RU32\n", this, "NATEngine::setNetworkSettings", aMtu, aSockSnd, aSockRcv, aTcpWndSnd, aTcpWndRcv));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setNetworkSettings(aMtu,
                                 aSockSnd,
                                 aSockRcv,
                                 aTcpWndSnd,
                                 aTcpWndRcv);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATEngine::setNetworkSettings", hrc));
    return hrc;
}

STDMETHODIMP NATEngineWrap::GetNetworkSettings(ULONG *aMtu,
                                               ULONG *aSockSnd,
                                               ULONG *aSockRcv,
                                               ULONG *aTcpWndSnd,
                                               ULONG *aTcpWndRcv)
{
    LogRelFlow(("{%p} %s:enter aMtu=%p aSockSnd=%p aSockRcv=%p aTcpWndSnd=%p aTcpWndRcv=%p\n", this, "NATEngine::getNetworkSettings", aMtu, aSockSnd, aSockRcv, aTcpWndSnd, aTcpWndRcv));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMtu);
        CheckComArgOutPointerValidThrow(aSockSnd);
        CheckComArgOutPointerValidThrow(aSockRcv);
        CheckComArgOutPointerValidThrow(aTcpWndSnd);
        CheckComArgOutPointerValidThrow(aTcpWndRcv);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNetworkSettings(aMtu,
                                 aSockSnd,
                                 aSockRcv,
                                 aTcpWndSnd,
                                 aTcpWndRcv);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMtu=%RU32 *aSockSnd=%RU32 *aSockRcv=%RU32 *aTcpWndSnd=%RU32 *aTcpWndRcv=%RU32 hrc=%Rhrc\n", this, "NATEngine::getNetworkSettings", *aMtu, *aSockSnd, *aSockRcv, *aTcpWndSnd, *aTcpWndRcv, hrc));
    return hrc;
}

STDMETHODIMP NATEngineWrap::AddRedirect(IN_BSTR aName,
                                        NATProtocol_T aProto,
                                        IN_BSTR aHostIP,
                                        USHORT aHostPort,
                                        IN_BSTR aGuestIP,
                                        USHORT aGuestPort)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aProto=%RU32 aHostIP=%ls aHostPort=%RU16 aGuestIP=%ls aGuestPort=%RU16\n", this, "NATEngine::addRedirect", aName, aProto, aHostIP, aHostPort, aGuestIP, aGuestPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = addRedirect(BSTRInConverter(aName).str(),
                          aProto,
                          BSTRInConverter(aHostIP).str(),
                          aHostPort,
                          BSTRInConverter(aGuestIP).str(),
                          aGuestPort);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATEngine::addRedirect", hrc));
    return hrc;
}

STDMETHODIMP NATEngineWrap::RemoveRedirect(IN_BSTR aName)
{
    LogRelFlow(("{%p} %s:enter aName=%ls\n", this, "NATEngine::removeRedirect", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = removeRedirect(BSTRInConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATEngine::removeRedirect", hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(NATEngineWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(NATEngineWrap, INATEngine)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "NATEngineWrap.cpp"

// ##### BEGINFILE "ExtPackPlugInWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IExtPackPlugIn.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef ExtPackPlugInWrap_H_
#define ExtPackPlugInWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE ExtPackPlugInWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IExtPackPlugIn)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(ExtPackPlugInWrap, IExtPackPlugIn)
    DECLARE_NOT_AGGREGATABLE(ExtPackPlugInWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(ExtPackPlugInWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IExtPackPlugIn)
        COM_INTERFACE_ENTRY2(IDispatch, IExtPackPlugIn)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(ExtPackPlugInWrap)

    // public IExtPackPlugIn properties
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(Description))(BSTR *aDescription);
    STDMETHOD(COMGETTER(Frontend))(BSTR *aFrontend);
    STDMETHOD(COMGETTER(ModulePath))(BSTR *aModulePath);

    // public IExtPackPlugIn methods

private:
    // wrapped IExtPackPlugIn properties
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getDescription(com::Utf8Str &aDescription) = 0;
    virtual HRESULT getFrontend(com::Utf8Str &aFrontend) = 0;
    virtual HRESULT getModulePath(com::Utf8Str &aModulePath) = 0;

    // wrapped IExtPackPlugIn methods
};

#endif // !ExtPackPlugInWrap_H_

// ##### ENDFILE "ExtPackPlugInWrap.h"

// ##### BEGINFILE "ExtPackPlugInWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IExtPackPlugIn.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_EXTPACKPLUGIN

#include "ExtPackPlugInWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(ExtPackPlugInWrap)

//
// IExtPackPlugIn properties
//

STDMETHODIMP ExtPackPlugInWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "ExtPackPlugIn::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "ExtPackPlugIn::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP ExtPackPlugInWrap::COMGETTER(Description)(BSTR *aDescription)
{
    LogRelFlow(("{%p} %s: enter aDescription=%p\n", this, "ExtPackPlugIn::getDescription", aDescription));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDescription);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDescription(BSTROutConverter(aDescription).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDescription=%ls hrc=%Rhrc\n", this, "ExtPackPlugIn::getDescription", *aDescription, hrc));
    return hrc;
}

STDMETHODIMP ExtPackPlugInWrap::COMGETTER(Frontend)(BSTR *aFrontend)
{
    LogRelFlow(("{%p} %s: enter aFrontend=%p\n", this, "ExtPackPlugIn::getFrontend", aFrontend));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFrontend);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFrontend(BSTROutConverter(aFrontend).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFrontend=%ls hrc=%Rhrc\n", this, "ExtPackPlugIn::getFrontend", *aFrontend, hrc));
    return hrc;
}

STDMETHODIMP ExtPackPlugInWrap::COMGETTER(ModulePath)(BSTR *aModulePath)
{
    LogRelFlow(("{%p} %s: enter aModulePath=%p\n", this, "ExtPackPlugIn::getModulePath", aModulePath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aModulePath);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getModulePath(BSTROutConverter(aModulePath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aModulePath=%ls hrc=%Rhrc\n", this, "ExtPackPlugIn::getModulePath", *aModulePath, hrc));
    return hrc;
}

//
// IExtPackPlugIn methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(ExtPackPlugInWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(ExtPackPlugInWrap, IExtPackPlugIn)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "ExtPackPlugInWrap.cpp"

// ##### BEGINFILE "ExtPackBaseWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IExtPackBase.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef ExtPackBaseWrap_H_
#define ExtPackBaseWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE ExtPackBaseWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IExtPackBase)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(ExtPackBaseWrap, IExtPackBase)
    DECLARE_NOT_AGGREGATABLE(ExtPackBaseWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(ExtPackBaseWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IExtPackBase)
        COM_INTERFACE_ENTRY2(IDispatch, IExtPackBase)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(ExtPackBaseWrap)

    // public IExtPackBase properties
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(Description))(BSTR *aDescription);
    STDMETHOD(COMGETTER(Version))(BSTR *aVersion);
    STDMETHOD(COMGETTER(Revision))(ULONG *aRevision);
    STDMETHOD(COMGETTER(Edition))(BSTR *aEdition);
    STDMETHOD(COMGETTER(VRDEModule))(BSTR *aVRDEModule);
    STDMETHOD(COMGETTER(PlugIns))(ComSafeArrayOut(IExtPackPlugIn *, aPlugIns));
    STDMETHOD(COMGETTER(Usable))(BOOL *aUsable);
    STDMETHOD(COMGETTER(WhyUnusable))(BSTR *aWhyUnusable);
    STDMETHOD(COMGETTER(ShowLicense))(BOOL *aShowLicense);
    STDMETHOD(COMGETTER(License))(BSTR *aLicense);

    // public IExtPackBase methods
    STDMETHOD(QueryLicense)(IN_BSTR aPreferredLocale,
                            IN_BSTR aPreferredLanguage,
                            IN_BSTR aFormat,
                            BSTR *aLicenseText);

private:
    // wrapped IExtPackBase properties
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getDescription(com::Utf8Str &aDescription) = 0;
    virtual HRESULT getVersion(com::Utf8Str &aVersion) = 0;
    virtual HRESULT getRevision(ULONG *aRevision) = 0;
    virtual HRESULT getEdition(com::Utf8Str &aEdition) = 0;
    virtual HRESULT getVRDEModule(com::Utf8Str &aVRDEModule) = 0;
    virtual HRESULT getPlugIns(std::vector<ComPtr<IExtPackPlugIn> > &aPlugIns) = 0;
    virtual HRESULT getUsable(BOOL *aUsable) = 0;
    virtual HRESULT getWhyUnusable(com::Utf8Str &aWhyUnusable) = 0;
    virtual HRESULT getShowLicense(BOOL *aShowLicense) = 0;
    virtual HRESULT getLicense(com::Utf8Str &aLicense) = 0;

    // wrapped IExtPackBase methods
    virtual HRESULT queryLicense(const com::Utf8Str &aPreferredLocale,
                                 const com::Utf8Str &aPreferredLanguage,
                                 const com::Utf8Str &aFormat,
                                 com::Utf8Str &aLicenseText) = 0;
};

#endif // !ExtPackBaseWrap_H_

// ##### ENDFILE "ExtPackBaseWrap.h"

// ##### BEGINFILE "ExtPackBaseWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IExtPackBase.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_EXTPACKBASE

#include "ExtPackBaseWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(ExtPackBaseWrap)

//
// IExtPackBase properties
//

STDMETHODIMP ExtPackBaseWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "ExtPackBase::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "ExtPackBase::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP ExtPackBaseWrap::COMGETTER(Description)(BSTR *aDescription)
{
    LogRelFlow(("{%p} %s: enter aDescription=%p\n", this, "ExtPackBase::getDescription", aDescription));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDescription);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDescription(BSTROutConverter(aDescription).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDescription=%ls hrc=%Rhrc\n", this, "ExtPackBase::getDescription", *aDescription, hrc));
    return hrc;
}

STDMETHODIMP ExtPackBaseWrap::COMGETTER(Version)(BSTR *aVersion)
{
    LogRelFlow(("{%p} %s: enter aVersion=%p\n", this, "ExtPackBase::getVersion", aVersion));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVersion);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVersion(BSTROutConverter(aVersion).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVersion=%ls hrc=%Rhrc\n", this, "ExtPackBase::getVersion", *aVersion, hrc));
    return hrc;
}

STDMETHODIMP ExtPackBaseWrap::COMGETTER(Revision)(ULONG *aRevision)
{
    LogRelFlow(("{%p} %s: enter aRevision=%p\n", this, "ExtPackBase::getRevision", aRevision));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRevision);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRevision(aRevision);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRevision=%RU32 hrc=%Rhrc\n", this, "ExtPackBase::getRevision", *aRevision, hrc));
    return hrc;
}

STDMETHODIMP ExtPackBaseWrap::COMGETTER(Edition)(BSTR *aEdition)
{
    LogRelFlow(("{%p} %s: enter aEdition=%p\n", this, "ExtPackBase::getEdition", aEdition));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEdition);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEdition(BSTROutConverter(aEdition).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEdition=%ls hrc=%Rhrc\n", this, "ExtPackBase::getEdition", *aEdition, hrc));
    return hrc;
}

STDMETHODIMP ExtPackBaseWrap::COMGETTER(VRDEModule)(BSTR *aVRDEModule)
{
    LogRelFlow(("{%p} %s: enter aVRDEModule=%p\n", this, "ExtPackBase::getVRDEModule", aVRDEModule));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVRDEModule);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVRDEModule(BSTROutConverter(aVRDEModule).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVRDEModule=%ls hrc=%Rhrc\n", this, "ExtPackBase::getVRDEModule", *aVRDEModule, hrc));
    return hrc;
}

STDMETHODIMP ExtPackBaseWrap::COMGETTER(PlugIns)(ComSafeArrayOut(IExtPackPlugIn *, aPlugIns))
{
    LogRelFlow(("{%p} %s: enter aPlugIns=%p\n", this, "ExtPackBase::getPlugIns", aPlugIns));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPlugIns);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPlugIns(ArrayComTypeOutConverter<IExtPackPlugIn>(ComSafeArrayOutArg(aPlugIns)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPlugIns=%zu hrc=%Rhrc\n", this, "ExtPackBase::getPlugIns", ComSafeArraySize(*aPlugIns), hrc));
    return hrc;
}

STDMETHODIMP ExtPackBaseWrap::COMGETTER(Usable)(BOOL *aUsable)
{
    LogRelFlow(("{%p} %s: enter aUsable=%p\n", this, "ExtPackBase::getUsable", aUsable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUsable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUsable(aUsable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUsable=%RTbool hrc=%Rhrc\n", this, "ExtPackBase::getUsable", *aUsable, hrc));
    return hrc;
}

STDMETHODIMP ExtPackBaseWrap::COMGETTER(WhyUnusable)(BSTR *aWhyUnusable)
{
    LogRelFlow(("{%p} %s: enter aWhyUnusable=%p\n", this, "ExtPackBase::getWhyUnusable", aWhyUnusable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWhyUnusable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWhyUnusable(BSTROutConverter(aWhyUnusable).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWhyUnusable=%ls hrc=%Rhrc\n", this, "ExtPackBase::getWhyUnusable", *aWhyUnusable, hrc));
    return hrc;
}

STDMETHODIMP ExtPackBaseWrap::COMGETTER(ShowLicense)(BOOL *aShowLicense)
{
    LogRelFlow(("{%p} %s: enter aShowLicense=%p\n", this, "ExtPackBase::getShowLicense", aShowLicense));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aShowLicense);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getShowLicense(aShowLicense);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aShowLicense=%RTbool hrc=%Rhrc\n", this, "ExtPackBase::getShowLicense", *aShowLicense, hrc));
    return hrc;
}

STDMETHODIMP ExtPackBaseWrap::COMGETTER(License)(BSTR *aLicense)
{
    LogRelFlow(("{%p} %s: enter aLicense=%p\n", this, "ExtPackBase::getLicense", aLicense));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLicense);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLicense(BSTROutConverter(aLicense).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLicense=%ls hrc=%Rhrc\n", this, "ExtPackBase::getLicense", *aLicense, hrc));
    return hrc;
}

//
// IExtPackBase methods
//

STDMETHODIMP ExtPackBaseWrap::QueryLicense(IN_BSTR aPreferredLocale,
                                           IN_BSTR aPreferredLanguage,
                                           IN_BSTR aFormat,
                                           BSTR *aLicenseText)
{
    LogRelFlow(("{%p} %s:enter aPreferredLocale=%ls aPreferredLanguage=%ls aFormat=%ls aLicenseText=%p\n", this, "ExtPackBase::queryLicense", aPreferredLocale, aPreferredLanguage, aFormat, aLicenseText));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLicenseText);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = queryLicense(BSTRInConverter(aPreferredLocale).str(),
                           BSTRInConverter(aPreferredLanguage).str(),
                           BSTRInConverter(aFormat).str(),
                           BSTROutConverter(aLicenseText).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aLicenseText=%ls hrc=%Rhrc\n", this, "ExtPackBase::queryLicense", *aLicenseText, hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(ExtPackBaseWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(ExtPackBaseWrap, IExtPackBase)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "ExtPackBaseWrap.cpp"

// ##### BEGINFILE "ExtPackWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IExtPack.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef ExtPackWrap_H_
#define ExtPackWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE ExtPackWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IExtPack)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(ExtPackWrap, IExtPack)
    DECLARE_NOT_AGGREGATABLE(ExtPackWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(ExtPackWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IExtPack)
        COM_INTERFACE_ENTRY(IExtPackBase)
        COM_INTERFACE_ENTRY2(IDispatch, IExtPack)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(ExtPackWrap)

    // public IExtPackBase properties
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(Description))(BSTR *aDescription);
    STDMETHOD(COMGETTER(Version))(BSTR *aVersion);
    STDMETHOD(COMGETTER(Revision))(ULONG *aRevision);
    STDMETHOD(COMGETTER(Edition))(BSTR *aEdition);
    STDMETHOD(COMGETTER(VRDEModule))(BSTR *aVRDEModule);
    STDMETHOD(COMGETTER(PlugIns))(ComSafeArrayOut(IExtPackPlugIn *, aPlugIns));
    STDMETHOD(COMGETTER(Usable))(BOOL *aUsable);
    STDMETHOD(COMGETTER(WhyUnusable))(BSTR *aWhyUnusable);
    STDMETHOD(COMGETTER(ShowLicense))(BOOL *aShowLicense);
    STDMETHOD(COMGETTER(License))(BSTR *aLicense);

    // public IExtPack properties

    // public IExtPackBase methods
    STDMETHOD(QueryLicense)(IN_BSTR aPreferredLocale,
                            IN_BSTR aPreferredLanguage,
                            IN_BSTR aFormat,
                            BSTR *aLicenseText);

    // public IExtPack methods
    STDMETHOD(QueryObject)(IN_BSTR aObjUuid,
                           IUnknown **aReturnInterface);

private:
    // wrapped IExtPackBase properties
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getDescription(com::Utf8Str &aDescription) = 0;
    virtual HRESULT getVersion(com::Utf8Str &aVersion) = 0;
    virtual HRESULT getRevision(ULONG *aRevision) = 0;
    virtual HRESULT getEdition(com::Utf8Str &aEdition) = 0;
    virtual HRESULT getVRDEModule(com::Utf8Str &aVRDEModule) = 0;
    virtual HRESULT getPlugIns(std::vector<ComPtr<IExtPackPlugIn> > &aPlugIns) = 0;
    virtual HRESULT getUsable(BOOL *aUsable) = 0;
    virtual HRESULT getWhyUnusable(com::Utf8Str &aWhyUnusable) = 0;
    virtual HRESULT getShowLicense(BOOL *aShowLicense) = 0;
    virtual HRESULT getLicense(com::Utf8Str &aLicense) = 0;

    // wrapped IExtPack properties

    // wrapped IExtPackBase methods
    virtual HRESULT queryLicense(const com::Utf8Str &aPreferredLocale,
                                 const com::Utf8Str &aPreferredLanguage,
                                 const com::Utf8Str &aFormat,
                                 com::Utf8Str &aLicenseText) = 0;

    // wrapped IExtPack methods
    virtual HRESULT queryObject(const com::Utf8Str &aObjUuid,
                                ComPtr<IUnknown> &aReturnInterface) = 0;
};

#endif // !ExtPackWrap_H_

// ##### ENDFILE "ExtPackWrap.h"

// ##### BEGINFILE "ExtPackWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IExtPack.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_EXTPACK

#include "ExtPackWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(ExtPackWrap)

//
// IExtPackBase properties
//

STDMETHODIMP ExtPackWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "ExtPack::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "ExtPack::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP ExtPackWrap::COMGETTER(Description)(BSTR *aDescription)
{
    LogRelFlow(("{%p} %s: enter aDescription=%p\n", this, "ExtPack::getDescription", aDescription));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDescription);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDescription(BSTROutConverter(aDescription).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDescription=%ls hrc=%Rhrc\n", this, "ExtPack::getDescription", *aDescription, hrc));
    return hrc;
}

STDMETHODIMP ExtPackWrap::COMGETTER(Version)(BSTR *aVersion)
{
    LogRelFlow(("{%p} %s: enter aVersion=%p\n", this, "ExtPack::getVersion", aVersion));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVersion);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVersion(BSTROutConverter(aVersion).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVersion=%ls hrc=%Rhrc\n", this, "ExtPack::getVersion", *aVersion, hrc));
    return hrc;
}

STDMETHODIMP ExtPackWrap::COMGETTER(Revision)(ULONG *aRevision)
{
    LogRelFlow(("{%p} %s: enter aRevision=%p\n", this, "ExtPack::getRevision", aRevision));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRevision);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRevision(aRevision);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRevision=%RU32 hrc=%Rhrc\n", this, "ExtPack::getRevision", *aRevision, hrc));
    return hrc;
}

STDMETHODIMP ExtPackWrap::COMGETTER(Edition)(BSTR *aEdition)
{
    LogRelFlow(("{%p} %s: enter aEdition=%p\n", this, "ExtPack::getEdition", aEdition));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEdition);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEdition(BSTROutConverter(aEdition).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEdition=%ls hrc=%Rhrc\n", this, "ExtPack::getEdition", *aEdition, hrc));
    return hrc;
}

STDMETHODIMP ExtPackWrap::COMGETTER(VRDEModule)(BSTR *aVRDEModule)
{
    LogRelFlow(("{%p} %s: enter aVRDEModule=%p\n", this, "ExtPack::getVRDEModule", aVRDEModule));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVRDEModule);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVRDEModule(BSTROutConverter(aVRDEModule).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVRDEModule=%ls hrc=%Rhrc\n", this, "ExtPack::getVRDEModule", *aVRDEModule, hrc));
    return hrc;
}

STDMETHODIMP ExtPackWrap::COMGETTER(PlugIns)(ComSafeArrayOut(IExtPackPlugIn *, aPlugIns))
{
    LogRelFlow(("{%p} %s: enter aPlugIns=%p\n", this, "ExtPack::getPlugIns", aPlugIns));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPlugIns);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPlugIns(ArrayComTypeOutConverter<IExtPackPlugIn>(ComSafeArrayOutArg(aPlugIns)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPlugIns=%zu hrc=%Rhrc\n", this, "ExtPack::getPlugIns", ComSafeArraySize(*aPlugIns), hrc));
    return hrc;
}

STDMETHODIMP ExtPackWrap::COMGETTER(Usable)(BOOL *aUsable)
{
    LogRelFlow(("{%p} %s: enter aUsable=%p\n", this, "ExtPack::getUsable", aUsable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUsable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUsable(aUsable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUsable=%RTbool hrc=%Rhrc\n", this, "ExtPack::getUsable", *aUsable, hrc));
    return hrc;
}

STDMETHODIMP ExtPackWrap::COMGETTER(WhyUnusable)(BSTR *aWhyUnusable)
{
    LogRelFlow(("{%p} %s: enter aWhyUnusable=%p\n", this, "ExtPack::getWhyUnusable", aWhyUnusable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWhyUnusable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWhyUnusable(BSTROutConverter(aWhyUnusable).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWhyUnusable=%ls hrc=%Rhrc\n", this, "ExtPack::getWhyUnusable", *aWhyUnusable, hrc));
    return hrc;
}

STDMETHODIMP ExtPackWrap::COMGETTER(ShowLicense)(BOOL *aShowLicense)
{
    LogRelFlow(("{%p} %s: enter aShowLicense=%p\n", this, "ExtPack::getShowLicense", aShowLicense));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aShowLicense);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getShowLicense(aShowLicense);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aShowLicense=%RTbool hrc=%Rhrc\n", this, "ExtPack::getShowLicense", *aShowLicense, hrc));
    return hrc;
}

STDMETHODIMP ExtPackWrap::COMGETTER(License)(BSTR *aLicense)
{
    LogRelFlow(("{%p} %s: enter aLicense=%p\n", this, "ExtPack::getLicense", aLicense));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLicense);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLicense(BSTROutConverter(aLicense).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLicense=%ls hrc=%Rhrc\n", this, "ExtPack::getLicense", *aLicense, hrc));
    return hrc;
}

//
// IExtPack properties
//

//
// IExtPackBase methods
//

STDMETHODIMP ExtPackWrap::QueryLicense(IN_BSTR aPreferredLocale,
                                       IN_BSTR aPreferredLanguage,
                                       IN_BSTR aFormat,
                                       BSTR *aLicenseText)
{
    LogRelFlow(("{%p} %s:enter aPreferredLocale=%ls aPreferredLanguage=%ls aFormat=%ls aLicenseText=%p\n", this, "ExtPack::queryLicense", aPreferredLocale, aPreferredLanguage, aFormat, aLicenseText));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLicenseText);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = queryLicense(BSTRInConverter(aPreferredLocale).str(),
                           BSTRInConverter(aPreferredLanguage).str(),
                           BSTRInConverter(aFormat).str(),
                           BSTROutConverter(aLicenseText).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aLicenseText=%ls hrc=%Rhrc\n", this, "ExtPack::queryLicense", *aLicenseText, hrc));
    return hrc;
}

//
// IExtPack methods
//

STDMETHODIMP ExtPackWrap::QueryObject(IN_BSTR aObjUuid,
                                      IUnknown **aReturnInterface)
{
    LogRelFlow(("{%p} %s:enter aObjUuid=%ls aReturnInterface=%p\n", this, "ExtPack::queryObject", aObjUuid, aReturnInterface));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aReturnInterface);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = queryObject(BSTRInConverter(aObjUuid).str(),
                          ComTypeOutConverter<IUnknown>(aReturnInterface).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aReturnInterface=%p hrc=%Rhrc\n", this, "ExtPack::queryObject", *aReturnInterface, hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(ExtPackWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(ExtPackWrap, IExtPack, IExtPackBase)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "ExtPackWrap.cpp"

// ##### BEGINFILE "ExtPackFileWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IExtPackFile.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef ExtPackFileWrap_H_
#define ExtPackFileWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE ExtPackFileWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IExtPackFile)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(ExtPackFileWrap, IExtPackFile)
    DECLARE_NOT_AGGREGATABLE(ExtPackFileWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(ExtPackFileWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IExtPackFile)
        COM_INTERFACE_ENTRY(IExtPackBase)
        COM_INTERFACE_ENTRY2(IDispatch, IExtPackFile)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(ExtPackFileWrap)

    // public IExtPackBase properties
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(Description))(BSTR *aDescription);
    STDMETHOD(COMGETTER(Version))(BSTR *aVersion);
    STDMETHOD(COMGETTER(Revision))(ULONG *aRevision);
    STDMETHOD(COMGETTER(Edition))(BSTR *aEdition);
    STDMETHOD(COMGETTER(VRDEModule))(BSTR *aVRDEModule);
    STDMETHOD(COMGETTER(PlugIns))(ComSafeArrayOut(IExtPackPlugIn *, aPlugIns));
    STDMETHOD(COMGETTER(Usable))(BOOL *aUsable);
    STDMETHOD(COMGETTER(WhyUnusable))(BSTR *aWhyUnusable);
    STDMETHOD(COMGETTER(ShowLicense))(BOOL *aShowLicense);
    STDMETHOD(COMGETTER(License))(BSTR *aLicense);

    // public IExtPackFile properties
    STDMETHOD(COMGETTER(FilePath))(BSTR *aFilePath);

    // public IExtPackBase methods
    STDMETHOD(QueryLicense)(IN_BSTR aPreferredLocale,
                            IN_BSTR aPreferredLanguage,
                            IN_BSTR aFormat,
                            BSTR *aLicenseText);

    // public IExtPackFile methods
    STDMETHOD(Install)(BOOL aReplace,
                       IN_BSTR aDisplayInfo,
                       IProgress **aProgess);

private:
    // wrapped IExtPackBase properties
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getDescription(com::Utf8Str &aDescription) = 0;
    virtual HRESULT getVersion(com::Utf8Str &aVersion) = 0;
    virtual HRESULT getRevision(ULONG *aRevision) = 0;
    virtual HRESULT getEdition(com::Utf8Str &aEdition) = 0;
    virtual HRESULT getVRDEModule(com::Utf8Str &aVRDEModule) = 0;
    virtual HRESULT getPlugIns(std::vector<ComPtr<IExtPackPlugIn> > &aPlugIns) = 0;
    virtual HRESULT getUsable(BOOL *aUsable) = 0;
    virtual HRESULT getWhyUnusable(com::Utf8Str &aWhyUnusable) = 0;
    virtual HRESULT getShowLicense(BOOL *aShowLicense) = 0;
    virtual HRESULT getLicense(com::Utf8Str &aLicense) = 0;

    // wrapped IExtPackFile properties
    virtual HRESULT getFilePath(com::Utf8Str &aFilePath) = 0;

    // wrapped IExtPackBase methods
    virtual HRESULT queryLicense(const com::Utf8Str &aPreferredLocale,
                                 const com::Utf8Str &aPreferredLanguage,
                                 const com::Utf8Str &aFormat,
                                 com::Utf8Str &aLicenseText) = 0;

    // wrapped IExtPackFile methods
    virtual HRESULT install(BOOL aReplace,
                            const com::Utf8Str &aDisplayInfo,
                            ComPtr<IProgress> &aProgess) = 0;
};

#endif // !ExtPackFileWrap_H_

// ##### ENDFILE "ExtPackFileWrap.h"

// ##### BEGINFILE "ExtPackFileWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IExtPackFile.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_EXTPACKFILE

#include "ExtPackFileWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(ExtPackFileWrap)

//
// IExtPackBase properties
//

STDMETHODIMP ExtPackFileWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "ExtPackFile::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "ExtPackFile::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP ExtPackFileWrap::COMGETTER(Description)(BSTR *aDescription)
{
    LogRelFlow(("{%p} %s: enter aDescription=%p\n", this, "ExtPackFile::getDescription", aDescription));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDescription);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDescription(BSTROutConverter(aDescription).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDescription=%ls hrc=%Rhrc\n", this, "ExtPackFile::getDescription", *aDescription, hrc));
    return hrc;
}

STDMETHODIMP ExtPackFileWrap::COMGETTER(Version)(BSTR *aVersion)
{
    LogRelFlow(("{%p} %s: enter aVersion=%p\n", this, "ExtPackFile::getVersion", aVersion));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVersion);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVersion(BSTROutConverter(aVersion).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVersion=%ls hrc=%Rhrc\n", this, "ExtPackFile::getVersion", *aVersion, hrc));
    return hrc;
}

STDMETHODIMP ExtPackFileWrap::COMGETTER(Revision)(ULONG *aRevision)
{
    LogRelFlow(("{%p} %s: enter aRevision=%p\n", this, "ExtPackFile::getRevision", aRevision));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRevision);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRevision(aRevision);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRevision=%RU32 hrc=%Rhrc\n", this, "ExtPackFile::getRevision", *aRevision, hrc));
    return hrc;
}

STDMETHODIMP ExtPackFileWrap::COMGETTER(Edition)(BSTR *aEdition)
{
    LogRelFlow(("{%p} %s: enter aEdition=%p\n", this, "ExtPackFile::getEdition", aEdition));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEdition);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEdition(BSTROutConverter(aEdition).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEdition=%ls hrc=%Rhrc\n", this, "ExtPackFile::getEdition", *aEdition, hrc));
    return hrc;
}

STDMETHODIMP ExtPackFileWrap::COMGETTER(VRDEModule)(BSTR *aVRDEModule)
{
    LogRelFlow(("{%p} %s: enter aVRDEModule=%p\n", this, "ExtPackFile::getVRDEModule", aVRDEModule));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVRDEModule);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVRDEModule(BSTROutConverter(aVRDEModule).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVRDEModule=%ls hrc=%Rhrc\n", this, "ExtPackFile::getVRDEModule", *aVRDEModule, hrc));
    return hrc;
}

STDMETHODIMP ExtPackFileWrap::COMGETTER(PlugIns)(ComSafeArrayOut(IExtPackPlugIn *, aPlugIns))
{
    LogRelFlow(("{%p} %s: enter aPlugIns=%p\n", this, "ExtPackFile::getPlugIns", aPlugIns));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPlugIns);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPlugIns(ArrayComTypeOutConverter<IExtPackPlugIn>(ComSafeArrayOutArg(aPlugIns)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPlugIns=%zu hrc=%Rhrc\n", this, "ExtPackFile::getPlugIns", ComSafeArraySize(*aPlugIns), hrc));
    return hrc;
}

STDMETHODIMP ExtPackFileWrap::COMGETTER(Usable)(BOOL *aUsable)
{
    LogRelFlow(("{%p} %s: enter aUsable=%p\n", this, "ExtPackFile::getUsable", aUsable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUsable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getUsable(aUsable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aUsable=%RTbool hrc=%Rhrc\n", this, "ExtPackFile::getUsable", *aUsable, hrc));
    return hrc;
}

STDMETHODIMP ExtPackFileWrap::COMGETTER(WhyUnusable)(BSTR *aWhyUnusable)
{
    LogRelFlow(("{%p} %s: enter aWhyUnusable=%p\n", this, "ExtPackFile::getWhyUnusable", aWhyUnusable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWhyUnusable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWhyUnusable(BSTROutConverter(aWhyUnusable).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWhyUnusable=%ls hrc=%Rhrc\n", this, "ExtPackFile::getWhyUnusable", *aWhyUnusable, hrc));
    return hrc;
}

STDMETHODIMP ExtPackFileWrap::COMGETTER(ShowLicense)(BOOL *aShowLicense)
{
    LogRelFlow(("{%p} %s: enter aShowLicense=%p\n", this, "ExtPackFile::getShowLicense", aShowLicense));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aShowLicense);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getShowLicense(aShowLicense);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aShowLicense=%RTbool hrc=%Rhrc\n", this, "ExtPackFile::getShowLicense", *aShowLicense, hrc));
    return hrc;
}

STDMETHODIMP ExtPackFileWrap::COMGETTER(License)(BSTR *aLicense)
{
    LogRelFlow(("{%p} %s: enter aLicense=%p\n", this, "ExtPackFile::getLicense", aLicense));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLicense);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getLicense(BSTROutConverter(aLicense).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aLicense=%ls hrc=%Rhrc\n", this, "ExtPackFile::getLicense", *aLicense, hrc));
    return hrc;
}

//
// IExtPackFile properties
//

STDMETHODIMP ExtPackFileWrap::COMGETTER(FilePath)(BSTR *aFilePath)
{
    LogRelFlow(("{%p} %s: enter aFilePath=%p\n", this, "ExtPackFile::getFilePath", aFilePath));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFilePath);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFilePath(BSTROutConverter(aFilePath).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFilePath=%ls hrc=%Rhrc\n", this, "ExtPackFile::getFilePath", *aFilePath, hrc));
    return hrc;
}

//
// IExtPackBase methods
//

STDMETHODIMP ExtPackFileWrap::QueryLicense(IN_BSTR aPreferredLocale,
                                           IN_BSTR aPreferredLanguage,
                                           IN_BSTR aFormat,
                                           BSTR *aLicenseText)
{
    LogRelFlow(("{%p} %s:enter aPreferredLocale=%ls aPreferredLanguage=%ls aFormat=%ls aLicenseText=%p\n", this, "ExtPackFile::queryLicense", aPreferredLocale, aPreferredLanguage, aFormat, aLicenseText));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aLicenseText);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = queryLicense(BSTRInConverter(aPreferredLocale).str(),
                           BSTRInConverter(aPreferredLanguage).str(),
                           BSTRInConverter(aFormat).str(),
                           BSTROutConverter(aLicenseText).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aLicenseText=%ls hrc=%Rhrc\n", this, "ExtPackFile::queryLicense", *aLicenseText, hrc));
    return hrc;
}

//
// IExtPackFile methods
//

STDMETHODIMP ExtPackFileWrap::Install(BOOL aReplace,
                                      IN_BSTR aDisplayInfo,
                                      IProgress **aProgess)
{
    LogRelFlow(("{%p} %s:enter aReplace=%RTbool aDisplayInfo=%ls aProgess=%p\n", this, "ExtPackFile::install", aReplace, aDisplayInfo, aProgess));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgess);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = install(aReplace,
                      BSTRInConverter(aDisplayInfo).str(),
                      ComTypeOutConverter<IProgress>(aProgess).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgess=%p hrc=%Rhrc\n", this, "ExtPackFile::install", *aProgess, hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(ExtPackFileWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(ExtPackFileWrap, IExtPackFile, IExtPackBase)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "ExtPackFileWrap.cpp"

// ##### BEGINFILE "ExtPackManagerWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IExtPackManager.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef ExtPackManagerWrap_H_
#define ExtPackManagerWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE ExtPackManagerWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IExtPackManager)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(ExtPackManagerWrap, IExtPackManager)
    DECLARE_NOT_AGGREGATABLE(ExtPackManagerWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(ExtPackManagerWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IExtPackManager)
        COM_INTERFACE_ENTRY2(IDispatch, IExtPackManager)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(ExtPackManagerWrap)

    // public IExtPackManager properties
    STDMETHOD(COMGETTER(InstalledExtPacks))(ComSafeArrayOut(IExtPack *, aInstalledExtPacks));

    // public IExtPackManager methods
    STDMETHOD(Find)(IN_BSTR aName,
                    IExtPack **aReturnData);
    STDMETHOD(OpenExtPackFile)(IN_BSTR aPath,
                               IExtPackFile **aFile);
    STDMETHOD(Uninstall)(IN_BSTR aName,
                         BOOL aForcedRemoval,
                         IN_BSTR aDisplayInfo,
                         IProgress **aProgess);
    STDMETHOD(Cleanup)();
    STDMETHOD(QueryAllPlugInsForFrontend)(IN_BSTR aFrontendName,
                                          ComSafeArrayOut(BSTR, aPlugInModules));
    STDMETHOD(IsExtPackUsable)(IN_BSTR aName,
                               BOOL *aUsable);

private:
    // wrapped IExtPackManager properties
    virtual HRESULT getInstalledExtPacks(std::vector<ComPtr<IExtPack> > &aInstalledExtPacks) = 0;

    // wrapped IExtPackManager methods
    virtual HRESULT find(const com::Utf8Str &aName,
                         ComPtr<IExtPack> &aReturnData) = 0;
    virtual HRESULT openExtPackFile(const com::Utf8Str &aPath,
                                    ComPtr<IExtPackFile> &aFile) = 0;
    virtual HRESULT uninstall(const com::Utf8Str &aName,
                              BOOL aForcedRemoval,
                              const com::Utf8Str &aDisplayInfo,
                              ComPtr<IProgress> &aProgess) = 0;
    virtual HRESULT cleanup() = 0;
    virtual HRESULT queryAllPlugInsForFrontend(const com::Utf8Str &aFrontendName,
                                               std::vector<com::Utf8Str> &aPlugInModules) = 0;
    virtual HRESULT isExtPackUsable(const com::Utf8Str &aName,
                                    BOOL *aUsable) = 0;
};

#endif // !ExtPackManagerWrap_H_

// ##### ENDFILE "ExtPackManagerWrap.h"

// ##### BEGINFILE "ExtPackManagerWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IExtPackManager.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_EXTPACKMANAGER

#include "ExtPackManagerWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(ExtPackManagerWrap)

//
// IExtPackManager properties
//

STDMETHODIMP ExtPackManagerWrap::COMGETTER(InstalledExtPacks)(ComSafeArrayOut(IExtPack *, aInstalledExtPacks))
{
    LogRelFlow(("{%p} %s: enter aInstalledExtPacks=%p\n", this, "ExtPackManager::getInstalledExtPacks", aInstalledExtPacks));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aInstalledExtPacks);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getInstalledExtPacks(ArrayComTypeOutConverter<IExtPack>(ComSafeArrayOutArg(aInstalledExtPacks)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aInstalledExtPacks=%zu hrc=%Rhrc\n", this, "ExtPackManager::getInstalledExtPacks", ComSafeArraySize(*aInstalledExtPacks), hrc));
    return hrc;
}

//
// IExtPackManager methods
//

STDMETHODIMP ExtPackManagerWrap::Find(IN_BSTR aName,
                                      IExtPack **aReturnData)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aReturnData=%p\n", this, "ExtPackManager::find", aName, aReturnData));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aReturnData);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = find(BSTRInConverter(aName).str(),
                   ComTypeOutConverter<IExtPack>(aReturnData).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aReturnData=%p hrc=%Rhrc\n", this, "ExtPackManager::find", *aReturnData, hrc));
    return hrc;
}

STDMETHODIMP ExtPackManagerWrap::OpenExtPackFile(IN_BSTR aPath,
                                                 IExtPackFile **aFile)
{
    LogRelFlow(("{%p} %s:enter aPath=%ls aFile=%p\n", this, "ExtPackManager::openExtPackFile", aPath, aFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFile);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = openExtPackFile(BSTRInConverter(aPath).str(),
                              ComTypeOutConverter<IExtPackFile>(aFile).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aFile=%p hrc=%Rhrc\n", this, "ExtPackManager::openExtPackFile", *aFile, hrc));
    return hrc;
}

STDMETHODIMP ExtPackManagerWrap::Uninstall(IN_BSTR aName,
                                           BOOL aForcedRemoval,
                                           IN_BSTR aDisplayInfo,
                                           IProgress **aProgess)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aForcedRemoval=%RTbool aDisplayInfo=%ls aProgess=%p\n", this, "ExtPackManager::uninstall", aName, aForcedRemoval, aDisplayInfo, aProgess));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProgess);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = uninstall(BSTRInConverter(aName).str(),
                        aForcedRemoval,
                        BSTRInConverter(aDisplayInfo).str(),
                        ComTypeOutConverter<IProgress>(aProgess).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aProgess=%p hrc=%Rhrc\n", this, "ExtPackManager::uninstall", *aProgess, hrc));
    return hrc;
}

STDMETHODIMP ExtPackManagerWrap::Cleanup()
{
    LogRelFlow(("{%p} %s:enter\n", this, "ExtPackManager::cleanup"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = cleanup();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "ExtPackManager::cleanup", hrc));
    return hrc;
}

STDMETHODIMP ExtPackManagerWrap::QueryAllPlugInsForFrontend(IN_BSTR aFrontendName,
                                                            ComSafeArrayOut(BSTR, aPlugInModules))
{
    LogRelFlow(("{%p} %s:enter aFrontendName=%ls aPlugInModules=%p\n", this, "ExtPackManager::queryAllPlugInsForFrontend", aFrontendName, aPlugInModules));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPlugInModules);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = queryAllPlugInsForFrontend(BSTRInConverter(aFrontendName).str(),
                                         ArrayBSTROutConverter(ComSafeArrayOutArg(aPlugInModules)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aPlugInModules=%zu hrc=%Rhrc\n", this, "ExtPackManager::queryAllPlugInsForFrontend", ComSafeArraySize(*aPlugInModules), hrc));
    return hrc;
}

STDMETHODIMP ExtPackManagerWrap::IsExtPackUsable(IN_BSTR aName,
                                                 BOOL *aUsable)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aUsable=%p\n", this, "ExtPackManager::isExtPackUsable", aName, aUsable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aUsable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = isExtPackUsable(BSTRInConverter(aName).str(),
                              aUsable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aUsable=%RTbool hrc=%Rhrc\n", this, "ExtPackManager::isExtPackUsable", *aUsable, hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(ExtPackManagerWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(ExtPackManagerWrap, IExtPackManager)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "ExtPackManagerWrap.cpp"

// ##### BEGINFILE "BandwidthGroupWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IBandwidthGroup.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef BandwidthGroupWrap_H_
#define BandwidthGroupWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE BandwidthGroupWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IBandwidthGroup)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(BandwidthGroupWrap, IBandwidthGroup)
    DECLARE_NOT_AGGREGATABLE(BandwidthGroupWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(BandwidthGroupWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IBandwidthGroup)
        COM_INTERFACE_ENTRY2(IDispatch, IBandwidthGroup)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(BandwidthGroupWrap)

    // public IBandwidthGroup properties
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(Type))(BandwidthGroupType_T *aType);
    STDMETHOD(COMGETTER(Reference))(ULONG *aReference);
    STDMETHOD(COMGETTER(MaxBytesPerSec))(LONG64 *aMaxBytesPerSec);
    STDMETHOD(COMSETTER(MaxBytesPerSec))(LONG64 aMaxBytesPerSec);

    // public IBandwidthGroup methods

private:
    // wrapped IBandwidthGroup properties
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getType(BandwidthGroupType_T *aType) = 0;
    virtual HRESULT getReference(ULONG *aReference) = 0;
    virtual HRESULT getMaxBytesPerSec(LONG64 *aMaxBytesPerSec) = 0;
    virtual HRESULT setMaxBytesPerSec(LONG64 aMaxBytesPerSec) = 0;

    // wrapped IBandwidthGroup methods
};

#endif // !BandwidthGroupWrap_H_

// ##### ENDFILE "BandwidthGroupWrap.h"

// ##### BEGINFILE "BandwidthGroupWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IBandwidthGroup.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_BANDWIDTHGROUP

#include "BandwidthGroupWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(BandwidthGroupWrap)

//
// IBandwidthGroup properties
//

STDMETHODIMP BandwidthGroupWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "BandwidthGroup::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "BandwidthGroup::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP BandwidthGroupWrap::COMGETTER(Type)(BandwidthGroupType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "BandwidthGroup::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "BandwidthGroup::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP BandwidthGroupWrap::COMGETTER(Reference)(ULONG *aReference)
{
    LogRelFlow(("{%p} %s: enter aReference=%p\n", this, "BandwidthGroup::getReference", aReference));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aReference);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getReference(aReference);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aReference=%RU32 hrc=%Rhrc\n", this, "BandwidthGroup::getReference", *aReference, hrc));
    return hrc;
}

STDMETHODIMP BandwidthGroupWrap::COMGETTER(MaxBytesPerSec)(LONG64 *aMaxBytesPerSec)
{
    LogRelFlow(("{%p} %s: enter aMaxBytesPerSec=%p\n", this, "BandwidthGroup::getMaxBytesPerSec", aMaxBytesPerSec));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMaxBytesPerSec);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMaxBytesPerSec(aMaxBytesPerSec);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMaxBytesPerSec=%RI64 hrc=%Rhrc\n", this, "BandwidthGroup::getMaxBytesPerSec", *aMaxBytesPerSec, hrc));
    return hrc;
}

STDMETHODIMP BandwidthGroupWrap::COMSETTER(MaxBytesPerSec)(LONG64 aMaxBytesPerSec)
{
    LogRelFlow(("{%p} %s: enter aMaxBytesPerSec=%RI64\n", this, "BandwidthGroup::setMaxBytesPerSec", aMaxBytesPerSec));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setMaxBytesPerSec(aMaxBytesPerSec);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "BandwidthGroup::setMaxBytesPerSec", hrc));
    return hrc;
}

//
// IBandwidthGroup methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(BandwidthGroupWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(BandwidthGroupWrap, IBandwidthGroup)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "BandwidthGroupWrap.cpp"

// ##### BEGINFILE "BandwidthControlWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IBandwidthControl.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef BandwidthControlWrap_H_
#define BandwidthControlWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE BandwidthControlWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IBandwidthControl)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(BandwidthControlWrap, IBandwidthControl)
    DECLARE_NOT_AGGREGATABLE(BandwidthControlWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(BandwidthControlWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IBandwidthControl)
        COM_INTERFACE_ENTRY2(IDispatch, IBandwidthControl)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(BandwidthControlWrap)

    // public IBandwidthControl properties
    STDMETHOD(COMGETTER(NumGroups))(ULONG *aNumGroups);

    // public IBandwidthControl methods
    STDMETHOD(CreateBandwidthGroup)(IN_BSTR aName,
                                    BandwidthGroupType_T aType,
                                    LONG64 aMaxBytesPerSec);
    STDMETHOD(DeleteBandwidthGroup)(IN_BSTR aName);
    STDMETHOD(GetBandwidthGroup)(IN_BSTR aName,
                                 IBandwidthGroup **aBandwidthGroup);
    STDMETHOD(GetAllBandwidthGroups)(ComSafeArrayOut(IBandwidthGroup *, aBandwidthGroups));

private:
    // wrapped IBandwidthControl properties
    virtual HRESULT getNumGroups(ULONG *aNumGroups) = 0;

    // wrapped IBandwidthControl methods
    virtual HRESULT createBandwidthGroup(const com::Utf8Str &aName,
                                         BandwidthGroupType_T aType,
                                         LONG64 aMaxBytesPerSec) = 0;
    virtual HRESULT deleteBandwidthGroup(const com::Utf8Str &aName) = 0;
    virtual HRESULT getBandwidthGroup(const com::Utf8Str &aName,
                                      ComPtr<IBandwidthGroup> &aBandwidthGroup) = 0;
    virtual HRESULT getAllBandwidthGroups(std::vector<ComPtr<IBandwidthGroup> > &aBandwidthGroups) = 0;
};

#endif // !BandwidthControlWrap_H_

// ##### ENDFILE "BandwidthControlWrap.h"

// ##### BEGINFILE "BandwidthControlWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IBandwidthControl.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_BANDWIDTHCONTROL

#include "BandwidthControlWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(BandwidthControlWrap)

//
// IBandwidthControl properties
//

STDMETHODIMP BandwidthControlWrap::COMGETTER(NumGroups)(ULONG *aNumGroups)
{
    LogRelFlow(("{%p} %s: enter aNumGroups=%p\n", this, "BandwidthControl::getNumGroups", aNumGroups));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNumGroups);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNumGroups(aNumGroups);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNumGroups=%RU32 hrc=%Rhrc\n", this, "BandwidthControl::getNumGroups", *aNumGroups, hrc));
    return hrc;
}

//
// IBandwidthControl methods
//

STDMETHODIMP BandwidthControlWrap::CreateBandwidthGroup(IN_BSTR aName,
                                                        BandwidthGroupType_T aType,
                                                        LONG64 aMaxBytesPerSec)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aType=%RU32 aMaxBytesPerSec=%RI64\n", this, "BandwidthControl::createBandwidthGroup", aName, aType, aMaxBytesPerSec));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = createBandwidthGroup(BSTRInConverter(aName).str(),
                                   aType,
                                   aMaxBytesPerSec);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "BandwidthControl::createBandwidthGroup", hrc));
    return hrc;
}

STDMETHODIMP BandwidthControlWrap::DeleteBandwidthGroup(IN_BSTR aName)
{
    LogRelFlow(("{%p} %s:enter aName=%ls\n", this, "BandwidthControl::deleteBandwidthGroup", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = deleteBandwidthGroup(BSTRInConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "BandwidthControl::deleteBandwidthGroup", hrc));
    return hrc;
}

STDMETHODIMP BandwidthControlWrap::GetBandwidthGroup(IN_BSTR aName,
                                                     IBandwidthGroup **aBandwidthGroup)
{
    LogRelFlow(("{%p} %s:enter aName=%ls aBandwidthGroup=%p\n", this, "BandwidthControl::getBandwidthGroup", aName, aBandwidthGroup));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBandwidthGroup);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBandwidthGroup(BSTRInConverter(aName).str(),
                                ComTypeOutConverter<IBandwidthGroup>(aBandwidthGroup).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aBandwidthGroup=%p hrc=%Rhrc\n", this, "BandwidthControl::getBandwidthGroup", *aBandwidthGroup, hrc));
    return hrc;
}

STDMETHODIMP BandwidthControlWrap::GetAllBandwidthGroups(ComSafeArrayOut(IBandwidthGroup *, aBandwidthGroups))
{
    LogRelFlow(("{%p} %s:enter aBandwidthGroups=%p\n", this, "BandwidthControl::getAllBandwidthGroups", aBandwidthGroups));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBandwidthGroups);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAllBandwidthGroups(ArrayComTypeOutConverter<IBandwidthGroup>(ComSafeArrayOutArg(aBandwidthGroups)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aBandwidthGroups=%zu hrc=%Rhrc\n", this, "BandwidthControl::getAllBandwidthGroups", ComSafeArraySize(*aBandwidthGroups), hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(BandwidthControlWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(BandwidthControlWrap, IBandwidthControl)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "BandwidthControlWrap.cpp"

// ##### BEGINFILE "VirtualBoxClientWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IVirtualBoxClient.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef VirtualBoxClientWrap_H_
#define VirtualBoxClientWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE VirtualBoxClientWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IVirtualBoxClient)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(VirtualBoxClientWrap, IVirtualBoxClient)
    DECLARE_NOT_AGGREGATABLE(VirtualBoxClientWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(VirtualBoxClientWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IVirtualBoxClient)
        COM_INTERFACE_ENTRY2(IDispatch, IVirtualBoxClient)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(VirtualBoxClientWrap)

    // public IVirtualBoxClient properties
    STDMETHOD(COMGETTER(VirtualBox))(IVirtualBox **aVirtualBox);
    STDMETHOD(COMGETTER(Session))(ISession **aSession);
    STDMETHOD(COMGETTER(EventSource))(IEventSource **aEventSource);

    // public IVirtualBoxClient methods
    STDMETHOD(CheckMachineError)(IMachine *aMachine);

private:
    // wrapped IVirtualBoxClient properties
    virtual HRESULT getVirtualBox(ComPtr<IVirtualBox> &aVirtualBox) = 0;
    virtual HRESULT getSession(ComPtr<ISession> &aSession) = 0;
    virtual HRESULT getEventSource(ComPtr<IEventSource> &aEventSource) = 0;

    // wrapped IVirtualBoxClient methods
    virtual HRESULT checkMachineError(const ComPtr<IMachine> &aMachine) = 0;
};

#endif // !VirtualBoxClientWrap_H_

// ##### ENDFILE "VirtualBoxClientWrap.h"

// ##### BEGINFILE "VirtualBoxClientWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IVirtualBoxClient.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_VIRTUALBOXCLIENT

#include "VirtualBoxClientWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(VirtualBoxClientWrap)

//
// IVirtualBoxClient properties
//

STDMETHODIMP VirtualBoxClientWrap::COMGETTER(VirtualBox)(IVirtualBox **aVirtualBox)
{
    LogRelFlow(("{%p} %s: enter aVirtualBox=%p\n", this, "VirtualBoxClient::getVirtualBox", aVirtualBox));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVirtualBox);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVirtualBox(ComTypeOutConverter<IVirtualBox>(aVirtualBox).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVirtualBox=%p hrc=%Rhrc\n", this, "VirtualBoxClient::getVirtualBox", *aVirtualBox, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxClientWrap::COMGETTER(Session)(ISession **aSession)
{
    LogRelFlow(("{%p} %s: enter aSession=%p\n", this, "VirtualBoxClient::getSession", aSession));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSession);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSession(ComTypeOutConverter<ISession>(aSession).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSession=%p hrc=%Rhrc\n", this, "VirtualBoxClient::getSession", *aSession, hrc));
    return hrc;
}

STDMETHODIMP VirtualBoxClientWrap::COMGETTER(EventSource)(IEventSource **aEventSource)
{
    LogRelFlow(("{%p} %s: enter aEventSource=%p\n", this, "VirtualBoxClient::getEventSource", aEventSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEventSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEventSource(ComTypeOutConverter<IEventSource>(aEventSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEventSource=%p hrc=%Rhrc\n", this, "VirtualBoxClient::getEventSource", *aEventSource, hrc));
    return hrc;
}

//
// IVirtualBoxClient methods
//

STDMETHODIMP VirtualBoxClientWrap::CheckMachineError(IMachine *aMachine)
{
    LogRelFlow(("{%p} %s:enter aMachine=%p\n", this, "VirtualBoxClient::checkMachineError", aMachine));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = checkMachineError(ComTypeInConverter<IMachine>(aMachine).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VirtualBoxClient::checkMachineError", hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(VirtualBoxClientWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(VirtualBoxClientWrap, IVirtualBoxClient)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "VirtualBoxClientWrap.cpp"

// ##### BEGINFILE "EventSourceWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IEventSource.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef EventSourceWrap_H_
#define EventSourceWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE EventSourceWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IEventSource)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(EventSourceWrap, IEventSource)
    DECLARE_NOT_AGGREGATABLE(EventSourceWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(EventSourceWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IEventSource)
        COM_INTERFACE_ENTRY2(IDispatch, IEventSource)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(EventSourceWrap)

    // public IEventSource properties

    // public IEventSource methods
    STDMETHOD(CreateListener)(IEventListener **aListener);
    STDMETHOD(CreateAggregator)(ComSafeArrayIn(IEventSource *, aSubordinates),
                                IEventSource **aResult);
    STDMETHOD(RegisterListener)(IEventListener *aListener,
                                ComSafeArrayIn(VBoxEventType_T, aInteresting),
                                BOOL aActive);
    STDMETHOD(UnregisterListener)(IEventListener *aListener);
    STDMETHOD(FireEvent)(IEvent *aEvent,
                         LONG aTimeout,
                         BOOL *aResult);
    STDMETHOD(GetEvent)(IEventListener *aListener,
                        LONG aTimeout,
                        IEvent **aEvent);
    STDMETHOD(EventProcessed)(IEventListener *aListener,
                              IEvent *aEvent);

private:
    // wrapped IEventSource properties

    // wrapped IEventSource methods
    virtual HRESULT createListener(ComPtr<IEventListener> &aListener) = 0;
    virtual HRESULT createAggregator(const std::vector<ComPtr<IEventSource> > &aSubordinates,
                                     ComPtr<IEventSource> &aResult) = 0;
    virtual HRESULT registerListener(const ComPtr<IEventListener> &aListener,
                                     const std::vector<VBoxEventType_T> &aInteresting,
                                     BOOL aActive) = 0;
    virtual HRESULT unregisterListener(const ComPtr<IEventListener> &aListener) = 0;
    virtual HRESULT fireEvent(const ComPtr<IEvent> &aEvent,
                              LONG aTimeout,
                              BOOL *aResult) = 0;
    virtual HRESULT getEvent(const ComPtr<IEventListener> &aListener,
                             LONG aTimeout,
                             ComPtr<IEvent> &aEvent) = 0;
    virtual HRESULT eventProcessed(const ComPtr<IEventListener> &aListener,
                                   const ComPtr<IEvent> &aEvent) = 0;
};

#endif // !EventSourceWrap_H_

// ##### ENDFILE "EventSourceWrap.h"

// ##### BEGINFILE "EventSourceWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IEventSource.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_EVENTSOURCE

#include "EventSourceWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(EventSourceWrap)

//
// IEventSource properties
//

//
// IEventSource methods
//

STDMETHODIMP EventSourceWrap::CreateListener(IEventListener **aListener)
{
    LogRelFlow(("{%p} %s:enter aListener=%p\n", this, "EventSource::createListener", aListener));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aListener);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = createListener(ComTypeOutConverter<IEventListener>(aListener).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aListener=%p hrc=%Rhrc\n", this, "EventSource::createListener", *aListener, hrc));
    return hrc;
}

STDMETHODIMP EventSourceWrap::CreateAggregator(ComSafeArrayIn(IEventSource *, aSubordinates),
                                               IEventSource **aResult)
{
    LogRelFlow(("{%p} %s:enter aSubordinates=%zu aResult=%p\n", this, "EventSource::createAggregator", aSubordinates, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = createAggregator(ArrayComTypeInConverter<IEventSource>(ComSafeArrayInArg(aSubordinates)).array(),
                               ComTypeOutConverter<IEventSource>(aResult).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%p hrc=%Rhrc\n", this, "EventSource::createAggregator", *aResult, hrc));
    return hrc;
}

STDMETHODIMP EventSourceWrap::RegisterListener(IEventListener *aListener,
                                               ComSafeArrayIn(VBoxEventType_T, aInteresting),
                                               BOOL aActive)
{
    LogRelFlow(("{%p} %s:enter aListener=%p aInteresting=%zu aActive=%RTbool\n", this, "EventSource::registerListener", aListener, aInteresting, aActive));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = registerListener(ComTypeInConverter<IEventListener>(aListener).ptr(),
                               ArrayInConverter<VBoxEventType_T>(ComSafeArrayInArg(aInteresting)).array(),
                               aActive);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "EventSource::registerListener", hrc));
    return hrc;
}

STDMETHODIMP EventSourceWrap::UnregisterListener(IEventListener *aListener)
{
    LogRelFlow(("{%p} %s:enter aListener=%p\n", this, "EventSource::unregisterListener", aListener));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = unregisterListener(ComTypeInConverter<IEventListener>(aListener).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "EventSource::unregisterListener", hrc));
    return hrc;
}

STDMETHODIMP EventSourceWrap::FireEvent(IEvent *aEvent,
                                        LONG aTimeout,
                                        BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aEvent=%p aTimeout=%RI32 aResult=%p\n", this, "EventSource::fireEvent", aEvent, aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = fireEvent(ComTypeInConverter<IEvent>(aEvent).ptr(),
                        aTimeout,
                        aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "EventSource::fireEvent", *aResult, hrc));
    return hrc;
}

STDMETHODIMP EventSourceWrap::GetEvent(IEventListener *aListener,
                                       LONG aTimeout,
                                       IEvent **aEvent)
{
    LogRelFlow(("{%p} %s:enter aListener=%p aTimeout=%RI32 aEvent=%p\n", this, "EventSource::getEvent", aListener, aTimeout, aEvent));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEvent);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEvent(ComTypeInConverter<IEventListener>(aListener).ptr(),
                       aTimeout,
                       ComTypeOutConverter<IEvent>(aEvent).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aEvent=%p hrc=%Rhrc\n", this, "EventSource::getEvent", *aEvent, hrc));
    return hrc;
}

STDMETHODIMP EventSourceWrap::EventProcessed(IEventListener *aListener,
                                             IEvent *aEvent)
{
    LogRelFlow(("{%p} %s:enter aListener=%p aEvent=%p\n", this, "EventSource::eventProcessed", aListener, aEvent));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = eventProcessed(ComTypeInConverter<IEventListener>(aListener).ptr(),
                             ComTypeInConverter<IEvent>(aEvent).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "EventSource::eventProcessed", hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(EventSourceWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(EventSourceWrap, IEventSource)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "EventSourceWrap.cpp"

// ##### BEGINFILE "EventListenerWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IEventListener.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef EventListenerWrap_H_
#define EventListenerWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE EventListenerWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IEventListener)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(EventListenerWrap, IEventListener)
    DECLARE_NOT_AGGREGATABLE(EventListenerWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(EventListenerWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IEventListener)
        COM_INTERFACE_ENTRY2(IDispatch, IEventListener)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(EventListenerWrap)

    // public IEventListener properties

    // public IEventListener methods
    STDMETHOD(HandleEvent)(IEvent *aEvent);

private:
    // wrapped IEventListener properties

    // wrapped IEventListener methods
    virtual HRESULT handleEvent(const ComPtr<IEvent> &aEvent) = 0;
};

#endif // !EventListenerWrap_H_

// ##### ENDFILE "EventListenerWrap.h"

// ##### BEGINFILE "EventListenerWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IEventListener.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_EVENTLISTENER

#include "EventListenerWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(EventListenerWrap)

//
// IEventListener properties
//

//
// IEventListener methods
//

STDMETHODIMP EventListenerWrap::HandleEvent(IEvent *aEvent)
{
    LogRelFlow(("{%p} %s:enter aEvent=%p\n", this, "EventListener::handleEvent", aEvent));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = handleEvent(ComTypeInConverter<IEvent>(aEvent).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "EventListener::handleEvent", hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(EventListenerWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(EventListenerWrap, IEventListener)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "EventListenerWrap.cpp"

// ##### BEGINFILE "EventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef EventWrap_H_
#define EventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE EventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(EventWrap, IEvent)
    DECLARE_NOT_AGGREGATABLE(EventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(EventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(EventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;
};

#endif // !EventWrap_H_

// ##### ENDFILE "EventWrap.h"

// ##### BEGINFILE "EventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_EVENT

#include "EventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(EventWrap)

//
// IEvent properties
//

STDMETHODIMP EventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "Event::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "Event::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP EventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "Event::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "Event::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP EventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "Event::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "Event::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP EventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "Event::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "Event::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP EventWrap::WaitProcessed(LONG aTimeout,
                                      BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "Event::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "Event::waitProcessed", *aResult, hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(EventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS1_CI(EventWrap, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "EventWrap.cpp"

// ##### BEGINFILE "ReusableEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IReusableEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef ReusableEventWrap_H_
#define ReusableEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE ReusableEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IReusableEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(ReusableEventWrap, IReusableEvent)
    DECLARE_NOT_AGGREGATABLE(ReusableEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(ReusableEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IReusableEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IReusableEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(ReusableEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IReusableEvent properties
    STDMETHOD(COMGETTER(Generation))(ULONG *aGeneration);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IReusableEvent methods
    STDMETHOD(Reuse)();

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IReusableEvent properties
    virtual HRESULT getGeneration(ULONG *aGeneration) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IReusableEvent methods
    virtual HRESULT reuse() = 0;
};

#endif // !ReusableEventWrap_H_

// ##### ENDFILE "ReusableEventWrap.h"

// ##### BEGINFILE "ReusableEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IReusableEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_REUSABLEEVENT

#include "ReusableEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(ReusableEventWrap)

//
// IEvent properties
//

STDMETHODIMP ReusableEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "ReusableEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "ReusableEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP ReusableEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "ReusableEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "ReusableEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP ReusableEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "ReusableEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "ReusableEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IReusableEvent properties
//

STDMETHODIMP ReusableEventWrap::COMGETTER(Generation)(ULONG *aGeneration)
{
    LogRelFlow(("{%p} %s: enter aGeneration=%p\n", this, "ReusableEvent::getGeneration", aGeneration));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGeneration);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGeneration(aGeneration);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGeneration=%RU32 hrc=%Rhrc\n", this, "ReusableEvent::getGeneration", *aGeneration, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP ReusableEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "ReusableEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "ReusableEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP ReusableEventWrap::WaitProcessed(LONG aTimeout,
                                              BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "ReusableEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "ReusableEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IReusableEvent methods
//

STDMETHODIMP ReusableEventWrap::Reuse()
{
    LogRelFlow(("{%p} %s:enter\n", this, "ReusableEvent::reuse"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = reuse();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "ReusableEvent::reuse", hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(ReusableEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(ReusableEventWrap, IReusableEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "ReusableEventWrap.cpp"

// ##### BEGINFILE "MachineEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IMachineEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef MachineEventWrap_H_
#define MachineEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE MachineEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IMachineEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(MachineEventWrap, IMachineEvent)
    DECLARE_NOT_AGGREGATABLE(MachineEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(MachineEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IMachineEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IMachineEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(MachineEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IMachineEvent properties
    STDMETHOD(COMGETTER(MachineId))(BSTR *aMachineId);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IMachineEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IMachineEvent properties
    virtual HRESULT getMachineId(com::Guid &aMachineId) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IMachineEvent methods
};

#endif // !MachineEventWrap_H_

// ##### ENDFILE "MachineEventWrap.h"

// ##### BEGINFILE "MachineEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IMachineEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_MACHINEEVENT

#include "MachineEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(MachineEventWrap)

//
// IEvent properties
//

STDMETHODIMP MachineEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "MachineEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "MachineEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP MachineEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "MachineEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "MachineEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP MachineEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "MachineEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "MachineEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IMachineEvent properties
//

STDMETHODIMP MachineEventWrap::COMGETTER(MachineId)(BSTR *aMachineId)
{
    LogRelFlow(("{%p} %s: enter aMachineId=%p\n", this, "MachineEvent::getMachineId", aMachineId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachineId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachineId(UuidOutConverter(aMachineId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachineId=%ls hrc=%Rhrc\n", this, "MachineEvent::getMachineId", *aMachineId, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP MachineEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "MachineEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP MachineEventWrap::WaitProcessed(LONG aTimeout,
                                             BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "MachineEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "MachineEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IMachineEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(MachineEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(MachineEventWrap, IMachineEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "MachineEventWrap.cpp"

// ##### BEGINFILE "MachineStateChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IMachineStateChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef MachineStateChangedEventWrap_H_
#define MachineStateChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE MachineStateChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IMachineStateChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(MachineStateChangedEventWrap, IMachineStateChangedEvent)
    DECLARE_NOT_AGGREGATABLE(MachineStateChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(MachineStateChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IMachineStateChangedEvent)
        COM_INTERFACE_ENTRY(IMachineEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IMachineStateChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(MachineStateChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IMachineEvent properties
    STDMETHOD(COMGETTER(MachineId))(BSTR *aMachineId);

    // public IMachineStateChangedEvent properties
    STDMETHOD(COMGETTER(State))(MachineState_T *aState);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IMachineEvent methods

    // public IMachineStateChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IMachineEvent properties
    virtual HRESULT getMachineId(com::Guid &aMachineId) = 0;

    // wrapped IMachineStateChangedEvent properties
    virtual HRESULT getState(MachineState_T *aState) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IMachineEvent methods

    // wrapped IMachineStateChangedEvent methods
};

#endif // !MachineStateChangedEventWrap_H_

// ##### ENDFILE "MachineStateChangedEventWrap.h"

// ##### BEGINFILE "MachineStateChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IMachineStateChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_MACHINESTATECHANGEDEVENT

#include "MachineStateChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(MachineStateChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP MachineStateChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "MachineStateChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "MachineStateChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP MachineStateChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "MachineStateChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "MachineStateChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP MachineStateChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "MachineStateChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "MachineStateChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IMachineEvent properties
//

STDMETHODIMP MachineStateChangedEventWrap::COMGETTER(MachineId)(BSTR *aMachineId)
{
    LogRelFlow(("{%p} %s: enter aMachineId=%p\n", this, "MachineStateChangedEvent::getMachineId", aMachineId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachineId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachineId(UuidOutConverter(aMachineId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachineId=%ls hrc=%Rhrc\n", this, "MachineStateChangedEvent::getMachineId", *aMachineId, hrc));
    return hrc;
}

//
// IMachineStateChangedEvent properties
//

STDMETHODIMP MachineStateChangedEventWrap::COMGETTER(State)(MachineState_T *aState)
{
    LogRelFlow(("{%p} %s: enter aState=%p\n", this, "MachineStateChangedEvent::getState", aState));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aState);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getState(aState);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aState=%RU32 hrc=%Rhrc\n", this, "MachineStateChangedEvent::getState", *aState, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP MachineStateChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "MachineStateChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineStateChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP MachineStateChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                         BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "MachineStateChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "MachineStateChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IMachineEvent methods
//

//
// IMachineStateChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(MachineStateChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS3_CI(MachineStateChangedEventWrap, IMachineStateChangedEvent, IMachineEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "MachineStateChangedEventWrap.cpp"

// ##### BEGINFILE "MachineDataChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IMachineDataChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef MachineDataChangedEventWrap_H_
#define MachineDataChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE MachineDataChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IMachineDataChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(MachineDataChangedEventWrap, IMachineDataChangedEvent)
    DECLARE_NOT_AGGREGATABLE(MachineDataChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(MachineDataChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IMachineDataChangedEvent)
        COM_INTERFACE_ENTRY(IMachineEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IMachineDataChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(MachineDataChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IMachineEvent properties
    STDMETHOD(COMGETTER(MachineId))(BSTR *aMachineId);

    // public IMachineDataChangedEvent properties
    STDMETHOD(COMGETTER(Temporary))(BOOL *aTemporary);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IMachineEvent methods

    // public IMachineDataChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IMachineEvent properties
    virtual HRESULT getMachineId(com::Guid &aMachineId) = 0;

    // wrapped IMachineDataChangedEvent properties
    virtual HRESULT getTemporary(BOOL *aTemporary) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IMachineEvent methods

    // wrapped IMachineDataChangedEvent methods
};

#endif // !MachineDataChangedEventWrap_H_

// ##### ENDFILE "MachineDataChangedEventWrap.h"

// ##### BEGINFILE "MachineDataChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IMachineDataChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_MACHINEDATACHANGEDEVENT

#include "MachineDataChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(MachineDataChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP MachineDataChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "MachineDataChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "MachineDataChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP MachineDataChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "MachineDataChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "MachineDataChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP MachineDataChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "MachineDataChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "MachineDataChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IMachineEvent properties
//

STDMETHODIMP MachineDataChangedEventWrap::COMGETTER(MachineId)(BSTR *aMachineId)
{
    LogRelFlow(("{%p} %s: enter aMachineId=%p\n", this, "MachineDataChangedEvent::getMachineId", aMachineId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachineId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachineId(UuidOutConverter(aMachineId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachineId=%ls hrc=%Rhrc\n", this, "MachineDataChangedEvent::getMachineId", *aMachineId, hrc));
    return hrc;
}

//
// IMachineDataChangedEvent properties
//

STDMETHODIMP MachineDataChangedEventWrap::COMGETTER(Temporary)(BOOL *aTemporary)
{
    LogRelFlow(("{%p} %s: enter aTemporary=%p\n", this, "MachineDataChangedEvent::getTemporary", aTemporary));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aTemporary);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getTemporary(aTemporary);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aTemporary=%RTbool hrc=%Rhrc\n", this, "MachineDataChangedEvent::getTemporary", *aTemporary, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP MachineDataChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "MachineDataChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineDataChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP MachineDataChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                        BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "MachineDataChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "MachineDataChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IMachineEvent methods
//

//
// IMachineDataChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(MachineDataChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS3_CI(MachineDataChangedEventWrap, IMachineDataChangedEvent, IMachineEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "MachineDataChangedEventWrap.cpp"

// ##### BEGINFILE "MediumRegisteredEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IMediumRegisteredEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef MediumRegisteredEventWrap_H_
#define MediumRegisteredEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE MediumRegisteredEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IMediumRegisteredEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(MediumRegisteredEventWrap, IMediumRegisteredEvent)
    DECLARE_NOT_AGGREGATABLE(MediumRegisteredEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(MediumRegisteredEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IMediumRegisteredEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IMediumRegisteredEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(MediumRegisteredEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IMediumRegisteredEvent properties
    STDMETHOD(COMGETTER(MediumId))(BSTR *aMediumId);
    STDMETHOD(COMGETTER(MediumType))(DeviceType_T *aMediumType);
    STDMETHOD(COMGETTER(Registered))(BOOL *aRegistered);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IMediumRegisteredEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IMediumRegisteredEvent properties
    virtual HRESULT getMediumId(com::Guid &aMediumId) = 0;
    virtual HRESULT getMediumType(DeviceType_T *aMediumType) = 0;
    virtual HRESULT getRegistered(BOOL *aRegistered) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IMediumRegisteredEvent methods
};

#endif // !MediumRegisteredEventWrap_H_

// ##### ENDFILE "MediumRegisteredEventWrap.h"

// ##### BEGINFILE "MediumRegisteredEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IMediumRegisteredEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_MEDIUMREGISTEREDEVENT

#include "MediumRegisteredEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(MediumRegisteredEventWrap)

//
// IEvent properties
//

STDMETHODIMP MediumRegisteredEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "MediumRegisteredEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "MediumRegisteredEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP MediumRegisteredEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "MediumRegisteredEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "MediumRegisteredEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP MediumRegisteredEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "MediumRegisteredEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "MediumRegisteredEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IMediumRegisteredEvent properties
//

STDMETHODIMP MediumRegisteredEventWrap::COMGETTER(MediumId)(BSTR *aMediumId)
{
    LogRelFlow(("{%p} %s: enter aMediumId=%p\n", this, "MediumRegisteredEvent::getMediumId", aMediumId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMediumId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMediumId(UuidOutConverter(aMediumId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMediumId=%ls hrc=%Rhrc\n", this, "MediumRegisteredEvent::getMediumId", *aMediumId, hrc));
    return hrc;
}

STDMETHODIMP MediumRegisteredEventWrap::COMGETTER(MediumType)(DeviceType_T *aMediumType)
{
    LogRelFlow(("{%p} %s: enter aMediumType=%p\n", this, "MediumRegisteredEvent::getMediumType", aMediumType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMediumType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMediumType(aMediumType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMediumType=%RU32 hrc=%Rhrc\n", this, "MediumRegisteredEvent::getMediumType", *aMediumType, hrc));
    return hrc;
}

STDMETHODIMP MediumRegisteredEventWrap::COMGETTER(Registered)(BOOL *aRegistered)
{
    LogRelFlow(("{%p} %s: enter aRegistered=%p\n", this, "MediumRegisteredEvent::getRegistered", aRegistered));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRegistered);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRegistered(aRegistered);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRegistered=%RTbool hrc=%Rhrc\n", this, "MediumRegisteredEvent::getRegistered", *aRegistered, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP MediumRegisteredEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "MediumRegisteredEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MediumRegisteredEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP MediumRegisteredEventWrap::WaitProcessed(LONG aTimeout,
                                                      BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "MediumRegisteredEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "MediumRegisteredEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IMediumRegisteredEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(MediumRegisteredEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(MediumRegisteredEventWrap, IMediumRegisteredEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "MediumRegisteredEventWrap.cpp"

// ##### BEGINFILE "MachineRegisteredEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IMachineRegisteredEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef MachineRegisteredEventWrap_H_
#define MachineRegisteredEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE MachineRegisteredEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IMachineRegisteredEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(MachineRegisteredEventWrap, IMachineRegisteredEvent)
    DECLARE_NOT_AGGREGATABLE(MachineRegisteredEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(MachineRegisteredEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IMachineRegisteredEvent)
        COM_INTERFACE_ENTRY(IMachineEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IMachineRegisteredEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(MachineRegisteredEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IMachineEvent properties
    STDMETHOD(COMGETTER(MachineId))(BSTR *aMachineId);

    // public IMachineRegisteredEvent properties
    STDMETHOD(COMGETTER(Registered))(BOOL *aRegistered);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IMachineEvent methods

    // public IMachineRegisteredEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IMachineEvent properties
    virtual HRESULT getMachineId(com::Guid &aMachineId) = 0;

    // wrapped IMachineRegisteredEvent properties
    virtual HRESULT getRegistered(BOOL *aRegistered) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IMachineEvent methods

    // wrapped IMachineRegisteredEvent methods
};

#endif // !MachineRegisteredEventWrap_H_

// ##### ENDFILE "MachineRegisteredEventWrap.h"

// ##### BEGINFILE "MachineRegisteredEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IMachineRegisteredEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_MACHINEREGISTEREDEVENT

#include "MachineRegisteredEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(MachineRegisteredEventWrap)

//
// IEvent properties
//

STDMETHODIMP MachineRegisteredEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "MachineRegisteredEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "MachineRegisteredEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP MachineRegisteredEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "MachineRegisteredEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "MachineRegisteredEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP MachineRegisteredEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "MachineRegisteredEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "MachineRegisteredEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IMachineEvent properties
//

STDMETHODIMP MachineRegisteredEventWrap::COMGETTER(MachineId)(BSTR *aMachineId)
{
    LogRelFlow(("{%p} %s: enter aMachineId=%p\n", this, "MachineRegisteredEvent::getMachineId", aMachineId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachineId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachineId(UuidOutConverter(aMachineId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachineId=%ls hrc=%Rhrc\n", this, "MachineRegisteredEvent::getMachineId", *aMachineId, hrc));
    return hrc;
}

//
// IMachineRegisteredEvent properties
//

STDMETHODIMP MachineRegisteredEventWrap::COMGETTER(Registered)(BOOL *aRegistered)
{
    LogRelFlow(("{%p} %s: enter aRegistered=%p\n", this, "MachineRegisteredEvent::getRegistered", aRegistered));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRegistered);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRegistered(aRegistered);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRegistered=%RTbool hrc=%Rhrc\n", this, "MachineRegisteredEvent::getRegistered", *aRegistered, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP MachineRegisteredEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "MachineRegisteredEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MachineRegisteredEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP MachineRegisteredEventWrap::WaitProcessed(LONG aTimeout,
                                                       BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "MachineRegisteredEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "MachineRegisteredEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IMachineEvent methods
//

//
// IMachineRegisteredEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(MachineRegisteredEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS3_CI(MachineRegisteredEventWrap, IMachineRegisteredEvent, IMachineEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "MachineRegisteredEventWrap.cpp"

// ##### BEGINFILE "SessionStateChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for ISessionStateChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef SessionStateChangedEventWrap_H_
#define SessionStateChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE SessionStateChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(ISessionStateChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(SessionStateChangedEventWrap, ISessionStateChangedEvent)
    DECLARE_NOT_AGGREGATABLE(SessionStateChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(SessionStateChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(ISessionStateChangedEvent)
        COM_INTERFACE_ENTRY(IMachineEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, ISessionStateChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(SessionStateChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IMachineEvent properties
    STDMETHOD(COMGETTER(MachineId))(BSTR *aMachineId);

    // public ISessionStateChangedEvent properties
    STDMETHOD(COMGETTER(State))(SessionState_T *aState);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IMachineEvent methods

    // public ISessionStateChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IMachineEvent properties
    virtual HRESULT getMachineId(com::Guid &aMachineId) = 0;

    // wrapped ISessionStateChangedEvent properties
    virtual HRESULT getState(SessionState_T *aState) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IMachineEvent methods

    // wrapped ISessionStateChangedEvent methods
};

#endif // !SessionStateChangedEventWrap_H_

// ##### ENDFILE "SessionStateChangedEventWrap.h"

// ##### BEGINFILE "SessionStateChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for ISessionStateChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_SESSIONSTATECHANGEDEVENT

#include "SessionStateChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(SessionStateChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP SessionStateChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "SessionStateChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "SessionStateChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP SessionStateChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "SessionStateChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "SessionStateChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP SessionStateChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "SessionStateChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "SessionStateChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IMachineEvent properties
//

STDMETHODIMP SessionStateChangedEventWrap::COMGETTER(MachineId)(BSTR *aMachineId)
{
    LogRelFlow(("{%p} %s: enter aMachineId=%p\n", this, "SessionStateChangedEvent::getMachineId", aMachineId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachineId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachineId(UuidOutConverter(aMachineId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachineId=%ls hrc=%Rhrc\n", this, "SessionStateChangedEvent::getMachineId", *aMachineId, hrc));
    return hrc;
}

//
// ISessionStateChangedEvent properties
//

STDMETHODIMP SessionStateChangedEventWrap::COMGETTER(State)(SessionState_T *aState)
{
    LogRelFlow(("{%p} %s: enter aState=%p\n", this, "SessionStateChangedEvent::getState", aState));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aState);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getState(aState);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aState=%RU32 hrc=%Rhrc\n", this, "SessionStateChangedEvent::getState", *aState, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP SessionStateChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "SessionStateChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SessionStateChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP SessionStateChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                         BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "SessionStateChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "SessionStateChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IMachineEvent methods
//

//
// ISessionStateChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(SessionStateChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS3_CI(SessionStateChangedEventWrap, ISessionStateChangedEvent, IMachineEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "SessionStateChangedEventWrap.cpp"

// ##### BEGINFILE "GuestPropertyChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestPropertyChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestPropertyChangedEventWrap_H_
#define GuestPropertyChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestPropertyChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestPropertyChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestPropertyChangedEventWrap, IGuestPropertyChangedEvent)
    DECLARE_NOT_AGGREGATABLE(GuestPropertyChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestPropertyChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestPropertyChangedEvent)
        COM_INTERFACE_ENTRY(IMachineEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestPropertyChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestPropertyChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IMachineEvent properties
    STDMETHOD(COMGETTER(MachineId))(BSTR *aMachineId);

    // public IGuestPropertyChangedEvent properties
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(Value))(BSTR *aValue);
    STDMETHOD(COMGETTER(Flags))(BSTR *aFlags);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IMachineEvent methods

    // public IGuestPropertyChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IMachineEvent properties
    virtual HRESULT getMachineId(com::Guid &aMachineId) = 0;

    // wrapped IGuestPropertyChangedEvent properties
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getValue(com::Utf8Str &aValue) = 0;
    virtual HRESULT getFlags(com::Utf8Str &aFlags) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IMachineEvent methods

    // wrapped IGuestPropertyChangedEvent methods
};

#endif // !GuestPropertyChangedEventWrap_H_

// ##### ENDFILE "GuestPropertyChangedEventWrap.h"

// ##### BEGINFILE "GuestPropertyChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestPropertyChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTPROPERTYCHANGEDEVENT

#include "GuestPropertyChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestPropertyChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP GuestPropertyChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestPropertyChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestPropertyChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestPropertyChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "GuestPropertyChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "GuestPropertyChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP GuestPropertyChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "GuestPropertyChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "GuestPropertyChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IMachineEvent properties
//

STDMETHODIMP GuestPropertyChangedEventWrap::COMGETTER(MachineId)(BSTR *aMachineId)
{
    LogRelFlow(("{%p} %s: enter aMachineId=%p\n", this, "GuestPropertyChangedEvent::getMachineId", aMachineId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachineId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachineId(UuidOutConverter(aMachineId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachineId=%ls hrc=%Rhrc\n", this, "GuestPropertyChangedEvent::getMachineId", *aMachineId, hrc));
    return hrc;
}

//
// IGuestPropertyChangedEvent properties
//

STDMETHODIMP GuestPropertyChangedEventWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "GuestPropertyChangedEvent::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "GuestPropertyChangedEvent::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP GuestPropertyChangedEventWrap::COMGETTER(Value)(BSTR *aValue)
{
    LogRelFlow(("{%p} %s: enter aValue=%p\n", this, "GuestPropertyChangedEvent::getValue", aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aValue);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getValue(BSTROutConverter(aValue).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aValue=%ls hrc=%Rhrc\n", this, "GuestPropertyChangedEvent::getValue", *aValue, hrc));
    return hrc;
}

STDMETHODIMP GuestPropertyChangedEventWrap::COMGETTER(Flags)(BSTR *aFlags)
{
    LogRelFlow(("{%p} %s: enter aFlags=%p\n", this, "GuestPropertyChangedEvent::getFlags", aFlags));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFlags);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFlags(BSTROutConverter(aFlags).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFlags=%ls hrc=%Rhrc\n", this, "GuestPropertyChangedEvent::getFlags", *aFlags, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP GuestPropertyChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestPropertyChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestPropertyChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP GuestPropertyChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                          BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "GuestPropertyChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "GuestPropertyChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IMachineEvent methods
//

//
// IGuestPropertyChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestPropertyChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS3_CI(GuestPropertyChangedEventWrap, IGuestPropertyChangedEvent, IMachineEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestPropertyChangedEventWrap.cpp"

// ##### BEGINFILE "SnapshotEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for ISnapshotEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef SnapshotEventWrap_H_
#define SnapshotEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE SnapshotEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(ISnapshotEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(SnapshotEventWrap, ISnapshotEvent)
    DECLARE_NOT_AGGREGATABLE(SnapshotEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(SnapshotEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(ISnapshotEvent)
        COM_INTERFACE_ENTRY(IMachineEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, ISnapshotEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(SnapshotEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IMachineEvent properties
    STDMETHOD(COMGETTER(MachineId))(BSTR *aMachineId);

    // public ISnapshotEvent properties
    STDMETHOD(COMGETTER(SnapshotId))(BSTR *aSnapshotId);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IMachineEvent methods

    // public ISnapshotEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IMachineEvent properties
    virtual HRESULT getMachineId(com::Guid &aMachineId) = 0;

    // wrapped ISnapshotEvent properties
    virtual HRESULT getSnapshotId(com::Guid &aSnapshotId) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IMachineEvent methods

    // wrapped ISnapshotEvent methods
};

#endif // !SnapshotEventWrap_H_

// ##### ENDFILE "SnapshotEventWrap.h"

// ##### BEGINFILE "SnapshotEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for ISnapshotEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_SNAPSHOTEVENT

#include "SnapshotEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(SnapshotEventWrap)

//
// IEvent properties
//

STDMETHODIMP SnapshotEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "SnapshotEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "SnapshotEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP SnapshotEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "SnapshotEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "SnapshotEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP SnapshotEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "SnapshotEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "SnapshotEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IMachineEvent properties
//

STDMETHODIMP SnapshotEventWrap::COMGETTER(MachineId)(BSTR *aMachineId)
{
    LogRelFlow(("{%p} %s: enter aMachineId=%p\n", this, "SnapshotEvent::getMachineId", aMachineId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachineId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachineId(UuidOutConverter(aMachineId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachineId=%ls hrc=%Rhrc\n", this, "SnapshotEvent::getMachineId", *aMachineId, hrc));
    return hrc;
}

//
// ISnapshotEvent properties
//

STDMETHODIMP SnapshotEventWrap::COMGETTER(SnapshotId)(BSTR *aSnapshotId)
{
    LogRelFlow(("{%p} %s: enter aSnapshotId=%p\n", this, "SnapshotEvent::getSnapshotId", aSnapshotId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSnapshotId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSnapshotId(UuidOutConverter(aSnapshotId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSnapshotId=%ls hrc=%Rhrc\n", this, "SnapshotEvent::getSnapshotId", *aSnapshotId, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP SnapshotEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "SnapshotEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SnapshotEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP SnapshotEventWrap::WaitProcessed(LONG aTimeout,
                                              BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "SnapshotEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "SnapshotEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IMachineEvent methods
//

//
// ISnapshotEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(SnapshotEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS3_CI(SnapshotEventWrap, ISnapshotEvent, IMachineEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "SnapshotEventWrap.cpp"

// ##### BEGINFILE "SnapshotTakenEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for ISnapshotTakenEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef SnapshotTakenEventWrap_H_
#define SnapshotTakenEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE SnapshotTakenEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(ISnapshotTakenEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(SnapshotTakenEventWrap, ISnapshotTakenEvent)
    DECLARE_NOT_AGGREGATABLE(SnapshotTakenEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(SnapshotTakenEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(ISnapshotTakenEvent)
        COM_INTERFACE_ENTRY(ISnapshotEvent)
        COM_INTERFACE_ENTRY(IMachineEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, ISnapshotTakenEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(SnapshotTakenEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IMachineEvent properties
    STDMETHOD(COMGETTER(MachineId))(BSTR *aMachineId);

    // public ISnapshotEvent properties
    STDMETHOD(COMGETTER(SnapshotId))(BSTR *aSnapshotId);

    // public ISnapshotTakenEvent properties

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IMachineEvent methods

    // public ISnapshotEvent methods

    // public ISnapshotTakenEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IMachineEvent properties
    virtual HRESULT getMachineId(com::Guid &aMachineId) = 0;

    // wrapped ISnapshotEvent properties
    virtual HRESULT getSnapshotId(com::Guid &aSnapshotId) = 0;

    // wrapped ISnapshotTakenEvent properties

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IMachineEvent methods

    // wrapped ISnapshotEvent methods

    // wrapped ISnapshotTakenEvent methods
};

#endif // !SnapshotTakenEventWrap_H_

// ##### ENDFILE "SnapshotTakenEventWrap.h"

// ##### BEGINFILE "SnapshotTakenEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for ISnapshotTakenEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_SNAPSHOTTAKENEVENT

#include "SnapshotTakenEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(SnapshotTakenEventWrap)

//
// IEvent properties
//

STDMETHODIMP SnapshotTakenEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "SnapshotTakenEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "SnapshotTakenEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP SnapshotTakenEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "SnapshotTakenEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "SnapshotTakenEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP SnapshotTakenEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "SnapshotTakenEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "SnapshotTakenEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IMachineEvent properties
//

STDMETHODIMP SnapshotTakenEventWrap::COMGETTER(MachineId)(BSTR *aMachineId)
{
    LogRelFlow(("{%p} %s: enter aMachineId=%p\n", this, "SnapshotTakenEvent::getMachineId", aMachineId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachineId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachineId(UuidOutConverter(aMachineId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachineId=%ls hrc=%Rhrc\n", this, "SnapshotTakenEvent::getMachineId", *aMachineId, hrc));
    return hrc;
}

//
// ISnapshotEvent properties
//

STDMETHODIMP SnapshotTakenEventWrap::COMGETTER(SnapshotId)(BSTR *aSnapshotId)
{
    LogRelFlow(("{%p} %s: enter aSnapshotId=%p\n", this, "SnapshotTakenEvent::getSnapshotId", aSnapshotId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSnapshotId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSnapshotId(UuidOutConverter(aSnapshotId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSnapshotId=%ls hrc=%Rhrc\n", this, "SnapshotTakenEvent::getSnapshotId", *aSnapshotId, hrc));
    return hrc;
}

//
// ISnapshotTakenEvent properties
//

//
// IEvent methods
//

STDMETHODIMP SnapshotTakenEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "SnapshotTakenEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SnapshotTakenEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP SnapshotTakenEventWrap::WaitProcessed(LONG aTimeout,
                                                   BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "SnapshotTakenEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "SnapshotTakenEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IMachineEvent methods
//

//
// ISnapshotEvent methods
//

//
// ISnapshotTakenEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(SnapshotTakenEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS4_CI(SnapshotTakenEventWrap, ISnapshotTakenEvent, ISnapshotEvent, IMachineEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "SnapshotTakenEventWrap.cpp"

// ##### BEGINFILE "SnapshotDeletedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for ISnapshotDeletedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef SnapshotDeletedEventWrap_H_
#define SnapshotDeletedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE SnapshotDeletedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(ISnapshotDeletedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(SnapshotDeletedEventWrap, ISnapshotDeletedEvent)
    DECLARE_NOT_AGGREGATABLE(SnapshotDeletedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(SnapshotDeletedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(ISnapshotDeletedEvent)
        COM_INTERFACE_ENTRY(ISnapshotEvent)
        COM_INTERFACE_ENTRY(IMachineEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, ISnapshotDeletedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(SnapshotDeletedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IMachineEvent properties
    STDMETHOD(COMGETTER(MachineId))(BSTR *aMachineId);

    // public ISnapshotEvent properties
    STDMETHOD(COMGETTER(SnapshotId))(BSTR *aSnapshotId);

    // public ISnapshotDeletedEvent properties

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IMachineEvent methods

    // public ISnapshotEvent methods

    // public ISnapshotDeletedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IMachineEvent properties
    virtual HRESULT getMachineId(com::Guid &aMachineId) = 0;

    // wrapped ISnapshotEvent properties
    virtual HRESULT getSnapshotId(com::Guid &aSnapshotId) = 0;

    // wrapped ISnapshotDeletedEvent properties

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IMachineEvent methods

    // wrapped ISnapshotEvent methods

    // wrapped ISnapshotDeletedEvent methods
};

#endif // !SnapshotDeletedEventWrap_H_

// ##### ENDFILE "SnapshotDeletedEventWrap.h"

// ##### BEGINFILE "SnapshotDeletedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for ISnapshotDeletedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_SNAPSHOTDELETEDEVENT

#include "SnapshotDeletedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(SnapshotDeletedEventWrap)

//
// IEvent properties
//

STDMETHODIMP SnapshotDeletedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "SnapshotDeletedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "SnapshotDeletedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP SnapshotDeletedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "SnapshotDeletedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "SnapshotDeletedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP SnapshotDeletedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "SnapshotDeletedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "SnapshotDeletedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IMachineEvent properties
//

STDMETHODIMP SnapshotDeletedEventWrap::COMGETTER(MachineId)(BSTR *aMachineId)
{
    LogRelFlow(("{%p} %s: enter aMachineId=%p\n", this, "SnapshotDeletedEvent::getMachineId", aMachineId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachineId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachineId(UuidOutConverter(aMachineId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachineId=%ls hrc=%Rhrc\n", this, "SnapshotDeletedEvent::getMachineId", *aMachineId, hrc));
    return hrc;
}

//
// ISnapshotEvent properties
//

STDMETHODIMP SnapshotDeletedEventWrap::COMGETTER(SnapshotId)(BSTR *aSnapshotId)
{
    LogRelFlow(("{%p} %s: enter aSnapshotId=%p\n", this, "SnapshotDeletedEvent::getSnapshotId", aSnapshotId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSnapshotId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSnapshotId(UuidOutConverter(aSnapshotId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSnapshotId=%ls hrc=%Rhrc\n", this, "SnapshotDeletedEvent::getSnapshotId", *aSnapshotId, hrc));
    return hrc;
}

//
// ISnapshotDeletedEvent properties
//

//
// IEvent methods
//

STDMETHODIMP SnapshotDeletedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "SnapshotDeletedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SnapshotDeletedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP SnapshotDeletedEventWrap::WaitProcessed(LONG aTimeout,
                                                     BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "SnapshotDeletedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "SnapshotDeletedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IMachineEvent methods
//

//
// ISnapshotEvent methods
//

//
// ISnapshotDeletedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(SnapshotDeletedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS4_CI(SnapshotDeletedEventWrap, ISnapshotDeletedEvent, ISnapshotEvent, IMachineEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "SnapshotDeletedEventWrap.cpp"

// ##### BEGINFILE "SnapshotChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for ISnapshotChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef SnapshotChangedEventWrap_H_
#define SnapshotChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE SnapshotChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(ISnapshotChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(SnapshotChangedEventWrap, ISnapshotChangedEvent)
    DECLARE_NOT_AGGREGATABLE(SnapshotChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(SnapshotChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(ISnapshotChangedEvent)
        COM_INTERFACE_ENTRY(ISnapshotEvent)
        COM_INTERFACE_ENTRY(IMachineEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, ISnapshotChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(SnapshotChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IMachineEvent properties
    STDMETHOD(COMGETTER(MachineId))(BSTR *aMachineId);

    // public ISnapshotEvent properties
    STDMETHOD(COMGETTER(SnapshotId))(BSTR *aSnapshotId);

    // public ISnapshotChangedEvent properties

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IMachineEvent methods

    // public ISnapshotEvent methods

    // public ISnapshotChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IMachineEvent properties
    virtual HRESULT getMachineId(com::Guid &aMachineId) = 0;

    // wrapped ISnapshotEvent properties
    virtual HRESULT getSnapshotId(com::Guid &aSnapshotId) = 0;

    // wrapped ISnapshotChangedEvent properties

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IMachineEvent methods

    // wrapped ISnapshotEvent methods

    // wrapped ISnapshotChangedEvent methods
};

#endif // !SnapshotChangedEventWrap_H_

// ##### ENDFILE "SnapshotChangedEventWrap.h"

// ##### BEGINFILE "SnapshotChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for ISnapshotChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_SNAPSHOTCHANGEDEVENT

#include "SnapshotChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(SnapshotChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP SnapshotChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "SnapshotChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "SnapshotChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP SnapshotChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "SnapshotChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "SnapshotChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP SnapshotChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "SnapshotChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "SnapshotChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IMachineEvent properties
//

STDMETHODIMP SnapshotChangedEventWrap::COMGETTER(MachineId)(BSTR *aMachineId)
{
    LogRelFlow(("{%p} %s: enter aMachineId=%p\n", this, "SnapshotChangedEvent::getMachineId", aMachineId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachineId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachineId(UuidOutConverter(aMachineId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachineId=%ls hrc=%Rhrc\n", this, "SnapshotChangedEvent::getMachineId", *aMachineId, hrc));
    return hrc;
}

//
// ISnapshotEvent properties
//

STDMETHODIMP SnapshotChangedEventWrap::COMGETTER(SnapshotId)(BSTR *aSnapshotId)
{
    LogRelFlow(("{%p} %s: enter aSnapshotId=%p\n", this, "SnapshotChangedEvent::getSnapshotId", aSnapshotId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSnapshotId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSnapshotId(UuidOutConverter(aSnapshotId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSnapshotId=%ls hrc=%Rhrc\n", this, "SnapshotChangedEvent::getSnapshotId", *aSnapshotId, hrc));
    return hrc;
}

//
// ISnapshotChangedEvent properties
//

//
// IEvent methods
//

STDMETHODIMP SnapshotChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "SnapshotChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SnapshotChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP SnapshotChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                     BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "SnapshotChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "SnapshotChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IMachineEvent methods
//

//
// ISnapshotEvent methods
//

//
// ISnapshotChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(SnapshotChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS4_CI(SnapshotChangedEventWrap, ISnapshotChangedEvent, ISnapshotEvent, IMachineEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "SnapshotChangedEventWrap.cpp"

// ##### BEGINFILE "MousePointerShapeChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IMousePointerShapeChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef MousePointerShapeChangedEventWrap_H_
#define MousePointerShapeChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE MousePointerShapeChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IMousePointerShapeChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(MousePointerShapeChangedEventWrap, IMousePointerShapeChangedEvent)
    DECLARE_NOT_AGGREGATABLE(MousePointerShapeChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(MousePointerShapeChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IMousePointerShapeChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IMousePointerShapeChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(MousePointerShapeChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IMousePointerShapeChangedEvent properties
    STDMETHOD(COMGETTER(Visible))(BOOL *aVisible);
    STDMETHOD(COMGETTER(Alpha))(BOOL *aAlpha);
    STDMETHOD(COMGETTER(Xhot))(ULONG *aXhot);
    STDMETHOD(COMGETTER(Yhot))(ULONG *aYhot);
    STDMETHOD(COMGETTER(Width))(ULONG *aWidth);
    STDMETHOD(COMGETTER(Height))(ULONG *aHeight);
    STDMETHOD(COMGETTER(Shape))(ComSafeArrayOut(BYTE, aShape));

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IMousePointerShapeChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IMousePointerShapeChangedEvent properties
    virtual HRESULT getVisible(BOOL *aVisible) = 0;
    virtual HRESULT getAlpha(BOOL *aAlpha) = 0;
    virtual HRESULT getXhot(ULONG *aXhot) = 0;
    virtual HRESULT getYhot(ULONG *aYhot) = 0;
    virtual HRESULT getWidth(ULONG *aWidth) = 0;
    virtual HRESULT getHeight(ULONG *aHeight) = 0;
    virtual HRESULT getShape(std::vector<BYTE> &aShape) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IMousePointerShapeChangedEvent methods
};

#endif // !MousePointerShapeChangedEventWrap_H_

// ##### ENDFILE "MousePointerShapeChangedEventWrap.h"

// ##### BEGINFILE "MousePointerShapeChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IMousePointerShapeChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_MOUSEPOINTERSHAPECHANGEDEVENT

#include "MousePointerShapeChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(MousePointerShapeChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP MousePointerShapeChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "MousePointerShapeChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "MousePointerShapeChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP MousePointerShapeChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "MousePointerShapeChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "MousePointerShapeChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP MousePointerShapeChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "MousePointerShapeChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "MousePointerShapeChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IMousePointerShapeChangedEvent properties
//

STDMETHODIMP MousePointerShapeChangedEventWrap::COMGETTER(Visible)(BOOL *aVisible)
{
    LogRelFlow(("{%p} %s: enter aVisible=%p\n", this, "MousePointerShapeChangedEvent::getVisible", aVisible));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aVisible);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVisible(aVisible);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aVisible=%RTbool hrc=%Rhrc\n", this, "MousePointerShapeChangedEvent::getVisible", *aVisible, hrc));
    return hrc;
}

STDMETHODIMP MousePointerShapeChangedEventWrap::COMGETTER(Alpha)(BOOL *aAlpha)
{
    LogRelFlow(("{%p} %s: enter aAlpha=%p\n", this, "MousePointerShapeChangedEvent::getAlpha", aAlpha));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAlpha);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAlpha(aAlpha);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAlpha=%RTbool hrc=%Rhrc\n", this, "MousePointerShapeChangedEvent::getAlpha", *aAlpha, hrc));
    return hrc;
}

STDMETHODIMP MousePointerShapeChangedEventWrap::COMGETTER(Xhot)(ULONG *aXhot)
{
    LogRelFlow(("{%p} %s: enter aXhot=%p\n", this, "MousePointerShapeChangedEvent::getXhot", aXhot));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aXhot);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getXhot(aXhot);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aXhot=%RU32 hrc=%Rhrc\n", this, "MousePointerShapeChangedEvent::getXhot", *aXhot, hrc));
    return hrc;
}

STDMETHODIMP MousePointerShapeChangedEventWrap::COMGETTER(Yhot)(ULONG *aYhot)
{
    LogRelFlow(("{%p} %s: enter aYhot=%p\n", this, "MousePointerShapeChangedEvent::getYhot", aYhot));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aYhot);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getYhot(aYhot);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aYhot=%RU32 hrc=%Rhrc\n", this, "MousePointerShapeChangedEvent::getYhot", *aYhot, hrc));
    return hrc;
}

STDMETHODIMP MousePointerShapeChangedEventWrap::COMGETTER(Width)(ULONG *aWidth)
{
    LogRelFlow(("{%p} %s: enter aWidth=%p\n", this, "MousePointerShapeChangedEvent::getWidth", aWidth));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWidth);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWidth(aWidth);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWidth=%RU32 hrc=%Rhrc\n", this, "MousePointerShapeChangedEvent::getWidth", *aWidth, hrc));
    return hrc;
}

STDMETHODIMP MousePointerShapeChangedEventWrap::COMGETTER(Height)(ULONG *aHeight)
{
    LogRelFlow(("{%p} %s: enter aHeight=%p\n", this, "MousePointerShapeChangedEvent::getHeight", aHeight));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHeight);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHeight(aHeight);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHeight=%RU32 hrc=%Rhrc\n", this, "MousePointerShapeChangedEvent::getHeight", *aHeight, hrc));
    return hrc;
}

STDMETHODIMP MousePointerShapeChangedEventWrap::COMGETTER(Shape)(ComSafeArrayOut(BYTE, aShape))
{
    LogRelFlow(("{%p} %s: enter aShape=%p\n", this, "MousePointerShapeChangedEvent::getShape", aShape));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aShape);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getShape(ArrayOutConverter<BYTE>(ComSafeArrayOutArg(aShape)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aShape=%zu hrc=%Rhrc\n", this, "MousePointerShapeChangedEvent::getShape", ComSafeArraySize(*aShape), hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP MousePointerShapeChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "MousePointerShapeChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MousePointerShapeChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP MousePointerShapeChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                              BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "MousePointerShapeChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "MousePointerShapeChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IMousePointerShapeChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(MousePointerShapeChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(MousePointerShapeChangedEventWrap, IMousePointerShapeChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "MousePointerShapeChangedEventWrap.cpp"

// ##### BEGINFILE "MouseCapabilityChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IMouseCapabilityChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef MouseCapabilityChangedEventWrap_H_
#define MouseCapabilityChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE MouseCapabilityChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IMouseCapabilityChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(MouseCapabilityChangedEventWrap, IMouseCapabilityChangedEvent)
    DECLARE_NOT_AGGREGATABLE(MouseCapabilityChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(MouseCapabilityChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IMouseCapabilityChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IMouseCapabilityChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(MouseCapabilityChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IMouseCapabilityChangedEvent properties
    STDMETHOD(COMGETTER(SupportsAbsolute))(BOOL *aSupportsAbsolute);
    STDMETHOD(COMGETTER(SupportsRelative))(BOOL *aSupportsRelative);
    STDMETHOD(COMGETTER(SupportsMultiTouch))(BOOL *aSupportsMultiTouch);
    STDMETHOD(COMGETTER(NeedsHostCursor))(BOOL *aNeedsHostCursor);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IMouseCapabilityChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IMouseCapabilityChangedEvent properties
    virtual HRESULT getSupportsAbsolute(BOOL *aSupportsAbsolute) = 0;
    virtual HRESULT getSupportsRelative(BOOL *aSupportsRelative) = 0;
    virtual HRESULT getSupportsMultiTouch(BOOL *aSupportsMultiTouch) = 0;
    virtual HRESULT getNeedsHostCursor(BOOL *aNeedsHostCursor) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IMouseCapabilityChangedEvent methods
};

#endif // !MouseCapabilityChangedEventWrap_H_

// ##### ENDFILE "MouseCapabilityChangedEventWrap.h"

// ##### BEGINFILE "MouseCapabilityChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IMouseCapabilityChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_MOUSECAPABILITYCHANGEDEVENT

#include "MouseCapabilityChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(MouseCapabilityChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP MouseCapabilityChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "MouseCapabilityChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "MouseCapabilityChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP MouseCapabilityChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "MouseCapabilityChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "MouseCapabilityChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP MouseCapabilityChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "MouseCapabilityChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "MouseCapabilityChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IMouseCapabilityChangedEvent properties
//

STDMETHODIMP MouseCapabilityChangedEventWrap::COMGETTER(SupportsAbsolute)(BOOL *aSupportsAbsolute)
{
    LogRelFlow(("{%p} %s: enter aSupportsAbsolute=%p\n", this, "MouseCapabilityChangedEvent::getSupportsAbsolute", aSupportsAbsolute));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSupportsAbsolute);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSupportsAbsolute(aSupportsAbsolute);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSupportsAbsolute=%RTbool hrc=%Rhrc\n", this, "MouseCapabilityChangedEvent::getSupportsAbsolute", *aSupportsAbsolute, hrc));
    return hrc;
}

STDMETHODIMP MouseCapabilityChangedEventWrap::COMGETTER(SupportsRelative)(BOOL *aSupportsRelative)
{
    LogRelFlow(("{%p} %s: enter aSupportsRelative=%p\n", this, "MouseCapabilityChangedEvent::getSupportsRelative", aSupportsRelative));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSupportsRelative);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSupportsRelative(aSupportsRelative);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSupportsRelative=%RTbool hrc=%Rhrc\n", this, "MouseCapabilityChangedEvent::getSupportsRelative", *aSupportsRelative, hrc));
    return hrc;
}

STDMETHODIMP MouseCapabilityChangedEventWrap::COMGETTER(SupportsMultiTouch)(BOOL *aSupportsMultiTouch)
{
    LogRelFlow(("{%p} %s: enter aSupportsMultiTouch=%p\n", this, "MouseCapabilityChangedEvent::getSupportsMultiTouch", aSupportsMultiTouch));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSupportsMultiTouch);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSupportsMultiTouch(aSupportsMultiTouch);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSupportsMultiTouch=%RTbool hrc=%Rhrc\n", this, "MouseCapabilityChangedEvent::getSupportsMultiTouch", *aSupportsMultiTouch, hrc));
    return hrc;
}

STDMETHODIMP MouseCapabilityChangedEventWrap::COMGETTER(NeedsHostCursor)(BOOL *aNeedsHostCursor)
{
    LogRelFlow(("{%p} %s: enter aNeedsHostCursor=%p\n", this, "MouseCapabilityChangedEvent::getNeedsHostCursor", aNeedsHostCursor));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNeedsHostCursor);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNeedsHostCursor(aNeedsHostCursor);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNeedsHostCursor=%RTbool hrc=%Rhrc\n", this, "MouseCapabilityChangedEvent::getNeedsHostCursor", *aNeedsHostCursor, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP MouseCapabilityChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "MouseCapabilityChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MouseCapabilityChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP MouseCapabilityChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                            BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "MouseCapabilityChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "MouseCapabilityChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IMouseCapabilityChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(MouseCapabilityChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(MouseCapabilityChangedEventWrap, IMouseCapabilityChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "MouseCapabilityChangedEventWrap.cpp"

// ##### BEGINFILE "KeyboardLedsChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IKeyboardLedsChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef KeyboardLedsChangedEventWrap_H_
#define KeyboardLedsChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE KeyboardLedsChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IKeyboardLedsChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(KeyboardLedsChangedEventWrap, IKeyboardLedsChangedEvent)
    DECLARE_NOT_AGGREGATABLE(KeyboardLedsChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(KeyboardLedsChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IKeyboardLedsChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IKeyboardLedsChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(KeyboardLedsChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IKeyboardLedsChangedEvent properties
    STDMETHOD(COMGETTER(NumLock))(BOOL *aNumLock);
    STDMETHOD(COMGETTER(CapsLock))(BOOL *aCapsLock);
    STDMETHOD(COMGETTER(ScrollLock))(BOOL *aScrollLock);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IKeyboardLedsChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IKeyboardLedsChangedEvent properties
    virtual HRESULT getNumLock(BOOL *aNumLock) = 0;
    virtual HRESULT getCapsLock(BOOL *aCapsLock) = 0;
    virtual HRESULT getScrollLock(BOOL *aScrollLock) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IKeyboardLedsChangedEvent methods
};

#endif // !KeyboardLedsChangedEventWrap_H_

// ##### ENDFILE "KeyboardLedsChangedEventWrap.h"

// ##### BEGINFILE "KeyboardLedsChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IKeyboardLedsChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_KEYBOARDLEDSCHANGEDEVENT

#include "KeyboardLedsChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(KeyboardLedsChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP KeyboardLedsChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "KeyboardLedsChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "KeyboardLedsChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP KeyboardLedsChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "KeyboardLedsChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "KeyboardLedsChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP KeyboardLedsChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "KeyboardLedsChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "KeyboardLedsChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IKeyboardLedsChangedEvent properties
//

STDMETHODIMP KeyboardLedsChangedEventWrap::COMGETTER(NumLock)(BOOL *aNumLock)
{
    LogRelFlow(("{%p} %s: enter aNumLock=%p\n", this, "KeyboardLedsChangedEvent::getNumLock", aNumLock));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNumLock);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNumLock(aNumLock);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNumLock=%RTbool hrc=%Rhrc\n", this, "KeyboardLedsChangedEvent::getNumLock", *aNumLock, hrc));
    return hrc;
}

STDMETHODIMP KeyboardLedsChangedEventWrap::COMGETTER(CapsLock)(BOOL *aCapsLock)
{
    LogRelFlow(("{%p} %s: enter aCapsLock=%p\n", this, "KeyboardLedsChangedEvent::getCapsLock", aCapsLock));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCapsLock);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getCapsLock(aCapsLock);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aCapsLock=%RTbool hrc=%Rhrc\n", this, "KeyboardLedsChangedEvent::getCapsLock", *aCapsLock, hrc));
    return hrc;
}

STDMETHODIMP KeyboardLedsChangedEventWrap::COMGETTER(ScrollLock)(BOOL *aScrollLock)
{
    LogRelFlow(("{%p} %s: enter aScrollLock=%p\n", this, "KeyboardLedsChangedEvent::getScrollLock", aScrollLock));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aScrollLock);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getScrollLock(aScrollLock);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aScrollLock=%RTbool hrc=%Rhrc\n", this, "KeyboardLedsChangedEvent::getScrollLock", *aScrollLock, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP KeyboardLedsChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "KeyboardLedsChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "KeyboardLedsChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP KeyboardLedsChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                         BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "KeyboardLedsChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "KeyboardLedsChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IKeyboardLedsChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(KeyboardLedsChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(KeyboardLedsChangedEventWrap, IKeyboardLedsChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "KeyboardLedsChangedEventWrap.cpp"

// ##### BEGINFILE "StateChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IStateChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef StateChangedEventWrap_H_
#define StateChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE StateChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IStateChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(StateChangedEventWrap, IStateChangedEvent)
    DECLARE_NOT_AGGREGATABLE(StateChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(StateChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IStateChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IStateChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(StateChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IStateChangedEvent properties
    STDMETHOD(COMGETTER(State))(MachineState_T *aState);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IStateChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IStateChangedEvent properties
    virtual HRESULT getState(MachineState_T *aState) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IStateChangedEvent methods
};

#endif // !StateChangedEventWrap_H_

// ##### ENDFILE "StateChangedEventWrap.h"

// ##### BEGINFILE "StateChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IStateChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_STATECHANGEDEVENT

#include "StateChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(StateChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP StateChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "StateChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "StateChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP StateChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "StateChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "StateChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP StateChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "StateChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "StateChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IStateChangedEvent properties
//

STDMETHODIMP StateChangedEventWrap::COMGETTER(State)(MachineState_T *aState)
{
    LogRelFlow(("{%p} %s: enter aState=%p\n", this, "StateChangedEvent::getState", aState));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aState);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getState(aState);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aState=%RU32 hrc=%Rhrc\n", this, "StateChangedEvent::getState", *aState, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP StateChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "StateChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "StateChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP StateChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                  BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "StateChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "StateChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IStateChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(StateChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(StateChangedEventWrap, IStateChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "StateChangedEventWrap.cpp"

// ##### BEGINFILE "AdditionsStateChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IAdditionsStateChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef AdditionsStateChangedEventWrap_H_
#define AdditionsStateChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE AdditionsStateChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IAdditionsStateChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(AdditionsStateChangedEventWrap, IAdditionsStateChangedEvent)
    DECLARE_NOT_AGGREGATABLE(AdditionsStateChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(AdditionsStateChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IAdditionsStateChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IAdditionsStateChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(AdditionsStateChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IAdditionsStateChangedEvent properties

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IAdditionsStateChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IAdditionsStateChangedEvent properties

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IAdditionsStateChangedEvent methods
};

#endif // !AdditionsStateChangedEventWrap_H_

// ##### ENDFILE "AdditionsStateChangedEventWrap.h"

// ##### BEGINFILE "AdditionsStateChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IAdditionsStateChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_ADDITIONSSTATECHANGEDEVENT

#include "AdditionsStateChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(AdditionsStateChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP AdditionsStateChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "AdditionsStateChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "AdditionsStateChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP AdditionsStateChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "AdditionsStateChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "AdditionsStateChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP AdditionsStateChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "AdditionsStateChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "AdditionsStateChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IAdditionsStateChangedEvent properties
//

//
// IEvent methods
//

STDMETHODIMP AdditionsStateChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "AdditionsStateChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "AdditionsStateChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP AdditionsStateChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                           BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "AdditionsStateChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "AdditionsStateChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IAdditionsStateChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(AdditionsStateChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(AdditionsStateChangedEventWrap, IAdditionsStateChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "AdditionsStateChangedEventWrap.cpp"

// ##### BEGINFILE "NetworkAdapterChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for INetworkAdapterChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef NetworkAdapterChangedEventWrap_H_
#define NetworkAdapterChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE NetworkAdapterChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(INetworkAdapterChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(NetworkAdapterChangedEventWrap, INetworkAdapterChangedEvent)
    DECLARE_NOT_AGGREGATABLE(NetworkAdapterChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(NetworkAdapterChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(INetworkAdapterChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, INetworkAdapterChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(NetworkAdapterChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public INetworkAdapterChangedEvent properties
    STDMETHOD(COMGETTER(NetworkAdapter))(INetworkAdapter **aNetworkAdapter);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public INetworkAdapterChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped INetworkAdapterChangedEvent properties
    virtual HRESULT getNetworkAdapter(ComPtr<INetworkAdapter> &aNetworkAdapter) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped INetworkAdapterChangedEvent methods
};

#endif // !NetworkAdapterChangedEventWrap_H_

// ##### ENDFILE "NetworkAdapterChangedEventWrap.h"

// ##### BEGINFILE "NetworkAdapterChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for INetworkAdapterChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_NETWORKADAPTERCHANGEDEVENT

#include "NetworkAdapterChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(NetworkAdapterChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP NetworkAdapterChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "NetworkAdapterChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "NetworkAdapterChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "NetworkAdapterChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "NetworkAdapterChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "NetworkAdapterChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "NetworkAdapterChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// INetworkAdapterChangedEvent properties
//

STDMETHODIMP NetworkAdapterChangedEventWrap::COMGETTER(NetworkAdapter)(INetworkAdapter **aNetworkAdapter)
{
    LogRelFlow(("{%p} %s: enter aNetworkAdapter=%p\n", this, "NetworkAdapterChangedEvent::getNetworkAdapter", aNetworkAdapter));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNetworkAdapter);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNetworkAdapter(ComTypeOutConverter<INetworkAdapter>(aNetworkAdapter).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNetworkAdapter=%p hrc=%Rhrc\n", this, "NetworkAdapterChangedEvent::getNetworkAdapter", *aNetworkAdapter, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP NetworkAdapterChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "NetworkAdapterChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NetworkAdapterChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP NetworkAdapterChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                           BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "NetworkAdapterChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "NetworkAdapterChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// INetworkAdapterChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(NetworkAdapterChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(NetworkAdapterChangedEventWrap, INetworkAdapterChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "NetworkAdapterChangedEventWrap.cpp"

// ##### BEGINFILE "SerialPortChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for ISerialPortChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef SerialPortChangedEventWrap_H_
#define SerialPortChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE SerialPortChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(ISerialPortChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(SerialPortChangedEventWrap, ISerialPortChangedEvent)
    DECLARE_NOT_AGGREGATABLE(SerialPortChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(SerialPortChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(ISerialPortChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, ISerialPortChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(SerialPortChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public ISerialPortChangedEvent properties
    STDMETHOD(COMGETTER(SerialPort))(ISerialPort **aSerialPort);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public ISerialPortChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped ISerialPortChangedEvent properties
    virtual HRESULT getSerialPort(ComPtr<ISerialPort> &aSerialPort) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped ISerialPortChangedEvent methods
};

#endif // !SerialPortChangedEventWrap_H_

// ##### ENDFILE "SerialPortChangedEventWrap.h"

// ##### BEGINFILE "SerialPortChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for ISerialPortChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_SERIALPORTCHANGEDEVENT

#include "SerialPortChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(SerialPortChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP SerialPortChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "SerialPortChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "SerialPortChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP SerialPortChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "SerialPortChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "SerialPortChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP SerialPortChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "SerialPortChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "SerialPortChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// ISerialPortChangedEvent properties
//

STDMETHODIMP SerialPortChangedEventWrap::COMGETTER(SerialPort)(ISerialPort **aSerialPort)
{
    LogRelFlow(("{%p} %s: enter aSerialPort=%p\n", this, "SerialPortChangedEvent::getSerialPort", aSerialPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSerialPort);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSerialPort(ComTypeOutConverter<ISerialPort>(aSerialPort).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSerialPort=%p hrc=%Rhrc\n", this, "SerialPortChangedEvent::getSerialPort", *aSerialPort, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP SerialPortChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "SerialPortChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SerialPortChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP SerialPortChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                       BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "SerialPortChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "SerialPortChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// ISerialPortChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(SerialPortChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(SerialPortChangedEventWrap, ISerialPortChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "SerialPortChangedEventWrap.cpp"

// ##### BEGINFILE "ParallelPortChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IParallelPortChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef ParallelPortChangedEventWrap_H_
#define ParallelPortChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE ParallelPortChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IParallelPortChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(ParallelPortChangedEventWrap, IParallelPortChangedEvent)
    DECLARE_NOT_AGGREGATABLE(ParallelPortChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(ParallelPortChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IParallelPortChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IParallelPortChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(ParallelPortChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IParallelPortChangedEvent properties
    STDMETHOD(COMGETTER(ParallelPort))(IParallelPort **aParallelPort);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IParallelPortChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IParallelPortChangedEvent properties
    virtual HRESULT getParallelPort(ComPtr<IParallelPort> &aParallelPort) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IParallelPortChangedEvent methods
};

#endif // !ParallelPortChangedEventWrap_H_

// ##### ENDFILE "ParallelPortChangedEventWrap.h"

// ##### BEGINFILE "ParallelPortChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IParallelPortChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_PARALLELPORTCHANGEDEVENT

#include "ParallelPortChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(ParallelPortChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP ParallelPortChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "ParallelPortChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "ParallelPortChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP ParallelPortChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "ParallelPortChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "ParallelPortChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP ParallelPortChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "ParallelPortChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "ParallelPortChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IParallelPortChangedEvent properties
//

STDMETHODIMP ParallelPortChangedEventWrap::COMGETTER(ParallelPort)(IParallelPort **aParallelPort)
{
    LogRelFlow(("{%p} %s: enter aParallelPort=%p\n", this, "ParallelPortChangedEvent::getParallelPort", aParallelPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aParallelPort);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getParallelPort(ComTypeOutConverter<IParallelPort>(aParallelPort).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aParallelPort=%p hrc=%Rhrc\n", this, "ParallelPortChangedEvent::getParallelPort", *aParallelPort, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP ParallelPortChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "ParallelPortChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "ParallelPortChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP ParallelPortChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                         BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "ParallelPortChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "ParallelPortChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IParallelPortChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(ParallelPortChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(ParallelPortChangedEventWrap, IParallelPortChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "ParallelPortChangedEventWrap.cpp"

// ##### BEGINFILE "StorageControllerChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IStorageControllerChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef StorageControllerChangedEventWrap_H_
#define StorageControllerChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE StorageControllerChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IStorageControllerChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(StorageControllerChangedEventWrap, IStorageControllerChangedEvent)
    DECLARE_NOT_AGGREGATABLE(StorageControllerChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(StorageControllerChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IStorageControllerChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IStorageControllerChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(StorageControllerChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IStorageControllerChangedEvent properties

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IStorageControllerChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IStorageControllerChangedEvent properties

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IStorageControllerChangedEvent methods
};

#endif // !StorageControllerChangedEventWrap_H_

// ##### ENDFILE "StorageControllerChangedEventWrap.h"

// ##### BEGINFILE "StorageControllerChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IStorageControllerChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_STORAGECONTROLLERCHANGEDEVENT

#include "StorageControllerChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(StorageControllerChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP StorageControllerChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "StorageControllerChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "StorageControllerChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP StorageControllerChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "StorageControllerChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "StorageControllerChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP StorageControllerChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "StorageControllerChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "StorageControllerChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IStorageControllerChangedEvent properties
//

//
// IEvent methods
//

STDMETHODIMP StorageControllerChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "StorageControllerChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "StorageControllerChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP StorageControllerChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                              BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "StorageControllerChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "StorageControllerChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IStorageControllerChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(StorageControllerChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(StorageControllerChangedEventWrap, IStorageControllerChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "StorageControllerChangedEventWrap.cpp"

// ##### BEGINFILE "MediumChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IMediumChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef MediumChangedEventWrap_H_
#define MediumChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE MediumChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IMediumChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(MediumChangedEventWrap, IMediumChangedEvent)
    DECLARE_NOT_AGGREGATABLE(MediumChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(MediumChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IMediumChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IMediumChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(MediumChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IMediumChangedEvent properties
    STDMETHOD(COMGETTER(MediumAttachment))(IMediumAttachment **aMediumAttachment);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IMediumChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IMediumChangedEvent properties
    virtual HRESULT getMediumAttachment(ComPtr<IMediumAttachment> &aMediumAttachment) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IMediumChangedEvent methods
};

#endif // !MediumChangedEventWrap_H_

// ##### ENDFILE "MediumChangedEventWrap.h"

// ##### BEGINFILE "MediumChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IMediumChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_MEDIUMCHANGEDEVENT

#include "MediumChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(MediumChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP MediumChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "MediumChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "MediumChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP MediumChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "MediumChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "MediumChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP MediumChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "MediumChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "MediumChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IMediumChangedEvent properties
//

STDMETHODIMP MediumChangedEventWrap::COMGETTER(MediumAttachment)(IMediumAttachment **aMediumAttachment)
{
    LogRelFlow(("{%p} %s: enter aMediumAttachment=%p\n", this, "MediumChangedEvent::getMediumAttachment", aMediumAttachment));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMediumAttachment);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMediumAttachment(ComTypeOutConverter<IMediumAttachment>(aMediumAttachment).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMediumAttachment=%p hrc=%Rhrc\n", this, "MediumChangedEvent::getMediumAttachment", *aMediumAttachment, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP MediumChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "MediumChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "MediumChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP MediumChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                   BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "MediumChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "MediumChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IMediumChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(MediumChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(MediumChangedEventWrap, IMediumChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "MediumChangedEventWrap.cpp"

// ##### BEGINFILE "ClipboardModeChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IClipboardModeChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef ClipboardModeChangedEventWrap_H_
#define ClipboardModeChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE ClipboardModeChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IClipboardModeChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(ClipboardModeChangedEventWrap, IClipboardModeChangedEvent)
    DECLARE_NOT_AGGREGATABLE(ClipboardModeChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(ClipboardModeChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IClipboardModeChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IClipboardModeChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(ClipboardModeChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IClipboardModeChangedEvent properties
    STDMETHOD(COMGETTER(ClipboardMode))(ClipboardMode_T *aClipboardMode);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IClipboardModeChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IClipboardModeChangedEvent properties
    virtual HRESULT getClipboardMode(ClipboardMode_T *aClipboardMode) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IClipboardModeChangedEvent methods
};

#endif // !ClipboardModeChangedEventWrap_H_

// ##### ENDFILE "ClipboardModeChangedEventWrap.h"

// ##### BEGINFILE "ClipboardModeChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IClipboardModeChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_CLIPBOARDMODECHANGEDEVENT

#include "ClipboardModeChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(ClipboardModeChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP ClipboardModeChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "ClipboardModeChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "ClipboardModeChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP ClipboardModeChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "ClipboardModeChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "ClipboardModeChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP ClipboardModeChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "ClipboardModeChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "ClipboardModeChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IClipboardModeChangedEvent properties
//

STDMETHODIMP ClipboardModeChangedEventWrap::COMGETTER(ClipboardMode)(ClipboardMode_T *aClipboardMode)
{
    LogRelFlow(("{%p} %s: enter aClipboardMode=%p\n", this, "ClipboardModeChangedEvent::getClipboardMode", aClipboardMode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aClipboardMode);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getClipboardMode(aClipboardMode);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aClipboardMode=%RU32 hrc=%Rhrc\n", this, "ClipboardModeChangedEvent::getClipboardMode", *aClipboardMode, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP ClipboardModeChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "ClipboardModeChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "ClipboardModeChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP ClipboardModeChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                          BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "ClipboardModeChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "ClipboardModeChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IClipboardModeChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(ClipboardModeChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(ClipboardModeChangedEventWrap, IClipboardModeChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "ClipboardModeChangedEventWrap.cpp"

// ##### BEGINFILE "DragAndDropModeChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IDragAndDropModeChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef DragAndDropModeChangedEventWrap_H_
#define DragAndDropModeChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE DragAndDropModeChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IDragAndDropModeChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(DragAndDropModeChangedEventWrap, IDragAndDropModeChangedEvent)
    DECLARE_NOT_AGGREGATABLE(DragAndDropModeChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(DragAndDropModeChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IDragAndDropModeChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IDragAndDropModeChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(DragAndDropModeChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IDragAndDropModeChangedEvent properties
    STDMETHOD(COMGETTER(DragAndDropMode))(DragAndDropMode_T *aDragAndDropMode);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IDragAndDropModeChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IDragAndDropModeChangedEvent properties
    virtual HRESULT getDragAndDropMode(DragAndDropMode_T *aDragAndDropMode) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IDragAndDropModeChangedEvent methods
};

#endif // !DragAndDropModeChangedEventWrap_H_

// ##### ENDFILE "DragAndDropModeChangedEventWrap.h"

// ##### BEGINFILE "DragAndDropModeChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IDragAndDropModeChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_DRAGANDDROPMODECHANGEDEVENT

#include "DragAndDropModeChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(DragAndDropModeChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP DragAndDropModeChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "DragAndDropModeChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "DragAndDropModeChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP DragAndDropModeChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "DragAndDropModeChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "DragAndDropModeChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP DragAndDropModeChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "DragAndDropModeChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "DragAndDropModeChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IDragAndDropModeChangedEvent properties
//

STDMETHODIMP DragAndDropModeChangedEventWrap::COMGETTER(DragAndDropMode)(DragAndDropMode_T *aDragAndDropMode)
{
    LogRelFlow(("{%p} %s: enter aDragAndDropMode=%p\n", this, "DragAndDropModeChangedEvent::getDragAndDropMode", aDragAndDropMode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDragAndDropMode);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDragAndDropMode(aDragAndDropMode);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDragAndDropMode=%RU32 hrc=%Rhrc\n", this, "DragAndDropModeChangedEvent::getDragAndDropMode", *aDragAndDropMode, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP DragAndDropModeChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "DragAndDropModeChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "DragAndDropModeChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP DragAndDropModeChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                            BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "DragAndDropModeChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "DragAndDropModeChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IDragAndDropModeChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(DragAndDropModeChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(DragAndDropModeChangedEventWrap, IDragAndDropModeChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "DragAndDropModeChangedEventWrap.cpp"

// ##### BEGINFILE "CPUChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for ICPUChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef CPUChangedEventWrap_H_
#define CPUChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE CPUChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(ICPUChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(CPUChangedEventWrap, ICPUChangedEvent)
    DECLARE_NOT_AGGREGATABLE(CPUChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CPUChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(ICPUChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, ICPUChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(CPUChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public ICPUChangedEvent properties
    STDMETHOD(COMGETTER(CPU))(ULONG *aCPU);
    STDMETHOD(COMGETTER(Add))(BOOL *aAdd);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public ICPUChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped ICPUChangedEvent properties
    virtual HRESULT getCPU(ULONG *aCPU) = 0;
    virtual HRESULT getAdd(BOOL *aAdd) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped ICPUChangedEvent methods
};

#endif // !CPUChangedEventWrap_H_

// ##### ENDFILE "CPUChangedEventWrap.h"

// ##### BEGINFILE "CPUChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for ICPUChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_CPUCHANGEDEVENT

#include "CPUChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(CPUChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP CPUChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "CPUChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "CPUChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP CPUChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "CPUChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "CPUChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP CPUChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "CPUChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "CPUChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// ICPUChangedEvent properties
//

STDMETHODIMP CPUChangedEventWrap::COMGETTER(CPU)(ULONG *aCPU)
{
    LogRelFlow(("{%p} %s: enter aCPU=%p\n", this, "CPUChangedEvent::getCPU", aCPU));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCPU);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getCPU(aCPU);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aCPU=%RU32 hrc=%Rhrc\n", this, "CPUChangedEvent::getCPU", *aCPU, hrc));
    return hrc;
}

STDMETHODIMP CPUChangedEventWrap::COMGETTER(Add)(BOOL *aAdd)
{
    LogRelFlow(("{%p} %s: enter aAdd=%p\n", this, "CPUChangedEvent::getAdd", aAdd));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAdd);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAdd(aAdd);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAdd=%RTbool hrc=%Rhrc\n", this, "CPUChangedEvent::getAdd", *aAdd, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP CPUChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "CPUChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "CPUChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP CPUChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "CPUChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "CPUChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// ICPUChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(CPUChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(CPUChangedEventWrap, ICPUChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "CPUChangedEventWrap.cpp"

// ##### BEGINFILE "CPUExecutionCapChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for ICPUExecutionCapChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef CPUExecutionCapChangedEventWrap_H_
#define CPUExecutionCapChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE CPUExecutionCapChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(ICPUExecutionCapChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(CPUExecutionCapChangedEventWrap, ICPUExecutionCapChangedEvent)
    DECLARE_NOT_AGGREGATABLE(CPUExecutionCapChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CPUExecutionCapChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(ICPUExecutionCapChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, ICPUExecutionCapChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(CPUExecutionCapChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public ICPUExecutionCapChangedEvent properties
    STDMETHOD(COMGETTER(ExecutionCap))(ULONG *aExecutionCap);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public ICPUExecutionCapChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped ICPUExecutionCapChangedEvent properties
    virtual HRESULT getExecutionCap(ULONG *aExecutionCap) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped ICPUExecutionCapChangedEvent methods
};

#endif // !CPUExecutionCapChangedEventWrap_H_

// ##### ENDFILE "CPUExecutionCapChangedEventWrap.h"

// ##### BEGINFILE "CPUExecutionCapChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for ICPUExecutionCapChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_CPUEXECUTIONCAPCHANGEDEVENT

#include "CPUExecutionCapChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(CPUExecutionCapChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP CPUExecutionCapChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "CPUExecutionCapChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "CPUExecutionCapChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP CPUExecutionCapChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "CPUExecutionCapChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "CPUExecutionCapChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP CPUExecutionCapChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "CPUExecutionCapChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "CPUExecutionCapChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// ICPUExecutionCapChangedEvent properties
//

STDMETHODIMP CPUExecutionCapChangedEventWrap::COMGETTER(ExecutionCap)(ULONG *aExecutionCap)
{
    LogRelFlow(("{%p} %s: enter aExecutionCap=%p\n", this, "CPUExecutionCapChangedEvent::getExecutionCap", aExecutionCap));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aExecutionCap);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getExecutionCap(aExecutionCap);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aExecutionCap=%RU32 hrc=%Rhrc\n", this, "CPUExecutionCapChangedEvent::getExecutionCap", *aExecutionCap, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP CPUExecutionCapChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "CPUExecutionCapChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "CPUExecutionCapChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP CPUExecutionCapChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                            BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "CPUExecutionCapChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "CPUExecutionCapChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// ICPUExecutionCapChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(CPUExecutionCapChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(CPUExecutionCapChangedEventWrap, ICPUExecutionCapChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "CPUExecutionCapChangedEventWrap.cpp"

// ##### BEGINFILE "GuestKeyboardEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestKeyboardEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestKeyboardEventWrap_H_
#define GuestKeyboardEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestKeyboardEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestKeyboardEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestKeyboardEventWrap, IGuestKeyboardEvent)
    DECLARE_NOT_AGGREGATABLE(GuestKeyboardEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestKeyboardEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestKeyboardEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestKeyboardEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestKeyboardEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IGuestKeyboardEvent properties
    STDMETHOD(COMGETTER(Scancodes))(ComSafeArrayOut(LONG, aScancodes));

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IGuestKeyboardEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IGuestKeyboardEvent properties
    virtual HRESULT getScancodes(std::vector<LONG> &aScancodes) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IGuestKeyboardEvent methods
};

#endif // !GuestKeyboardEventWrap_H_

// ##### ENDFILE "GuestKeyboardEventWrap.h"

// ##### BEGINFILE "GuestKeyboardEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestKeyboardEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTKEYBOARDEVENT

#include "GuestKeyboardEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestKeyboardEventWrap)

//
// IEvent properties
//

STDMETHODIMP GuestKeyboardEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestKeyboardEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestKeyboardEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestKeyboardEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "GuestKeyboardEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "GuestKeyboardEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP GuestKeyboardEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "GuestKeyboardEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "GuestKeyboardEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IGuestKeyboardEvent properties
//

STDMETHODIMP GuestKeyboardEventWrap::COMGETTER(Scancodes)(ComSafeArrayOut(LONG, aScancodes))
{
    LogRelFlow(("{%p} %s: enter aScancodes=%p\n", this, "GuestKeyboardEvent::getScancodes", aScancodes));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aScancodes);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getScancodes(ArrayOutConverter<LONG>(ComSafeArrayOutArg(aScancodes)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aScancodes=%zu hrc=%Rhrc\n", this, "GuestKeyboardEvent::getScancodes", ComSafeArraySize(*aScancodes), hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP GuestKeyboardEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestKeyboardEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestKeyboardEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP GuestKeyboardEventWrap::WaitProcessed(LONG aTimeout,
                                                   BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "GuestKeyboardEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "GuestKeyboardEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IGuestKeyboardEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestKeyboardEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(GuestKeyboardEventWrap, IGuestKeyboardEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestKeyboardEventWrap.cpp"

// ##### BEGINFILE "GuestMouseEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestMouseEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestMouseEventWrap_H_
#define GuestMouseEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestMouseEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestMouseEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestMouseEventWrap, IGuestMouseEvent)
    DECLARE_NOT_AGGREGATABLE(GuestMouseEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestMouseEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestMouseEvent)
        COM_INTERFACE_ENTRY(IReusableEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestMouseEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestMouseEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IReusableEvent properties
    STDMETHOD(COMGETTER(Generation))(ULONG *aGeneration);

    // public IGuestMouseEvent properties
    STDMETHOD(COMGETTER(Mode))(GuestMouseEventMode_T *aMode);
    STDMETHOD(COMGETTER(X))(LONG *aX);
    STDMETHOD(COMGETTER(Y))(LONG *aY);
    STDMETHOD(COMGETTER(Z))(LONG *aZ);
    STDMETHOD(COMGETTER(W))(LONG *aW);
    STDMETHOD(COMGETTER(Buttons))(LONG *aButtons);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IReusableEvent methods
    STDMETHOD(Reuse)();

    // public IGuestMouseEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IReusableEvent properties
    virtual HRESULT getGeneration(ULONG *aGeneration) = 0;

    // wrapped IGuestMouseEvent properties
    virtual HRESULT getMode(GuestMouseEventMode_T *aMode) = 0;
    virtual HRESULT getX(LONG *aX) = 0;
    virtual HRESULT getY(LONG *aY) = 0;
    virtual HRESULT getZ(LONG *aZ) = 0;
    virtual HRESULT getW(LONG *aW) = 0;
    virtual HRESULT getButtons(LONG *aButtons) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IReusableEvent methods
    virtual HRESULT reuse() = 0;

    // wrapped IGuestMouseEvent methods
};

#endif // !GuestMouseEventWrap_H_

// ##### ENDFILE "GuestMouseEventWrap.h"

// ##### BEGINFILE "GuestMouseEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestMouseEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTMOUSEEVENT

#include "GuestMouseEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestMouseEventWrap)

//
// IEvent properties
//

STDMETHODIMP GuestMouseEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestMouseEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestMouseEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestMouseEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "GuestMouseEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "GuestMouseEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP GuestMouseEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "GuestMouseEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "GuestMouseEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IReusableEvent properties
//

STDMETHODIMP GuestMouseEventWrap::COMGETTER(Generation)(ULONG *aGeneration)
{
    LogRelFlow(("{%p} %s: enter aGeneration=%p\n", this, "GuestMouseEvent::getGeneration", aGeneration));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGeneration);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGeneration(aGeneration);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGeneration=%RU32 hrc=%Rhrc\n", this, "GuestMouseEvent::getGeneration", *aGeneration, hrc));
    return hrc;
}

//
// IGuestMouseEvent properties
//

STDMETHODIMP GuestMouseEventWrap::COMGETTER(Mode)(GuestMouseEventMode_T *aMode)
{
    LogRelFlow(("{%p} %s: enter aMode=%p\n", this, "GuestMouseEvent::getMode", aMode));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMode);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMode(aMode);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMode=%RU32 hrc=%Rhrc\n", this, "GuestMouseEvent::getMode", *aMode, hrc));
    return hrc;
}

STDMETHODIMP GuestMouseEventWrap::COMGETTER(X)(LONG *aX)
{
    LogRelFlow(("{%p} %s: enter aX=%p\n", this, "GuestMouseEvent::getX", aX));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aX);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getX(aX);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aX=%RI32 hrc=%Rhrc\n", this, "GuestMouseEvent::getX", *aX, hrc));
    return hrc;
}

STDMETHODIMP GuestMouseEventWrap::COMGETTER(Y)(LONG *aY)
{
    LogRelFlow(("{%p} %s: enter aY=%p\n", this, "GuestMouseEvent::getY", aY));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aY);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getY(aY);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aY=%RI32 hrc=%Rhrc\n", this, "GuestMouseEvent::getY", *aY, hrc));
    return hrc;
}

STDMETHODIMP GuestMouseEventWrap::COMGETTER(Z)(LONG *aZ)
{
    LogRelFlow(("{%p} %s: enter aZ=%p\n", this, "GuestMouseEvent::getZ", aZ));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aZ);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getZ(aZ);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aZ=%RI32 hrc=%Rhrc\n", this, "GuestMouseEvent::getZ", *aZ, hrc));
    return hrc;
}

STDMETHODIMP GuestMouseEventWrap::COMGETTER(W)(LONG *aW)
{
    LogRelFlow(("{%p} %s: enter aW=%p\n", this, "GuestMouseEvent::getW", aW));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aW);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getW(aW);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aW=%RI32 hrc=%Rhrc\n", this, "GuestMouseEvent::getW", *aW, hrc));
    return hrc;
}

STDMETHODIMP GuestMouseEventWrap::COMGETTER(Buttons)(LONG *aButtons)
{
    LogRelFlow(("{%p} %s: enter aButtons=%p\n", this, "GuestMouseEvent::getButtons", aButtons));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aButtons);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getButtons(aButtons);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aButtons=%RI32 hrc=%Rhrc\n", this, "GuestMouseEvent::getButtons", *aButtons, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP GuestMouseEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestMouseEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestMouseEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP GuestMouseEventWrap::WaitProcessed(LONG aTimeout,
                                                BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "GuestMouseEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "GuestMouseEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IReusableEvent methods
//

STDMETHODIMP GuestMouseEventWrap::Reuse()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestMouseEvent::reuse"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = reuse();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestMouseEvent::reuse", hrc));
    return hrc;
}

//
// IGuestMouseEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestMouseEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS3_CI(GuestMouseEventWrap, IGuestMouseEvent, IReusableEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestMouseEventWrap.cpp"

// ##### BEGINFILE "GuestMultiTouchEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestMultiTouchEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestMultiTouchEventWrap_H_
#define GuestMultiTouchEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestMultiTouchEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestMultiTouchEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestMultiTouchEventWrap, IGuestMultiTouchEvent)
    DECLARE_NOT_AGGREGATABLE(GuestMultiTouchEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestMultiTouchEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestMultiTouchEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestMultiTouchEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestMultiTouchEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IGuestMultiTouchEvent properties
    STDMETHOD(COMGETTER(ContactCount))(LONG *aContactCount);
    STDMETHOD(COMGETTER(XPositions))(ComSafeArrayOut(SHORT, aXPositions));
    STDMETHOD(COMGETTER(YPositions))(ComSafeArrayOut(SHORT, aYPositions));
    STDMETHOD(COMGETTER(ContactIds))(ComSafeArrayOut(USHORT, aContactIds));
    STDMETHOD(COMGETTER(ContactFlags))(ComSafeArrayOut(USHORT, aContactFlags));
    STDMETHOD(COMGETTER(ScanTime))(ULONG *aScanTime);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IGuestMultiTouchEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IGuestMultiTouchEvent properties
    virtual HRESULT getContactCount(LONG *aContactCount) = 0;
    virtual HRESULT getXPositions(std::vector<SHORT> &aXPositions) = 0;
    virtual HRESULT getYPositions(std::vector<SHORT> &aYPositions) = 0;
    virtual HRESULT getContactIds(std::vector<USHORT> &aContactIds) = 0;
    virtual HRESULT getContactFlags(std::vector<USHORT> &aContactFlags) = 0;
    virtual HRESULT getScanTime(ULONG *aScanTime) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IGuestMultiTouchEvent methods
};

#endif // !GuestMultiTouchEventWrap_H_

// ##### ENDFILE "GuestMultiTouchEventWrap.h"

// ##### BEGINFILE "GuestMultiTouchEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestMultiTouchEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTMULTITOUCHEVENT

#include "GuestMultiTouchEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestMultiTouchEventWrap)

//
// IEvent properties
//

STDMETHODIMP GuestMultiTouchEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestMultiTouchEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestMultiTouchEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestMultiTouchEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "GuestMultiTouchEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "GuestMultiTouchEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP GuestMultiTouchEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "GuestMultiTouchEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "GuestMultiTouchEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IGuestMultiTouchEvent properties
//

STDMETHODIMP GuestMultiTouchEventWrap::COMGETTER(ContactCount)(LONG *aContactCount)
{
    LogRelFlow(("{%p} %s: enter aContactCount=%p\n", this, "GuestMultiTouchEvent::getContactCount", aContactCount));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aContactCount);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getContactCount(aContactCount);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aContactCount=%RI32 hrc=%Rhrc\n", this, "GuestMultiTouchEvent::getContactCount", *aContactCount, hrc));
    return hrc;
}

STDMETHODIMP GuestMultiTouchEventWrap::COMGETTER(XPositions)(ComSafeArrayOut(SHORT, aXPositions))
{
    LogRelFlow(("{%p} %s: enter aXPositions=%p\n", this, "GuestMultiTouchEvent::getXPositions", aXPositions));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aXPositions);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getXPositions(ArrayOutConverter<SHORT>(ComSafeArrayOutArg(aXPositions)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aXPositions=%zu hrc=%Rhrc\n", this, "GuestMultiTouchEvent::getXPositions", ComSafeArraySize(*aXPositions), hrc));
    return hrc;
}

STDMETHODIMP GuestMultiTouchEventWrap::COMGETTER(YPositions)(ComSafeArrayOut(SHORT, aYPositions))
{
    LogRelFlow(("{%p} %s: enter aYPositions=%p\n", this, "GuestMultiTouchEvent::getYPositions", aYPositions));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aYPositions);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getYPositions(ArrayOutConverter<SHORT>(ComSafeArrayOutArg(aYPositions)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aYPositions=%zu hrc=%Rhrc\n", this, "GuestMultiTouchEvent::getYPositions", ComSafeArraySize(*aYPositions), hrc));
    return hrc;
}

STDMETHODIMP GuestMultiTouchEventWrap::COMGETTER(ContactIds)(ComSafeArrayOut(USHORT, aContactIds))
{
    LogRelFlow(("{%p} %s: enter aContactIds=%p\n", this, "GuestMultiTouchEvent::getContactIds", aContactIds));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aContactIds);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getContactIds(ArrayOutConverter<USHORT>(ComSafeArrayOutArg(aContactIds)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aContactIds=%zu hrc=%Rhrc\n", this, "GuestMultiTouchEvent::getContactIds", ComSafeArraySize(*aContactIds), hrc));
    return hrc;
}

STDMETHODIMP GuestMultiTouchEventWrap::COMGETTER(ContactFlags)(ComSafeArrayOut(USHORT, aContactFlags))
{
    LogRelFlow(("{%p} %s: enter aContactFlags=%p\n", this, "GuestMultiTouchEvent::getContactFlags", aContactFlags));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aContactFlags);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getContactFlags(ArrayOutConverter<USHORT>(ComSafeArrayOutArg(aContactFlags)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aContactFlags=%zu hrc=%Rhrc\n", this, "GuestMultiTouchEvent::getContactFlags", ComSafeArraySize(*aContactFlags), hrc));
    return hrc;
}

STDMETHODIMP GuestMultiTouchEventWrap::COMGETTER(ScanTime)(ULONG *aScanTime)
{
    LogRelFlow(("{%p} %s: enter aScanTime=%p\n", this, "GuestMultiTouchEvent::getScanTime", aScanTime));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aScanTime);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getScanTime(aScanTime);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aScanTime=%RU32 hrc=%Rhrc\n", this, "GuestMultiTouchEvent::getScanTime", *aScanTime, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP GuestMultiTouchEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestMultiTouchEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestMultiTouchEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP GuestMultiTouchEventWrap::WaitProcessed(LONG aTimeout,
                                                     BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "GuestMultiTouchEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "GuestMultiTouchEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IGuestMultiTouchEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestMultiTouchEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(GuestMultiTouchEventWrap, IGuestMultiTouchEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestMultiTouchEventWrap.cpp"

// ##### BEGINFILE "GuestSessionEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestSessionEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestSessionEventWrap_H_
#define GuestSessionEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestSessionEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestSessionEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestSessionEventWrap, IGuestSessionEvent)
    DECLARE_NOT_AGGREGATABLE(GuestSessionEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestSessionEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestSessionEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestSessionEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestSessionEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IGuestSessionEvent properties
    STDMETHOD(COMGETTER(Session))(IGuestSession **aSession);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IGuestSessionEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IGuestSessionEvent properties
    virtual HRESULT getSession(ComPtr<IGuestSession> &aSession) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IGuestSessionEvent methods
};

#endif // !GuestSessionEventWrap_H_

// ##### ENDFILE "GuestSessionEventWrap.h"

// ##### BEGINFILE "GuestSessionEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestSessionEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTSESSIONEVENT

#include "GuestSessionEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestSessionEventWrap)

//
// IEvent properties
//

STDMETHODIMP GuestSessionEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestSessionEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestSessionEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "GuestSessionEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "GuestSessionEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "GuestSessionEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "GuestSessionEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IGuestSessionEvent properties
//

STDMETHODIMP GuestSessionEventWrap::COMGETTER(Session)(IGuestSession **aSession)
{
    LogRelFlow(("{%p} %s: enter aSession=%p\n", this, "GuestSessionEvent::getSession", aSession));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSession);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSession(ComTypeOutConverter<IGuestSession>(aSession).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSession=%p hrc=%Rhrc\n", this, "GuestSessionEvent::getSession", *aSession, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP GuestSessionEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestSessionEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestSessionEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP GuestSessionEventWrap::WaitProcessed(LONG aTimeout,
                                                  BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "GuestSessionEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "GuestSessionEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IGuestSessionEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestSessionEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(GuestSessionEventWrap, IGuestSessionEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestSessionEventWrap.cpp"

// ##### BEGINFILE "GuestSessionStateChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestSessionStateChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestSessionStateChangedEventWrap_H_
#define GuestSessionStateChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestSessionStateChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestSessionStateChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestSessionStateChangedEventWrap, IGuestSessionStateChangedEvent)
    DECLARE_NOT_AGGREGATABLE(GuestSessionStateChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestSessionStateChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestSessionStateChangedEvent)
        COM_INTERFACE_ENTRY(IGuestSessionEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestSessionStateChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestSessionStateChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IGuestSessionEvent properties
    STDMETHOD(COMGETTER(Session))(IGuestSession **aSession);

    // public IGuestSessionStateChangedEvent properties
    STDMETHOD(COMGETTER(Id))(ULONG *aId);
    STDMETHOD(COMGETTER(Status))(GuestSessionStatus_T *aStatus);
    STDMETHOD(COMGETTER(Error))(IVirtualBoxErrorInfo **aError);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IGuestSessionEvent methods

    // public IGuestSessionStateChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IGuestSessionEvent properties
    virtual HRESULT getSession(ComPtr<IGuestSession> &aSession) = 0;

    // wrapped IGuestSessionStateChangedEvent properties
    virtual HRESULT getId(ULONG *aId) = 0;
    virtual HRESULT getStatus(GuestSessionStatus_T *aStatus) = 0;
    virtual HRESULT getError(ComPtr<IVirtualBoxErrorInfo> &aError) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IGuestSessionEvent methods

    // wrapped IGuestSessionStateChangedEvent methods
};

#endif // !GuestSessionStateChangedEventWrap_H_

// ##### ENDFILE "GuestSessionStateChangedEventWrap.h"

// ##### BEGINFILE "GuestSessionStateChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestSessionStateChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTSESSIONSTATECHANGEDEVENT

#include "GuestSessionStateChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestSessionStateChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP GuestSessionStateChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestSessionStateChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestSessionStateChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionStateChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "GuestSessionStateChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "GuestSessionStateChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionStateChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "GuestSessionStateChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "GuestSessionStateChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IGuestSessionEvent properties
//

STDMETHODIMP GuestSessionStateChangedEventWrap::COMGETTER(Session)(IGuestSession **aSession)
{
    LogRelFlow(("{%p} %s: enter aSession=%p\n", this, "GuestSessionStateChangedEvent::getSession", aSession));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSession);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSession(ComTypeOutConverter<IGuestSession>(aSession).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSession=%p hrc=%Rhrc\n", this, "GuestSessionStateChangedEvent::getSession", *aSession, hrc));
    return hrc;
}

//
// IGuestSessionStateChangedEvent properties
//

STDMETHODIMP GuestSessionStateChangedEventWrap::COMGETTER(Id)(ULONG *aId)
{
    LogRelFlow(("{%p} %s: enter aId=%p\n", this, "GuestSessionStateChangedEvent::getId", aId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getId(aId);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aId=%RU32 hrc=%Rhrc\n", this, "GuestSessionStateChangedEvent::getId", *aId, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionStateChangedEventWrap::COMGETTER(Status)(GuestSessionStatus_T *aStatus)
{
    LogRelFlow(("{%p} %s: enter aStatus=%p\n", this, "GuestSessionStateChangedEvent::getStatus", aStatus));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStatus);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getStatus(aStatus);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aStatus=%RU32 hrc=%Rhrc\n", this, "GuestSessionStateChangedEvent::getStatus", *aStatus, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionStateChangedEventWrap::COMGETTER(Error)(IVirtualBoxErrorInfo **aError)
{
    LogRelFlow(("{%p} %s: enter aError=%p\n", this, "GuestSessionStateChangedEvent::getError", aError));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aError);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getError(ComTypeOutConverter<IVirtualBoxErrorInfo>(aError).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aError=%p hrc=%Rhrc\n", this, "GuestSessionStateChangedEvent::getError", *aError, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP GuestSessionStateChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestSessionStateChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestSessionStateChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP GuestSessionStateChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                              BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "GuestSessionStateChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "GuestSessionStateChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IGuestSessionEvent methods
//

//
// IGuestSessionStateChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestSessionStateChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS3_CI(GuestSessionStateChangedEventWrap, IGuestSessionStateChangedEvent, IGuestSessionEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestSessionStateChangedEventWrap.cpp"

// ##### BEGINFILE "GuestSessionRegisteredEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestSessionRegisteredEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestSessionRegisteredEventWrap_H_
#define GuestSessionRegisteredEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestSessionRegisteredEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestSessionRegisteredEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestSessionRegisteredEventWrap, IGuestSessionRegisteredEvent)
    DECLARE_NOT_AGGREGATABLE(GuestSessionRegisteredEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestSessionRegisteredEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestSessionRegisteredEvent)
        COM_INTERFACE_ENTRY(IGuestSessionEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestSessionRegisteredEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestSessionRegisteredEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IGuestSessionEvent properties
    STDMETHOD(COMGETTER(Session))(IGuestSession **aSession);

    // public IGuestSessionRegisteredEvent properties
    STDMETHOD(COMGETTER(Registered))(BOOL *aRegistered);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IGuestSessionEvent methods

    // public IGuestSessionRegisteredEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IGuestSessionEvent properties
    virtual HRESULT getSession(ComPtr<IGuestSession> &aSession) = 0;

    // wrapped IGuestSessionRegisteredEvent properties
    virtual HRESULT getRegistered(BOOL *aRegistered) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IGuestSessionEvent methods

    // wrapped IGuestSessionRegisteredEvent methods
};

#endif // !GuestSessionRegisteredEventWrap_H_

// ##### ENDFILE "GuestSessionRegisteredEventWrap.h"

// ##### BEGINFILE "GuestSessionRegisteredEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestSessionRegisteredEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTSESSIONREGISTEREDEVENT

#include "GuestSessionRegisteredEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestSessionRegisteredEventWrap)

//
// IEvent properties
//

STDMETHODIMP GuestSessionRegisteredEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestSessionRegisteredEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestSessionRegisteredEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionRegisteredEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "GuestSessionRegisteredEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "GuestSessionRegisteredEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP GuestSessionRegisteredEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "GuestSessionRegisteredEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "GuestSessionRegisteredEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IGuestSessionEvent properties
//

STDMETHODIMP GuestSessionRegisteredEventWrap::COMGETTER(Session)(IGuestSession **aSession)
{
    LogRelFlow(("{%p} %s: enter aSession=%p\n", this, "GuestSessionRegisteredEvent::getSession", aSession));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSession);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSession(ComTypeOutConverter<IGuestSession>(aSession).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSession=%p hrc=%Rhrc\n", this, "GuestSessionRegisteredEvent::getSession", *aSession, hrc));
    return hrc;
}

//
// IGuestSessionRegisteredEvent properties
//

STDMETHODIMP GuestSessionRegisteredEventWrap::COMGETTER(Registered)(BOOL *aRegistered)
{
    LogRelFlow(("{%p} %s: enter aRegistered=%p\n", this, "GuestSessionRegisteredEvent::getRegistered", aRegistered));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRegistered);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRegistered(aRegistered);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRegistered=%RTbool hrc=%Rhrc\n", this, "GuestSessionRegisteredEvent::getRegistered", *aRegistered, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP GuestSessionRegisteredEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestSessionRegisteredEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestSessionRegisteredEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP GuestSessionRegisteredEventWrap::WaitProcessed(LONG aTimeout,
                                                            BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "GuestSessionRegisteredEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "GuestSessionRegisteredEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IGuestSessionEvent methods
//

//
// IGuestSessionRegisteredEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestSessionRegisteredEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS3_CI(GuestSessionRegisteredEventWrap, IGuestSessionRegisteredEvent, IGuestSessionEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestSessionRegisteredEventWrap.cpp"

// ##### BEGINFILE "GuestProcessEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestProcessEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestProcessEventWrap_H_
#define GuestProcessEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestProcessEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestProcessEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestProcessEventWrap, IGuestProcessEvent)
    DECLARE_NOT_AGGREGATABLE(GuestProcessEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestProcessEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestProcessEvent)
        COM_INTERFACE_ENTRY(IGuestSessionEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestProcessEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestProcessEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IGuestSessionEvent properties
    STDMETHOD(COMGETTER(Session))(IGuestSession **aSession);

    // public IGuestProcessEvent properties
    STDMETHOD(COMGETTER(Process))(IGuestProcess **aProcess);
    STDMETHOD(COMGETTER(Pid))(ULONG *aPid);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IGuestSessionEvent methods

    // public IGuestProcessEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IGuestSessionEvent properties
    virtual HRESULT getSession(ComPtr<IGuestSession> &aSession) = 0;

    // wrapped IGuestProcessEvent properties
    virtual HRESULT getProcess(ComPtr<IGuestProcess> &aProcess) = 0;
    virtual HRESULT getPid(ULONG *aPid) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IGuestSessionEvent methods

    // wrapped IGuestProcessEvent methods
};

#endif // !GuestProcessEventWrap_H_

// ##### ENDFILE "GuestProcessEventWrap.h"

// ##### BEGINFILE "GuestProcessEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestProcessEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTPROCESSEVENT

#include "GuestProcessEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestProcessEventWrap)

//
// IEvent properties
//

STDMETHODIMP GuestProcessEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestProcessEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestProcessEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "GuestProcessEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "GuestProcessEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "GuestProcessEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "GuestProcessEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IGuestSessionEvent properties
//

STDMETHODIMP GuestProcessEventWrap::COMGETTER(Session)(IGuestSession **aSession)
{
    LogRelFlow(("{%p} %s: enter aSession=%p\n", this, "GuestProcessEvent::getSession", aSession));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSession);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSession(ComTypeOutConverter<IGuestSession>(aSession).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSession=%p hrc=%Rhrc\n", this, "GuestProcessEvent::getSession", *aSession, hrc));
    return hrc;
}

//
// IGuestProcessEvent properties
//

STDMETHODIMP GuestProcessEventWrap::COMGETTER(Process)(IGuestProcess **aProcess)
{
    LogRelFlow(("{%p} %s: enter aProcess=%p\n", this, "GuestProcessEvent::getProcess", aProcess));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProcess);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProcess(ComTypeOutConverter<IGuestProcess>(aProcess).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProcess=%p hrc=%Rhrc\n", this, "GuestProcessEvent::getProcess", *aProcess, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessEventWrap::COMGETTER(Pid)(ULONG *aPid)
{
    LogRelFlow(("{%p} %s: enter aPid=%p\n", this, "GuestProcessEvent::getPid", aPid));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPid);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPid(aPid);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPid=%RU32 hrc=%Rhrc\n", this, "GuestProcessEvent::getPid", *aPid, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP GuestProcessEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestProcessEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestProcessEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP GuestProcessEventWrap::WaitProcessed(LONG aTimeout,
                                                  BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "GuestProcessEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "GuestProcessEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IGuestSessionEvent methods
//

//
// IGuestProcessEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestProcessEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS3_CI(GuestProcessEventWrap, IGuestProcessEvent, IGuestSessionEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestProcessEventWrap.cpp"

// ##### BEGINFILE "GuestProcessRegisteredEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestProcessRegisteredEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestProcessRegisteredEventWrap_H_
#define GuestProcessRegisteredEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestProcessRegisteredEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestProcessRegisteredEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestProcessRegisteredEventWrap, IGuestProcessRegisteredEvent)
    DECLARE_NOT_AGGREGATABLE(GuestProcessRegisteredEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestProcessRegisteredEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestProcessRegisteredEvent)
        COM_INTERFACE_ENTRY(IGuestProcessEvent)
        COM_INTERFACE_ENTRY(IGuestSessionEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestProcessRegisteredEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestProcessRegisteredEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IGuestSessionEvent properties
    STDMETHOD(COMGETTER(Session))(IGuestSession **aSession);

    // public IGuestProcessEvent properties
    STDMETHOD(COMGETTER(Process))(IGuestProcess **aProcess);
    STDMETHOD(COMGETTER(Pid))(ULONG *aPid);

    // public IGuestProcessRegisteredEvent properties
    STDMETHOD(COMGETTER(Registered))(BOOL *aRegistered);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IGuestSessionEvent methods

    // public IGuestProcessEvent methods

    // public IGuestProcessRegisteredEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IGuestSessionEvent properties
    virtual HRESULT getSession(ComPtr<IGuestSession> &aSession) = 0;

    // wrapped IGuestProcessEvent properties
    virtual HRESULT getProcess(ComPtr<IGuestProcess> &aProcess) = 0;
    virtual HRESULT getPid(ULONG *aPid) = 0;

    // wrapped IGuestProcessRegisteredEvent properties
    virtual HRESULT getRegistered(BOOL *aRegistered) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IGuestSessionEvent methods

    // wrapped IGuestProcessEvent methods

    // wrapped IGuestProcessRegisteredEvent methods
};

#endif // !GuestProcessRegisteredEventWrap_H_

// ##### ENDFILE "GuestProcessRegisteredEventWrap.h"

// ##### BEGINFILE "GuestProcessRegisteredEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestProcessRegisteredEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTPROCESSREGISTEREDEVENT

#include "GuestProcessRegisteredEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestProcessRegisteredEventWrap)

//
// IEvent properties
//

STDMETHODIMP GuestProcessRegisteredEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestProcessRegisteredEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestProcessRegisteredEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessRegisteredEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "GuestProcessRegisteredEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "GuestProcessRegisteredEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessRegisteredEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "GuestProcessRegisteredEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "GuestProcessRegisteredEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IGuestSessionEvent properties
//

STDMETHODIMP GuestProcessRegisteredEventWrap::COMGETTER(Session)(IGuestSession **aSession)
{
    LogRelFlow(("{%p} %s: enter aSession=%p\n", this, "GuestProcessRegisteredEvent::getSession", aSession));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSession);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSession(ComTypeOutConverter<IGuestSession>(aSession).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSession=%p hrc=%Rhrc\n", this, "GuestProcessRegisteredEvent::getSession", *aSession, hrc));
    return hrc;
}

//
// IGuestProcessEvent properties
//

STDMETHODIMP GuestProcessRegisteredEventWrap::COMGETTER(Process)(IGuestProcess **aProcess)
{
    LogRelFlow(("{%p} %s: enter aProcess=%p\n", this, "GuestProcessRegisteredEvent::getProcess", aProcess));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProcess);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProcess(ComTypeOutConverter<IGuestProcess>(aProcess).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProcess=%p hrc=%Rhrc\n", this, "GuestProcessRegisteredEvent::getProcess", *aProcess, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessRegisteredEventWrap::COMGETTER(Pid)(ULONG *aPid)
{
    LogRelFlow(("{%p} %s: enter aPid=%p\n", this, "GuestProcessRegisteredEvent::getPid", aPid));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPid);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPid(aPid);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPid=%RU32 hrc=%Rhrc\n", this, "GuestProcessRegisteredEvent::getPid", *aPid, hrc));
    return hrc;
}

//
// IGuestProcessRegisteredEvent properties
//

STDMETHODIMP GuestProcessRegisteredEventWrap::COMGETTER(Registered)(BOOL *aRegistered)
{
    LogRelFlow(("{%p} %s: enter aRegistered=%p\n", this, "GuestProcessRegisteredEvent::getRegistered", aRegistered));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRegistered);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRegistered(aRegistered);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRegistered=%RTbool hrc=%Rhrc\n", this, "GuestProcessRegisteredEvent::getRegistered", *aRegistered, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP GuestProcessRegisteredEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestProcessRegisteredEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestProcessRegisteredEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP GuestProcessRegisteredEventWrap::WaitProcessed(LONG aTimeout,
                                                            BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "GuestProcessRegisteredEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "GuestProcessRegisteredEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IGuestSessionEvent methods
//

//
// IGuestProcessEvent methods
//

//
// IGuestProcessRegisteredEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestProcessRegisteredEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS4_CI(GuestProcessRegisteredEventWrap, IGuestProcessRegisteredEvent, IGuestProcessEvent, IGuestSessionEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestProcessRegisteredEventWrap.cpp"

// ##### BEGINFILE "GuestProcessStateChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestProcessStateChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestProcessStateChangedEventWrap_H_
#define GuestProcessStateChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestProcessStateChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestProcessStateChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestProcessStateChangedEventWrap, IGuestProcessStateChangedEvent)
    DECLARE_NOT_AGGREGATABLE(GuestProcessStateChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestProcessStateChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestProcessStateChangedEvent)
        COM_INTERFACE_ENTRY(IGuestProcessEvent)
        COM_INTERFACE_ENTRY(IGuestSessionEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestProcessStateChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestProcessStateChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IGuestSessionEvent properties
    STDMETHOD(COMGETTER(Session))(IGuestSession **aSession);

    // public IGuestProcessEvent properties
    STDMETHOD(COMGETTER(Process))(IGuestProcess **aProcess);
    STDMETHOD(COMGETTER(Pid))(ULONG *aPid);

    // public IGuestProcessStateChangedEvent properties
    STDMETHOD(COMGETTER(Status))(ProcessStatus_T *aStatus);
    STDMETHOD(COMGETTER(Error))(IVirtualBoxErrorInfo **aError);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IGuestSessionEvent methods

    // public IGuestProcessEvent methods

    // public IGuestProcessStateChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IGuestSessionEvent properties
    virtual HRESULT getSession(ComPtr<IGuestSession> &aSession) = 0;

    // wrapped IGuestProcessEvent properties
    virtual HRESULT getProcess(ComPtr<IGuestProcess> &aProcess) = 0;
    virtual HRESULT getPid(ULONG *aPid) = 0;

    // wrapped IGuestProcessStateChangedEvent properties
    virtual HRESULT getStatus(ProcessStatus_T *aStatus) = 0;
    virtual HRESULT getError(ComPtr<IVirtualBoxErrorInfo> &aError) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IGuestSessionEvent methods

    // wrapped IGuestProcessEvent methods

    // wrapped IGuestProcessStateChangedEvent methods
};

#endif // !GuestProcessStateChangedEventWrap_H_

// ##### ENDFILE "GuestProcessStateChangedEventWrap.h"

// ##### BEGINFILE "GuestProcessStateChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestProcessStateChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTPROCESSSTATECHANGEDEVENT

#include "GuestProcessStateChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestProcessStateChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP GuestProcessStateChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestProcessStateChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestProcessStateChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessStateChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "GuestProcessStateChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "GuestProcessStateChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessStateChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "GuestProcessStateChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "GuestProcessStateChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IGuestSessionEvent properties
//

STDMETHODIMP GuestProcessStateChangedEventWrap::COMGETTER(Session)(IGuestSession **aSession)
{
    LogRelFlow(("{%p} %s: enter aSession=%p\n", this, "GuestProcessStateChangedEvent::getSession", aSession));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSession);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSession(ComTypeOutConverter<IGuestSession>(aSession).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSession=%p hrc=%Rhrc\n", this, "GuestProcessStateChangedEvent::getSession", *aSession, hrc));
    return hrc;
}

//
// IGuestProcessEvent properties
//

STDMETHODIMP GuestProcessStateChangedEventWrap::COMGETTER(Process)(IGuestProcess **aProcess)
{
    LogRelFlow(("{%p} %s: enter aProcess=%p\n", this, "GuestProcessStateChangedEvent::getProcess", aProcess));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProcess);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProcess(ComTypeOutConverter<IGuestProcess>(aProcess).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProcess=%p hrc=%Rhrc\n", this, "GuestProcessStateChangedEvent::getProcess", *aProcess, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessStateChangedEventWrap::COMGETTER(Pid)(ULONG *aPid)
{
    LogRelFlow(("{%p} %s: enter aPid=%p\n", this, "GuestProcessStateChangedEvent::getPid", aPid));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPid);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPid(aPid);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPid=%RU32 hrc=%Rhrc\n", this, "GuestProcessStateChangedEvent::getPid", *aPid, hrc));
    return hrc;
}

//
// IGuestProcessStateChangedEvent properties
//

STDMETHODIMP GuestProcessStateChangedEventWrap::COMGETTER(Status)(ProcessStatus_T *aStatus)
{
    LogRelFlow(("{%p} %s: enter aStatus=%p\n", this, "GuestProcessStateChangedEvent::getStatus", aStatus));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStatus);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getStatus(aStatus);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aStatus=%RU32 hrc=%Rhrc\n", this, "GuestProcessStateChangedEvent::getStatus", *aStatus, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessStateChangedEventWrap::COMGETTER(Error)(IVirtualBoxErrorInfo **aError)
{
    LogRelFlow(("{%p} %s: enter aError=%p\n", this, "GuestProcessStateChangedEvent::getError", aError));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aError);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getError(ComTypeOutConverter<IVirtualBoxErrorInfo>(aError).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aError=%p hrc=%Rhrc\n", this, "GuestProcessStateChangedEvent::getError", *aError, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP GuestProcessStateChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestProcessStateChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestProcessStateChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP GuestProcessStateChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                              BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "GuestProcessStateChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "GuestProcessStateChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IGuestSessionEvent methods
//

//
// IGuestProcessEvent methods
//

//
// IGuestProcessStateChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestProcessStateChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS4_CI(GuestProcessStateChangedEventWrap, IGuestProcessStateChangedEvent, IGuestProcessEvent, IGuestSessionEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestProcessStateChangedEventWrap.cpp"

// ##### BEGINFILE "GuestProcessIOEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestProcessIOEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestProcessIOEventWrap_H_
#define GuestProcessIOEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestProcessIOEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestProcessIOEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestProcessIOEventWrap, IGuestProcessIOEvent)
    DECLARE_NOT_AGGREGATABLE(GuestProcessIOEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestProcessIOEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestProcessIOEvent)
        COM_INTERFACE_ENTRY(IGuestProcessEvent)
        COM_INTERFACE_ENTRY(IGuestSessionEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestProcessIOEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestProcessIOEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IGuestSessionEvent properties
    STDMETHOD(COMGETTER(Session))(IGuestSession **aSession);

    // public IGuestProcessEvent properties
    STDMETHOD(COMGETTER(Process))(IGuestProcess **aProcess);
    STDMETHOD(COMGETTER(Pid))(ULONG *aPid);

    // public IGuestProcessIOEvent properties
    STDMETHOD(COMGETTER(Handle))(ULONG *aHandle);
    STDMETHOD(COMGETTER(Processed))(ULONG *aProcessed);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IGuestSessionEvent methods

    // public IGuestProcessEvent methods

    // public IGuestProcessIOEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IGuestSessionEvent properties
    virtual HRESULT getSession(ComPtr<IGuestSession> &aSession) = 0;

    // wrapped IGuestProcessEvent properties
    virtual HRESULT getProcess(ComPtr<IGuestProcess> &aProcess) = 0;
    virtual HRESULT getPid(ULONG *aPid) = 0;

    // wrapped IGuestProcessIOEvent properties
    virtual HRESULT getHandle(ULONG *aHandle) = 0;
    virtual HRESULT getProcessed(ULONG *aProcessed) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IGuestSessionEvent methods

    // wrapped IGuestProcessEvent methods

    // wrapped IGuestProcessIOEvent methods
};

#endif // !GuestProcessIOEventWrap_H_

// ##### ENDFILE "GuestProcessIOEventWrap.h"

// ##### BEGINFILE "GuestProcessIOEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestProcessIOEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTPROCESSIOEVENT

#include "GuestProcessIOEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestProcessIOEventWrap)

//
// IEvent properties
//

STDMETHODIMP GuestProcessIOEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestProcessIOEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestProcessIOEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessIOEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "GuestProcessIOEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "GuestProcessIOEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessIOEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "GuestProcessIOEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "GuestProcessIOEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IGuestSessionEvent properties
//

STDMETHODIMP GuestProcessIOEventWrap::COMGETTER(Session)(IGuestSession **aSession)
{
    LogRelFlow(("{%p} %s: enter aSession=%p\n", this, "GuestProcessIOEvent::getSession", aSession));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSession);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSession(ComTypeOutConverter<IGuestSession>(aSession).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSession=%p hrc=%Rhrc\n", this, "GuestProcessIOEvent::getSession", *aSession, hrc));
    return hrc;
}

//
// IGuestProcessEvent properties
//

STDMETHODIMP GuestProcessIOEventWrap::COMGETTER(Process)(IGuestProcess **aProcess)
{
    LogRelFlow(("{%p} %s: enter aProcess=%p\n", this, "GuestProcessIOEvent::getProcess", aProcess));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProcess);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProcess(ComTypeOutConverter<IGuestProcess>(aProcess).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProcess=%p hrc=%Rhrc\n", this, "GuestProcessIOEvent::getProcess", *aProcess, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessIOEventWrap::COMGETTER(Pid)(ULONG *aPid)
{
    LogRelFlow(("{%p} %s: enter aPid=%p\n", this, "GuestProcessIOEvent::getPid", aPid));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPid);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPid(aPid);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPid=%RU32 hrc=%Rhrc\n", this, "GuestProcessIOEvent::getPid", *aPid, hrc));
    return hrc;
}

//
// IGuestProcessIOEvent properties
//

STDMETHODIMP GuestProcessIOEventWrap::COMGETTER(Handle)(ULONG *aHandle)
{
    LogRelFlow(("{%p} %s: enter aHandle=%p\n", this, "GuestProcessIOEvent::getHandle", aHandle));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHandle);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHandle(aHandle);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHandle=%RU32 hrc=%Rhrc\n", this, "GuestProcessIOEvent::getHandle", *aHandle, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessIOEventWrap::COMGETTER(Processed)(ULONG *aProcessed)
{
    LogRelFlow(("{%p} %s: enter aProcessed=%p\n", this, "GuestProcessIOEvent::getProcessed", aProcessed));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProcessed);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProcessed(aProcessed);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProcessed=%RU32 hrc=%Rhrc\n", this, "GuestProcessIOEvent::getProcessed", *aProcessed, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP GuestProcessIOEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestProcessIOEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestProcessIOEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP GuestProcessIOEventWrap::WaitProcessed(LONG aTimeout,
                                                    BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "GuestProcessIOEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "GuestProcessIOEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IGuestSessionEvent methods
//

//
// IGuestProcessEvent methods
//

//
// IGuestProcessIOEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestProcessIOEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS4_CI(GuestProcessIOEventWrap, IGuestProcessIOEvent, IGuestProcessEvent, IGuestSessionEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestProcessIOEventWrap.cpp"

// ##### BEGINFILE "GuestProcessInputNotifyEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestProcessInputNotifyEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestProcessInputNotifyEventWrap_H_
#define GuestProcessInputNotifyEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestProcessInputNotifyEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestProcessInputNotifyEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestProcessInputNotifyEventWrap, IGuestProcessInputNotifyEvent)
    DECLARE_NOT_AGGREGATABLE(GuestProcessInputNotifyEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestProcessInputNotifyEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestProcessInputNotifyEvent)
        COM_INTERFACE_ENTRY(IGuestProcessIOEvent)
        COM_INTERFACE_ENTRY(IGuestProcessEvent)
        COM_INTERFACE_ENTRY(IGuestSessionEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestProcessInputNotifyEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestProcessInputNotifyEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IGuestSessionEvent properties
    STDMETHOD(COMGETTER(Session))(IGuestSession **aSession);

    // public IGuestProcessEvent properties
    STDMETHOD(COMGETTER(Process))(IGuestProcess **aProcess);
    STDMETHOD(COMGETTER(Pid))(ULONG *aPid);

    // public IGuestProcessIOEvent properties
    STDMETHOD(COMGETTER(Handle))(ULONG *aHandle);
    STDMETHOD(COMGETTER(Processed))(ULONG *aProcessed);

    // public IGuestProcessInputNotifyEvent properties
    STDMETHOD(COMGETTER(Status))(ProcessInputStatus_T *aStatus);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IGuestSessionEvent methods

    // public IGuestProcessEvent methods

    // public IGuestProcessIOEvent methods

    // public IGuestProcessInputNotifyEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IGuestSessionEvent properties
    virtual HRESULT getSession(ComPtr<IGuestSession> &aSession) = 0;

    // wrapped IGuestProcessEvent properties
    virtual HRESULT getProcess(ComPtr<IGuestProcess> &aProcess) = 0;
    virtual HRESULT getPid(ULONG *aPid) = 0;

    // wrapped IGuestProcessIOEvent properties
    virtual HRESULT getHandle(ULONG *aHandle) = 0;
    virtual HRESULT getProcessed(ULONG *aProcessed) = 0;

    // wrapped IGuestProcessInputNotifyEvent properties
    virtual HRESULT getStatus(ProcessInputStatus_T *aStatus) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IGuestSessionEvent methods

    // wrapped IGuestProcessEvent methods

    // wrapped IGuestProcessIOEvent methods

    // wrapped IGuestProcessInputNotifyEvent methods
};

#endif // !GuestProcessInputNotifyEventWrap_H_

// ##### ENDFILE "GuestProcessInputNotifyEventWrap.h"

// ##### BEGINFILE "GuestProcessInputNotifyEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestProcessInputNotifyEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTPROCESSINPUTNOTIFYEVENT

#include "GuestProcessInputNotifyEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestProcessInputNotifyEventWrap)

//
// IEvent properties
//

STDMETHODIMP GuestProcessInputNotifyEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestProcessInputNotifyEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestProcessInputNotifyEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessInputNotifyEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "GuestProcessInputNotifyEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "GuestProcessInputNotifyEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessInputNotifyEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "GuestProcessInputNotifyEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "GuestProcessInputNotifyEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IGuestSessionEvent properties
//

STDMETHODIMP GuestProcessInputNotifyEventWrap::COMGETTER(Session)(IGuestSession **aSession)
{
    LogRelFlow(("{%p} %s: enter aSession=%p\n", this, "GuestProcessInputNotifyEvent::getSession", aSession));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSession);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSession(ComTypeOutConverter<IGuestSession>(aSession).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSession=%p hrc=%Rhrc\n", this, "GuestProcessInputNotifyEvent::getSession", *aSession, hrc));
    return hrc;
}

//
// IGuestProcessEvent properties
//

STDMETHODIMP GuestProcessInputNotifyEventWrap::COMGETTER(Process)(IGuestProcess **aProcess)
{
    LogRelFlow(("{%p} %s: enter aProcess=%p\n", this, "GuestProcessInputNotifyEvent::getProcess", aProcess));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProcess);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProcess(ComTypeOutConverter<IGuestProcess>(aProcess).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProcess=%p hrc=%Rhrc\n", this, "GuestProcessInputNotifyEvent::getProcess", *aProcess, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessInputNotifyEventWrap::COMGETTER(Pid)(ULONG *aPid)
{
    LogRelFlow(("{%p} %s: enter aPid=%p\n", this, "GuestProcessInputNotifyEvent::getPid", aPid));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPid);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPid(aPid);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPid=%RU32 hrc=%Rhrc\n", this, "GuestProcessInputNotifyEvent::getPid", *aPid, hrc));
    return hrc;
}

//
// IGuestProcessIOEvent properties
//

STDMETHODIMP GuestProcessInputNotifyEventWrap::COMGETTER(Handle)(ULONG *aHandle)
{
    LogRelFlow(("{%p} %s: enter aHandle=%p\n", this, "GuestProcessInputNotifyEvent::getHandle", aHandle));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHandle);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHandle(aHandle);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHandle=%RU32 hrc=%Rhrc\n", this, "GuestProcessInputNotifyEvent::getHandle", *aHandle, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessInputNotifyEventWrap::COMGETTER(Processed)(ULONG *aProcessed)
{
    LogRelFlow(("{%p} %s: enter aProcessed=%p\n", this, "GuestProcessInputNotifyEvent::getProcessed", aProcessed));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProcessed);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProcessed(aProcessed);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProcessed=%RU32 hrc=%Rhrc\n", this, "GuestProcessInputNotifyEvent::getProcessed", *aProcessed, hrc));
    return hrc;
}

//
// IGuestProcessInputNotifyEvent properties
//

STDMETHODIMP GuestProcessInputNotifyEventWrap::COMGETTER(Status)(ProcessInputStatus_T *aStatus)
{
    LogRelFlow(("{%p} %s: enter aStatus=%p\n", this, "GuestProcessInputNotifyEvent::getStatus", aStatus));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStatus);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getStatus(aStatus);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aStatus=%RU32 hrc=%Rhrc\n", this, "GuestProcessInputNotifyEvent::getStatus", *aStatus, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP GuestProcessInputNotifyEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestProcessInputNotifyEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestProcessInputNotifyEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP GuestProcessInputNotifyEventWrap::WaitProcessed(LONG aTimeout,
                                                             BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "GuestProcessInputNotifyEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "GuestProcessInputNotifyEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IGuestSessionEvent methods
//

//
// IGuestProcessEvent methods
//

//
// IGuestProcessIOEvent methods
//

//
// IGuestProcessInputNotifyEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestProcessInputNotifyEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS5_CI(GuestProcessInputNotifyEventWrap, IGuestProcessInputNotifyEvent, IGuestProcessIOEvent, IGuestProcessEvent, IGuestSessionEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestProcessInputNotifyEventWrap.cpp"

// ##### BEGINFILE "GuestProcessOutputEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestProcessOutputEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestProcessOutputEventWrap_H_
#define GuestProcessOutputEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestProcessOutputEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestProcessOutputEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestProcessOutputEventWrap, IGuestProcessOutputEvent)
    DECLARE_NOT_AGGREGATABLE(GuestProcessOutputEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestProcessOutputEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestProcessOutputEvent)
        COM_INTERFACE_ENTRY(IGuestProcessIOEvent)
        COM_INTERFACE_ENTRY(IGuestProcessEvent)
        COM_INTERFACE_ENTRY(IGuestSessionEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestProcessOutputEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestProcessOutputEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IGuestSessionEvent properties
    STDMETHOD(COMGETTER(Session))(IGuestSession **aSession);

    // public IGuestProcessEvent properties
    STDMETHOD(COMGETTER(Process))(IGuestProcess **aProcess);
    STDMETHOD(COMGETTER(Pid))(ULONG *aPid);

    // public IGuestProcessIOEvent properties
    STDMETHOD(COMGETTER(Handle))(ULONG *aHandle);
    STDMETHOD(COMGETTER(Processed))(ULONG *aProcessed);

    // public IGuestProcessOutputEvent properties
    STDMETHOD(COMGETTER(Data))(ComSafeArrayOut(BYTE, aData));

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IGuestSessionEvent methods

    // public IGuestProcessEvent methods

    // public IGuestProcessIOEvent methods

    // public IGuestProcessOutputEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IGuestSessionEvent properties
    virtual HRESULT getSession(ComPtr<IGuestSession> &aSession) = 0;

    // wrapped IGuestProcessEvent properties
    virtual HRESULT getProcess(ComPtr<IGuestProcess> &aProcess) = 0;
    virtual HRESULT getPid(ULONG *aPid) = 0;

    // wrapped IGuestProcessIOEvent properties
    virtual HRESULT getHandle(ULONG *aHandle) = 0;
    virtual HRESULT getProcessed(ULONG *aProcessed) = 0;

    // wrapped IGuestProcessOutputEvent properties
    virtual HRESULT getData(std::vector<BYTE> &aData) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IGuestSessionEvent methods

    // wrapped IGuestProcessEvent methods

    // wrapped IGuestProcessIOEvent methods

    // wrapped IGuestProcessOutputEvent methods
};

#endif // !GuestProcessOutputEventWrap_H_

// ##### ENDFILE "GuestProcessOutputEventWrap.h"

// ##### BEGINFILE "GuestProcessOutputEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestProcessOutputEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTPROCESSOUTPUTEVENT

#include "GuestProcessOutputEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestProcessOutputEventWrap)

//
// IEvent properties
//

STDMETHODIMP GuestProcessOutputEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestProcessOutputEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestProcessOutputEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessOutputEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "GuestProcessOutputEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "GuestProcessOutputEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessOutputEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "GuestProcessOutputEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "GuestProcessOutputEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IGuestSessionEvent properties
//

STDMETHODIMP GuestProcessOutputEventWrap::COMGETTER(Session)(IGuestSession **aSession)
{
    LogRelFlow(("{%p} %s: enter aSession=%p\n", this, "GuestProcessOutputEvent::getSession", aSession));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSession);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSession(ComTypeOutConverter<IGuestSession>(aSession).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSession=%p hrc=%Rhrc\n", this, "GuestProcessOutputEvent::getSession", *aSession, hrc));
    return hrc;
}

//
// IGuestProcessEvent properties
//

STDMETHODIMP GuestProcessOutputEventWrap::COMGETTER(Process)(IGuestProcess **aProcess)
{
    LogRelFlow(("{%p} %s: enter aProcess=%p\n", this, "GuestProcessOutputEvent::getProcess", aProcess));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProcess);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProcess(ComTypeOutConverter<IGuestProcess>(aProcess).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProcess=%p hrc=%Rhrc\n", this, "GuestProcessOutputEvent::getProcess", *aProcess, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessOutputEventWrap::COMGETTER(Pid)(ULONG *aPid)
{
    LogRelFlow(("{%p} %s: enter aPid=%p\n", this, "GuestProcessOutputEvent::getPid", aPid));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPid);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPid(aPid);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPid=%RU32 hrc=%Rhrc\n", this, "GuestProcessOutputEvent::getPid", *aPid, hrc));
    return hrc;
}

//
// IGuestProcessIOEvent properties
//

STDMETHODIMP GuestProcessOutputEventWrap::COMGETTER(Handle)(ULONG *aHandle)
{
    LogRelFlow(("{%p} %s: enter aHandle=%p\n", this, "GuestProcessOutputEvent::getHandle", aHandle));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHandle);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHandle(aHandle);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHandle=%RU32 hrc=%Rhrc\n", this, "GuestProcessOutputEvent::getHandle", *aHandle, hrc));
    return hrc;
}

STDMETHODIMP GuestProcessOutputEventWrap::COMGETTER(Processed)(ULONG *aProcessed)
{
    LogRelFlow(("{%p} %s: enter aProcessed=%p\n", this, "GuestProcessOutputEvent::getProcessed", aProcessed));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProcessed);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProcessed(aProcessed);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProcessed=%RU32 hrc=%Rhrc\n", this, "GuestProcessOutputEvent::getProcessed", *aProcessed, hrc));
    return hrc;
}

//
// IGuestProcessOutputEvent properties
//

STDMETHODIMP GuestProcessOutputEventWrap::COMGETTER(Data)(ComSafeArrayOut(BYTE, aData))
{
    LogRelFlow(("{%p} %s: enter aData=%p\n", this, "GuestProcessOutputEvent::getData", aData));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aData);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getData(ArrayOutConverter<BYTE>(ComSafeArrayOutArg(aData)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aData=%zu hrc=%Rhrc\n", this, "GuestProcessOutputEvent::getData", ComSafeArraySize(*aData), hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP GuestProcessOutputEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestProcessOutputEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestProcessOutputEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP GuestProcessOutputEventWrap::WaitProcessed(LONG aTimeout,
                                                        BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "GuestProcessOutputEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "GuestProcessOutputEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IGuestSessionEvent methods
//

//
// IGuestProcessEvent methods
//

//
// IGuestProcessIOEvent methods
//

//
// IGuestProcessOutputEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestProcessOutputEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS5_CI(GuestProcessOutputEventWrap, IGuestProcessOutputEvent, IGuestProcessIOEvent, IGuestProcessEvent, IGuestSessionEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestProcessOutputEventWrap.cpp"

// ##### BEGINFILE "GuestFileEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestFileEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestFileEventWrap_H_
#define GuestFileEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestFileEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestFileEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestFileEventWrap, IGuestFileEvent)
    DECLARE_NOT_AGGREGATABLE(GuestFileEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestFileEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestFileEvent)
        COM_INTERFACE_ENTRY(IGuestSessionEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestFileEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestFileEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IGuestSessionEvent properties
    STDMETHOD(COMGETTER(Session))(IGuestSession **aSession);

    // public IGuestFileEvent properties
    STDMETHOD(COMGETTER(File))(IGuestFile **aFile);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IGuestSessionEvent methods

    // public IGuestFileEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IGuestSessionEvent properties
    virtual HRESULT getSession(ComPtr<IGuestSession> &aSession) = 0;

    // wrapped IGuestFileEvent properties
    virtual HRESULT getFile(ComPtr<IGuestFile> &aFile) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IGuestSessionEvent methods

    // wrapped IGuestFileEvent methods
};

#endif // !GuestFileEventWrap_H_

// ##### ENDFILE "GuestFileEventWrap.h"

// ##### BEGINFILE "GuestFileEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestFileEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTFILEEVENT

#include "GuestFileEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestFileEventWrap)

//
// IEvent properties
//

STDMETHODIMP GuestFileEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestFileEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestFileEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestFileEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "GuestFileEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "GuestFileEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP GuestFileEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "GuestFileEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "GuestFileEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IGuestSessionEvent properties
//

STDMETHODIMP GuestFileEventWrap::COMGETTER(Session)(IGuestSession **aSession)
{
    LogRelFlow(("{%p} %s: enter aSession=%p\n", this, "GuestFileEvent::getSession", aSession));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSession);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSession(ComTypeOutConverter<IGuestSession>(aSession).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSession=%p hrc=%Rhrc\n", this, "GuestFileEvent::getSession", *aSession, hrc));
    return hrc;
}

//
// IGuestFileEvent properties
//

STDMETHODIMP GuestFileEventWrap::COMGETTER(File)(IGuestFile **aFile)
{
    LogRelFlow(("{%p} %s: enter aFile=%p\n", this, "GuestFileEvent::getFile", aFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFile);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFile(ComTypeOutConverter<IGuestFile>(aFile).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFile=%p hrc=%Rhrc\n", this, "GuestFileEvent::getFile", *aFile, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP GuestFileEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestFileEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestFileEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP GuestFileEventWrap::WaitProcessed(LONG aTimeout,
                                               BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "GuestFileEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "GuestFileEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IGuestSessionEvent methods
//

//
// IGuestFileEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestFileEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS3_CI(GuestFileEventWrap, IGuestFileEvent, IGuestSessionEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestFileEventWrap.cpp"

// ##### BEGINFILE "GuestFileRegisteredEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestFileRegisteredEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestFileRegisteredEventWrap_H_
#define GuestFileRegisteredEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestFileRegisteredEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestFileRegisteredEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestFileRegisteredEventWrap, IGuestFileRegisteredEvent)
    DECLARE_NOT_AGGREGATABLE(GuestFileRegisteredEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestFileRegisteredEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestFileRegisteredEvent)
        COM_INTERFACE_ENTRY(IGuestFileEvent)
        COM_INTERFACE_ENTRY(IGuestSessionEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestFileRegisteredEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestFileRegisteredEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IGuestSessionEvent properties
    STDMETHOD(COMGETTER(Session))(IGuestSession **aSession);

    // public IGuestFileEvent properties
    STDMETHOD(COMGETTER(File))(IGuestFile **aFile);

    // public IGuestFileRegisteredEvent properties
    STDMETHOD(COMGETTER(Registered))(BOOL *aRegistered);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IGuestSessionEvent methods

    // public IGuestFileEvent methods

    // public IGuestFileRegisteredEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IGuestSessionEvent properties
    virtual HRESULT getSession(ComPtr<IGuestSession> &aSession) = 0;

    // wrapped IGuestFileEvent properties
    virtual HRESULT getFile(ComPtr<IGuestFile> &aFile) = 0;

    // wrapped IGuestFileRegisteredEvent properties
    virtual HRESULT getRegistered(BOOL *aRegistered) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IGuestSessionEvent methods

    // wrapped IGuestFileEvent methods

    // wrapped IGuestFileRegisteredEvent methods
};

#endif // !GuestFileRegisteredEventWrap_H_

// ##### ENDFILE "GuestFileRegisteredEventWrap.h"

// ##### BEGINFILE "GuestFileRegisteredEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestFileRegisteredEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTFILEREGISTEREDEVENT

#include "GuestFileRegisteredEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestFileRegisteredEventWrap)

//
// IEvent properties
//

STDMETHODIMP GuestFileRegisteredEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestFileRegisteredEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestFileRegisteredEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestFileRegisteredEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "GuestFileRegisteredEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "GuestFileRegisteredEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP GuestFileRegisteredEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "GuestFileRegisteredEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "GuestFileRegisteredEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IGuestSessionEvent properties
//

STDMETHODIMP GuestFileRegisteredEventWrap::COMGETTER(Session)(IGuestSession **aSession)
{
    LogRelFlow(("{%p} %s: enter aSession=%p\n", this, "GuestFileRegisteredEvent::getSession", aSession));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSession);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSession(ComTypeOutConverter<IGuestSession>(aSession).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSession=%p hrc=%Rhrc\n", this, "GuestFileRegisteredEvent::getSession", *aSession, hrc));
    return hrc;
}

//
// IGuestFileEvent properties
//

STDMETHODIMP GuestFileRegisteredEventWrap::COMGETTER(File)(IGuestFile **aFile)
{
    LogRelFlow(("{%p} %s: enter aFile=%p\n", this, "GuestFileRegisteredEvent::getFile", aFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFile);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFile(ComTypeOutConverter<IGuestFile>(aFile).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFile=%p hrc=%Rhrc\n", this, "GuestFileRegisteredEvent::getFile", *aFile, hrc));
    return hrc;
}

//
// IGuestFileRegisteredEvent properties
//

STDMETHODIMP GuestFileRegisteredEventWrap::COMGETTER(Registered)(BOOL *aRegistered)
{
    LogRelFlow(("{%p} %s: enter aRegistered=%p\n", this, "GuestFileRegisteredEvent::getRegistered", aRegistered));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRegistered);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRegistered(aRegistered);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRegistered=%RTbool hrc=%Rhrc\n", this, "GuestFileRegisteredEvent::getRegistered", *aRegistered, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP GuestFileRegisteredEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestFileRegisteredEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestFileRegisteredEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP GuestFileRegisteredEventWrap::WaitProcessed(LONG aTimeout,
                                                         BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "GuestFileRegisteredEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "GuestFileRegisteredEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IGuestSessionEvent methods
//

//
// IGuestFileEvent methods
//

//
// IGuestFileRegisteredEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestFileRegisteredEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS4_CI(GuestFileRegisteredEventWrap, IGuestFileRegisteredEvent, IGuestFileEvent, IGuestSessionEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestFileRegisteredEventWrap.cpp"

// ##### BEGINFILE "GuestFileStateChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestFileStateChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestFileStateChangedEventWrap_H_
#define GuestFileStateChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestFileStateChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestFileStateChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestFileStateChangedEventWrap, IGuestFileStateChangedEvent)
    DECLARE_NOT_AGGREGATABLE(GuestFileStateChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestFileStateChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestFileStateChangedEvent)
        COM_INTERFACE_ENTRY(IGuestFileEvent)
        COM_INTERFACE_ENTRY(IGuestSessionEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestFileStateChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestFileStateChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IGuestSessionEvent properties
    STDMETHOD(COMGETTER(Session))(IGuestSession **aSession);

    // public IGuestFileEvent properties
    STDMETHOD(COMGETTER(File))(IGuestFile **aFile);

    // public IGuestFileStateChangedEvent properties
    STDMETHOD(COMGETTER(Status))(FileStatus_T *aStatus);
    STDMETHOD(COMGETTER(Error))(IVirtualBoxErrorInfo **aError);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IGuestSessionEvent methods

    // public IGuestFileEvent methods

    // public IGuestFileStateChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IGuestSessionEvent properties
    virtual HRESULT getSession(ComPtr<IGuestSession> &aSession) = 0;

    // wrapped IGuestFileEvent properties
    virtual HRESULT getFile(ComPtr<IGuestFile> &aFile) = 0;

    // wrapped IGuestFileStateChangedEvent properties
    virtual HRESULT getStatus(FileStatus_T *aStatus) = 0;
    virtual HRESULT getError(ComPtr<IVirtualBoxErrorInfo> &aError) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IGuestSessionEvent methods

    // wrapped IGuestFileEvent methods

    // wrapped IGuestFileStateChangedEvent methods
};

#endif // !GuestFileStateChangedEventWrap_H_

// ##### ENDFILE "GuestFileStateChangedEventWrap.h"

// ##### BEGINFILE "GuestFileStateChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestFileStateChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTFILESTATECHANGEDEVENT

#include "GuestFileStateChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestFileStateChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP GuestFileStateChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestFileStateChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestFileStateChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestFileStateChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "GuestFileStateChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "GuestFileStateChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP GuestFileStateChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "GuestFileStateChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "GuestFileStateChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IGuestSessionEvent properties
//

STDMETHODIMP GuestFileStateChangedEventWrap::COMGETTER(Session)(IGuestSession **aSession)
{
    LogRelFlow(("{%p} %s: enter aSession=%p\n", this, "GuestFileStateChangedEvent::getSession", aSession));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSession);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSession(ComTypeOutConverter<IGuestSession>(aSession).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSession=%p hrc=%Rhrc\n", this, "GuestFileStateChangedEvent::getSession", *aSession, hrc));
    return hrc;
}

//
// IGuestFileEvent properties
//

STDMETHODIMP GuestFileStateChangedEventWrap::COMGETTER(File)(IGuestFile **aFile)
{
    LogRelFlow(("{%p} %s: enter aFile=%p\n", this, "GuestFileStateChangedEvent::getFile", aFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFile);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFile(ComTypeOutConverter<IGuestFile>(aFile).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFile=%p hrc=%Rhrc\n", this, "GuestFileStateChangedEvent::getFile", *aFile, hrc));
    return hrc;
}

//
// IGuestFileStateChangedEvent properties
//

STDMETHODIMP GuestFileStateChangedEventWrap::COMGETTER(Status)(FileStatus_T *aStatus)
{
    LogRelFlow(("{%p} %s: enter aStatus=%p\n", this, "GuestFileStateChangedEvent::getStatus", aStatus));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStatus);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getStatus(aStatus);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aStatus=%RU32 hrc=%Rhrc\n", this, "GuestFileStateChangedEvent::getStatus", *aStatus, hrc));
    return hrc;
}

STDMETHODIMP GuestFileStateChangedEventWrap::COMGETTER(Error)(IVirtualBoxErrorInfo **aError)
{
    LogRelFlow(("{%p} %s: enter aError=%p\n", this, "GuestFileStateChangedEvent::getError", aError));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aError);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getError(ComTypeOutConverter<IVirtualBoxErrorInfo>(aError).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aError=%p hrc=%Rhrc\n", this, "GuestFileStateChangedEvent::getError", *aError, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP GuestFileStateChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestFileStateChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestFileStateChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP GuestFileStateChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                           BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "GuestFileStateChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "GuestFileStateChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IGuestSessionEvent methods
//

//
// IGuestFileEvent methods
//

//
// IGuestFileStateChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestFileStateChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS4_CI(GuestFileStateChangedEventWrap, IGuestFileStateChangedEvent, IGuestFileEvent, IGuestSessionEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestFileStateChangedEventWrap.cpp"

// ##### BEGINFILE "GuestFileIOEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestFileIOEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestFileIOEventWrap_H_
#define GuestFileIOEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestFileIOEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestFileIOEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestFileIOEventWrap, IGuestFileIOEvent)
    DECLARE_NOT_AGGREGATABLE(GuestFileIOEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestFileIOEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestFileIOEvent)
        COM_INTERFACE_ENTRY(IGuestFileEvent)
        COM_INTERFACE_ENTRY(IGuestSessionEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestFileIOEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestFileIOEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IGuestSessionEvent properties
    STDMETHOD(COMGETTER(Session))(IGuestSession **aSession);

    // public IGuestFileEvent properties
    STDMETHOD(COMGETTER(File))(IGuestFile **aFile);

    // public IGuestFileIOEvent properties
    STDMETHOD(COMGETTER(Offset))(LONG64 *aOffset);
    STDMETHOD(COMGETTER(Processed))(ULONG *aProcessed);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IGuestSessionEvent methods

    // public IGuestFileEvent methods

    // public IGuestFileIOEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IGuestSessionEvent properties
    virtual HRESULT getSession(ComPtr<IGuestSession> &aSession) = 0;

    // wrapped IGuestFileEvent properties
    virtual HRESULT getFile(ComPtr<IGuestFile> &aFile) = 0;

    // wrapped IGuestFileIOEvent properties
    virtual HRESULT getOffset(LONG64 *aOffset) = 0;
    virtual HRESULT getProcessed(ULONG *aProcessed) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IGuestSessionEvent methods

    // wrapped IGuestFileEvent methods

    // wrapped IGuestFileIOEvent methods
};

#endif // !GuestFileIOEventWrap_H_

// ##### ENDFILE "GuestFileIOEventWrap.h"

// ##### BEGINFILE "GuestFileIOEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestFileIOEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTFILEIOEVENT

#include "GuestFileIOEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestFileIOEventWrap)

//
// IEvent properties
//

STDMETHODIMP GuestFileIOEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestFileIOEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestFileIOEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestFileIOEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "GuestFileIOEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "GuestFileIOEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP GuestFileIOEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "GuestFileIOEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "GuestFileIOEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IGuestSessionEvent properties
//

STDMETHODIMP GuestFileIOEventWrap::COMGETTER(Session)(IGuestSession **aSession)
{
    LogRelFlow(("{%p} %s: enter aSession=%p\n", this, "GuestFileIOEvent::getSession", aSession));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSession);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSession(ComTypeOutConverter<IGuestSession>(aSession).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSession=%p hrc=%Rhrc\n", this, "GuestFileIOEvent::getSession", *aSession, hrc));
    return hrc;
}

//
// IGuestFileEvent properties
//

STDMETHODIMP GuestFileIOEventWrap::COMGETTER(File)(IGuestFile **aFile)
{
    LogRelFlow(("{%p} %s: enter aFile=%p\n", this, "GuestFileIOEvent::getFile", aFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFile);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFile(ComTypeOutConverter<IGuestFile>(aFile).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFile=%p hrc=%Rhrc\n", this, "GuestFileIOEvent::getFile", *aFile, hrc));
    return hrc;
}

//
// IGuestFileIOEvent properties
//

STDMETHODIMP GuestFileIOEventWrap::COMGETTER(Offset)(LONG64 *aOffset)
{
    LogRelFlow(("{%p} %s: enter aOffset=%p\n", this, "GuestFileIOEvent::getOffset", aOffset));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOffset);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOffset(aOffset);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOffset=%RI64 hrc=%Rhrc\n", this, "GuestFileIOEvent::getOffset", *aOffset, hrc));
    return hrc;
}

STDMETHODIMP GuestFileIOEventWrap::COMGETTER(Processed)(ULONG *aProcessed)
{
    LogRelFlow(("{%p} %s: enter aProcessed=%p\n", this, "GuestFileIOEvent::getProcessed", aProcessed));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProcessed);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProcessed(aProcessed);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProcessed=%RU32 hrc=%Rhrc\n", this, "GuestFileIOEvent::getProcessed", *aProcessed, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP GuestFileIOEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestFileIOEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestFileIOEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP GuestFileIOEventWrap::WaitProcessed(LONG aTimeout,
                                                 BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "GuestFileIOEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "GuestFileIOEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IGuestSessionEvent methods
//

//
// IGuestFileEvent methods
//

//
// IGuestFileIOEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestFileIOEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS4_CI(GuestFileIOEventWrap, IGuestFileIOEvent, IGuestFileEvent, IGuestSessionEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestFileIOEventWrap.cpp"

// ##### BEGINFILE "GuestFileOffsetChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestFileOffsetChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestFileOffsetChangedEventWrap_H_
#define GuestFileOffsetChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestFileOffsetChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestFileOffsetChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestFileOffsetChangedEventWrap, IGuestFileOffsetChangedEvent)
    DECLARE_NOT_AGGREGATABLE(GuestFileOffsetChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestFileOffsetChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestFileOffsetChangedEvent)
        COM_INTERFACE_ENTRY(IGuestFileIOEvent)
        COM_INTERFACE_ENTRY(IGuestFileEvent)
        COM_INTERFACE_ENTRY(IGuestSessionEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestFileOffsetChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestFileOffsetChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IGuestSessionEvent properties
    STDMETHOD(COMGETTER(Session))(IGuestSession **aSession);

    // public IGuestFileEvent properties
    STDMETHOD(COMGETTER(File))(IGuestFile **aFile);

    // public IGuestFileIOEvent properties
    STDMETHOD(COMGETTER(Offset))(LONG64 *aOffset);
    STDMETHOD(COMGETTER(Processed))(ULONG *aProcessed);

    // public IGuestFileOffsetChangedEvent properties

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IGuestSessionEvent methods

    // public IGuestFileEvent methods

    // public IGuestFileIOEvent methods

    // public IGuestFileOffsetChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IGuestSessionEvent properties
    virtual HRESULT getSession(ComPtr<IGuestSession> &aSession) = 0;

    // wrapped IGuestFileEvent properties
    virtual HRESULT getFile(ComPtr<IGuestFile> &aFile) = 0;

    // wrapped IGuestFileIOEvent properties
    virtual HRESULT getOffset(LONG64 *aOffset) = 0;
    virtual HRESULT getProcessed(ULONG *aProcessed) = 0;

    // wrapped IGuestFileOffsetChangedEvent properties

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IGuestSessionEvent methods

    // wrapped IGuestFileEvent methods

    // wrapped IGuestFileIOEvent methods

    // wrapped IGuestFileOffsetChangedEvent methods
};

#endif // !GuestFileOffsetChangedEventWrap_H_

// ##### ENDFILE "GuestFileOffsetChangedEventWrap.h"

// ##### BEGINFILE "GuestFileOffsetChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestFileOffsetChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTFILEOFFSETCHANGEDEVENT

#include "GuestFileOffsetChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestFileOffsetChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP GuestFileOffsetChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestFileOffsetChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestFileOffsetChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestFileOffsetChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "GuestFileOffsetChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "GuestFileOffsetChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP GuestFileOffsetChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "GuestFileOffsetChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "GuestFileOffsetChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IGuestSessionEvent properties
//

STDMETHODIMP GuestFileOffsetChangedEventWrap::COMGETTER(Session)(IGuestSession **aSession)
{
    LogRelFlow(("{%p} %s: enter aSession=%p\n", this, "GuestFileOffsetChangedEvent::getSession", aSession));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSession);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSession(ComTypeOutConverter<IGuestSession>(aSession).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSession=%p hrc=%Rhrc\n", this, "GuestFileOffsetChangedEvent::getSession", *aSession, hrc));
    return hrc;
}

//
// IGuestFileEvent properties
//

STDMETHODIMP GuestFileOffsetChangedEventWrap::COMGETTER(File)(IGuestFile **aFile)
{
    LogRelFlow(("{%p} %s: enter aFile=%p\n", this, "GuestFileOffsetChangedEvent::getFile", aFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFile);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFile(ComTypeOutConverter<IGuestFile>(aFile).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFile=%p hrc=%Rhrc\n", this, "GuestFileOffsetChangedEvent::getFile", *aFile, hrc));
    return hrc;
}

//
// IGuestFileIOEvent properties
//

STDMETHODIMP GuestFileOffsetChangedEventWrap::COMGETTER(Offset)(LONG64 *aOffset)
{
    LogRelFlow(("{%p} %s: enter aOffset=%p\n", this, "GuestFileOffsetChangedEvent::getOffset", aOffset));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOffset);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOffset(aOffset);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOffset=%RI64 hrc=%Rhrc\n", this, "GuestFileOffsetChangedEvent::getOffset", *aOffset, hrc));
    return hrc;
}

STDMETHODIMP GuestFileOffsetChangedEventWrap::COMGETTER(Processed)(ULONG *aProcessed)
{
    LogRelFlow(("{%p} %s: enter aProcessed=%p\n", this, "GuestFileOffsetChangedEvent::getProcessed", aProcessed));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProcessed);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProcessed(aProcessed);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProcessed=%RU32 hrc=%Rhrc\n", this, "GuestFileOffsetChangedEvent::getProcessed", *aProcessed, hrc));
    return hrc;
}

//
// IGuestFileOffsetChangedEvent properties
//

//
// IEvent methods
//

STDMETHODIMP GuestFileOffsetChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestFileOffsetChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestFileOffsetChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP GuestFileOffsetChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                            BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "GuestFileOffsetChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "GuestFileOffsetChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IGuestSessionEvent methods
//

//
// IGuestFileEvent methods
//

//
// IGuestFileIOEvent methods
//

//
// IGuestFileOffsetChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestFileOffsetChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS5_CI(GuestFileOffsetChangedEventWrap, IGuestFileOffsetChangedEvent, IGuestFileIOEvent, IGuestFileEvent, IGuestSessionEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestFileOffsetChangedEventWrap.cpp"

// ##### BEGINFILE "GuestFileReadEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestFileReadEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestFileReadEventWrap_H_
#define GuestFileReadEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestFileReadEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestFileReadEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestFileReadEventWrap, IGuestFileReadEvent)
    DECLARE_NOT_AGGREGATABLE(GuestFileReadEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestFileReadEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestFileReadEvent)
        COM_INTERFACE_ENTRY(IGuestFileIOEvent)
        COM_INTERFACE_ENTRY(IGuestFileEvent)
        COM_INTERFACE_ENTRY(IGuestSessionEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestFileReadEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestFileReadEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IGuestSessionEvent properties
    STDMETHOD(COMGETTER(Session))(IGuestSession **aSession);

    // public IGuestFileEvent properties
    STDMETHOD(COMGETTER(File))(IGuestFile **aFile);

    // public IGuestFileIOEvent properties
    STDMETHOD(COMGETTER(Offset))(LONG64 *aOffset);
    STDMETHOD(COMGETTER(Processed))(ULONG *aProcessed);

    // public IGuestFileReadEvent properties
    STDMETHOD(COMGETTER(Data))(ComSafeArrayOut(BYTE, aData));

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IGuestSessionEvent methods

    // public IGuestFileEvent methods

    // public IGuestFileIOEvent methods

    // public IGuestFileReadEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IGuestSessionEvent properties
    virtual HRESULT getSession(ComPtr<IGuestSession> &aSession) = 0;

    // wrapped IGuestFileEvent properties
    virtual HRESULT getFile(ComPtr<IGuestFile> &aFile) = 0;

    // wrapped IGuestFileIOEvent properties
    virtual HRESULT getOffset(LONG64 *aOffset) = 0;
    virtual HRESULT getProcessed(ULONG *aProcessed) = 0;

    // wrapped IGuestFileReadEvent properties
    virtual HRESULT getData(std::vector<BYTE> &aData) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IGuestSessionEvent methods

    // wrapped IGuestFileEvent methods

    // wrapped IGuestFileIOEvent methods

    // wrapped IGuestFileReadEvent methods
};

#endif // !GuestFileReadEventWrap_H_

// ##### ENDFILE "GuestFileReadEventWrap.h"

// ##### BEGINFILE "GuestFileReadEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestFileReadEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTFILEREADEVENT

#include "GuestFileReadEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestFileReadEventWrap)

//
// IEvent properties
//

STDMETHODIMP GuestFileReadEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestFileReadEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestFileReadEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestFileReadEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "GuestFileReadEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "GuestFileReadEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP GuestFileReadEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "GuestFileReadEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "GuestFileReadEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IGuestSessionEvent properties
//

STDMETHODIMP GuestFileReadEventWrap::COMGETTER(Session)(IGuestSession **aSession)
{
    LogRelFlow(("{%p} %s: enter aSession=%p\n", this, "GuestFileReadEvent::getSession", aSession));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSession);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSession(ComTypeOutConverter<IGuestSession>(aSession).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSession=%p hrc=%Rhrc\n", this, "GuestFileReadEvent::getSession", *aSession, hrc));
    return hrc;
}

//
// IGuestFileEvent properties
//

STDMETHODIMP GuestFileReadEventWrap::COMGETTER(File)(IGuestFile **aFile)
{
    LogRelFlow(("{%p} %s: enter aFile=%p\n", this, "GuestFileReadEvent::getFile", aFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFile);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFile(ComTypeOutConverter<IGuestFile>(aFile).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFile=%p hrc=%Rhrc\n", this, "GuestFileReadEvent::getFile", *aFile, hrc));
    return hrc;
}

//
// IGuestFileIOEvent properties
//

STDMETHODIMP GuestFileReadEventWrap::COMGETTER(Offset)(LONG64 *aOffset)
{
    LogRelFlow(("{%p} %s: enter aOffset=%p\n", this, "GuestFileReadEvent::getOffset", aOffset));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOffset);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOffset(aOffset);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOffset=%RI64 hrc=%Rhrc\n", this, "GuestFileReadEvent::getOffset", *aOffset, hrc));
    return hrc;
}

STDMETHODIMP GuestFileReadEventWrap::COMGETTER(Processed)(ULONG *aProcessed)
{
    LogRelFlow(("{%p} %s: enter aProcessed=%p\n", this, "GuestFileReadEvent::getProcessed", aProcessed));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProcessed);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProcessed(aProcessed);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProcessed=%RU32 hrc=%Rhrc\n", this, "GuestFileReadEvent::getProcessed", *aProcessed, hrc));
    return hrc;
}

//
// IGuestFileReadEvent properties
//

STDMETHODIMP GuestFileReadEventWrap::COMGETTER(Data)(ComSafeArrayOut(BYTE, aData))
{
    LogRelFlow(("{%p} %s: enter aData=%p\n", this, "GuestFileReadEvent::getData", aData));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aData);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getData(ArrayOutConverter<BYTE>(ComSafeArrayOutArg(aData)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aData=%zu hrc=%Rhrc\n", this, "GuestFileReadEvent::getData", ComSafeArraySize(*aData), hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP GuestFileReadEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestFileReadEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestFileReadEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP GuestFileReadEventWrap::WaitProcessed(LONG aTimeout,
                                                   BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "GuestFileReadEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "GuestFileReadEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IGuestSessionEvent methods
//

//
// IGuestFileEvent methods
//

//
// IGuestFileIOEvent methods
//

//
// IGuestFileReadEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestFileReadEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS5_CI(GuestFileReadEventWrap, IGuestFileReadEvent, IGuestFileIOEvent, IGuestFileEvent, IGuestSessionEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestFileReadEventWrap.cpp"

// ##### BEGINFILE "GuestFileWriteEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestFileWriteEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestFileWriteEventWrap_H_
#define GuestFileWriteEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestFileWriteEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestFileWriteEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestFileWriteEventWrap, IGuestFileWriteEvent)
    DECLARE_NOT_AGGREGATABLE(GuestFileWriteEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestFileWriteEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestFileWriteEvent)
        COM_INTERFACE_ENTRY(IGuestFileIOEvent)
        COM_INTERFACE_ENTRY(IGuestFileEvent)
        COM_INTERFACE_ENTRY(IGuestSessionEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestFileWriteEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestFileWriteEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IGuestSessionEvent properties
    STDMETHOD(COMGETTER(Session))(IGuestSession **aSession);

    // public IGuestFileEvent properties
    STDMETHOD(COMGETTER(File))(IGuestFile **aFile);

    // public IGuestFileIOEvent properties
    STDMETHOD(COMGETTER(Offset))(LONG64 *aOffset);
    STDMETHOD(COMGETTER(Processed))(ULONG *aProcessed);

    // public IGuestFileWriteEvent properties

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IGuestSessionEvent methods

    // public IGuestFileEvent methods

    // public IGuestFileIOEvent methods

    // public IGuestFileWriteEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IGuestSessionEvent properties
    virtual HRESULT getSession(ComPtr<IGuestSession> &aSession) = 0;

    // wrapped IGuestFileEvent properties
    virtual HRESULT getFile(ComPtr<IGuestFile> &aFile) = 0;

    // wrapped IGuestFileIOEvent properties
    virtual HRESULT getOffset(LONG64 *aOffset) = 0;
    virtual HRESULT getProcessed(ULONG *aProcessed) = 0;

    // wrapped IGuestFileWriteEvent properties

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IGuestSessionEvent methods

    // wrapped IGuestFileEvent methods

    // wrapped IGuestFileIOEvent methods

    // wrapped IGuestFileWriteEvent methods
};

#endif // !GuestFileWriteEventWrap_H_

// ##### ENDFILE "GuestFileWriteEventWrap.h"

// ##### BEGINFILE "GuestFileWriteEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestFileWriteEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTFILEWRITEEVENT

#include "GuestFileWriteEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestFileWriteEventWrap)

//
// IEvent properties
//

STDMETHODIMP GuestFileWriteEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestFileWriteEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestFileWriteEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestFileWriteEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "GuestFileWriteEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "GuestFileWriteEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP GuestFileWriteEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "GuestFileWriteEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "GuestFileWriteEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IGuestSessionEvent properties
//

STDMETHODIMP GuestFileWriteEventWrap::COMGETTER(Session)(IGuestSession **aSession)
{
    LogRelFlow(("{%p} %s: enter aSession=%p\n", this, "GuestFileWriteEvent::getSession", aSession));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSession);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSession(ComTypeOutConverter<IGuestSession>(aSession).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSession=%p hrc=%Rhrc\n", this, "GuestFileWriteEvent::getSession", *aSession, hrc));
    return hrc;
}

//
// IGuestFileEvent properties
//

STDMETHODIMP GuestFileWriteEventWrap::COMGETTER(File)(IGuestFile **aFile)
{
    LogRelFlow(("{%p} %s: enter aFile=%p\n", this, "GuestFileWriteEvent::getFile", aFile));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFile);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFile(ComTypeOutConverter<IGuestFile>(aFile).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFile=%p hrc=%Rhrc\n", this, "GuestFileWriteEvent::getFile", *aFile, hrc));
    return hrc;
}

//
// IGuestFileIOEvent properties
//

STDMETHODIMP GuestFileWriteEventWrap::COMGETTER(Offset)(LONG64 *aOffset)
{
    LogRelFlow(("{%p} %s: enter aOffset=%p\n", this, "GuestFileWriteEvent::getOffset", aOffset));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOffset);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOffset(aOffset);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOffset=%RI64 hrc=%Rhrc\n", this, "GuestFileWriteEvent::getOffset", *aOffset, hrc));
    return hrc;
}

STDMETHODIMP GuestFileWriteEventWrap::COMGETTER(Processed)(ULONG *aProcessed)
{
    LogRelFlow(("{%p} %s: enter aProcessed=%p\n", this, "GuestFileWriteEvent::getProcessed", aProcessed));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProcessed);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProcessed(aProcessed);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProcessed=%RU32 hrc=%Rhrc\n", this, "GuestFileWriteEvent::getProcessed", *aProcessed, hrc));
    return hrc;
}

//
// IGuestFileWriteEvent properties
//

//
// IEvent methods
//

STDMETHODIMP GuestFileWriteEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestFileWriteEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestFileWriteEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP GuestFileWriteEventWrap::WaitProcessed(LONG aTimeout,
                                                    BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "GuestFileWriteEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "GuestFileWriteEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IGuestSessionEvent methods
//

//
// IGuestFileEvent methods
//

//
// IGuestFileIOEvent methods
//

//
// IGuestFileWriteEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestFileWriteEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS5_CI(GuestFileWriteEventWrap, IGuestFileWriteEvent, IGuestFileIOEvent, IGuestFileEvent, IGuestSessionEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestFileWriteEventWrap.cpp"

// ##### BEGINFILE "VRDEServerChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IVRDEServerChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef VRDEServerChangedEventWrap_H_
#define VRDEServerChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE VRDEServerChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IVRDEServerChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(VRDEServerChangedEventWrap, IVRDEServerChangedEvent)
    DECLARE_NOT_AGGREGATABLE(VRDEServerChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(VRDEServerChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IVRDEServerChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IVRDEServerChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(VRDEServerChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IVRDEServerChangedEvent properties

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IVRDEServerChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IVRDEServerChangedEvent properties

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IVRDEServerChangedEvent methods
};

#endif // !VRDEServerChangedEventWrap_H_

// ##### ENDFILE "VRDEServerChangedEventWrap.h"

// ##### BEGINFILE "VRDEServerChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IVRDEServerChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_VRDESERVERCHANGEDEVENT

#include "VRDEServerChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(VRDEServerChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP VRDEServerChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "VRDEServerChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "VRDEServerChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "VRDEServerChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "VRDEServerChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "VRDEServerChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "VRDEServerChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IVRDEServerChangedEvent properties
//

//
// IEvent methods
//

STDMETHODIMP VRDEServerChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "VRDEServerChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VRDEServerChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP VRDEServerChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                       BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "VRDEServerChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "VRDEServerChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IVRDEServerChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(VRDEServerChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(VRDEServerChangedEventWrap, IVRDEServerChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "VRDEServerChangedEventWrap.cpp"

// ##### BEGINFILE "VRDEServerInfoChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IVRDEServerInfoChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef VRDEServerInfoChangedEventWrap_H_
#define VRDEServerInfoChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE VRDEServerInfoChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IVRDEServerInfoChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(VRDEServerInfoChangedEventWrap, IVRDEServerInfoChangedEvent)
    DECLARE_NOT_AGGREGATABLE(VRDEServerInfoChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(VRDEServerInfoChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IVRDEServerInfoChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IVRDEServerInfoChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(VRDEServerInfoChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IVRDEServerInfoChangedEvent properties

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IVRDEServerInfoChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IVRDEServerInfoChangedEvent properties

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IVRDEServerInfoChangedEvent methods
};

#endif // !VRDEServerInfoChangedEventWrap_H_

// ##### ENDFILE "VRDEServerInfoChangedEventWrap.h"

// ##### BEGINFILE "VRDEServerInfoChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IVRDEServerInfoChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_VRDESERVERINFOCHANGEDEVENT

#include "VRDEServerInfoChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(VRDEServerInfoChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP VRDEServerInfoChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "VRDEServerInfoChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "VRDEServerInfoChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerInfoChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "VRDEServerInfoChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "VRDEServerInfoChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP VRDEServerInfoChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "VRDEServerInfoChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "VRDEServerInfoChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IVRDEServerInfoChangedEvent properties
//

//
// IEvent methods
//

STDMETHODIMP VRDEServerInfoChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "VRDEServerInfoChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VRDEServerInfoChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP VRDEServerInfoChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                           BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "VRDEServerInfoChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "VRDEServerInfoChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IVRDEServerInfoChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(VRDEServerInfoChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(VRDEServerInfoChangedEventWrap, IVRDEServerInfoChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "VRDEServerInfoChangedEventWrap.cpp"

// ##### BEGINFILE "VideoCaptureChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IVideoCaptureChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef VideoCaptureChangedEventWrap_H_
#define VideoCaptureChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE VideoCaptureChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IVideoCaptureChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(VideoCaptureChangedEventWrap, IVideoCaptureChangedEvent)
    DECLARE_NOT_AGGREGATABLE(VideoCaptureChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(VideoCaptureChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IVideoCaptureChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IVideoCaptureChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(VideoCaptureChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IVideoCaptureChangedEvent properties

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IVideoCaptureChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IVideoCaptureChangedEvent properties

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IVideoCaptureChangedEvent methods
};

#endif // !VideoCaptureChangedEventWrap_H_

// ##### ENDFILE "VideoCaptureChangedEventWrap.h"

// ##### BEGINFILE "VideoCaptureChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IVideoCaptureChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_VIDEOCAPTURECHANGEDEVENT

#include "VideoCaptureChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(VideoCaptureChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP VideoCaptureChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "VideoCaptureChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "VideoCaptureChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP VideoCaptureChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "VideoCaptureChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "VideoCaptureChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP VideoCaptureChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "VideoCaptureChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "VideoCaptureChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IVideoCaptureChangedEvent properties
//

//
// IEvent methods
//

STDMETHODIMP VideoCaptureChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "VideoCaptureChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VideoCaptureChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP VideoCaptureChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                         BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "VideoCaptureChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "VideoCaptureChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IVideoCaptureChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(VideoCaptureChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(VideoCaptureChangedEventWrap, IVideoCaptureChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "VideoCaptureChangedEventWrap.cpp"

// ##### BEGINFILE "USBControllerChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IUSBControllerChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef USBControllerChangedEventWrap_H_
#define USBControllerChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE USBControllerChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IUSBControllerChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(USBControllerChangedEventWrap, IUSBControllerChangedEvent)
    DECLARE_NOT_AGGREGATABLE(USBControllerChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(USBControllerChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IUSBControllerChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IUSBControllerChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(USBControllerChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IUSBControllerChangedEvent properties

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IUSBControllerChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IUSBControllerChangedEvent properties

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IUSBControllerChangedEvent methods
};

#endif // !USBControllerChangedEventWrap_H_

// ##### ENDFILE "USBControllerChangedEventWrap.h"

// ##### BEGINFILE "USBControllerChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IUSBControllerChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_USBCONTROLLERCHANGEDEVENT

#include "USBControllerChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(USBControllerChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP USBControllerChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "USBControllerChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "USBControllerChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP USBControllerChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "USBControllerChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "USBControllerChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP USBControllerChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "USBControllerChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "USBControllerChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IUSBControllerChangedEvent properties
//

//
// IEvent methods
//

STDMETHODIMP USBControllerChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "USBControllerChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "USBControllerChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP USBControllerChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                          BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "USBControllerChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "USBControllerChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IUSBControllerChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(USBControllerChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(USBControllerChangedEventWrap, IUSBControllerChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "USBControllerChangedEventWrap.cpp"

// ##### BEGINFILE "USBDeviceStateChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IUSBDeviceStateChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef USBDeviceStateChangedEventWrap_H_
#define USBDeviceStateChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE USBDeviceStateChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IUSBDeviceStateChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(USBDeviceStateChangedEventWrap, IUSBDeviceStateChangedEvent)
    DECLARE_NOT_AGGREGATABLE(USBDeviceStateChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(USBDeviceStateChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IUSBDeviceStateChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IUSBDeviceStateChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(USBDeviceStateChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IUSBDeviceStateChangedEvent properties
    STDMETHOD(COMGETTER(Device))(IUSBDevice **aDevice);
    STDMETHOD(COMGETTER(Attached))(BOOL *aAttached);
    STDMETHOD(COMGETTER(Error))(IVirtualBoxErrorInfo **aError);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IUSBDeviceStateChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IUSBDeviceStateChangedEvent properties
    virtual HRESULT getDevice(ComPtr<IUSBDevice> &aDevice) = 0;
    virtual HRESULT getAttached(BOOL *aAttached) = 0;
    virtual HRESULT getError(ComPtr<IVirtualBoxErrorInfo> &aError) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IUSBDeviceStateChangedEvent methods
};

#endif // !USBDeviceStateChangedEventWrap_H_

// ##### ENDFILE "USBDeviceStateChangedEventWrap.h"

// ##### BEGINFILE "USBDeviceStateChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IUSBDeviceStateChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_USBDEVICESTATECHANGEDEVENT

#include "USBDeviceStateChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(USBDeviceStateChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP USBDeviceStateChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "USBDeviceStateChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "USBDeviceStateChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceStateChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "USBDeviceStateChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "USBDeviceStateChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceStateChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "USBDeviceStateChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "USBDeviceStateChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IUSBDeviceStateChangedEvent properties
//

STDMETHODIMP USBDeviceStateChangedEventWrap::COMGETTER(Device)(IUSBDevice **aDevice)
{
    LogRelFlow(("{%p} %s: enter aDevice=%p\n", this, "USBDeviceStateChangedEvent::getDevice", aDevice));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDevice);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDevice(ComTypeOutConverter<IUSBDevice>(aDevice).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDevice=%p hrc=%Rhrc\n", this, "USBDeviceStateChangedEvent::getDevice", *aDevice, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceStateChangedEventWrap::COMGETTER(Attached)(BOOL *aAttached)
{
    LogRelFlow(("{%p} %s: enter aAttached=%p\n", this, "USBDeviceStateChangedEvent::getAttached", aAttached));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAttached);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAttached(aAttached);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAttached=%RTbool hrc=%Rhrc\n", this, "USBDeviceStateChangedEvent::getAttached", *aAttached, hrc));
    return hrc;
}

STDMETHODIMP USBDeviceStateChangedEventWrap::COMGETTER(Error)(IVirtualBoxErrorInfo **aError)
{
    LogRelFlow(("{%p} %s: enter aError=%p\n", this, "USBDeviceStateChangedEvent::getError", aError));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aError);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getError(ComTypeOutConverter<IVirtualBoxErrorInfo>(aError).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aError=%p hrc=%Rhrc\n", this, "USBDeviceStateChangedEvent::getError", *aError, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP USBDeviceStateChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "USBDeviceStateChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "USBDeviceStateChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP USBDeviceStateChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                           BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "USBDeviceStateChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "USBDeviceStateChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IUSBDeviceStateChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(USBDeviceStateChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(USBDeviceStateChangedEventWrap, IUSBDeviceStateChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "USBDeviceStateChangedEventWrap.cpp"

// ##### BEGINFILE "SharedFolderChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for ISharedFolderChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef SharedFolderChangedEventWrap_H_
#define SharedFolderChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE SharedFolderChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(ISharedFolderChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(SharedFolderChangedEventWrap, ISharedFolderChangedEvent)
    DECLARE_NOT_AGGREGATABLE(SharedFolderChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(SharedFolderChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(ISharedFolderChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, ISharedFolderChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(SharedFolderChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public ISharedFolderChangedEvent properties
    STDMETHOD(COMGETTER(Scope))(Scope_T *aScope);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public ISharedFolderChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped ISharedFolderChangedEvent properties
    virtual HRESULT getScope(Scope_T *aScope) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped ISharedFolderChangedEvent methods
};

#endif // !SharedFolderChangedEventWrap_H_

// ##### ENDFILE "SharedFolderChangedEventWrap.h"

// ##### BEGINFILE "SharedFolderChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for ISharedFolderChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_SHAREDFOLDERCHANGEDEVENT

#include "SharedFolderChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(SharedFolderChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP SharedFolderChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "SharedFolderChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "SharedFolderChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP SharedFolderChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "SharedFolderChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "SharedFolderChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP SharedFolderChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "SharedFolderChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "SharedFolderChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// ISharedFolderChangedEvent properties
//

STDMETHODIMP SharedFolderChangedEventWrap::COMGETTER(Scope)(Scope_T *aScope)
{
    LogRelFlow(("{%p} %s: enter aScope=%p\n", this, "SharedFolderChangedEvent::getScope", aScope));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aScope);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getScope(aScope);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aScope=%RU32 hrc=%Rhrc\n", this, "SharedFolderChangedEvent::getScope", *aScope, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP SharedFolderChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "SharedFolderChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "SharedFolderChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP SharedFolderChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                         BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "SharedFolderChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "SharedFolderChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// ISharedFolderChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(SharedFolderChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(SharedFolderChangedEventWrap, ISharedFolderChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "SharedFolderChangedEventWrap.cpp"

// ##### BEGINFILE "RuntimeErrorEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IRuntimeErrorEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef RuntimeErrorEventWrap_H_
#define RuntimeErrorEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE RuntimeErrorEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IRuntimeErrorEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(RuntimeErrorEventWrap, IRuntimeErrorEvent)
    DECLARE_NOT_AGGREGATABLE(RuntimeErrorEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(RuntimeErrorEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IRuntimeErrorEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IRuntimeErrorEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(RuntimeErrorEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IRuntimeErrorEvent properties
    STDMETHOD(COMGETTER(Fatal))(BOOL *aFatal);
    STDMETHOD(COMGETTER(Id))(BSTR *aId);
    STDMETHOD(COMGETTER(Message))(BSTR *aMessage);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IRuntimeErrorEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IRuntimeErrorEvent properties
    virtual HRESULT getFatal(BOOL *aFatal) = 0;
    virtual HRESULT getId(com::Utf8Str &aId) = 0;
    virtual HRESULT getMessage(com::Utf8Str &aMessage) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IRuntimeErrorEvent methods
};

#endif // !RuntimeErrorEventWrap_H_

// ##### ENDFILE "RuntimeErrorEventWrap.h"

// ##### BEGINFILE "RuntimeErrorEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IRuntimeErrorEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_RUNTIMEERROREVENT

#include "RuntimeErrorEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(RuntimeErrorEventWrap)

//
// IEvent properties
//

STDMETHODIMP RuntimeErrorEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "RuntimeErrorEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "RuntimeErrorEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP RuntimeErrorEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "RuntimeErrorEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "RuntimeErrorEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP RuntimeErrorEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "RuntimeErrorEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "RuntimeErrorEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IRuntimeErrorEvent properties
//

STDMETHODIMP RuntimeErrorEventWrap::COMGETTER(Fatal)(BOOL *aFatal)
{
    LogRelFlow(("{%p} %s: enter aFatal=%p\n", this, "RuntimeErrorEvent::getFatal", aFatal));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aFatal);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getFatal(aFatal);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aFatal=%RTbool hrc=%Rhrc\n", this, "RuntimeErrorEvent::getFatal", *aFatal, hrc));
    return hrc;
}

STDMETHODIMP RuntimeErrorEventWrap::COMGETTER(Id)(BSTR *aId)
{
    LogRelFlow(("{%p} %s: enter aId=%p\n", this, "RuntimeErrorEvent::getId", aId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getId(BSTROutConverter(aId).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aId=%ls hrc=%Rhrc\n", this, "RuntimeErrorEvent::getId", *aId, hrc));
    return hrc;
}

STDMETHODIMP RuntimeErrorEventWrap::COMGETTER(Message)(BSTR *aMessage)
{
    LogRelFlow(("{%p} %s: enter aMessage=%p\n", this, "RuntimeErrorEvent::getMessage", aMessage));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMessage);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMessage(BSTROutConverter(aMessage).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMessage=%ls hrc=%Rhrc\n", this, "RuntimeErrorEvent::getMessage", *aMessage, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP RuntimeErrorEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "RuntimeErrorEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "RuntimeErrorEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP RuntimeErrorEventWrap::WaitProcessed(LONG aTimeout,
                                                  BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "RuntimeErrorEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "RuntimeErrorEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IRuntimeErrorEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(RuntimeErrorEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(RuntimeErrorEventWrap, IRuntimeErrorEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "RuntimeErrorEventWrap.cpp"

// ##### BEGINFILE "EventSourceChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IEventSourceChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef EventSourceChangedEventWrap_H_
#define EventSourceChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE EventSourceChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IEventSourceChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(EventSourceChangedEventWrap, IEventSourceChangedEvent)
    DECLARE_NOT_AGGREGATABLE(EventSourceChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(EventSourceChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IEventSourceChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IEventSourceChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(EventSourceChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IEventSourceChangedEvent properties
    STDMETHOD(COMGETTER(Listener))(IEventListener **aListener);
    STDMETHOD(COMGETTER(Add))(BOOL *aAdd);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IEventSourceChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IEventSourceChangedEvent properties
    virtual HRESULT getListener(ComPtr<IEventListener> &aListener) = 0;
    virtual HRESULT getAdd(BOOL *aAdd) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IEventSourceChangedEvent methods
};

#endif // !EventSourceChangedEventWrap_H_

// ##### ENDFILE "EventSourceChangedEventWrap.h"

// ##### BEGINFILE "EventSourceChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IEventSourceChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_EVENTSOURCECHANGEDEVENT

#include "EventSourceChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(EventSourceChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP EventSourceChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "EventSourceChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "EventSourceChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP EventSourceChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "EventSourceChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "EventSourceChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP EventSourceChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "EventSourceChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "EventSourceChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IEventSourceChangedEvent properties
//

STDMETHODIMP EventSourceChangedEventWrap::COMGETTER(Listener)(IEventListener **aListener)
{
    LogRelFlow(("{%p} %s: enter aListener=%p\n", this, "EventSourceChangedEvent::getListener", aListener));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aListener);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getListener(ComTypeOutConverter<IEventListener>(aListener).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aListener=%p hrc=%Rhrc\n", this, "EventSourceChangedEvent::getListener", *aListener, hrc));
    return hrc;
}

STDMETHODIMP EventSourceChangedEventWrap::COMGETTER(Add)(BOOL *aAdd)
{
    LogRelFlow(("{%p} %s: enter aAdd=%p\n", this, "EventSourceChangedEvent::getAdd", aAdd));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAdd);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAdd(aAdd);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAdd=%RTbool hrc=%Rhrc\n", this, "EventSourceChangedEvent::getAdd", *aAdd, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP EventSourceChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "EventSourceChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "EventSourceChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP EventSourceChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                        BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "EventSourceChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "EventSourceChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IEventSourceChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(EventSourceChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(EventSourceChangedEventWrap, IEventSourceChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "EventSourceChangedEventWrap.cpp"

// ##### BEGINFILE "ExtraDataChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IExtraDataChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef ExtraDataChangedEventWrap_H_
#define ExtraDataChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE ExtraDataChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IExtraDataChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(ExtraDataChangedEventWrap, IExtraDataChangedEvent)
    DECLARE_NOT_AGGREGATABLE(ExtraDataChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(ExtraDataChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IExtraDataChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IExtraDataChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(ExtraDataChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IExtraDataChangedEvent properties
    STDMETHOD(COMGETTER(MachineId))(BSTR *aMachineId);
    STDMETHOD(COMGETTER(Key))(BSTR *aKey);
    STDMETHOD(COMGETTER(Value))(BSTR *aValue);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IExtraDataChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IExtraDataChangedEvent properties
    virtual HRESULT getMachineId(com::Guid &aMachineId) = 0;
    virtual HRESULT getKey(com::Utf8Str &aKey) = 0;
    virtual HRESULT getValue(com::Utf8Str &aValue) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IExtraDataChangedEvent methods
};

#endif // !ExtraDataChangedEventWrap_H_

// ##### ENDFILE "ExtraDataChangedEventWrap.h"

// ##### BEGINFILE "ExtraDataChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IExtraDataChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_EXTRADATACHANGEDEVENT

#include "ExtraDataChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(ExtraDataChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP ExtraDataChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "ExtraDataChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "ExtraDataChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP ExtraDataChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "ExtraDataChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "ExtraDataChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP ExtraDataChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "ExtraDataChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "ExtraDataChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IExtraDataChangedEvent properties
//

STDMETHODIMP ExtraDataChangedEventWrap::COMGETTER(MachineId)(BSTR *aMachineId)
{
    LogRelFlow(("{%p} %s: enter aMachineId=%p\n", this, "ExtraDataChangedEvent::getMachineId", aMachineId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachineId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachineId(UuidOutConverter(aMachineId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachineId=%ls hrc=%Rhrc\n", this, "ExtraDataChangedEvent::getMachineId", *aMachineId, hrc));
    return hrc;
}

STDMETHODIMP ExtraDataChangedEventWrap::COMGETTER(Key)(BSTR *aKey)
{
    LogRelFlow(("{%p} %s: enter aKey=%p\n", this, "ExtraDataChangedEvent::getKey", aKey));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aKey);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getKey(BSTROutConverter(aKey).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aKey=%ls hrc=%Rhrc\n", this, "ExtraDataChangedEvent::getKey", *aKey, hrc));
    return hrc;
}

STDMETHODIMP ExtraDataChangedEventWrap::COMGETTER(Value)(BSTR *aValue)
{
    LogRelFlow(("{%p} %s: enter aValue=%p\n", this, "ExtraDataChangedEvent::getValue", aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aValue);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getValue(BSTROutConverter(aValue).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aValue=%ls hrc=%Rhrc\n", this, "ExtraDataChangedEvent::getValue", *aValue, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP ExtraDataChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "ExtraDataChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "ExtraDataChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP ExtraDataChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                      BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "ExtraDataChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "ExtraDataChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IExtraDataChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(ExtraDataChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(ExtraDataChangedEventWrap, IExtraDataChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "ExtraDataChangedEventWrap.cpp"

// ##### BEGINFILE "VetoEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IVetoEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef VetoEventWrap_H_
#define VetoEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE VetoEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IVetoEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(VetoEventWrap, IVetoEvent)
    DECLARE_NOT_AGGREGATABLE(VetoEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(VetoEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IVetoEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IVetoEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(VetoEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IVetoEvent properties

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IVetoEvent methods
    STDMETHOD(AddVeto)(IN_BSTR aReason);
    STDMETHOD(IsVetoed)(BOOL *aResult);
    STDMETHOD(GetVetos)(ComSafeArrayOut(BSTR, aResult));

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IVetoEvent properties

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IVetoEvent methods
    virtual HRESULT addVeto(const com::Utf8Str &aReason) = 0;
    virtual HRESULT isVetoed(BOOL *aResult) = 0;
    virtual HRESULT getVetos(std::vector<com::Utf8Str> &aResult) = 0;
};

#endif // !VetoEventWrap_H_

// ##### ENDFILE "VetoEventWrap.h"

// ##### BEGINFILE "VetoEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IVetoEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_VETOEVENT

#include "VetoEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(VetoEventWrap)

//
// IEvent properties
//

STDMETHODIMP VetoEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "VetoEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "VetoEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP VetoEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "VetoEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "VetoEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP VetoEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "VetoEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "VetoEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IVetoEvent properties
//

//
// IEvent methods
//

STDMETHODIMP VetoEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "VetoEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VetoEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP VetoEventWrap::WaitProcessed(LONG aTimeout,
                                          BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "VetoEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "VetoEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IVetoEvent methods
//

STDMETHODIMP VetoEventWrap::AddVeto(IN_BSTR aReason)
{
    LogRelFlow(("{%p} %s:enter aReason=%ls\n", this, "VetoEvent::addVeto", aReason));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = addVeto(BSTRInConverter(aReason).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VetoEvent::addVeto", hrc));
    return hrc;
}

STDMETHODIMP VetoEventWrap::IsVetoed(BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aResult=%p\n", this, "VetoEvent::isVetoed", aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = isVetoed(aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "VetoEvent::isVetoed", *aResult, hrc));
    return hrc;
}

STDMETHODIMP VetoEventWrap::GetVetos(ComSafeArrayOut(BSTR, aResult))
{
    LogRelFlow(("{%p} %s:enter aResult=%p\n", this, "VetoEvent::getVetos", aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVetos(ArrayBSTROutConverter(ComSafeArrayOutArg(aResult)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%zu hrc=%Rhrc\n", this, "VetoEvent::getVetos", ComSafeArraySize(*aResult), hrc));
    return hrc;
}

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(VetoEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(VetoEventWrap, IVetoEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "VetoEventWrap.cpp"

// ##### BEGINFILE "ExtraDataCanChangeEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IExtraDataCanChangeEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef ExtraDataCanChangeEventWrap_H_
#define ExtraDataCanChangeEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE ExtraDataCanChangeEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IExtraDataCanChangeEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(ExtraDataCanChangeEventWrap, IExtraDataCanChangeEvent)
    DECLARE_NOT_AGGREGATABLE(ExtraDataCanChangeEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(ExtraDataCanChangeEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IExtraDataCanChangeEvent)
        COM_INTERFACE_ENTRY(IVetoEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IExtraDataCanChangeEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(ExtraDataCanChangeEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IVetoEvent properties

    // public IExtraDataCanChangeEvent properties
    STDMETHOD(COMGETTER(MachineId))(BSTR *aMachineId);
    STDMETHOD(COMGETTER(Key))(BSTR *aKey);
    STDMETHOD(COMGETTER(Value))(BSTR *aValue);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IVetoEvent methods
    STDMETHOD(AddVeto)(IN_BSTR aReason);
    STDMETHOD(IsVetoed)(BOOL *aResult);
    STDMETHOD(GetVetos)(ComSafeArrayOut(BSTR, aResult));

    // public IExtraDataCanChangeEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IVetoEvent properties

    // wrapped IExtraDataCanChangeEvent properties
    virtual HRESULT getMachineId(com::Guid &aMachineId) = 0;
    virtual HRESULT getKey(com::Utf8Str &aKey) = 0;
    virtual HRESULT getValue(com::Utf8Str &aValue) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IVetoEvent methods
    virtual HRESULT addVeto(const com::Utf8Str &aReason) = 0;
    virtual HRESULT isVetoed(BOOL *aResult) = 0;
    virtual HRESULT getVetos(std::vector<com::Utf8Str> &aResult) = 0;

    // wrapped IExtraDataCanChangeEvent methods
};

#endif // !ExtraDataCanChangeEventWrap_H_

// ##### ENDFILE "ExtraDataCanChangeEventWrap.h"

// ##### BEGINFILE "ExtraDataCanChangeEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IExtraDataCanChangeEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_EXTRADATACANCHANGEEVENT

#include "ExtraDataCanChangeEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(ExtraDataCanChangeEventWrap)

//
// IEvent properties
//

STDMETHODIMP ExtraDataCanChangeEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "ExtraDataCanChangeEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "ExtraDataCanChangeEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP ExtraDataCanChangeEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "ExtraDataCanChangeEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "ExtraDataCanChangeEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP ExtraDataCanChangeEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "ExtraDataCanChangeEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "ExtraDataCanChangeEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IVetoEvent properties
//

//
// IExtraDataCanChangeEvent properties
//

STDMETHODIMP ExtraDataCanChangeEventWrap::COMGETTER(MachineId)(BSTR *aMachineId)
{
    LogRelFlow(("{%p} %s: enter aMachineId=%p\n", this, "ExtraDataCanChangeEvent::getMachineId", aMachineId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachineId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachineId(UuidOutConverter(aMachineId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachineId=%ls hrc=%Rhrc\n", this, "ExtraDataCanChangeEvent::getMachineId", *aMachineId, hrc));
    return hrc;
}

STDMETHODIMP ExtraDataCanChangeEventWrap::COMGETTER(Key)(BSTR *aKey)
{
    LogRelFlow(("{%p} %s: enter aKey=%p\n", this, "ExtraDataCanChangeEvent::getKey", aKey));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aKey);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getKey(BSTROutConverter(aKey).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aKey=%ls hrc=%Rhrc\n", this, "ExtraDataCanChangeEvent::getKey", *aKey, hrc));
    return hrc;
}

STDMETHODIMP ExtraDataCanChangeEventWrap::COMGETTER(Value)(BSTR *aValue)
{
    LogRelFlow(("{%p} %s: enter aValue=%p\n", this, "ExtraDataCanChangeEvent::getValue", aValue));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aValue);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getValue(BSTROutConverter(aValue).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aValue=%ls hrc=%Rhrc\n", this, "ExtraDataCanChangeEvent::getValue", *aValue, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP ExtraDataCanChangeEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "ExtraDataCanChangeEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "ExtraDataCanChangeEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP ExtraDataCanChangeEventWrap::WaitProcessed(LONG aTimeout,
                                                        BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "ExtraDataCanChangeEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "ExtraDataCanChangeEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IVetoEvent methods
//

STDMETHODIMP ExtraDataCanChangeEventWrap::AddVeto(IN_BSTR aReason)
{
    LogRelFlow(("{%p} %s:enter aReason=%ls\n", this, "ExtraDataCanChangeEvent::addVeto", aReason));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = addVeto(BSTRInConverter(aReason).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "ExtraDataCanChangeEvent::addVeto", hrc));
    return hrc;
}

STDMETHODIMP ExtraDataCanChangeEventWrap::IsVetoed(BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aResult=%p\n", this, "ExtraDataCanChangeEvent::isVetoed", aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = isVetoed(aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "ExtraDataCanChangeEvent::isVetoed", *aResult, hrc));
    return hrc;
}

STDMETHODIMP ExtraDataCanChangeEventWrap::GetVetos(ComSafeArrayOut(BSTR, aResult))
{
    LogRelFlow(("{%p} %s:enter aResult=%p\n", this, "ExtraDataCanChangeEvent::getVetos", aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVetos(ArrayBSTROutConverter(ComSafeArrayOutArg(aResult)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%zu hrc=%Rhrc\n", this, "ExtraDataCanChangeEvent::getVetos", ComSafeArraySize(*aResult), hrc));
    return hrc;
}

//
// IExtraDataCanChangeEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(ExtraDataCanChangeEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS3_CI(ExtraDataCanChangeEventWrap, IExtraDataCanChangeEvent, IVetoEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "ExtraDataCanChangeEventWrap.cpp"

// ##### BEGINFILE "CanShowWindowEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for ICanShowWindowEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef CanShowWindowEventWrap_H_
#define CanShowWindowEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE CanShowWindowEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(ICanShowWindowEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(CanShowWindowEventWrap, ICanShowWindowEvent)
    DECLARE_NOT_AGGREGATABLE(CanShowWindowEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CanShowWindowEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(ICanShowWindowEvent)
        COM_INTERFACE_ENTRY(IVetoEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, ICanShowWindowEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(CanShowWindowEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IVetoEvent properties

    // public ICanShowWindowEvent properties

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IVetoEvent methods
    STDMETHOD(AddVeto)(IN_BSTR aReason);
    STDMETHOD(IsVetoed)(BOOL *aResult);
    STDMETHOD(GetVetos)(ComSafeArrayOut(BSTR, aResult));

    // public ICanShowWindowEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IVetoEvent properties

    // wrapped ICanShowWindowEvent properties

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IVetoEvent methods
    virtual HRESULT addVeto(const com::Utf8Str &aReason) = 0;
    virtual HRESULT isVetoed(BOOL *aResult) = 0;
    virtual HRESULT getVetos(std::vector<com::Utf8Str> &aResult) = 0;

    // wrapped ICanShowWindowEvent methods
};

#endif // !CanShowWindowEventWrap_H_

// ##### ENDFILE "CanShowWindowEventWrap.h"

// ##### BEGINFILE "CanShowWindowEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for ICanShowWindowEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_CANSHOWWINDOWEVENT

#include "CanShowWindowEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(CanShowWindowEventWrap)

//
// IEvent properties
//

STDMETHODIMP CanShowWindowEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "CanShowWindowEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "CanShowWindowEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP CanShowWindowEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "CanShowWindowEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "CanShowWindowEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP CanShowWindowEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "CanShowWindowEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "CanShowWindowEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IVetoEvent properties
//

//
// ICanShowWindowEvent properties
//

//
// IEvent methods
//

STDMETHODIMP CanShowWindowEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "CanShowWindowEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "CanShowWindowEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP CanShowWindowEventWrap::WaitProcessed(LONG aTimeout,
                                                   BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "CanShowWindowEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "CanShowWindowEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IVetoEvent methods
//

STDMETHODIMP CanShowWindowEventWrap::AddVeto(IN_BSTR aReason)
{
    LogRelFlow(("{%p} %s:enter aReason=%ls\n", this, "CanShowWindowEvent::addVeto", aReason));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = addVeto(BSTRInConverter(aReason).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "CanShowWindowEvent::addVeto", hrc));
    return hrc;
}

STDMETHODIMP CanShowWindowEventWrap::IsVetoed(BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aResult=%p\n", this, "CanShowWindowEvent::isVetoed", aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = isVetoed(aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "CanShowWindowEvent::isVetoed", *aResult, hrc));
    return hrc;
}

STDMETHODIMP CanShowWindowEventWrap::GetVetos(ComSafeArrayOut(BSTR, aResult))
{
    LogRelFlow(("{%p} %s:enter aResult=%p\n", this, "CanShowWindowEvent::getVetos", aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getVetos(ArrayBSTROutConverter(ComSafeArrayOutArg(aResult)).array());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%zu hrc=%Rhrc\n", this, "CanShowWindowEvent::getVetos", ComSafeArraySize(*aResult), hrc));
    return hrc;
}

//
// ICanShowWindowEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(CanShowWindowEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS3_CI(CanShowWindowEventWrap, ICanShowWindowEvent, IVetoEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "CanShowWindowEventWrap.cpp"

// ##### BEGINFILE "ShowWindowEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IShowWindowEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef ShowWindowEventWrap_H_
#define ShowWindowEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE ShowWindowEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IShowWindowEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(ShowWindowEventWrap, IShowWindowEvent)
    DECLARE_NOT_AGGREGATABLE(ShowWindowEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(ShowWindowEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IShowWindowEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IShowWindowEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(ShowWindowEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IShowWindowEvent properties
    STDMETHOD(COMGETTER(WinId))(LONG64 *aWinId);
    STDMETHOD(COMSETTER(WinId))(LONG64 aWinId);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IShowWindowEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IShowWindowEvent properties
    virtual HRESULT getWinId(LONG64 *aWinId) = 0;
    virtual HRESULT setWinId(LONG64 aWinId) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IShowWindowEvent methods
};

#endif // !ShowWindowEventWrap_H_

// ##### ENDFILE "ShowWindowEventWrap.h"

// ##### BEGINFILE "ShowWindowEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IShowWindowEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_SHOWWINDOWEVENT

#include "ShowWindowEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(ShowWindowEventWrap)

//
// IEvent properties
//

STDMETHODIMP ShowWindowEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "ShowWindowEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "ShowWindowEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP ShowWindowEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "ShowWindowEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "ShowWindowEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP ShowWindowEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "ShowWindowEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "ShowWindowEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IShowWindowEvent properties
//

STDMETHODIMP ShowWindowEventWrap::COMGETTER(WinId)(LONG64 *aWinId)
{
    LogRelFlow(("{%p} %s: enter aWinId=%p\n", this, "ShowWindowEvent::getWinId", aWinId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWinId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWinId(aWinId);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWinId=%RI64 hrc=%Rhrc\n", this, "ShowWindowEvent::getWinId", *aWinId, hrc));
    return hrc;
}

STDMETHODIMP ShowWindowEventWrap::COMSETTER(WinId)(LONG64 aWinId)
{
    LogRelFlow(("{%p} %s: enter aWinId=%RI64\n", this, "ShowWindowEvent::setWinId", aWinId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setWinId(aWinId);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "ShowWindowEvent::setWinId", hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP ShowWindowEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "ShowWindowEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "ShowWindowEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP ShowWindowEventWrap::WaitProcessed(LONG aTimeout,
                                                BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "ShowWindowEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "ShowWindowEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IShowWindowEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(ShowWindowEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(ShowWindowEventWrap, IShowWindowEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "ShowWindowEventWrap.cpp"

// ##### BEGINFILE "NATRedirectEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for INATRedirectEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef NATRedirectEventWrap_H_
#define NATRedirectEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE NATRedirectEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(INATRedirectEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(NATRedirectEventWrap, INATRedirectEvent)
    DECLARE_NOT_AGGREGATABLE(NATRedirectEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(NATRedirectEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(INATRedirectEvent)
        COM_INTERFACE_ENTRY(IMachineEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, INATRedirectEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(NATRedirectEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IMachineEvent properties
    STDMETHOD(COMGETTER(MachineId))(BSTR *aMachineId);

    // public INATRedirectEvent properties
    STDMETHOD(COMGETTER(Slot))(ULONG *aSlot);
    STDMETHOD(COMGETTER(Remove))(BOOL *aRemove);
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(Proto))(NATProtocol_T *aProto);
    STDMETHOD(COMGETTER(HostIP))(BSTR *aHostIP);
    STDMETHOD(COMGETTER(HostPort))(LONG *aHostPort);
    STDMETHOD(COMGETTER(GuestIP))(BSTR *aGuestIP);
    STDMETHOD(COMGETTER(GuestPort))(LONG *aGuestPort);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IMachineEvent methods

    // public INATRedirectEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IMachineEvent properties
    virtual HRESULT getMachineId(com::Guid &aMachineId) = 0;

    // wrapped INATRedirectEvent properties
    virtual HRESULT getSlot(ULONG *aSlot) = 0;
    virtual HRESULT getRemove(BOOL *aRemove) = 0;
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getProto(NATProtocol_T *aProto) = 0;
    virtual HRESULT getHostIP(com::Utf8Str &aHostIP) = 0;
    virtual HRESULT getHostPort(LONG *aHostPort) = 0;
    virtual HRESULT getGuestIP(com::Utf8Str &aGuestIP) = 0;
    virtual HRESULT getGuestPort(LONG *aGuestPort) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IMachineEvent methods

    // wrapped INATRedirectEvent methods
};

#endif // !NATRedirectEventWrap_H_

// ##### ENDFILE "NATRedirectEventWrap.h"

// ##### BEGINFILE "NATRedirectEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for INATRedirectEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_NATREDIRECTEVENT

#include "NATRedirectEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(NATRedirectEventWrap)

//
// IEvent properties
//

STDMETHODIMP NATRedirectEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "NATRedirectEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "NATRedirectEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP NATRedirectEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "NATRedirectEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "NATRedirectEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP NATRedirectEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "NATRedirectEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "NATRedirectEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IMachineEvent properties
//

STDMETHODIMP NATRedirectEventWrap::COMGETTER(MachineId)(BSTR *aMachineId)
{
    LogRelFlow(("{%p} %s: enter aMachineId=%p\n", this, "NATRedirectEvent::getMachineId", aMachineId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachineId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachineId(UuidOutConverter(aMachineId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachineId=%ls hrc=%Rhrc\n", this, "NATRedirectEvent::getMachineId", *aMachineId, hrc));
    return hrc;
}

//
// INATRedirectEvent properties
//

STDMETHODIMP NATRedirectEventWrap::COMGETTER(Slot)(ULONG *aSlot)
{
    LogRelFlow(("{%p} %s: enter aSlot=%p\n", this, "NATRedirectEvent::getSlot", aSlot));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSlot);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSlot(aSlot);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSlot=%RU32 hrc=%Rhrc\n", this, "NATRedirectEvent::getSlot", *aSlot, hrc));
    return hrc;
}

STDMETHODIMP NATRedirectEventWrap::COMGETTER(Remove)(BOOL *aRemove)
{
    LogRelFlow(("{%p} %s: enter aRemove=%p\n", this, "NATRedirectEvent::getRemove", aRemove));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRemove);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRemove(aRemove);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRemove=%RTbool hrc=%Rhrc\n", this, "NATRedirectEvent::getRemove", *aRemove, hrc));
    return hrc;
}

STDMETHODIMP NATRedirectEventWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "NATRedirectEvent::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "NATRedirectEvent::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP NATRedirectEventWrap::COMGETTER(Proto)(NATProtocol_T *aProto)
{
    LogRelFlow(("{%p} %s: enter aProto=%p\n", this, "NATRedirectEvent::getProto", aProto));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProto);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProto(aProto);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProto=%RU32 hrc=%Rhrc\n", this, "NATRedirectEvent::getProto", *aProto, hrc));
    return hrc;
}

STDMETHODIMP NATRedirectEventWrap::COMGETTER(HostIP)(BSTR *aHostIP)
{
    LogRelFlow(("{%p} %s: enter aHostIP=%p\n", this, "NATRedirectEvent::getHostIP", aHostIP));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHostIP);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHostIP(BSTROutConverter(aHostIP).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHostIP=%ls hrc=%Rhrc\n", this, "NATRedirectEvent::getHostIP", *aHostIP, hrc));
    return hrc;
}

STDMETHODIMP NATRedirectEventWrap::COMGETTER(HostPort)(LONG *aHostPort)
{
    LogRelFlow(("{%p} %s: enter aHostPort=%p\n", this, "NATRedirectEvent::getHostPort", aHostPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHostPort);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHostPort(aHostPort);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHostPort=%RI32 hrc=%Rhrc\n", this, "NATRedirectEvent::getHostPort", *aHostPort, hrc));
    return hrc;
}

STDMETHODIMP NATRedirectEventWrap::COMGETTER(GuestIP)(BSTR *aGuestIP)
{
    LogRelFlow(("{%p} %s: enter aGuestIP=%p\n", this, "NATRedirectEvent::getGuestIP", aGuestIP));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGuestIP);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGuestIP(BSTROutConverter(aGuestIP).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGuestIP=%ls hrc=%Rhrc\n", this, "NATRedirectEvent::getGuestIP", *aGuestIP, hrc));
    return hrc;
}

STDMETHODIMP NATRedirectEventWrap::COMGETTER(GuestPort)(LONG *aGuestPort)
{
    LogRelFlow(("{%p} %s: enter aGuestPort=%p\n", this, "NATRedirectEvent::getGuestPort", aGuestPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGuestPort);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGuestPort(aGuestPort);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGuestPort=%RI32 hrc=%Rhrc\n", this, "NATRedirectEvent::getGuestPort", *aGuestPort, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP NATRedirectEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "NATRedirectEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATRedirectEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP NATRedirectEventWrap::WaitProcessed(LONG aTimeout,
                                                 BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "NATRedirectEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "NATRedirectEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IMachineEvent methods
//

//
// INATRedirectEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(NATRedirectEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS3_CI(NATRedirectEventWrap, INATRedirectEvent, IMachineEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "NATRedirectEventWrap.cpp"

// ##### BEGINFILE "HostPCIDevicePlugEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IHostPCIDevicePlugEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef HostPCIDevicePlugEventWrap_H_
#define HostPCIDevicePlugEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE HostPCIDevicePlugEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IHostPCIDevicePlugEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(HostPCIDevicePlugEventWrap, IHostPCIDevicePlugEvent)
    DECLARE_NOT_AGGREGATABLE(HostPCIDevicePlugEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(HostPCIDevicePlugEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IHostPCIDevicePlugEvent)
        COM_INTERFACE_ENTRY(IMachineEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IHostPCIDevicePlugEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(HostPCIDevicePlugEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IMachineEvent properties
    STDMETHOD(COMGETTER(MachineId))(BSTR *aMachineId);

    // public IHostPCIDevicePlugEvent properties
    STDMETHOD(COMGETTER(Plugged))(BOOL *aPlugged);
    STDMETHOD(COMGETTER(Success))(BOOL *aSuccess);
    STDMETHOD(COMGETTER(Attachment))(IPCIDeviceAttachment **aAttachment);
    STDMETHOD(COMGETTER(Message))(BSTR *aMessage);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IMachineEvent methods

    // public IHostPCIDevicePlugEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IMachineEvent properties
    virtual HRESULT getMachineId(com::Guid &aMachineId) = 0;

    // wrapped IHostPCIDevicePlugEvent properties
    virtual HRESULT getPlugged(BOOL *aPlugged) = 0;
    virtual HRESULT getSuccess(BOOL *aSuccess) = 0;
    virtual HRESULT getAttachment(ComPtr<IPCIDeviceAttachment> &aAttachment) = 0;
    virtual HRESULT getMessage(com::Utf8Str &aMessage) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IMachineEvent methods

    // wrapped IHostPCIDevicePlugEvent methods
};

#endif // !HostPCIDevicePlugEventWrap_H_

// ##### ENDFILE "HostPCIDevicePlugEventWrap.h"

// ##### BEGINFILE "HostPCIDevicePlugEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IHostPCIDevicePlugEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_HOSTPCIDEVICEPLUGEVENT

#include "HostPCIDevicePlugEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(HostPCIDevicePlugEventWrap)

//
// IEvent properties
//

STDMETHODIMP HostPCIDevicePlugEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "HostPCIDevicePlugEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "HostPCIDevicePlugEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP HostPCIDevicePlugEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "HostPCIDevicePlugEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "HostPCIDevicePlugEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP HostPCIDevicePlugEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "HostPCIDevicePlugEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "HostPCIDevicePlugEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IMachineEvent properties
//

STDMETHODIMP HostPCIDevicePlugEventWrap::COMGETTER(MachineId)(BSTR *aMachineId)
{
    LogRelFlow(("{%p} %s: enter aMachineId=%p\n", this, "HostPCIDevicePlugEvent::getMachineId", aMachineId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMachineId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMachineId(UuidOutConverter(aMachineId).uuid());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMachineId=%ls hrc=%Rhrc\n", this, "HostPCIDevicePlugEvent::getMachineId", *aMachineId, hrc));
    return hrc;
}

//
// IHostPCIDevicePlugEvent properties
//

STDMETHODIMP HostPCIDevicePlugEventWrap::COMGETTER(Plugged)(BOOL *aPlugged)
{
    LogRelFlow(("{%p} %s: enter aPlugged=%p\n", this, "HostPCIDevicePlugEvent::getPlugged", aPlugged));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aPlugged);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getPlugged(aPlugged);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aPlugged=%RTbool hrc=%Rhrc\n", this, "HostPCIDevicePlugEvent::getPlugged", *aPlugged, hrc));
    return hrc;
}

STDMETHODIMP HostPCIDevicePlugEventWrap::COMGETTER(Success)(BOOL *aSuccess)
{
    LogRelFlow(("{%p} %s: enter aSuccess=%p\n", this, "HostPCIDevicePlugEvent::getSuccess", aSuccess));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSuccess);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSuccess(aSuccess);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSuccess=%RTbool hrc=%Rhrc\n", this, "HostPCIDevicePlugEvent::getSuccess", *aSuccess, hrc));
    return hrc;
}

STDMETHODIMP HostPCIDevicePlugEventWrap::COMGETTER(Attachment)(IPCIDeviceAttachment **aAttachment)
{
    LogRelFlow(("{%p} %s: enter aAttachment=%p\n", this, "HostPCIDevicePlugEvent::getAttachment", aAttachment));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAttachment);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAttachment(ComTypeOutConverter<IPCIDeviceAttachment>(aAttachment).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAttachment=%p hrc=%Rhrc\n", this, "HostPCIDevicePlugEvent::getAttachment", *aAttachment, hrc));
    return hrc;
}

STDMETHODIMP HostPCIDevicePlugEventWrap::COMGETTER(Message)(BSTR *aMessage)
{
    LogRelFlow(("{%p} %s: enter aMessage=%p\n", this, "HostPCIDevicePlugEvent::getMessage", aMessage));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aMessage);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getMessage(BSTROutConverter(aMessage).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aMessage=%ls hrc=%Rhrc\n", this, "HostPCIDevicePlugEvent::getMessage", *aMessage, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP HostPCIDevicePlugEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "HostPCIDevicePlugEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "HostPCIDevicePlugEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP HostPCIDevicePlugEventWrap::WaitProcessed(LONG aTimeout,
                                                       BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "HostPCIDevicePlugEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "HostPCIDevicePlugEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IMachineEvent methods
//

//
// IHostPCIDevicePlugEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(HostPCIDevicePlugEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS3_CI(HostPCIDevicePlugEventWrap, IHostPCIDevicePlugEvent, IMachineEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "HostPCIDevicePlugEventWrap.cpp"

// ##### BEGINFILE "VBoxSVCAvailabilityChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IVBoxSVCAvailabilityChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef VBoxSVCAvailabilityChangedEventWrap_H_
#define VBoxSVCAvailabilityChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE VBoxSVCAvailabilityChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IVBoxSVCAvailabilityChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(VBoxSVCAvailabilityChangedEventWrap, IVBoxSVCAvailabilityChangedEvent)
    DECLARE_NOT_AGGREGATABLE(VBoxSVCAvailabilityChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(VBoxSVCAvailabilityChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IVBoxSVCAvailabilityChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IVBoxSVCAvailabilityChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(VBoxSVCAvailabilityChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IVBoxSVCAvailabilityChangedEvent properties
    STDMETHOD(COMGETTER(Available))(BOOL *aAvailable);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IVBoxSVCAvailabilityChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IVBoxSVCAvailabilityChangedEvent properties
    virtual HRESULT getAvailable(BOOL *aAvailable) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IVBoxSVCAvailabilityChangedEvent methods
};

#endif // !VBoxSVCAvailabilityChangedEventWrap_H_

// ##### ENDFILE "VBoxSVCAvailabilityChangedEventWrap.h"

// ##### BEGINFILE "VBoxSVCAvailabilityChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IVBoxSVCAvailabilityChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_VBOXSVCAVAILABILITYCHANGEDEVENT

#include "VBoxSVCAvailabilityChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(VBoxSVCAvailabilityChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP VBoxSVCAvailabilityChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "VBoxSVCAvailabilityChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "VBoxSVCAvailabilityChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP VBoxSVCAvailabilityChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "VBoxSVCAvailabilityChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "VBoxSVCAvailabilityChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP VBoxSVCAvailabilityChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "VBoxSVCAvailabilityChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "VBoxSVCAvailabilityChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IVBoxSVCAvailabilityChangedEvent properties
//

STDMETHODIMP VBoxSVCAvailabilityChangedEventWrap::COMGETTER(Available)(BOOL *aAvailable)
{
    LogRelFlow(("{%p} %s: enter aAvailable=%p\n", this, "VBoxSVCAvailabilityChangedEvent::getAvailable", aAvailable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAvailable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAvailable(aAvailable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAvailable=%RTbool hrc=%Rhrc\n", this, "VBoxSVCAvailabilityChangedEvent::getAvailable", *aAvailable, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP VBoxSVCAvailabilityChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "VBoxSVCAvailabilityChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "VBoxSVCAvailabilityChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP VBoxSVCAvailabilityChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                                BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "VBoxSVCAvailabilityChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "VBoxSVCAvailabilityChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IVBoxSVCAvailabilityChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(VBoxSVCAvailabilityChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(VBoxSVCAvailabilityChangedEventWrap, IVBoxSVCAvailabilityChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "VBoxSVCAvailabilityChangedEventWrap.cpp"

// ##### BEGINFILE "BandwidthGroupChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IBandwidthGroupChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef BandwidthGroupChangedEventWrap_H_
#define BandwidthGroupChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE BandwidthGroupChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IBandwidthGroupChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(BandwidthGroupChangedEventWrap, IBandwidthGroupChangedEvent)
    DECLARE_NOT_AGGREGATABLE(BandwidthGroupChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(BandwidthGroupChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IBandwidthGroupChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IBandwidthGroupChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(BandwidthGroupChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IBandwidthGroupChangedEvent properties
    STDMETHOD(COMGETTER(BandwidthGroup))(IBandwidthGroup **aBandwidthGroup);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IBandwidthGroupChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IBandwidthGroupChangedEvent properties
    virtual HRESULT getBandwidthGroup(ComPtr<IBandwidthGroup> &aBandwidthGroup) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IBandwidthGroupChangedEvent methods
};

#endif // !BandwidthGroupChangedEventWrap_H_

// ##### ENDFILE "BandwidthGroupChangedEventWrap.h"

// ##### BEGINFILE "BandwidthGroupChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IBandwidthGroupChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_BANDWIDTHGROUPCHANGEDEVENT

#include "BandwidthGroupChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(BandwidthGroupChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP BandwidthGroupChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "BandwidthGroupChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "BandwidthGroupChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP BandwidthGroupChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "BandwidthGroupChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "BandwidthGroupChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP BandwidthGroupChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "BandwidthGroupChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "BandwidthGroupChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IBandwidthGroupChangedEvent properties
//

STDMETHODIMP BandwidthGroupChangedEventWrap::COMGETTER(BandwidthGroup)(IBandwidthGroup **aBandwidthGroup)
{
    LogRelFlow(("{%p} %s: enter aBandwidthGroup=%p\n", this, "BandwidthGroupChangedEvent::getBandwidthGroup", aBandwidthGroup));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aBandwidthGroup);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getBandwidthGroup(ComTypeOutConverter<IBandwidthGroup>(aBandwidthGroup).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aBandwidthGroup=%p hrc=%Rhrc\n", this, "BandwidthGroupChangedEvent::getBandwidthGroup", *aBandwidthGroup, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP BandwidthGroupChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "BandwidthGroupChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "BandwidthGroupChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP BandwidthGroupChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                           BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "BandwidthGroupChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "BandwidthGroupChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IBandwidthGroupChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(BandwidthGroupChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(BandwidthGroupChangedEventWrap, IBandwidthGroupChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "BandwidthGroupChangedEventWrap.cpp"

// ##### BEGINFILE "GuestMonitorChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestMonitorChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestMonitorChangedEventWrap_H_
#define GuestMonitorChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestMonitorChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestMonitorChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestMonitorChangedEventWrap, IGuestMonitorChangedEvent)
    DECLARE_NOT_AGGREGATABLE(GuestMonitorChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestMonitorChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestMonitorChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestMonitorChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestMonitorChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IGuestMonitorChangedEvent properties
    STDMETHOD(COMGETTER(ChangeType))(GuestMonitorChangedEventType_T *aChangeType);
    STDMETHOD(COMGETTER(ScreenId))(ULONG *aScreenId);
    STDMETHOD(COMGETTER(OriginX))(ULONG *aOriginX);
    STDMETHOD(COMGETTER(OriginY))(ULONG *aOriginY);
    STDMETHOD(COMGETTER(Width))(ULONG *aWidth);
    STDMETHOD(COMGETTER(Height))(ULONG *aHeight);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IGuestMonitorChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IGuestMonitorChangedEvent properties
    virtual HRESULT getChangeType(GuestMonitorChangedEventType_T *aChangeType) = 0;
    virtual HRESULT getScreenId(ULONG *aScreenId) = 0;
    virtual HRESULT getOriginX(ULONG *aOriginX) = 0;
    virtual HRESULT getOriginY(ULONG *aOriginY) = 0;
    virtual HRESULT getWidth(ULONG *aWidth) = 0;
    virtual HRESULT getHeight(ULONG *aHeight) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IGuestMonitorChangedEvent methods
};

#endif // !GuestMonitorChangedEventWrap_H_

// ##### ENDFILE "GuestMonitorChangedEventWrap.h"

// ##### BEGINFILE "GuestMonitorChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestMonitorChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTMONITORCHANGEDEVENT

#include "GuestMonitorChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestMonitorChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP GuestMonitorChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestMonitorChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestMonitorChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestMonitorChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "GuestMonitorChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "GuestMonitorChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP GuestMonitorChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "GuestMonitorChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "GuestMonitorChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IGuestMonitorChangedEvent properties
//

STDMETHODIMP GuestMonitorChangedEventWrap::COMGETTER(ChangeType)(GuestMonitorChangedEventType_T *aChangeType)
{
    LogRelFlow(("{%p} %s: enter aChangeType=%p\n", this, "GuestMonitorChangedEvent::getChangeType", aChangeType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aChangeType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getChangeType(aChangeType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aChangeType=%RU32 hrc=%Rhrc\n", this, "GuestMonitorChangedEvent::getChangeType", *aChangeType, hrc));
    return hrc;
}

STDMETHODIMP GuestMonitorChangedEventWrap::COMGETTER(ScreenId)(ULONG *aScreenId)
{
    LogRelFlow(("{%p} %s: enter aScreenId=%p\n", this, "GuestMonitorChangedEvent::getScreenId", aScreenId));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aScreenId);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getScreenId(aScreenId);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aScreenId=%RU32 hrc=%Rhrc\n", this, "GuestMonitorChangedEvent::getScreenId", *aScreenId, hrc));
    return hrc;
}

STDMETHODIMP GuestMonitorChangedEventWrap::COMGETTER(OriginX)(ULONG *aOriginX)
{
    LogRelFlow(("{%p} %s: enter aOriginX=%p\n", this, "GuestMonitorChangedEvent::getOriginX", aOriginX));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOriginX);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOriginX(aOriginX);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOriginX=%RU32 hrc=%Rhrc\n", this, "GuestMonitorChangedEvent::getOriginX", *aOriginX, hrc));
    return hrc;
}

STDMETHODIMP GuestMonitorChangedEventWrap::COMGETTER(OriginY)(ULONG *aOriginY)
{
    LogRelFlow(("{%p} %s: enter aOriginY=%p\n", this, "GuestMonitorChangedEvent::getOriginY", aOriginY));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aOriginY);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getOriginY(aOriginY);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aOriginY=%RU32 hrc=%Rhrc\n", this, "GuestMonitorChangedEvent::getOriginY", *aOriginY, hrc));
    return hrc;
}

STDMETHODIMP GuestMonitorChangedEventWrap::COMGETTER(Width)(ULONG *aWidth)
{
    LogRelFlow(("{%p} %s: enter aWidth=%p\n", this, "GuestMonitorChangedEvent::getWidth", aWidth));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWidth);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWidth(aWidth);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWidth=%RU32 hrc=%Rhrc\n", this, "GuestMonitorChangedEvent::getWidth", *aWidth, hrc));
    return hrc;
}

STDMETHODIMP GuestMonitorChangedEventWrap::COMGETTER(Height)(ULONG *aHeight)
{
    LogRelFlow(("{%p} %s: enter aHeight=%p\n", this, "GuestMonitorChangedEvent::getHeight", aHeight));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHeight);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHeight(aHeight);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHeight=%RU32 hrc=%Rhrc\n", this, "GuestMonitorChangedEvent::getHeight", *aHeight, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP GuestMonitorChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestMonitorChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestMonitorChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP GuestMonitorChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                         BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "GuestMonitorChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "GuestMonitorChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IGuestMonitorChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestMonitorChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(GuestMonitorChangedEventWrap, IGuestMonitorChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestMonitorChangedEventWrap.cpp"

// ##### BEGINFILE "GuestUserStateChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IGuestUserStateChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef GuestUserStateChangedEventWrap_H_
#define GuestUserStateChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE GuestUserStateChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IGuestUserStateChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(GuestUserStateChangedEventWrap, IGuestUserStateChangedEvent)
    DECLARE_NOT_AGGREGATABLE(GuestUserStateChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(GuestUserStateChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IGuestUserStateChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IGuestUserStateChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(GuestUserStateChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IGuestUserStateChangedEvent properties
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(Domain))(BSTR *aDomain);
    STDMETHOD(COMGETTER(State))(GuestUserState_T *aState);
    STDMETHOD(COMGETTER(StateDetails))(BSTR *aStateDetails);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IGuestUserStateChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IGuestUserStateChangedEvent properties
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getDomain(com::Utf8Str &aDomain) = 0;
    virtual HRESULT getState(GuestUserState_T *aState) = 0;
    virtual HRESULT getStateDetails(com::Utf8Str &aStateDetails) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IGuestUserStateChangedEvent methods
};

#endif // !GuestUserStateChangedEventWrap_H_

// ##### ENDFILE "GuestUserStateChangedEventWrap.h"

// ##### BEGINFILE "GuestUserStateChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IGuestUserStateChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_GUESTUSERSTATECHANGEDEVENT

#include "GuestUserStateChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(GuestUserStateChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP GuestUserStateChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "GuestUserStateChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "GuestUserStateChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP GuestUserStateChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "GuestUserStateChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "GuestUserStateChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP GuestUserStateChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "GuestUserStateChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "GuestUserStateChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IGuestUserStateChangedEvent properties
//

STDMETHODIMP GuestUserStateChangedEventWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "GuestUserStateChangedEvent::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "GuestUserStateChangedEvent::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP GuestUserStateChangedEventWrap::COMGETTER(Domain)(BSTR *aDomain)
{
    LogRelFlow(("{%p} %s: enter aDomain=%p\n", this, "GuestUserStateChangedEvent::getDomain", aDomain));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aDomain);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getDomain(BSTROutConverter(aDomain).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aDomain=%ls hrc=%Rhrc\n", this, "GuestUserStateChangedEvent::getDomain", *aDomain, hrc));
    return hrc;
}

STDMETHODIMP GuestUserStateChangedEventWrap::COMGETTER(State)(GuestUserState_T *aState)
{
    LogRelFlow(("{%p} %s: enter aState=%p\n", this, "GuestUserStateChangedEvent::getState", aState));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aState);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getState(aState);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aState=%RU32 hrc=%Rhrc\n", this, "GuestUserStateChangedEvent::getState", *aState, hrc));
    return hrc;
}

STDMETHODIMP GuestUserStateChangedEventWrap::COMGETTER(StateDetails)(BSTR *aStateDetails)
{
    LogRelFlow(("{%p} %s: enter aStateDetails=%p\n", this, "GuestUserStateChangedEvent::getStateDetails", aStateDetails));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStateDetails);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getStateDetails(BSTROutConverter(aStateDetails).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aStateDetails=%ls hrc=%Rhrc\n", this, "GuestUserStateChangedEvent::getStateDetails", *aStateDetails, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP GuestUserStateChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "GuestUserStateChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "GuestUserStateChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP GuestUserStateChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                           BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "GuestUserStateChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "GuestUserStateChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IGuestUserStateChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(GuestUserStateChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(GuestUserStateChangedEventWrap, IGuestUserStateChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "GuestUserStateChangedEventWrap.cpp"

// ##### BEGINFILE "StorageDeviceChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IStorageDeviceChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef StorageDeviceChangedEventWrap_H_
#define StorageDeviceChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE StorageDeviceChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IStorageDeviceChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(StorageDeviceChangedEventWrap, IStorageDeviceChangedEvent)
    DECLARE_NOT_AGGREGATABLE(StorageDeviceChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(StorageDeviceChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IStorageDeviceChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IStorageDeviceChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(StorageDeviceChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IStorageDeviceChangedEvent properties
    STDMETHOD(COMGETTER(StorageDevice))(IMediumAttachment **aStorageDevice);
    STDMETHOD(COMGETTER(Removed))(BOOL *aRemoved);
    STDMETHOD(COMGETTER(Silent))(BOOL *aSilent);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IStorageDeviceChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IStorageDeviceChangedEvent properties
    virtual HRESULT getStorageDevice(ComPtr<IMediumAttachment> &aStorageDevice) = 0;
    virtual HRESULT getRemoved(BOOL *aRemoved) = 0;
    virtual HRESULT getSilent(BOOL *aSilent) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IStorageDeviceChangedEvent methods
};

#endif // !StorageDeviceChangedEventWrap_H_

// ##### ENDFILE "StorageDeviceChangedEventWrap.h"

// ##### BEGINFILE "StorageDeviceChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IStorageDeviceChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_STORAGEDEVICECHANGEDEVENT

#include "StorageDeviceChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(StorageDeviceChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP StorageDeviceChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "StorageDeviceChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "StorageDeviceChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP StorageDeviceChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "StorageDeviceChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "StorageDeviceChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP StorageDeviceChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "StorageDeviceChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "StorageDeviceChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IStorageDeviceChangedEvent properties
//

STDMETHODIMP StorageDeviceChangedEventWrap::COMGETTER(StorageDevice)(IMediumAttachment **aStorageDevice)
{
    LogRelFlow(("{%p} %s: enter aStorageDevice=%p\n", this, "StorageDeviceChangedEvent::getStorageDevice", aStorageDevice));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStorageDevice);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getStorageDevice(ComTypeOutConverter<IMediumAttachment>(aStorageDevice).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aStorageDevice=%p hrc=%Rhrc\n", this, "StorageDeviceChangedEvent::getStorageDevice", *aStorageDevice, hrc));
    return hrc;
}

STDMETHODIMP StorageDeviceChangedEventWrap::COMGETTER(Removed)(BOOL *aRemoved)
{
    LogRelFlow(("{%p} %s: enter aRemoved=%p\n", this, "StorageDeviceChangedEvent::getRemoved", aRemoved));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aRemoved);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getRemoved(aRemoved);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aRemoved=%RTbool hrc=%Rhrc\n", this, "StorageDeviceChangedEvent::getRemoved", *aRemoved, hrc));
    return hrc;
}

STDMETHODIMP StorageDeviceChangedEventWrap::COMGETTER(Silent)(BOOL *aSilent)
{
    LogRelFlow(("{%p} %s: enter aSilent=%p\n", this, "StorageDeviceChangedEvent::getSilent", aSilent));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSilent);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSilent(aSilent);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSilent=%RTbool hrc=%Rhrc\n", this, "StorageDeviceChangedEvent::getSilent", *aSilent, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP StorageDeviceChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "StorageDeviceChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "StorageDeviceChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP StorageDeviceChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                          BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "StorageDeviceChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "StorageDeviceChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IStorageDeviceChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(StorageDeviceChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(StorageDeviceChangedEventWrap, IStorageDeviceChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "StorageDeviceChangedEventWrap.cpp"

// ##### BEGINFILE "NATNetworkChangedEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for INATNetworkChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef NATNetworkChangedEventWrap_H_
#define NATNetworkChangedEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE NATNetworkChangedEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(INATNetworkChangedEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(NATNetworkChangedEventWrap, INATNetworkChangedEvent)
    DECLARE_NOT_AGGREGATABLE(NATNetworkChangedEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(NATNetworkChangedEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(INATNetworkChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, INATNetworkChangedEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(NATNetworkChangedEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public INATNetworkChangedEvent properties
    STDMETHOD(COMGETTER(NetworkName))(BSTR *aNetworkName);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public INATNetworkChangedEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped INATNetworkChangedEvent properties
    virtual HRESULT getNetworkName(com::Utf8Str &aNetworkName) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped INATNetworkChangedEvent methods
};

#endif // !NATNetworkChangedEventWrap_H_

// ##### ENDFILE "NATNetworkChangedEventWrap.h"

// ##### BEGINFILE "NATNetworkChangedEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for INATNetworkChangedEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_NATNETWORKCHANGEDEVENT

#include "NATNetworkChangedEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(NATNetworkChangedEventWrap)

//
// IEvent properties
//

STDMETHODIMP NATNetworkChangedEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "NATNetworkChangedEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "NATNetworkChangedEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkChangedEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "NATNetworkChangedEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "NATNetworkChangedEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkChangedEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "NATNetworkChangedEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "NATNetworkChangedEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// INATNetworkChangedEvent properties
//

STDMETHODIMP NATNetworkChangedEventWrap::COMGETTER(NetworkName)(BSTR *aNetworkName)
{
    LogRelFlow(("{%p} %s: enter aNetworkName=%p\n", this, "NATNetworkChangedEvent::getNetworkName", aNetworkName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNetworkName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNetworkName(BSTROutConverter(aNetworkName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNetworkName=%ls hrc=%Rhrc\n", this, "NATNetworkChangedEvent::getNetworkName", *aNetworkName, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP NATNetworkChangedEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "NATNetworkChangedEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATNetworkChangedEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP NATNetworkChangedEventWrap::WaitProcessed(LONG aTimeout,
                                                       BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "NATNetworkChangedEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "NATNetworkChangedEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// INATNetworkChangedEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(NATNetworkChangedEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(NATNetworkChangedEventWrap, INATNetworkChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "NATNetworkChangedEventWrap.cpp"

// ##### BEGINFILE "NATNetworkStartStopEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for INATNetworkStartStopEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef NATNetworkStartStopEventWrap_H_
#define NATNetworkStartStopEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE NATNetworkStartStopEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(INATNetworkStartStopEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(NATNetworkStartStopEventWrap, INATNetworkStartStopEvent)
    DECLARE_NOT_AGGREGATABLE(NATNetworkStartStopEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(NATNetworkStartStopEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(INATNetworkStartStopEvent)
        COM_INTERFACE_ENTRY(INATNetworkChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, INATNetworkStartStopEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(NATNetworkStartStopEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public INATNetworkChangedEvent properties
    STDMETHOD(COMGETTER(NetworkName))(BSTR *aNetworkName);

    // public INATNetworkStartStopEvent properties
    STDMETHOD(COMGETTER(StartEvent))(BOOL *aStartEvent);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public INATNetworkChangedEvent methods

    // public INATNetworkStartStopEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped INATNetworkChangedEvent properties
    virtual HRESULT getNetworkName(com::Utf8Str &aNetworkName) = 0;

    // wrapped INATNetworkStartStopEvent properties
    virtual HRESULT getStartEvent(BOOL *aStartEvent) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped INATNetworkChangedEvent methods

    // wrapped INATNetworkStartStopEvent methods
};

#endif // !NATNetworkStartStopEventWrap_H_

// ##### ENDFILE "NATNetworkStartStopEventWrap.h"

// ##### BEGINFILE "NATNetworkStartStopEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for INATNetworkStartStopEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_NATNETWORKSTARTSTOPEVENT

#include "NATNetworkStartStopEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(NATNetworkStartStopEventWrap)

//
// IEvent properties
//

STDMETHODIMP NATNetworkStartStopEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "NATNetworkStartStopEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "NATNetworkStartStopEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkStartStopEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "NATNetworkStartStopEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "NATNetworkStartStopEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkStartStopEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "NATNetworkStartStopEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "NATNetworkStartStopEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// INATNetworkChangedEvent properties
//

STDMETHODIMP NATNetworkStartStopEventWrap::COMGETTER(NetworkName)(BSTR *aNetworkName)
{
    LogRelFlow(("{%p} %s: enter aNetworkName=%p\n", this, "NATNetworkStartStopEvent::getNetworkName", aNetworkName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNetworkName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNetworkName(BSTROutConverter(aNetworkName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNetworkName=%ls hrc=%Rhrc\n", this, "NATNetworkStartStopEvent::getNetworkName", *aNetworkName, hrc));
    return hrc;
}

//
// INATNetworkStartStopEvent properties
//

STDMETHODIMP NATNetworkStartStopEventWrap::COMGETTER(StartEvent)(BOOL *aStartEvent)
{
    LogRelFlow(("{%p} %s: enter aStartEvent=%p\n", this, "NATNetworkStartStopEvent::getStartEvent", aStartEvent));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aStartEvent);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getStartEvent(aStartEvent);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aStartEvent=%RTbool hrc=%Rhrc\n", this, "NATNetworkStartStopEvent::getStartEvent", *aStartEvent, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP NATNetworkStartStopEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "NATNetworkStartStopEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATNetworkStartStopEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP NATNetworkStartStopEventWrap::WaitProcessed(LONG aTimeout,
                                                         BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "NATNetworkStartStopEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "NATNetworkStartStopEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// INATNetworkChangedEvent methods
//

//
// INATNetworkStartStopEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(NATNetworkStartStopEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS3_CI(NATNetworkStartStopEventWrap, INATNetworkStartStopEvent, INATNetworkChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "NATNetworkStartStopEventWrap.cpp"

// ##### BEGINFILE "NATNetworkAlterEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for INATNetworkAlterEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef NATNetworkAlterEventWrap_H_
#define NATNetworkAlterEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE NATNetworkAlterEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(INATNetworkAlterEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(NATNetworkAlterEventWrap, INATNetworkAlterEvent)
    DECLARE_NOT_AGGREGATABLE(NATNetworkAlterEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(NATNetworkAlterEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(INATNetworkAlterEvent)
        COM_INTERFACE_ENTRY(INATNetworkChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, INATNetworkAlterEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(NATNetworkAlterEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public INATNetworkChangedEvent properties
    STDMETHOD(COMGETTER(NetworkName))(BSTR *aNetworkName);

    // public INATNetworkAlterEvent properties

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public INATNetworkChangedEvent methods

    // public INATNetworkAlterEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped INATNetworkChangedEvent properties
    virtual HRESULT getNetworkName(com::Utf8Str &aNetworkName) = 0;

    // wrapped INATNetworkAlterEvent properties

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped INATNetworkChangedEvent methods

    // wrapped INATNetworkAlterEvent methods
};

#endif // !NATNetworkAlterEventWrap_H_

// ##### ENDFILE "NATNetworkAlterEventWrap.h"

// ##### BEGINFILE "NATNetworkAlterEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for INATNetworkAlterEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_NATNETWORKALTEREVENT

#include "NATNetworkAlterEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(NATNetworkAlterEventWrap)

//
// IEvent properties
//

STDMETHODIMP NATNetworkAlterEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "NATNetworkAlterEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "NATNetworkAlterEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkAlterEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "NATNetworkAlterEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "NATNetworkAlterEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkAlterEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "NATNetworkAlterEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "NATNetworkAlterEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// INATNetworkChangedEvent properties
//

STDMETHODIMP NATNetworkAlterEventWrap::COMGETTER(NetworkName)(BSTR *aNetworkName)
{
    LogRelFlow(("{%p} %s: enter aNetworkName=%p\n", this, "NATNetworkAlterEvent::getNetworkName", aNetworkName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNetworkName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNetworkName(BSTROutConverter(aNetworkName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNetworkName=%ls hrc=%Rhrc\n", this, "NATNetworkAlterEvent::getNetworkName", *aNetworkName, hrc));
    return hrc;
}

//
// INATNetworkAlterEvent properties
//

//
// IEvent methods
//

STDMETHODIMP NATNetworkAlterEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "NATNetworkAlterEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATNetworkAlterEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP NATNetworkAlterEventWrap::WaitProcessed(LONG aTimeout,
                                                     BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "NATNetworkAlterEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "NATNetworkAlterEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// INATNetworkChangedEvent methods
//

//
// INATNetworkAlterEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(NATNetworkAlterEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS3_CI(NATNetworkAlterEventWrap, INATNetworkAlterEvent, INATNetworkChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "NATNetworkAlterEventWrap.cpp"

// ##### BEGINFILE "NATNetworkCreationDeletionEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for INATNetworkCreationDeletionEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef NATNetworkCreationDeletionEventWrap_H_
#define NATNetworkCreationDeletionEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE NATNetworkCreationDeletionEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(INATNetworkCreationDeletionEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(NATNetworkCreationDeletionEventWrap, INATNetworkCreationDeletionEvent)
    DECLARE_NOT_AGGREGATABLE(NATNetworkCreationDeletionEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(NATNetworkCreationDeletionEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(INATNetworkCreationDeletionEvent)
        COM_INTERFACE_ENTRY(INATNetworkAlterEvent)
        COM_INTERFACE_ENTRY(INATNetworkChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, INATNetworkCreationDeletionEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(NATNetworkCreationDeletionEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public INATNetworkChangedEvent properties
    STDMETHOD(COMGETTER(NetworkName))(BSTR *aNetworkName);

    // public INATNetworkAlterEvent properties

    // public INATNetworkCreationDeletionEvent properties
    STDMETHOD(COMGETTER(CreationEvent))(BOOL *aCreationEvent);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public INATNetworkChangedEvent methods

    // public INATNetworkAlterEvent methods

    // public INATNetworkCreationDeletionEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped INATNetworkChangedEvent properties
    virtual HRESULT getNetworkName(com::Utf8Str &aNetworkName) = 0;

    // wrapped INATNetworkAlterEvent properties

    // wrapped INATNetworkCreationDeletionEvent properties
    virtual HRESULT getCreationEvent(BOOL *aCreationEvent) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped INATNetworkChangedEvent methods

    // wrapped INATNetworkAlterEvent methods

    // wrapped INATNetworkCreationDeletionEvent methods
};

#endif // !NATNetworkCreationDeletionEventWrap_H_

// ##### ENDFILE "NATNetworkCreationDeletionEventWrap.h"

// ##### BEGINFILE "NATNetworkCreationDeletionEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for INATNetworkCreationDeletionEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_NATNETWORKCREATIONDELETIONEVENT

#include "NATNetworkCreationDeletionEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(NATNetworkCreationDeletionEventWrap)

//
// IEvent properties
//

STDMETHODIMP NATNetworkCreationDeletionEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "NATNetworkCreationDeletionEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "NATNetworkCreationDeletionEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkCreationDeletionEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "NATNetworkCreationDeletionEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "NATNetworkCreationDeletionEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkCreationDeletionEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "NATNetworkCreationDeletionEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "NATNetworkCreationDeletionEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// INATNetworkChangedEvent properties
//

STDMETHODIMP NATNetworkCreationDeletionEventWrap::COMGETTER(NetworkName)(BSTR *aNetworkName)
{
    LogRelFlow(("{%p} %s: enter aNetworkName=%p\n", this, "NATNetworkCreationDeletionEvent::getNetworkName", aNetworkName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNetworkName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNetworkName(BSTROutConverter(aNetworkName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNetworkName=%ls hrc=%Rhrc\n", this, "NATNetworkCreationDeletionEvent::getNetworkName", *aNetworkName, hrc));
    return hrc;
}

//
// INATNetworkAlterEvent properties
//

//
// INATNetworkCreationDeletionEvent properties
//

STDMETHODIMP NATNetworkCreationDeletionEventWrap::COMGETTER(CreationEvent)(BOOL *aCreationEvent)
{
    LogRelFlow(("{%p} %s: enter aCreationEvent=%p\n", this, "NATNetworkCreationDeletionEvent::getCreationEvent", aCreationEvent));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCreationEvent);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getCreationEvent(aCreationEvent);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aCreationEvent=%RTbool hrc=%Rhrc\n", this, "NATNetworkCreationDeletionEvent::getCreationEvent", *aCreationEvent, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP NATNetworkCreationDeletionEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "NATNetworkCreationDeletionEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATNetworkCreationDeletionEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP NATNetworkCreationDeletionEventWrap::WaitProcessed(LONG aTimeout,
                                                                BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "NATNetworkCreationDeletionEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "NATNetworkCreationDeletionEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// INATNetworkChangedEvent methods
//

//
// INATNetworkAlterEvent methods
//

//
// INATNetworkCreationDeletionEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(NATNetworkCreationDeletionEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS4_CI(NATNetworkCreationDeletionEventWrap, INATNetworkCreationDeletionEvent, INATNetworkAlterEvent, INATNetworkChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "NATNetworkCreationDeletionEventWrap.cpp"

// ##### BEGINFILE "NATNetworkSettingEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for INATNetworkSettingEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef NATNetworkSettingEventWrap_H_
#define NATNetworkSettingEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE NATNetworkSettingEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(INATNetworkSettingEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(NATNetworkSettingEventWrap, INATNetworkSettingEvent)
    DECLARE_NOT_AGGREGATABLE(NATNetworkSettingEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(NATNetworkSettingEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(INATNetworkSettingEvent)
        COM_INTERFACE_ENTRY(INATNetworkAlterEvent)
        COM_INTERFACE_ENTRY(INATNetworkChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, INATNetworkSettingEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(NATNetworkSettingEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public INATNetworkChangedEvent properties
    STDMETHOD(COMGETTER(NetworkName))(BSTR *aNetworkName);

    // public INATNetworkAlterEvent properties

    // public INATNetworkSettingEvent properties
    STDMETHOD(COMGETTER(Enabled))(BOOL *aEnabled);
    STDMETHOD(COMGETTER(Network))(BSTR *aNetwork);
    STDMETHOD(COMGETTER(Gateway))(BSTR *aGateway);
    STDMETHOD(COMGETTER(AdvertiseDefaultIPv6RouteEnabled))(BOOL *aAdvertiseDefaultIPv6RouteEnabled);
    STDMETHOD(COMGETTER(NeedDhcpServer))(BOOL *aNeedDhcpServer);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public INATNetworkChangedEvent methods

    // public INATNetworkAlterEvent methods

    // public INATNetworkSettingEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped INATNetworkChangedEvent properties
    virtual HRESULT getNetworkName(com::Utf8Str &aNetworkName) = 0;

    // wrapped INATNetworkAlterEvent properties

    // wrapped INATNetworkSettingEvent properties
    virtual HRESULT getEnabled(BOOL *aEnabled) = 0;
    virtual HRESULT getNetwork(com::Utf8Str &aNetwork) = 0;
    virtual HRESULT getGateway(com::Utf8Str &aGateway) = 0;
    virtual HRESULT getAdvertiseDefaultIPv6RouteEnabled(BOOL *aAdvertiseDefaultIPv6RouteEnabled) = 0;
    virtual HRESULT getNeedDhcpServer(BOOL *aNeedDhcpServer) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped INATNetworkChangedEvent methods

    // wrapped INATNetworkAlterEvent methods

    // wrapped INATNetworkSettingEvent methods
};

#endif // !NATNetworkSettingEventWrap_H_

// ##### ENDFILE "NATNetworkSettingEventWrap.h"

// ##### BEGINFILE "NATNetworkSettingEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for INATNetworkSettingEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_NATNETWORKSETTINGEVENT

#include "NATNetworkSettingEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(NATNetworkSettingEventWrap)

//
// IEvent properties
//

STDMETHODIMP NATNetworkSettingEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "NATNetworkSettingEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "NATNetworkSettingEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkSettingEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "NATNetworkSettingEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "NATNetworkSettingEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkSettingEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "NATNetworkSettingEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "NATNetworkSettingEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// INATNetworkChangedEvent properties
//

STDMETHODIMP NATNetworkSettingEventWrap::COMGETTER(NetworkName)(BSTR *aNetworkName)
{
    LogRelFlow(("{%p} %s: enter aNetworkName=%p\n", this, "NATNetworkSettingEvent::getNetworkName", aNetworkName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNetworkName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNetworkName(BSTROutConverter(aNetworkName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNetworkName=%ls hrc=%Rhrc\n", this, "NATNetworkSettingEvent::getNetworkName", *aNetworkName, hrc));
    return hrc;
}

//
// INATNetworkAlterEvent properties
//

//
// INATNetworkSettingEvent properties
//

STDMETHODIMP NATNetworkSettingEventWrap::COMGETTER(Enabled)(BOOL *aEnabled)
{
    LogRelFlow(("{%p} %s: enter aEnabled=%p\n", this, "NATNetworkSettingEvent::getEnabled", aEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getEnabled(aEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aEnabled=%RTbool hrc=%Rhrc\n", this, "NATNetworkSettingEvent::getEnabled", *aEnabled, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkSettingEventWrap::COMGETTER(Network)(BSTR *aNetwork)
{
    LogRelFlow(("{%p} %s: enter aNetwork=%p\n", this, "NATNetworkSettingEvent::getNetwork", aNetwork));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNetwork);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNetwork(BSTROutConverter(aNetwork).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNetwork=%ls hrc=%Rhrc\n", this, "NATNetworkSettingEvent::getNetwork", *aNetwork, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkSettingEventWrap::COMGETTER(Gateway)(BSTR *aGateway)
{
    LogRelFlow(("{%p} %s: enter aGateway=%p\n", this, "NATNetworkSettingEvent::getGateway", aGateway));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGateway);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGateway(BSTROutConverter(aGateway).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGateway=%ls hrc=%Rhrc\n", this, "NATNetworkSettingEvent::getGateway", *aGateway, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkSettingEventWrap::COMGETTER(AdvertiseDefaultIPv6RouteEnabled)(BOOL *aAdvertiseDefaultIPv6RouteEnabled)
{
    LogRelFlow(("{%p} %s: enter aAdvertiseDefaultIPv6RouteEnabled=%p\n", this, "NATNetworkSettingEvent::getAdvertiseDefaultIPv6RouteEnabled", aAdvertiseDefaultIPv6RouteEnabled));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aAdvertiseDefaultIPv6RouteEnabled);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getAdvertiseDefaultIPv6RouteEnabled(aAdvertiseDefaultIPv6RouteEnabled);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aAdvertiseDefaultIPv6RouteEnabled=%RTbool hrc=%Rhrc\n", this, "NATNetworkSettingEvent::getAdvertiseDefaultIPv6RouteEnabled", *aAdvertiseDefaultIPv6RouteEnabled, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkSettingEventWrap::COMGETTER(NeedDhcpServer)(BOOL *aNeedDhcpServer)
{
    LogRelFlow(("{%p} %s: enter aNeedDhcpServer=%p\n", this, "NATNetworkSettingEvent::getNeedDhcpServer", aNeedDhcpServer));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNeedDhcpServer);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNeedDhcpServer(aNeedDhcpServer);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNeedDhcpServer=%RTbool hrc=%Rhrc\n", this, "NATNetworkSettingEvent::getNeedDhcpServer", *aNeedDhcpServer, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP NATNetworkSettingEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "NATNetworkSettingEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATNetworkSettingEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP NATNetworkSettingEventWrap::WaitProcessed(LONG aTimeout,
                                                       BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "NATNetworkSettingEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "NATNetworkSettingEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// INATNetworkChangedEvent methods
//

//
// INATNetworkAlterEvent methods
//

//
// INATNetworkSettingEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(NATNetworkSettingEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS4_CI(NATNetworkSettingEventWrap, INATNetworkSettingEvent, INATNetworkAlterEvent, INATNetworkChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "NATNetworkSettingEventWrap.cpp"

// ##### BEGINFILE "NATNetworkPortForwardEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for INATNetworkPortForwardEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef NATNetworkPortForwardEventWrap_H_
#define NATNetworkPortForwardEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE NATNetworkPortForwardEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(INATNetworkPortForwardEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(NATNetworkPortForwardEventWrap, INATNetworkPortForwardEvent)
    DECLARE_NOT_AGGREGATABLE(NATNetworkPortForwardEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(NATNetworkPortForwardEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(INATNetworkPortForwardEvent)
        COM_INTERFACE_ENTRY(INATNetworkAlterEvent)
        COM_INTERFACE_ENTRY(INATNetworkChangedEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, INATNetworkPortForwardEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(NATNetworkPortForwardEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public INATNetworkChangedEvent properties
    STDMETHOD(COMGETTER(NetworkName))(BSTR *aNetworkName);

    // public INATNetworkAlterEvent properties

    // public INATNetworkPortForwardEvent properties
    STDMETHOD(COMGETTER(Create))(BOOL *aCreate);
    STDMETHOD(COMGETTER(Ipv6))(BOOL *aIpv6);
    STDMETHOD(COMGETTER(Name))(BSTR *aName);
    STDMETHOD(COMGETTER(Proto))(NATProtocol_T *aProto);
    STDMETHOD(COMGETTER(HostIp))(BSTR *aHostIp);
    STDMETHOD(COMGETTER(HostPort))(LONG *aHostPort);
    STDMETHOD(COMGETTER(GuestIp))(BSTR *aGuestIp);
    STDMETHOD(COMGETTER(GuestPort))(LONG *aGuestPort);

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public INATNetworkChangedEvent methods

    // public INATNetworkAlterEvent methods

    // public INATNetworkPortForwardEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped INATNetworkChangedEvent properties
    virtual HRESULT getNetworkName(com::Utf8Str &aNetworkName) = 0;

    // wrapped INATNetworkAlterEvent properties

    // wrapped INATNetworkPortForwardEvent properties
    virtual HRESULT getCreate(BOOL *aCreate) = 0;
    virtual HRESULT getIpv6(BOOL *aIpv6) = 0;
    virtual HRESULT getName(com::Utf8Str &aName) = 0;
    virtual HRESULT getProto(NATProtocol_T *aProto) = 0;
    virtual HRESULT getHostIp(com::Utf8Str &aHostIp) = 0;
    virtual HRESULT getHostPort(LONG *aHostPort) = 0;
    virtual HRESULT getGuestIp(com::Utf8Str &aGuestIp) = 0;
    virtual HRESULT getGuestPort(LONG *aGuestPort) = 0;

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped INATNetworkChangedEvent methods

    // wrapped INATNetworkAlterEvent methods

    // wrapped INATNetworkPortForwardEvent methods
};

#endif // !NATNetworkPortForwardEventWrap_H_

// ##### ENDFILE "NATNetworkPortForwardEventWrap.h"

// ##### BEGINFILE "NATNetworkPortForwardEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for INATNetworkPortForwardEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_NATNETWORKPORTFORWARDEVENT

#include "NATNetworkPortForwardEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(NATNetworkPortForwardEventWrap)

//
// IEvent properties
//

STDMETHODIMP NATNetworkPortForwardEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "NATNetworkPortForwardEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "NATNetworkPortForwardEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkPortForwardEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "NATNetworkPortForwardEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "NATNetworkPortForwardEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkPortForwardEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "NATNetworkPortForwardEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "NATNetworkPortForwardEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// INATNetworkChangedEvent properties
//

STDMETHODIMP NATNetworkPortForwardEventWrap::COMGETTER(NetworkName)(BSTR *aNetworkName)
{
    LogRelFlow(("{%p} %s: enter aNetworkName=%p\n", this, "NATNetworkPortForwardEvent::getNetworkName", aNetworkName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aNetworkName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getNetworkName(BSTROutConverter(aNetworkName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aNetworkName=%ls hrc=%Rhrc\n", this, "NATNetworkPortForwardEvent::getNetworkName", *aNetworkName, hrc));
    return hrc;
}

//
// INATNetworkAlterEvent properties
//

//
// INATNetworkPortForwardEvent properties
//

STDMETHODIMP NATNetworkPortForwardEventWrap::COMGETTER(Create)(BOOL *aCreate)
{
    LogRelFlow(("{%p} %s: enter aCreate=%p\n", this, "NATNetworkPortForwardEvent::getCreate", aCreate));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aCreate);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getCreate(aCreate);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aCreate=%RTbool hrc=%Rhrc\n", this, "NATNetworkPortForwardEvent::getCreate", *aCreate, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkPortForwardEventWrap::COMGETTER(Ipv6)(BOOL *aIpv6)
{
    LogRelFlow(("{%p} %s: enter aIpv6=%p\n", this, "NATNetworkPortForwardEvent::getIpv6", aIpv6));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aIpv6);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getIpv6(aIpv6);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aIpv6=%RTbool hrc=%Rhrc\n", this, "NATNetworkPortForwardEvent::getIpv6", *aIpv6, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkPortForwardEventWrap::COMGETTER(Name)(BSTR *aName)
{
    LogRelFlow(("{%p} %s: enter aName=%p\n", this, "NATNetworkPortForwardEvent::getName", aName));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aName);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getName(BSTROutConverter(aName).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aName=%ls hrc=%Rhrc\n", this, "NATNetworkPortForwardEvent::getName", *aName, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkPortForwardEventWrap::COMGETTER(Proto)(NATProtocol_T *aProto)
{
    LogRelFlow(("{%p} %s: enter aProto=%p\n", this, "NATNetworkPortForwardEvent::getProto", aProto));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aProto);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getProto(aProto);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aProto=%RU32 hrc=%Rhrc\n", this, "NATNetworkPortForwardEvent::getProto", *aProto, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkPortForwardEventWrap::COMGETTER(HostIp)(BSTR *aHostIp)
{
    LogRelFlow(("{%p} %s: enter aHostIp=%p\n", this, "NATNetworkPortForwardEvent::getHostIp", aHostIp));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHostIp);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHostIp(BSTROutConverter(aHostIp).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHostIp=%ls hrc=%Rhrc\n", this, "NATNetworkPortForwardEvent::getHostIp", *aHostIp, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkPortForwardEventWrap::COMGETTER(HostPort)(LONG *aHostPort)
{
    LogRelFlow(("{%p} %s: enter aHostPort=%p\n", this, "NATNetworkPortForwardEvent::getHostPort", aHostPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aHostPort);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getHostPort(aHostPort);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aHostPort=%RI32 hrc=%Rhrc\n", this, "NATNetworkPortForwardEvent::getHostPort", *aHostPort, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkPortForwardEventWrap::COMGETTER(GuestIp)(BSTR *aGuestIp)
{
    LogRelFlow(("{%p} %s: enter aGuestIp=%p\n", this, "NATNetworkPortForwardEvent::getGuestIp", aGuestIp));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGuestIp);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGuestIp(BSTROutConverter(aGuestIp).str());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGuestIp=%ls hrc=%Rhrc\n", this, "NATNetworkPortForwardEvent::getGuestIp", *aGuestIp, hrc));
    return hrc;
}

STDMETHODIMP NATNetworkPortForwardEventWrap::COMGETTER(GuestPort)(LONG *aGuestPort)
{
    LogRelFlow(("{%p} %s: enter aGuestPort=%p\n", this, "NATNetworkPortForwardEvent::getGuestPort", aGuestPort));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aGuestPort);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getGuestPort(aGuestPort);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aGuestPort=%RI32 hrc=%Rhrc\n", this, "NATNetworkPortForwardEvent::getGuestPort", *aGuestPort, hrc));
    return hrc;
}

//
// IEvent methods
//

STDMETHODIMP NATNetworkPortForwardEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "NATNetworkPortForwardEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "NATNetworkPortForwardEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP NATNetworkPortForwardEventWrap::WaitProcessed(LONG aTimeout,
                                                           BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "NATNetworkPortForwardEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "NATNetworkPortForwardEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// INATNetworkChangedEvent methods
//

//
// INATNetworkAlterEvent methods
//

//
// INATNetworkPortForwardEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(NATNetworkPortForwardEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS4_CI(NATNetworkPortForwardEventWrap, INATNetworkPortForwardEvent, INATNetworkAlterEvent, INATNetworkChangedEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "NATNetworkPortForwardEventWrap.cpp"

// ##### BEGINFILE "HostNameResolutionConfigurationChangeEventWrap.h"
/** @file
 *
 * VirtualBox API class wrapper header for IHostNameResolutionConfigurationChangeEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#ifndef HostNameResolutionConfigurationChangeEventWrap_H_
#define HostNameResolutionConfigurationChangeEventWrap_H_

#include "VirtualBoxBase.h"
#include "Wrapper.h"

class ATL_NO_VTABLE HostNameResolutionConfigurationChangeEventWrap:
    public VirtualBoxBase,
    VBOX_SCRIPTABLE_IMPL(IHostNameResolutionConfigurationChangeEvent)
{
    Q_OBJECT

public:
    VIRTUALBOXBASE_ADD_ERRORINFO_SUPPORT(HostNameResolutionConfigurationChangeEventWrap, IHostNameResolutionConfigurationChangeEvent)
    DECLARE_NOT_AGGREGATABLE(HostNameResolutionConfigurationChangeEventWrap)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(HostNameResolutionConfigurationChangeEventWrap)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
        COM_INTERFACE_ENTRY(IHostNameResolutionConfigurationChangeEvent)
        COM_INTERFACE_ENTRY(IEvent)
        COM_INTERFACE_ENTRY2(IDispatch, IHostNameResolutionConfigurationChangeEvent)
    END_COM_MAP()

    DECLARE_EMPTY_CTOR_DTOR(HostNameResolutionConfigurationChangeEventWrap)

    // public IEvent properties
    STDMETHOD(COMGETTER(Type))(VBoxEventType_T *aType);
    STDMETHOD(COMGETTER(Source))(IEventSource **aSource);
    STDMETHOD(COMGETTER(Waitable))(BOOL *aWaitable);

    // public IHostNameResolutionConfigurationChangeEvent properties

    // public IEvent methods
    STDMETHOD(SetProcessed)();
    STDMETHOD(WaitProcessed)(LONG aTimeout,
                             BOOL *aResult);

    // public IHostNameResolutionConfigurationChangeEvent methods

private:
    // wrapped IEvent properties
    virtual HRESULT getType(VBoxEventType_T *aType) = 0;
    virtual HRESULT getSource(ComPtr<IEventSource> &aSource) = 0;
    virtual HRESULT getWaitable(BOOL *aWaitable) = 0;

    // wrapped IHostNameResolutionConfigurationChangeEvent properties

    // wrapped IEvent methods
    virtual HRESULT setProcessed() = 0;
    virtual HRESULT waitProcessed(LONG aTimeout,
                                  BOOL *aResult) = 0;

    // wrapped IHostNameResolutionConfigurationChangeEvent methods
};

#endif // !HostNameResolutionConfigurationChangeEventWrap_H_

// ##### ENDFILE "HostNameResolutionConfigurationChangeEventWrap.h"

// ##### BEGINFILE "HostNameResolutionConfigurationChangeEventWrap.cpp"
/** @file
 *
 * VirtualBox API class wrapper code for IHostNameResolutionConfigurationChangeEvent.
 *
 * DO NOT EDIT! This is a generated file.
 * Generated from: src/VBox/Main/idl/VirtualBox.xidl
 * Generator: src/VBox/Main/idl/apiwrap-server.xsl
 */

/**
 * Copyright (C) 2010-2014 Oracle Corporation
 *
 * This file is part of VirtualBox Open Source Edition (OSE), as
 * available from http://www.virtualbox.org. This file is free software;
 * you can redistribute it and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software
 * Foundation, in version 2 as it comes in the "COPYING" file of the
 * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 */

#define LOG_GROUP_MAIN_OVERRIDE LOG_GROUP_MAIN_HOSTNAMERESOLUTIONCONFIGURATIONCHANGEEVENT

#include "HostNameResolutionConfigurationChangeEventWrap.h"
#include "Logging.h"

DEFINE_EMPTY_CTOR_DTOR(HostNameResolutionConfigurationChangeEventWrap)

//
// IEvent properties
//

STDMETHODIMP HostNameResolutionConfigurationChangeEventWrap::COMGETTER(Type)(VBoxEventType_T *aType)
{
    LogRelFlow(("{%p} %s: enter aType=%p\n", this, "HostNameResolutionConfigurationChangeEvent::getType", aType));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aType);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getType(aType);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aType=%RU32 hrc=%Rhrc\n", this, "HostNameResolutionConfigurationChangeEvent::getType", *aType, hrc));
    return hrc;
}

STDMETHODIMP HostNameResolutionConfigurationChangeEventWrap::COMGETTER(Source)(IEventSource **aSource)
{
    LogRelFlow(("{%p} %s: enter aSource=%p\n", this, "HostNameResolutionConfigurationChangeEvent::getSource", aSource));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aSource);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getSource(ComTypeOutConverter<IEventSource>(aSource).ptr());
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aSource=%p hrc=%Rhrc\n", this, "HostNameResolutionConfigurationChangeEvent::getSource", *aSource, hrc));
    return hrc;
}

STDMETHODIMP HostNameResolutionConfigurationChangeEventWrap::COMGETTER(Waitable)(BOOL *aWaitable)
{
    LogRelFlow(("{%p} %s: enter aWaitable=%p\n", this, "HostNameResolutionConfigurationChangeEvent::getWaitable", aWaitable));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aWaitable);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = getWaitable(aWaitable);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave *aWaitable=%RTbool hrc=%Rhrc\n", this, "HostNameResolutionConfigurationChangeEvent::getWaitable", *aWaitable, hrc));
    return hrc;
}

//
// IHostNameResolutionConfigurationChangeEvent properties
//

//
// IEvent methods
//

STDMETHODIMP HostNameResolutionConfigurationChangeEventWrap::SetProcessed()
{
    LogRelFlow(("{%p} %s:enter\n", this, "HostNameResolutionConfigurationChangeEvent::setProcessed"));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = setProcessed();
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave hrc=%Rhrc\n", this, "HostNameResolutionConfigurationChangeEvent::setProcessed", hrc));
    return hrc;
}

STDMETHODIMP HostNameResolutionConfigurationChangeEventWrap::WaitProcessed(LONG aTimeout,
                                                                           BOOL *aResult)
{
    LogRelFlow(("{%p} %s:enter aTimeout=%RI32 aResult=%p\n", this, "HostNameResolutionConfigurationChangeEvent::waitProcessed", aTimeout, aResult));

    VirtualBoxBase::clearError();

    HRESULT hrc;

    try
    {
        CheckComArgOutPointerValidThrow(aResult);

        AutoCaller autoCaller(this);
        if (FAILED(autoCaller.rc()))
            throw autoCaller.rc();

        hrc = waitProcessed(aTimeout,
                            aResult);
    }
    catch (HRESULT hrc2)
    {
        hrc = hrc2;
    }
    catch (...)
    {
        hrc = VirtualBoxBase::handleUnexpectedExceptions(this, RT_SRC_POS);
    }

    LogRelFlow(("{%p} %s: leave aResult=%RTbool hrc=%Rhrc\n", this, "HostNameResolutionConfigurationChangeEvent::waitProcessed", *aResult, hrc));
    return hrc;
}

//
// IHostNameResolutionConfigurationChangeEvent methods
//

#ifdef VBOX_WITH_XPCOM
NS_DECL_CLASSINFO(HostNameResolutionConfigurationChangeEventWrap)
NS_IMPL_THREADSAFE_ISUPPORTS2_CI(HostNameResolutionConfigurationChangeEventWrap, IHostNameResolutionConfigurationChangeEvent, IEvent)
#endif // VBOX_WITH_XPCOM

// ##### ENDFILE "HostNameResolutionConfigurationChangeEventWrap.cpp"
