
// ##### BEGINFILE "COMEnums.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrappers for VirtualBox Main API (COM) enums.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/src/globals/COMWrappers.xsl
 */

#ifndef ___COMEnums_h___
#define ___COMEnums_h___

/* GUI includes: */
#include "COMDefs.h"

/* KSettingsVersion enum: */
enum KSettingsVersion
{
    KSettingsVersion_Null = ::SettingsVersion_Null,
    KSettingsVersion_v1_0 = ::SettingsVersion_v1_0,
    KSettingsVersion_v1_1 = ::SettingsVersion_v1_1,
    KSettingsVersion_v1_2 = ::SettingsVersion_v1_2,
    KSettingsVersion_v1_3pre = ::SettingsVersion_v1_3pre,
    KSettingsVersion_v1_3 = ::SettingsVersion_v1_3,
    KSettingsVersion_v1_4 = ::SettingsVersion_v1_4,
    KSettingsVersion_v1_5 = ::SettingsVersion_v1_5,
    KSettingsVersion_v1_6 = ::SettingsVersion_v1_6,
    KSettingsVersion_v1_7 = ::SettingsVersion_v1_7,
    KSettingsVersion_v1_8 = ::SettingsVersion_v1_8,
    KSettingsVersion_v1_9 = ::SettingsVersion_v1_9,
    KSettingsVersion_v1_10 = ::SettingsVersion_v1_10,
    KSettingsVersion_v1_11 = ::SettingsVersion_v1_11,
    KSettingsVersion_v1_12 = ::SettingsVersion_v1_12,
    KSettingsVersion_v1_13 = ::SettingsVersion_v1_13,
    KSettingsVersion_v1_14 = ::SettingsVersion_v1_14,
    KSettingsVersion_Future = ::SettingsVersion_Future,
    KSettingsVersion_Max
};

/* KAccessMode enum: */
enum KAccessMode
{
    KAccessMode_ReadOnly = ::AccessMode_ReadOnly,
    KAccessMode_ReadWrite = ::AccessMode_ReadWrite,
    KAccessMode_Max
};

/* KMachineState enum: */
enum KMachineState
{
    KMachineState_Null = ::MachineState_Null,
    KMachineState_PoweredOff = ::MachineState_PoweredOff,
    KMachineState_Saved = ::MachineState_Saved,
    KMachineState_Teleported = ::MachineState_Teleported,
    KMachineState_Aborted = ::MachineState_Aborted,
    KMachineState_Running = ::MachineState_Running,
    KMachineState_Paused = ::MachineState_Paused,
    KMachineState_Stuck = ::MachineState_Stuck,
    KMachineState_Teleporting = ::MachineState_Teleporting,
    KMachineState_LiveSnapshotting = ::MachineState_LiveSnapshotting,
    KMachineState_Starting = ::MachineState_Starting,
    KMachineState_Stopping = ::MachineState_Stopping,
    KMachineState_Saving = ::MachineState_Saving,
    KMachineState_Restoring = ::MachineState_Restoring,
    KMachineState_TeleportingPausedVM = ::MachineState_TeleportingPausedVM,
    KMachineState_TeleportingIn = ::MachineState_TeleportingIn,
    KMachineState_FaultTolerantSyncing = ::MachineState_FaultTolerantSyncing,
    KMachineState_DeletingSnapshotOnline = ::MachineState_DeletingSnapshotOnline,
    KMachineState_DeletingSnapshotPaused = ::MachineState_DeletingSnapshotPaused,
    KMachineState_RestoringSnapshot = ::MachineState_RestoringSnapshot,
    KMachineState_DeletingSnapshot = ::MachineState_DeletingSnapshot,
    KMachineState_SettingUp = ::MachineState_SettingUp,
    KMachineState_FirstOnline = ::MachineState_FirstOnline,
    KMachineState_LastOnline = ::MachineState_LastOnline,
    KMachineState_FirstTransient = ::MachineState_FirstTransient,
    KMachineState_LastTransient = ::MachineState_LastTransient,
    KMachineState_Max
};

/* KSessionState enum: */
enum KSessionState
{
    KSessionState_Null = ::SessionState_Null,
    KSessionState_Unlocked = ::SessionState_Unlocked,
    KSessionState_Locked = ::SessionState_Locked,
    KSessionState_Spawning = ::SessionState_Spawning,
    KSessionState_Unlocking = ::SessionState_Unlocking,
    KSessionState_Max
};

/* KCPUPropertyType enum: */
enum KCPUPropertyType
{
    KCPUPropertyType_Null = ::CPUPropertyType_Null,
    KCPUPropertyType_PAE = ::CPUPropertyType_PAE,
    KCPUPropertyType_Synthetic = ::CPUPropertyType_Synthetic,
    KCPUPropertyType_LongMode = ::CPUPropertyType_LongMode,
    KCPUPropertyType_TripleFaultReset = ::CPUPropertyType_TripleFaultReset,
    KCPUPropertyType_Max
};

/* KHWVirtExPropertyType enum: */
enum KHWVirtExPropertyType
{
    KHWVirtExPropertyType_Null = ::HWVirtExPropertyType_Null,
    KHWVirtExPropertyType_Enabled = ::HWVirtExPropertyType_Enabled,
    KHWVirtExPropertyType_VPID = ::HWVirtExPropertyType_VPID,
    KHWVirtExPropertyType_NestedPaging = ::HWVirtExPropertyType_NestedPaging,
    KHWVirtExPropertyType_UnrestrictedExecution = ::HWVirtExPropertyType_UnrestrictedExecution,
    KHWVirtExPropertyType_LargePages = ::HWVirtExPropertyType_LargePages,
    KHWVirtExPropertyType_Force = ::HWVirtExPropertyType_Force,
    KHWVirtExPropertyType_Max
};

/* KFaultToleranceState enum: */
enum KFaultToleranceState
{
    KFaultToleranceState_Inactive = ::FaultToleranceState_Inactive,
    KFaultToleranceState_Master = ::FaultToleranceState_Master,
    KFaultToleranceState_Standby = ::FaultToleranceState_Standby,
    KFaultToleranceState_Max
};

/* KLockType enum: */
enum KLockType
{
    KLockType_Write = ::LockType_Write,
    KLockType_Shared = ::LockType_Shared,
    KLockType_VM = ::LockType_VM,
    KLockType_Max
};

/* KSessionType enum: */
enum KSessionType
{
    KSessionType_Null = ::SessionType_Null,
    KSessionType_WriteLock = ::SessionType_WriteLock,
    KSessionType_Remote = ::SessionType_Remote,
    KSessionType_Shared = ::SessionType_Shared,
    KSessionType_Max
};

/* KDeviceType enum: */
enum KDeviceType
{
    KDeviceType_Null = ::DeviceType_Null,
    KDeviceType_Floppy = ::DeviceType_Floppy,
    KDeviceType_DVD = ::DeviceType_DVD,
    KDeviceType_HardDisk = ::DeviceType_HardDisk,
    KDeviceType_Network = ::DeviceType_Network,
    KDeviceType_USB = ::DeviceType_USB,
    KDeviceType_SharedFolder = ::DeviceType_SharedFolder,
    KDeviceType_Max
};

/* KDeviceActivity enum: */
enum KDeviceActivity
{
    KDeviceActivity_Null = ::DeviceActivity_Null,
    KDeviceActivity_Idle = ::DeviceActivity_Idle,
    KDeviceActivity_Reading = ::DeviceActivity_Reading,
    KDeviceActivity_Writing = ::DeviceActivity_Writing,
    KDeviceActivity_Max
};

/* KClipboardMode enum: */
enum KClipboardMode
{
    KClipboardMode_Disabled = ::ClipboardMode_Disabled,
    KClipboardMode_HostToGuest = ::ClipboardMode_HostToGuest,
    KClipboardMode_GuestToHost = ::ClipboardMode_GuestToHost,
    KClipboardMode_Bidirectional = ::ClipboardMode_Bidirectional,
    KClipboardMode_Max
};

/* KDragAndDropMode enum: */
enum KDragAndDropMode
{
    KDragAndDropMode_Disabled = ::DragAndDropMode_Disabled,
    KDragAndDropMode_HostToGuest = ::DragAndDropMode_HostToGuest,
    KDragAndDropMode_GuestToHost = ::DragAndDropMode_GuestToHost,
    KDragAndDropMode_Bidirectional = ::DragAndDropMode_Bidirectional,
    KDragAndDropMode_Max
};

/* KScope enum: */
enum KScope
{
    KScope_Global = ::Scope_Global,
    KScope_Machine = ::Scope_Machine,
    KScope_Session = ::Scope_Session,
    KScope_Max
};

/* KBIOSBootMenuMode enum: */
enum KBIOSBootMenuMode
{
    KBIOSBootMenuMode_Disabled = ::BIOSBootMenuMode_Disabled,
    KBIOSBootMenuMode_MenuOnly = ::BIOSBootMenuMode_MenuOnly,
    KBIOSBootMenuMode_MessageAndMenu = ::BIOSBootMenuMode_MessageAndMenu,
    KBIOSBootMenuMode_Max
};

/* KProcessorFeature enum: */
enum KProcessorFeature
{
    KProcessorFeature_HWVirtEx = ::ProcessorFeature_HWVirtEx,
    KProcessorFeature_PAE = ::ProcessorFeature_PAE,
    KProcessorFeature_LongMode = ::ProcessorFeature_LongMode,
    KProcessorFeature_NestedPaging = ::ProcessorFeature_NestedPaging,
    KProcessorFeature_Max
};

/* KFirmwareType enum: */
enum KFirmwareType
{
    KFirmwareType_BIOS = ::FirmwareType_BIOS,
    KFirmwareType_EFI = ::FirmwareType_EFI,
    KFirmwareType_EFI32 = ::FirmwareType_EFI32,
    KFirmwareType_EFI64 = ::FirmwareType_EFI64,
    KFirmwareType_EFIDUAL = ::FirmwareType_EFIDUAL,
    KFirmwareType_Max
};

/* KPointingHIDType enum: */
enum KPointingHIDType
{
    KPointingHIDType_None = ::PointingHIDType_None,
    KPointingHIDType_PS2Mouse = ::PointingHIDType_PS2Mouse,
    KPointingHIDType_USBMouse = ::PointingHIDType_USBMouse,
    KPointingHIDType_USBTablet = ::PointingHIDType_USBTablet,
    KPointingHIDType_ComboMouse = ::PointingHIDType_ComboMouse,
    KPointingHIDType_USBMultiTouch = ::PointingHIDType_USBMultiTouch,
    KPointingHIDType_Max
};

/* KKeyboardHIDType enum: */
enum KKeyboardHIDType
{
    KKeyboardHIDType_None = ::KeyboardHIDType_None,
    KKeyboardHIDType_PS2Keyboard = ::KeyboardHIDType_PS2Keyboard,
    KKeyboardHIDType_USBKeyboard = ::KeyboardHIDType_USBKeyboard,
    KKeyboardHIDType_ComboKeyboard = ::KeyboardHIDType_ComboKeyboard,
    KKeyboardHIDType_Max
};

/* KDhcpOpt enum: */
enum KDhcpOpt
{
    KDhcpOpt_SubnetMask = ::DhcpOpt_SubnetMask,
    KDhcpOpt_TimeOffset = ::DhcpOpt_TimeOffset,
    KDhcpOpt_Router = ::DhcpOpt_Router,
    KDhcpOpt_TimeServer = ::DhcpOpt_TimeServer,
    KDhcpOpt_NameServer = ::DhcpOpt_NameServer,
    KDhcpOpt_DomainNameServer = ::DhcpOpt_DomainNameServer,
    KDhcpOpt_LogServer = ::DhcpOpt_LogServer,
    KDhcpOpt_Cookie = ::DhcpOpt_Cookie,
    KDhcpOpt_LPRServer = ::DhcpOpt_LPRServer,
    KDhcpOpt_ImpressServer = ::DhcpOpt_ImpressServer,
    KDhcpOpt_ResourseLocationServer = ::DhcpOpt_ResourseLocationServer,
    KDhcpOpt_HostName = ::DhcpOpt_HostName,
    KDhcpOpt_BootFileSize = ::DhcpOpt_BootFileSize,
    KDhcpOpt_MeritDumpFile = ::DhcpOpt_MeritDumpFile,
    KDhcpOpt_DomainName = ::DhcpOpt_DomainName,
    KDhcpOpt_SwapServer = ::DhcpOpt_SwapServer,
    KDhcpOpt_RootPath = ::DhcpOpt_RootPath,
    KDhcpOpt_ExtensionPath = ::DhcpOpt_ExtensionPath,
    KDhcpOpt_IPForwardingEnableDisable = ::DhcpOpt_IPForwardingEnableDisable,
    KDhcpOpt_NonLocalSourceRoutingEnableDisable = ::DhcpOpt_NonLocalSourceRoutingEnableDisable,
    KDhcpOpt_PolicyFilter = ::DhcpOpt_PolicyFilter,
    KDhcpOpt_MaximumDatagramReassemblySize = ::DhcpOpt_MaximumDatagramReassemblySize,
    KDhcpOpt_DefaultIPTime2Live = ::DhcpOpt_DefaultIPTime2Live,
    KDhcpOpt_PathMTUAgingTimeout = ::DhcpOpt_PathMTUAgingTimeout,
    KDhcpOpt_IPLayerParametersPerInterface = ::DhcpOpt_IPLayerParametersPerInterface,
    KDhcpOpt_InterfaceMTU = ::DhcpOpt_InterfaceMTU,
    KDhcpOpt_AllSubnetsAreLocal = ::DhcpOpt_AllSubnetsAreLocal,
    KDhcpOpt_BroadcastAddress = ::DhcpOpt_BroadcastAddress,
    KDhcpOpt_PerformMaskDiscovery = ::DhcpOpt_PerformMaskDiscovery,
    KDhcpOpt_MaskSupplier = ::DhcpOpt_MaskSupplier,
    KDhcpOpt_PerformRouteDiscovery = ::DhcpOpt_PerformRouteDiscovery,
    KDhcpOpt_RouterSolicitationAddress = ::DhcpOpt_RouterSolicitationAddress,
    KDhcpOpt_StaticRoute = ::DhcpOpt_StaticRoute,
    KDhcpOpt_TrailerEncapsulation = ::DhcpOpt_TrailerEncapsulation,
    KDhcpOpt_ARPCacheTimeout = ::DhcpOpt_ARPCacheTimeout,
    KDhcpOpt_EthernetEncapsulation = ::DhcpOpt_EthernetEncapsulation,
    KDhcpOpt_TCPDefaultTTL = ::DhcpOpt_TCPDefaultTTL,
    KDhcpOpt_TCPKeepAliveInterval = ::DhcpOpt_TCPKeepAliveInterval,
    KDhcpOpt_TCPKeepAliveGarbage = ::DhcpOpt_TCPKeepAliveGarbage,
    KDhcpOpt_NetworkInformationServiceDomain = ::DhcpOpt_NetworkInformationServiceDomain,
    KDhcpOpt_NetworkInformationServiceServers = ::DhcpOpt_NetworkInformationServiceServers,
    KDhcpOpt_NetworkTimeProtocolServers = ::DhcpOpt_NetworkTimeProtocolServers,
    KDhcpOpt_VendorSpecificInformation = ::DhcpOpt_VendorSpecificInformation,
    KDhcpOpt_Option_44 = ::DhcpOpt_Option_44,
    KDhcpOpt_Option_45 = ::DhcpOpt_Option_45,
    KDhcpOpt_Option_46 = ::DhcpOpt_Option_46,
    KDhcpOpt_Option_47 = ::DhcpOpt_Option_47,
    KDhcpOpt_Option_48 = ::DhcpOpt_Option_48,
    KDhcpOpt_Option_49 = ::DhcpOpt_Option_49,
    KDhcpOpt_IPAddressLeaseTime = ::DhcpOpt_IPAddressLeaseTime,
    KDhcpOpt_Option_64 = ::DhcpOpt_Option_64,
    KDhcpOpt_Option_65 = ::DhcpOpt_Option_65,
    KDhcpOpt_TFTPServerName = ::DhcpOpt_TFTPServerName,
    KDhcpOpt_BootfileName = ::DhcpOpt_BootfileName,
    KDhcpOpt_Option_68 = ::DhcpOpt_Option_68,
    KDhcpOpt_Option_69 = ::DhcpOpt_Option_69,
    KDhcpOpt_Option_70 = ::DhcpOpt_Option_70,
    KDhcpOpt_Option_71 = ::DhcpOpt_Option_71,
    KDhcpOpt_Option_72 = ::DhcpOpt_Option_72,
    KDhcpOpt_Option_73 = ::DhcpOpt_Option_73,
    KDhcpOpt_Option_74 = ::DhcpOpt_Option_74,
    KDhcpOpt_Option_75 = ::DhcpOpt_Option_75,
    KDhcpOpt_Option_119 = ::DhcpOpt_Option_119,
    KDhcpOpt_Max
};

/* KVFSType enum: */
enum KVFSType
{
    KVFSType_File = ::VFSType_File,
    KVFSType_Cloud = ::VFSType_Cloud,
    KVFSType_S3 = ::VFSType_S3,
    KVFSType_WebDav = ::VFSType_WebDav,
    KVFSType_Max
};

/* KVFSFileType enum: */
enum KVFSFileType
{
    KVFSFileType_Unknown = ::VFSFileType_Unknown,
    KVFSFileType_Fifo = ::VFSFileType_Fifo,
    KVFSFileType_DevChar = ::VFSFileType_DevChar,
    KVFSFileType_Directory = ::VFSFileType_Directory,
    KVFSFileType_DevBlock = ::VFSFileType_DevBlock,
    KVFSFileType_File = ::VFSFileType_File,
    KVFSFileType_SymLink = ::VFSFileType_SymLink,
    KVFSFileType_Socket = ::VFSFileType_Socket,
    KVFSFileType_WhiteOut = ::VFSFileType_WhiteOut,
    KVFSFileType_Max
};

/* KImportOptions enum: */
enum KImportOptions
{
    KImportOptions_KeepAllMACs = ::ImportOptions_KeepAllMACs,
    KImportOptions_KeepNATMACs = ::ImportOptions_KeepNATMACs,
    KImportOptions_Max
};

/* KExportOptions enum: */
enum KExportOptions
{
    KExportOptions_CreateManifest = ::ExportOptions_CreateManifest,
    KExportOptions_ExportDVDImages = ::ExportOptions_ExportDVDImages,
    KExportOptions_StripAllMACs = ::ExportOptions_StripAllMACs,
    KExportOptions_StripAllNonNATMACs = ::ExportOptions_StripAllNonNATMACs,
    KExportOptions_Max
};

/* KVirtualSystemDescriptionType enum: */
enum KVirtualSystemDescriptionType
{
    KVirtualSystemDescriptionType_Ignore = ::VirtualSystemDescriptionType_Ignore,
    KVirtualSystemDescriptionType_OS = ::VirtualSystemDescriptionType_OS,
    KVirtualSystemDescriptionType_Name = ::VirtualSystemDescriptionType_Name,
    KVirtualSystemDescriptionType_Product = ::VirtualSystemDescriptionType_Product,
    KVirtualSystemDescriptionType_Vendor = ::VirtualSystemDescriptionType_Vendor,
    KVirtualSystemDescriptionType_Version = ::VirtualSystemDescriptionType_Version,
    KVirtualSystemDescriptionType_ProductUrl = ::VirtualSystemDescriptionType_ProductUrl,
    KVirtualSystemDescriptionType_VendorUrl = ::VirtualSystemDescriptionType_VendorUrl,
    KVirtualSystemDescriptionType_Description = ::VirtualSystemDescriptionType_Description,
    KVirtualSystemDescriptionType_License = ::VirtualSystemDescriptionType_License,
    KVirtualSystemDescriptionType_Miscellaneous = ::VirtualSystemDescriptionType_Miscellaneous,
    KVirtualSystemDescriptionType_CPU = ::VirtualSystemDescriptionType_CPU,
    KVirtualSystemDescriptionType_Memory = ::VirtualSystemDescriptionType_Memory,
    KVirtualSystemDescriptionType_HardDiskControllerIDE = ::VirtualSystemDescriptionType_HardDiskControllerIDE,
    KVirtualSystemDescriptionType_HardDiskControllerSATA = ::VirtualSystemDescriptionType_HardDiskControllerSATA,
    KVirtualSystemDescriptionType_HardDiskControllerSCSI = ::VirtualSystemDescriptionType_HardDiskControllerSCSI,
    KVirtualSystemDescriptionType_HardDiskControllerSAS = ::VirtualSystemDescriptionType_HardDiskControllerSAS,
    KVirtualSystemDescriptionType_HardDiskImage = ::VirtualSystemDescriptionType_HardDiskImage,
    KVirtualSystemDescriptionType_Floppy = ::VirtualSystemDescriptionType_Floppy,
    KVirtualSystemDescriptionType_CDROM = ::VirtualSystemDescriptionType_CDROM,
    KVirtualSystemDescriptionType_NetworkAdapter = ::VirtualSystemDescriptionType_NetworkAdapter,
    KVirtualSystemDescriptionType_USBController = ::VirtualSystemDescriptionType_USBController,
    KVirtualSystemDescriptionType_SoundCard = ::VirtualSystemDescriptionType_SoundCard,
    KVirtualSystemDescriptionType_SettingsFile = ::VirtualSystemDescriptionType_SettingsFile,
    KVirtualSystemDescriptionType_Max
};

/* KVirtualSystemDescriptionValueType enum: */
enum KVirtualSystemDescriptionValueType
{
    KVirtualSystemDescriptionValueType_Reference = ::VirtualSystemDescriptionValueType_Reference,
    KVirtualSystemDescriptionValueType_Original = ::VirtualSystemDescriptionValueType_Original,
    KVirtualSystemDescriptionValueType_Auto = ::VirtualSystemDescriptionValueType_Auto,
    KVirtualSystemDescriptionValueType_ExtraConfig = ::VirtualSystemDescriptionValueType_ExtraConfig,
    KVirtualSystemDescriptionValueType_Max
};

/* KGraphicsControllerType enum: */
enum KGraphicsControllerType
{
    KGraphicsControllerType_Null = ::GraphicsControllerType_Null,
    KGraphicsControllerType_VBoxVGA = ::GraphicsControllerType_VBoxVGA,
    KGraphicsControllerType_VMSVGA = ::GraphicsControllerType_VMSVGA,
    KGraphicsControllerType_Max
};

/* KCleanupMode enum: */
enum KCleanupMode
{
    KCleanupMode_UnregisterOnly = ::CleanupMode_UnregisterOnly,
    KCleanupMode_DetachAllReturnNone = ::CleanupMode_DetachAllReturnNone,
    KCleanupMode_DetachAllReturnHardDisksOnly = ::CleanupMode_DetachAllReturnHardDisksOnly,
    KCleanupMode_Full = ::CleanupMode_Full,
    KCleanupMode_Max
};

/* KCloneMode enum: */
enum KCloneMode
{
    KCloneMode_MachineState = ::CloneMode_MachineState,
    KCloneMode_MachineAndChildStates = ::CloneMode_MachineAndChildStates,
    KCloneMode_AllStates = ::CloneMode_AllStates,
    KCloneMode_Max
};

/* KCloneOptions enum: */
enum KCloneOptions
{
    KCloneOptions_Link = ::CloneOptions_Link,
    KCloneOptions_KeepAllMACs = ::CloneOptions_KeepAllMACs,
    KCloneOptions_KeepNATMACs = ::CloneOptions_KeepNATMACs,
    KCloneOptions_KeepDiskNames = ::CloneOptions_KeepDiskNames,
    KCloneOptions_Max
};

/* KAutostopType enum: */
enum KAutostopType
{
    KAutostopType_Disabled = ::AutostopType_Disabled,
    KAutostopType_SaveState = ::AutostopType_SaveState,
    KAutostopType_PowerOff = ::AutostopType_PowerOff,
    KAutostopType_AcpiShutdown = ::AutostopType_AcpiShutdown,
    KAutostopType_Max
};

/* KHostNetworkInterfaceMediumType enum: */
enum KHostNetworkInterfaceMediumType
{
    KHostNetworkInterfaceMediumType_Unknown = ::HostNetworkInterfaceMediumType_Unknown,
    KHostNetworkInterfaceMediumType_Ethernet = ::HostNetworkInterfaceMediumType_Ethernet,
    KHostNetworkInterfaceMediumType_PPP = ::HostNetworkInterfaceMediumType_PPP,
    KHostNetworkInterfaceMediumType_SLIP = ::HostNetworkInterfaceMediumType_SLIP,
    KHostNetworkInterfaceMediumType_Max
};

/* KHostNetworkInterfaceStatus enum: */
enum KHostNetworkInterfaceStatus
{
    KHostNetworkInterfaceStatus_Unknown = ::HostNetworkInterfaceStatus_Unknown,
    KHostNetworkInterfaceStatus_Up = ::HostNetworkInterfaceStatus_Up,
    KHostNetworkInterfaceStatus_Down = ::HostNetworkInterfaceStatus_Down,
    KHostNetworkInterfaceStatus_Max
};

/* KHostNetworkInterfaceType enum: */
enum KHostNetworkInterfaceType
{
    KHostNetworkInterfaceType_Bridged = ::HostNetworkInterfaceType_Bridged,
    KHostNetworkInterfaceType_HostOnly = ::HostNetworkInterfaceType_HostOnly,
    KHostNetworkInterfaceType_Max
};

/* KAdditionsFacilityType enum: */
enum KAdditionsFacilityType
{
    KAdditionsFacilityType_None = ::AdditionsFacilityType_None,
    KAdditionsFacilityType_VBoxGuestDriver = ::AdditionsFacilityType_VBoxGuestDriver,
    KAdditionsFacilityType_AutoLogon = ::AdditionsFacilityType_AutoLogon,
    KAdditionsFacilityType_VBoxService = ::AdditionsFacilityType_VBoxService,
    KAdditionsFacilityType_VBoxTrayClient = ::AdditionsFacilityType_VBoxTrayClient,
    KAdditionsFacilityType_Seamless = ::AdditionsFacilityType_Seamless,
    KAdditionsFacilityType_Graphics = ::AdditionsFacilityType_Graphics,
    KAdditionsFacilityType_All = ::AdditionsFacilityType_All,
    KAdditionsFacilityType_Max
};

/* KAdditionsFacilityClass enum: */
enum KAdditionsFacilityClass
{
    KAdditionsFacilityClass_None = ::AdditionsFacilityClass_None,
    KAdditionsFacilityClass_Driver = ::AdditionsFacilityClass_Driver,
    KAdditionsFacilityClass_Service = ::AdditionsFacilityClass_Service,
    KAdditionsFacilityClass_Program = ::AdditionsFacilityClass_Program,
    KAdditionsFacilityClass_Feature = ::AdditionsFacilityClass_Feature,
    KAdditionsFacilityClass_ThirdParty = ::AdditionsFacilityClass_ThirdParty,
    KAdditionsFacilityClass_All = ::AdditionsFacilityClass_All,
    KAdditionsFacilityClass_Max
};

/* KAdditionsFacilityStatus enum: */
enum KAdditionsFacilityStatus
{
    KAdditionsFacilityStatus_Inactive = ::AdditionsFacilityStatus_Inactive,
    KAdditionsFacilityStatus_Paused = ::AdditionsFacilityStatus_Paused,
    KAdditionsFacilityStatus_PreInit = ::AdditionsFacilityStatus_PreInit,
    KAdditionsFacilityStatus_Init = ::AdditionsFacilityStatus_Init,
    KAdditionsFacilityStatus_Active = ::AdditionsFacilityStatus_Active,
    KAdditionsFacilityStatus_Terminating = ::AdditionsFacilityStatus_Terminating,
    KAdditionsFacilityStatus_Terminated = ::AdditionsFacilityStatus_Terminated,
    KAdditionsFacilityStatus_Failed = ::AdditionsFacilityStatus_Failed,
    KAdditionsFacilityStatus_Unknown = ::AdditionsFacilityStatus_Unknown,
    KAdditionsFacilityStatus_Max
};

/* KAdditionsRunLevelType enum: */
enum KAdditionsRunLevelType
{
    KAdditionsRunLevelType_None = ::AdditionsRunLevelType_None,
    KAdditionsRunLevelType_System = ::AdditionsRunLevelType_System,
    KAdditionsRunLevelType_Userland = ::AdditionsRunLevelType_Userland,
    KAdditionsRunLevelType_Desktop = ::AdditionsRunLevelType_Desktop,
    KAdditionsRunLevelType_Max
};

/* KAdditionsUpdateFlag enum: */
enum KAdditionsUpdateFlag
{
    KAdditionsUpdateFlag_None = ::AdditionsUpdateFlag_None,
    KAdditionsUpdateFlag_WaitForUpdateStartOnly = ::AdditionsUpdateFlag_WaitForUpdateStartOnly,
    KAdditionsUpdateFlag_Max
};

/* KGuestSessionStatus enum: */
enum KGuestSessionStatus
{
    KGuestSessionStatus_Undefined = ::GuestSessionStatus_Undefined,
    KGuestSessionStatus_Starting = ::GuestSessionStatus_Starting,
    KGuestSessionStatus_Started = ::GuestSessionStatus_Started,
    KGuestSessionStatus_Terminating = ::GuestSessionStatus_Terminating,
    KGuestSessionStatus_Terminated = ::GuestSessionStatus_Terminated,
    KGuestSessionStatus_TimedOutKilled = ::GuestSessionStatus_TimedOutKilled,
    KGuestSessionStatus_TimedOutAbnormally = ::GuestSessionStatus_TimedOutAbnormally,
    KGuestSessionStatus_Down = ::GuestSessionStatus_Down,
    KGuestSessionStatus_Error = ::GuestSessionStatus_Error,
    KGuestSessionStatus_Max
};

/* KGuestSessionWaitForFlag enum: */
enum KGuestSessionWaitForFlag
{
    KGuestSessionWaitForFlag_None = ::GuestSessionWaitForFlag_None,
    KGuestSessionWaitForFlag_Start = ::GuestSessionWaitForFlag_Start,
    KGuestSessionWaitForFlag_Terminate = ::GuestSessionWaitForFlag_Terminate,
    KGuestSessionWaitForFlag_Status = ::GuestSessionWaitForFlag_Status,
    KGuestSessionWaitForFlag_Max
};

/* KGuestSessionWaitResult enum: */
enum KGuestSessionWaitResult
{
    KGuestSessionWaitResult_None = ::GuestSessionWaitResult_None,
    KGuestSessionWaitResult_Start = ::GuestSessionWaitResult_Start,
    KGuestSessionWaitResult_Terminate = ::GuestSessionWaitResult_Terminate,
    KGuestSessionWaitResult_Status = ::GuestSessionWaitResult_Status,
    KGuestSessionWaitResult_Error = ::GuestSessionWaitResult_Error,
    KGuestSessionWaitResult_Timeout = ::GuestSessionWaitResult_Timeout,
    KGuestSessionWaitResult_WaitFlagNotSupported = ::GuestSessionWaitResult_WaitFlagNotSupported,
    KGuestSessionWaitResult_Max
};

/* KGuestUserState enum: */
enum KGuestUserState
{
    KGuestUserState_Unknown = ::GuestUserState_Unknown,
    KGuestUserState_LoggedIn = ::GuestUserState_LoggedIn,
    KGuestUserState_LoggedOut = ::GuestUserState_LoggedOut,
    KGuestUserState_Locked = ::GuestUserState_Locked,
    KGuestUserState_Unlocked = ::GuestUserState_Unlocked,
    KGuestUserState_Disabled = ::GuestUserState_Disabled,
    KGuestUserState_Idle = ::GuestUserState_Idle,
    KGuestUserState_InUse = ::GuestUserState_InUse,
    KGuestUserState_Created = ::GuestUserState_Created,
    KGuestUserState_Deleted = ::GuestUserState_Deleted,
    KGuestUserState_SessionChanged = ::GuestUserState_SessionChanged,
    KGuestUserState_CredentialsChanged = ::GuestUserState_CredentialsChanged,
    KGuestUserState_RoleChanged = ::GuestUserState_RoleChanged,
    KGuestUserState_GroupAdded = ::GuestUserState_GroupAdded,
    KGuestUserState_GroupRemoved = ::GuestUserState_GroupRemoved,
    KGuestUserState_Elevated = ::GuestUserState_Elevated,
    KGuestUserState_Max
};

/* KFileSeekType enum: */
enum KFileSeekType
{
    KFileSeekType_Set = ::FileSeekType_Set,
    KFileSeekType_Current = ::FileSeekType_Current,
    KFileSeekType_Max
};

/* KProcessInputFlag enum: */
enum KProcessInputFlag
{
    KProcessInputFlag_None = ::ProcessInputFlag_None,
    KProcessInputFlag_EndOfFile = ::ProcessInputFlag_EndOfFile,
    KProcessInputFlag_Max
};

/* KProcessOutputFlag enum: */
enum KProcessOutputFlag
{
    KProcessOutputFlag_None = ::ProcessOutputFlag_None,
    KProcessOutputFlag_StdErr = ::ProcessOutputFlag_StdErr,
    KProcessOutputFlag_Max
};

/* KProcessWaitForFlag enum: */
enum KProcessWaitForFlag
{
    KProcessWaitForFlag_None = ::ProcessWaitForFlag_None,
    KProcessWaitForFlag_Start = ::ProcessWaitForFlag_Start,
    KProcessWaitForFlag_Terminate = ::ProcessWaitForFlag_Terminate,
    KProcessWaitForFlag_StdIn = ::ProcessWaitForFlag_StdIn,
    KProcessWaitForFlag_StdOut = ::ProcessWaitForFlag_StdOut,
    KProcessWaitForFlag_StdErr = ::ProcessWaitForFlag_StdErr,
    KProcessWaitForFlag_Max
};

/* KProcessWaitResult enum: */
enum KProcessWaitResult
{
    KProcessWaitResult_None = ::ProcessWaitResult_None,
    KProcessWaitResult_Start = ::ProcessWaitResult_Start,
    KProcessWaitResult_Terminate = ::ProcessWaitResult_Terminate,
    KProcessWaitResult_Status = ::ProcessWaitResult_Status,
    KProcessWaitResult_Error = ::ProcessWaitResult_Error,
    KProcessWaitResult_Timeout = ::ProcessWaitResult_Timeout,
    KProcessWaitResult_StdIn = ::ProcessWaitResult_StdIn,
    KProcessWaitResult_StdOut = ::ProcessWaitResult_StdOut,
    KProcessWaitResult_StdErr = ::ProcessWaitResult_StdErr,
    KProcessWaitResult_WaitFlagNotSupported = ::ProcessWaitResult_WaitFlagNotSupported,
    KProcessWaitResult_Max
};

/* KCopyFileFlag enum: */
enum KCopyFileFlag
{
    KCopyFileFlag_None = ::CopyFileFlag_None,
    KCopyFileFlag_Recursive = ::CopyFileFlag_Recursive,
    KCopyFileFlag_Update = ::CopyFileFlag_Update,
    KCopyFileFlag_FollowLinks = ::CopyFileFlag_FollowLinks,
    KCopyFileFlag_Max
};

/* KDirectoryCreateFlag enum: */
enum KDirectoryCreateFlag
{
    KDirectoryCreateFlag_None = ::DirectoryCreateFlag_None,
    KDirectoryCreateFlag_Parents = ::DirectoryCreateFlag_Parents,
    KDirectoryCreateFlag_Max
};

/* KDirectoryRemoveRecFlag enum: */
enum KDirectoryRemoveRecFlag
{
    KDirectoryRemoveRecFlag_None = ::DirectoryRemoveRecFlag_None,
    KDirectoryRemoveRecFlag_ContentAndDir = ::DirectoryRemoveRecFlag_ContentAndDir,
    KDirectoryRemoveRecFlag_ContentOnly = ::DirectoryRemoveRecFlag_ContentOnly,
    KDirectoryRemoveRecFlag_Max
};

/* KPathRenameFlag enum: */
enum KPathRenameFlag
{
    KPathRenameFlag_None = ::PathRenameFlag_None,
    KPathRenameFlag_NoReplace = ::PathRenameFlag_NoReplace,
    KPathRenameFlag_Replace = ::PathRenameFlag_Replace,
    KPathRenameFlag_NoSymlinks = ::PathRenameFlag_NoSymlinks,
    KPathRenameFlag_Max
};

/* KProcessCreateFlag enum: */
enum KProcessCreateFlag
{
    KProcessCreateFlag_None = ::ProcessCreateFlag_None,
    KProcessCreateFlag_WaitForProcessStartOnly = ::ProcessCreateFlag_WaitForProcessStartOnly,
    KProcessCreateFlag_IgnoreOrphanedProcesses = ::ProcessCreateFlag_IgnoreOrphanedProcesses,
    KProcessCreateFlag_Hidden = ::ProcessCreateFlag_Hidden,
    KProcessCreateFlag_NoProfile = ::ProcessCreateFlag_NoProfile,
    KProcessCreateFlag_WaitForStdOut = ::ProcessCreateFlag_WaitForStdOut,
    KProcessCreateFlag_WaitForStdErr = ::ProcessCreateFlag_WaitForStdErr,
    KProcessCreateFlag_ExpandArguments = ::ProcessCreateFlag_ExpandArguments,
    KProcessCreateFlag_UnquotedArguments = ::ProcessCreateFlag_UnquotedArguments,
    KProcessCreateFlag_Max
};

/* KProcessPriority enum: */
enum KProcessPriority
{
    KProcessPriority_Invalid = ::ProcessPriority_Invalid,
    KProcessPriority_Default = ::ProcessPriority_Default,
    KProcessPriority_Max
};

/* KSymlinkType enum: */
enum KSymlinkType
{
    KSymlinkType_Unknown = ::SymlinkType_Unknown,
    KSymlinkType_Directory = ::SymlinkType_Directory,
    KSymlinkType_File = ::SymlinkType_File,
    KSymlinkType_Max
};

/* KSymlinkReadFlag enum: */
enum KSymlinkReadFlag
{
    KSymlinkReadFlag_None = ::SymlinkReadFlag_None,
    KSymlinkReadFlag_NoSymlinks = ::SymlinkReadFlag_NoSymlinks,
    KSymlinkReadFlag_Max
};

/* KProcessStatus enum: */
enum KProcessStatus
{
    KProcessStatus_Undefined = ::ProcessStatus_Undefined,
    KProcessStatus_Starting = ::ProcessStatus_Starting,
    KProcessStatus_Started = ::ProcessStatus_Started,
    KProcessStatus_Paused = ::ProcessStatus_Paused,
    KProcessStatus_Terminating = ::ProcessStatus_Terminating,
    KProcessStatus_TerminatedNormally = ::ProcessStatus_TerminatedNormally,
    KProcessStatus_TerminatedSignal = ::ProcessStatus_TerminatedSignal,
    KProcessStatus_TerminatedAbnormally = ::ProcessStatus_TerminatedAbnormally,
    KProcessStatus_TimedOutKilled = ::ProcessStatus_TimedOutKilled,
    KProcessStatus_TimedOutAbnormally = ::ProcessStatus_TimedOutAbnormally,
    KProcessStatus_Down = ::ProcessStatus_Down,
    KProcessStatus_Error = ::ProcessStatus_Error,
    KProcessStatus_Max
};

/* KProcessInputStatus enum: */
enum KProcessInputStatus
{
    KProcessInputStatus_Undefined = ::ProcessInputStatus_Undefined,
    KProcessInputStatus_Broken = ::ProcessInputStatus_Broken,
    KProcessInputStatus_Available = ::ProcessInputStatus_Available,
    KProcessInputStatus_Written = ::ProcessInputStatus_Written,
    KProcessInputStatus_Overflow = ::ProcessInputStatus_Overflow,
    KProcessInputStatus_Max
};

/* KFileStatus enum: */
enum KFileStatus
{
    KFileStatus_Undefined = ::FileStatus_Undefined,
    KFileStatus_Opening = ::FileStatus_Opening,
    KFileStatus_Open = ::FileStatus_Open,
    KFileStatus_Closing = ::FileStatus_Closing,
    KFileStatus_Closed = ::FileStatus_Closed,
    KFileStatus_Down = ::FileStatus_Down,
    KFileStatus_Error = ::FileStatus_Error,
    KFileStatus_Max
};

/* KFsObjType enum: */
enum KFsObjType
{
    KFsObjType_Undefined = ::FsObjType_Undefined,
    KFsObjType_FIFO = ::FsObjType_FIFO,
    KFsObjType_DevChar = ::FsObjType_DevChar,
    KFsObjType_DevBlock = ::FsObjType_DevBlock,
    KFsObjType_Directory = ::FsObjType_Directory,
    KFsObjType_File = ::FsObjType_File,
    KFsObjType_Symlink = ::FsObjType_Symlink,
    KFsObjType_Socket = ::FsObjType_Socket,
    KFsObjType_Whiteout = ::FsObjType_Whiteout,
    KFsObjType_Max
};

/* KDragAndDropAction enum: */
enum KDragAndDropAction
{
    KDragAndDropAction_Ignore = ::DragAndDropAction_Ignore,
    KDragAndDropAction_Copy = ::DragAndDropAction_Copy,
    KDragAndDropAction_Move = ::DragAndDropAction_Move,
    KDragAndDropAction_Link = ::DragAndDropAction_Link,
    KDragAndDropAction_Max
};

/* KDirectoryOpenFlag enum: */
enum KDirectoryOpenFlag
{
    KDirectoryOpenFlag_None = ::DirectoryOpenFlag_None,
    KDirectoryOpenFlag_NoSymlinks = ::DirectoryOpenFlag_NoSymlinks,
    KDirectoryOpenFlag_Max
};

/* KMediumState enum: */
enum KMediumState
{
    KMediumState_NotCreated = ::MediumState_NotCreated,
    KMediumState_Created = ::MediumState_Created,
    KMediumState_LockedRead = ::MediumState_LockedRead,
    KMediumState_LockedWrite = ::MediumState_LockedWrite,
    KMediumState_Inaccessible = ::MediumState_Inaccessible,
    KMediumState_Creating = ::MediumState_Creating,
    KMediumState_Deleting = ::MediumState_Deleting,
    KMediumState_Max
};

/* KMediumType enum: */
enum KMediumType
{
    KMediumType_Normal = ::MediumType_Normal,
    KMediumType_Immutable = ::MediumType_Immutable,
    KMediumType_Writethrough = ::MediumType_Writethrough,
    KMediumType_Shareable = ::MediumType_Shareable,
    KMediumType_Readonly = ::MediumType_Readonly,
    KMediumType_MultiAttach = ::MediumType_MultiAttach,
    KMediumType_Max
};

/* KMediumVariant enum: */
enum KMediumVariant
{
    KMediumVariant_Standard = ::MediumVariant_Standard,
    KMediumVariant_VmdkSplit2G = ::MediumVariant_VmdkSplit2G,
    KMediumVariant_VmdkRawDisk = ::MediumVariant_VmdkRawDisk,
    KMediumVariant_VmdkStreamOptimized = ::MediumVariant_VmdkStreamOptimized,
    KMediumVariant_VmdkESX = ::MediumVariant_VmdkESX,
    KMediumVariant_Fixed = ::MediumVariant_Fixed,
    KMediumVariant_Diff = ::MediumVariant_Diff,
    KMediumVariant_NoCreateDir = ::MediumVariant_NoCreateDir,
    KMediumVariant_Max
};

/* KDataType enum: */
enum KDataType
{
    KDataType_Int32 = ::DataType_Int32,
    KDataType_Int8 = ::DataType_Int8,
    KDataType_String = ::DataType_String,
    KDataType_Max
};

/* KDataFlags enum: */
enum KDataFlags
{
    KDataFlags_None = ::DataFlags_None,
    KDataFlags_Mandatory = ::DataFlags_Mandatory,
    KDataFlags_Expert = ::DataFlags_Expert,
    KDataFlags_Array = ::DataFlags_Array,
    KDataFlags_FlagMask = ::DataFlags_FlagMask,
    KDataFlags_Max
};

/* KMediumFormatCapabilities enum: */
enum KMediumFormatCapabilities
{
    KMediumFormatCapabilities_Uuid = ::MediumFormatCapabilities_Uuid,
    KMediumFormatCapabilities_CreateFixed = ::MediumFormatCapabilities_CreateFixed,
    KMediumFormatCapabilities_CreateDynamic = ::MediumFormatCapabilities_CreateDynamic,
    KMediumFormatCapabilities_CreateSplit2G = ::MediumFormatCapabilities_CreateSplit2G,
    KMediumFormatCapabilities_Differencing = ::MediumFormatCapabilities_Differencing,
    KMediumFormatCapabilities_Asynchronous = ::MediumFormatCapabilities_Asynchronous,
    KMediumFormatCapabilities_File = ::MediumFormatCapabilities_File,
    KMediumFormatCapabilities_Properties = ::MediumFormatCapabilities_Properties,
    KMediumFormatCapabilities_TcpNetworking = ::MediumFormatCapabilities_TcpNetworking,
    KMediumFormatCapabilities_VFS = ::MediumFormatCapabilities_VFS,
    KMediumFormatCapabilities_CapabilityMask = ::MediumFormatCapabilities_CapabilityMask,
    KMediumFormatCapabilities_Max
};

/* KMouseButtonState enum: */
enum KMouseButtonState
{
    KMouseButtonState_LeftButton = ::MouseButtonState_LeftButton,
    KMouseButtonState_RightButton = ::MouseButtonState_RightButton,
    KMouseButtonState_MiddleButton = ::MouseButtonState_MiddleButton,
    KMouseButtonState_WheelUp = ::MouseButtonState_WheelUp,
    KMouseButtonState_WheelDown = ::MouseButtonState_WheelDown,
    KMouseButtonState_XButton1 = ::MouseButtonState_XButton1,
    KMouseButtonState_XButton2 = ::MouseButtonState_XButton2,
    KMouseButtonState_MouseStateMask = ::MouseButtonState_MouseStateMask,
    KMouseButtonState_Max
};

/* KTouchContactState enum: */
enum KTouchContactState
{
    KTouchContactState_None = ::TouchContactState_None,
    KTouchContactState_InContact = ::TouchContactState_InContact,
    KTouchContactState_InRange = ::TouchContactState_InRange,
    KTouchContactState_ContactStateMask = ::TouchContactState_ContactStateMask,
    KTouchContactState_Max
};

/* KFramebufferPixelFormat enum: */
enum KFramebufferPixelFormat
{
    KFramebufferPixelFormat_Opaque = ::FramebufferPixelFormat_Opaque,
    KFramebufferPixelFormat_FOURCC_RGB = ::FramebufferPixelFormat_FOURCC_RGB,
    KFramebufferPixelFormat_Max
};

/* KNetworkAttachmentType enum: */
enum KNetworkAttachmentType
{
    KNetworkAttachmentType_Null = ::NetworkAttachmentType_Null,
    KNetworkAttachmentType_NAT = ::NetworkAttachmentType_NAT,
    KNetworkAttachmentType_Bridged = ::NetworkAttachmentType_Bridged,
    KNetworkAttachmentType_Internal = ::NetworkAttachmentType_Internal,
    KNetworkAttachmentType_HostOnly = ::NetworkAttachmentType_HostOnly,
    KNetworkAttachmentType_Generic = ::NetworkAttachmentType_Generic,
    KNetworkAttachmentType_NATNetwork = ::NetworkAttachmentType_NATNetwork,
    KNetworkAttachmentType_Max
};

/* KNetworkAdapterType enum: */
enum KNetworkAdapterType
{
    KNetworkAdapterType_Null = ::NetworkAdapterType_Null,
    KNetworkAdapterType_Am79C970A = ::NetworkAdapterType_Am79C970A,
    KNetworkAdapterType_Am79C973 = ::NetworkAdapterType_Am79C973,
    KNetworkAdapterType_I82540EM = ::NetworkAdapterType_I82540EM,
    KNetworkAdapterType_I82543GC = ::NetworkAdapterType_I82543GC,
    KNetworkAdapterType_I82545EM = ::NetworkAdapterType_I82545EM,
    KNetworkAdapterType_Virtio = ::NetworkAdapterType_Virtio,
    KNetworkAdapterType_Max
};

/* KNetworkAdapterPromiscModePolicy enum: */
enum KNetworkAdapterPromiscModePolicy
{
    KNetworkAdapterPromiscModePolicy_Deny = ::NetworkAdapterPromiscModePolicy_Deny,
    KNetworkAdapterPromiscModePolicy_AllowNetwork = ::NetworkAdapterPromiscModePolicy_AllowNetwork,
    KNetworkAdapterPromiscModePolicy_AllowAll = ::NetworkAdapterPromiscModePolicy_AllowAll,
    KNetworkAdapterPromiscModePolicy_Max
};

/* KPortMode enum: */
enum KPortMode
{
    KPortMode_Disconnected = ::PortMode_Disconnected,
    KPortMode_HostPipe = ::PortMode_HostPipe,
    KPortMode_HostDevice = ::PortMode_HostDevice,
    KPortMode_RawFile = ::PortMode_RawFile,
    KPortMode_Max
};

/* KUSBControllerType enum: */
enum KUSBControllerType
{
    KUSBControllerType_Null = ::USBControllerType_Null,
    KUSBControllerType_OHCI = ::USBControllerType_OHCI,
    KUSBControllerType_EHCI = ::USBControllerType_EHCI,
    KUSBControllerType_Last = ::USBControllerType_Last,
    KUSBControllerType_Max
};

/* KUSBDeviceState enum: */
enum KUSBDeviceState
{
    KUSBDeviceState_NotSupported = ::USBDeviceState_NotSupported,
    KUSBDeviceState_Unavailable = ::USBDeviceState_Unavailable,
    KUSBDeviceState_Busy = ::USBDeviceState_Busy,
    KUSBDeviceState_Available = ::USBDeviceState_Available,
    KUSBDeviceState_Held = ::USBDeviceState_Held,
    KUSBDeviceState_Captured = ::USBDeviceState_Captured,
    KUSBDeviceState_Max
};

/* KUSBDeviceFilterAction enum: */
enum KUSBDeviceFilterAction
{
    KUSBDeviceFilterAction_Null = ::USBDeviceFilterAction_Null,
    KUSBDeviceFilterAction_Ignore = ::USBDeviceFilterAction_Ignore,
    KUSBDeviceFilterAction_Hold = ::USBDeviceFilterAction_Hold,
    KUSBDeviceFilterAction_Max
};

/* KAudioDriverType enum: */
enum KAudioDriverType
{
    KAudioDriverType_Null = ::AudioDriverType_Null,
    KAudioDriverType_WinMM = ::AudioDriverType_WinMM,
    KAudioDriverType_OSS = ::AudioDriverType_OSS,
    KAudioDriverType_ALSA = ::AudioDriverType_ALSA,
    KAudioDriverType_DirectSound = ::AudioDriverType_DirectSound,
    KAudioDriverType_CoreAudio = ::AudioDriverType_CoreAudio,
    KAudioDriverType_MMPM = ::AudioDriverType_MMPM,
    KAudioDriverType_Pulse = ::AudioDriverType_Pulse,
    KAudioDriverType_SolAudio = ::AudioDriverType_SolAudio,
    KAudioDriverType_Max
};

/* KAudioControllerType enum: */
enum KAudioControllerType
{
    KAudioControllerType_AC97 = ::AudioControllerType_AC97,
    KAudioControllerType_SB16 = ::AudioControllerType_SB16,
    KAudioControllerType_HDA = ::AudioControllerType_HDA,
    KAudioControllerType_Max
};

/* KAuthType enum: */
enum KAuthType
{
    KAuthType_Null = ::AuthType_Null,
    KAuthType_External = ::AuthType_External,
    KAuthType_Guest = ::AuthType_Guest,
    KAuthType_Max
};

/* KReason enum: */
enum KReason
{
    KReason_Unspecified = ::Reason_Unspecified,
    KReason_HostSuspend = ::Reason_HostSuspend,
    KReason_HostResume = ::Reason_HostResume,
    KReason_HostBatteryLow = ::Reason_HostBatteryLow,
    KReason_Max
};

/* KStorageBus enum: */
enum KStorageBus
{
    KStorageBus_Null = ::StorageBus_Null,
    KStorageBus_IDE = ::StorageBus_IDE,
    KStorageBus_SATA = ::StorageBus_SATA,
    KStorageBus_SCSI = ::StorageBus_SCSI,
    KStorageBus_Floppy = ::StorageBus_Floppy,
    KStorageBus_SAS = ::StorageBus_SAS,
    KStorageBus_Max
};

/* KStorageControllerType enum: */
enum KStorageControllerType
{
    KStorageControllerType_Null = ::StorageControllerType_Null,
    KStorageControllerType_LsiLogic = ::StorageControllerType_LsiLogic,
    KStorageControllerType_BusLogic = ::StorageControllerType_BusLogic,
    KStorageControllerType_IntelAhci = ::StorageControllerType_IntelAhci,
    KStorageControllerType_PIIX3 = ::StorageControllerType_PIIX3,
    KStorageControllerType_PIIX4 = ::StorageControllerType_PIIX4,
    KStorageControllerType_ICH6 = ::StorageControllerType_ICH6,
    KStorageControllerType_I82078 = ::StorageControllerType_I82078,
    KStorageControllerType_LsiLogicSas = ::StorageControllerType_LsiLogicSas,
    KStorageControllerType_Max
};

/* KChipsetType enum: */
enum KChipsetType
{
    KChipsetType_Null = ::ChipsetType_Null,
    KChipsetType_PIIX3 = ::ChipsetType_PIIX3,
    KChipsetType_ICH9 = ::ChipsetType_ICH9,
    KChipsetType_Max
};

/* KNATAliasMode enum: */
enum KNATAliasMode
{
    KNATAliasMode_AliasLog = ::NATAliasMode_AliasLog,
    KNATAliasMode_AliasProxyOnly = ::NATAliasMode_AliasProxyOnly,
    KNATAliasMode_AliasUseSamePorts = ::NATAliasMode_AliasUseSamePorts,
    KNATAliasMode_Max
};

/* KNATProtocol enum: */
enum KNATProtocol
{
    KNATProtocol_UDP = ::NATProtocol_UDP,
    KNATProtocol_TCP = ::NATProtocol_TCP,
    KNATProtocol_Max
};

/* KBandwidthGroupType enum: */
enum KBandwidthGroupType
{
    KBandwidthGroupType_Null = ::BandwidthGroupType_Null,
    KBandwidthGroupType_Disk = ::BandwidthGroupType_Disk,
    KBandwidthGroupType_Network = ::BandwidthGroupType_Network,
    KBandwidthGroupType_Max
};

/* KVBoxEventType enum: */
enum KVBoxEventType
{
    KVBoxEventType_Invalid = ::VBoxEventType_Invalid,
    KVBoxEventType_Any = ::VBoxEventType_Any,
    KVBoxEventType_Vetoable = ::VBoxEventType_Vetoable,
    KVBoxEventType_MachineEvent = ::VBoxEventType_MachineEvent,
    KVBoxEventType_SnapshotEvent = ::VBoxEventType_SnapshotEvent,
    KVBoxEventType_InputEvent = ::VBoxEventType_InputEvent,
    KVBoxEventType_LastWildcard = ::VBoxEventType_LastWildcard,
    KVBoxEventType_OnMachineStateChanged = ::VBoxEventType_OnMachineStateChanged,
    KVBoxEventType_OnMachineDataChanged = ::VBoxEventType_OnMachineDataChanged,
    KVBoxEventType_OnExtraDataChanged = ::VBoxEventType_OnExtraDataChanged,
    KVBoxEventType_OnExtraDataCanChange = ::VBoxEventType_OnExtraDataCanChange,
    KVBoxEventType_OnMediumRegistered = ::VBoxEventType_OnMediumRegistered,
    KVBoxEventType_OnMachineRegistered = ::VBoxEventType_OnMachineRegistered,
    KVBoxEventType_OnSessionStateChanged = ::VBoxEventType_OnSessionStateChanged,
    KVBoxEventType_OnSnapshotTaken = ::VBoxEventType_OnSnapshotTaken,
    KVBoxEventType_OnSnapshotDeleted = ::VBoxEventType_OnSnapshotDeleted,
    KVBoxEventType_OnSnapshotChanged = ::VBoxEventType_OnSnapshotChanged,
    KVBoxEventType_OnGuestPropertyChanged = ::VBoxEventType_OnGuestPropertyChanged,
    KVBoxEventType_OnMousePointerShapeChanged = ::VBoxEventType_OnMousePointerShapeChanged,
    KVBoxEventType_OnMouseCapabilityChanged = ::VBoxEventType_OnMouseCapabilityChanged,
    KVBoxEventType_OnKeyboardLedsChanged = ::VBoxEventType_OnKeyboardLedsChanged,
    KVBoxEventType_OnStateChanged = ::VBoxEventType_OnStateChanged,
    KVBoxEventType_OnAdditionsStateChanged = ::VBoxEventType_OnAdditionsStateChanged,
    KVBoxEventType_OnNetworkAdapterChanged = ::VBoxEventType_OnNetworkAdapterChanged,
    KVBoxEventType_OnSerialPortChanged = ::VBoxEventType_OnSerialPortChanged,
    KVBoxEventType_OnParallelPortChanged = ::VBoxEventType_OnParallelPortChanged,
    KVBoxEventType_OnStorageControllerChanged = ::VBoxEventType_OnStorageControllerChanged,
    KVBoxEventType_OnMediumChanged = ::VBoxEventType_OnMediumChanged,
    KVBoxEventType_OnVRDEServerChanged = ::VBoxEventType_OnVRDEServerChanged,
    KVBoxEventType_OnUSBControllerChanged = ::VBoxEventType_OnUSBControllerChanged,
    KVBoxEventType_OnUSBDeviceStateChanged = ::VBoxEventType_OnUSBDeviceStateChanged,
    KVBoxEventType_OnSharedFolderChanged = ::VBoxEventType_OnSharedFolderChanged,
    KVBoxEventType_OnRuntimeError = ::VBoxEventType_OnRuntimeError,
    KVBoxEventType_OnCanShowWindow = ::VBoxEventType_OnCanShowWindow,
    KVBoxEventType_OnShowWindow = ::VBoxEventType_OnShowWindow,
    KVBoxEventType_OnCPUChanged = ::VBoxEventType_OnCPUChanged,
    KVBoxEventType_OnVRDEServerInfoChanged = ::VBoxEventType_OnVRDEServerInfoChanged,
    KVBoxEventType_OnEventSourceChanged = ::VBoxEventType_OnEventSourceChanged,
    KVBoxEventType_OnCPUExecutionCapChanged = ::VBoxEventType_OnCPUExecutionCapChanged,
    KVBoxEventType_OnGuestKeyboard = ::VBoxEventType_OnGuestKeyboard,
    KVBoxEventType_OnGuestMouse = ::VBoxEventType_OnGuestMouse,
    KVBoxEventType_OnNATRedirect = ::VBoxEventType_OnNATRedirect,
    KVBoxEventType_OnHostPCIDevicePlug = ::VBoxEventType_OnHostPCIDevicePlug,
    KVBoxEventType_OnVBoxSVCAvailabilityChanged = ::VBoxEventType_OnVBoxSVCAvailabilityChanged,
    KVBoxEventType_OnBandwidthGroupChanged = ::VBoxEventType_OnBandwidthGroupChanged,
    KVBoxEventType_OnGuestMonitorChanged = ::VBoxEventType_OnGuestMonitorChanged,
    KVBoxEventType_OnStorageDeviceChanged = ::VBoxEventType_OnStorageDeviceChanged,
    KVBoxEventType_OnClipboardModeChanged = ::VBoxEventType_OnClipboardModeChanged,
    KVBoxEventType_OnDragAndDropModeChanged = ::VBoxEventType_OnDragAndDropModeChanged,
    KVBoxEventType_OnNATNetworkChanged = ::VBoxEventType_OnNATNetworkChanged,
    KVBoxEventType_OnNATNetworkStartStop = ::VBoxEventType_OnNATNetworkStartStop,
    KVBoxEventType_OnNATNetworkAlter = ::VBoxEventType_OnNATNetworkAlter,
    KVBoxEventType_OnNATNetworkCreationDeletion = ::VBoxEventType_OnNATNetworkCreationDeletion,
    KVBoxEventType_OnNATNetworkSetting = ::VBoxEventType_OnNATNetworkSetting,
    KVBoxEventType_OnNATNetworkPortForward = ::VBoxEventType_OnNATNetworkPortForward,
    KVBoxEventType_OnGuestSessionStateChanged = ::VBoxEventType_OnGuestSessionStateChanged,
    KVBoxEventType_OnGuestSessionRegistered = ::VBoxEventType_OnGuestSessionRegistered,
    KVBoxEventType_OnGuestProcessRegistered = ::VBoxEventType_OnGuestProcessRegistered,
    KVBoxEventType_OnGuestProcessStateChanged = ::VBoxEventType_OnGuestProcessStateChanged,
    KVBoxEventType_OnGuestProcessInputNotify = ::VBoxEventType_OnGuestProcessInputNotify,
    KVBoxEventType_OnGuestProcessOutput = ::VBoxEventType_OnGuestProcessOutput,
    KVBoxEventType_OnGuestFileRegistered = ::VBoxEventType_OnGuestFileRegistered,
    KVBoxEventType_OnGuestFileStateChanged = ::VBoxEventType_OnGuestFileStateChanged,
    KVBoxEventType_OnGuestFileOffsetChanged = ::VBoxEventType_OnGuestFileOffsetChanged,
    KVBoxEventType_OnGuestFileRead = ::VBoxEventType_OnGuestFileRead,
    KVBoxEventType_OnGuestFileWrite = ::VBoxEventType_OnGuestFileWrite,
    KVBoxEventType_OnVideoCaptureChanged = ::VBoxEventType_OnVideoCaptureChanged,
    KVBoxEventType_OnGuestUserStateChanged = ::VBoxEventType_OnGuestUserStateChanged,
    KVBoxEventType_OnGuestMultiTouch = ::VBoxEventType_OnGuestMultiTouch,
    KVBoxEventType_OnHostNameResolutionConfigurationChange = ::VBoxEventType_OnHostNameResolutionConfigurationChange,
    KVBoxEventType_Last = ::VBoxEventType_Last,
    KVBoxEventType_Max
};

/* KGuestMouseEventMode enum: */
enum KGuestMouseEventMode
{
    KGuestMouseEventMode_Relative = ::GuestMouseEventMode_Relative,
    KGuestMouseEventMode_Absolute = ::GuestMouseEventMode_Absolute,
    KGuestMouseEventMode_Max
};

/* KGuestMonitorChangedEventType enum: */
enum KGuestMonitorChangedEventType
{
    KGuestMonitorChangedEventType_Enabled = ::GuestMonitorChangedEventType_Enabled,
    KGuestMonitorChangedEventType_Disabled = ::GuestMonitorChangedEventType_Disabled,
    KGuestMonitorChangedEventType_NewOrigin = ::GuestMonitorChangedEventType_NewOrigin,
    KGuestMonitorChangedEventType_Max
};

/* Let QMetaType know about generated enums: */
Q_DECLARE_METATYPE(KSettingsVersion)
Q_DECLARE_METATYPE(KAccessMode)
Q_DECLARE_METATYPE(KMachineState)
Q_DECLARE_METATYPE(KSessionState)
Q_DECLARE_METATYPE(KCPUPropertyType)
Q_DECLARE_METATYPE(KHWVirtExPropertyType)
Q_DECLARE_METATYPE(KFaultToleranceState)
Q_DECLARE_METATYPE(KLockType)
Q_DECLARE_METATYPE(KSessionType)
Q_DECLARE_METATYPE(KDeviceType)
Q_DECLARE_METATYPE(KDeviceActivity)
Q_DECLARE_METATYPE(KClipboardMode)
Q_DECLARE_METATYPE(KDragAndDropMode)
Q_DECLARE_METATYPE(KScope)
Q_DECLARE_METATYPE(KBIOSBootMenuMode)
Q_DECLARE_METATYPE(KProcessorFeature)
Q_DECLARE_METATYPE(KFirmwareType)
Q_DECLARE_METATYPE(KPointingHIDType)
Q_DECLARE_METATYPE(KKeyboardHIDType)
Q_DECLARE_METATYPE(KDhcpOpt)
Q_DECLARE_METATYPE(KVFSType)
Q_DECLARE_METATYPE(KVFSFileType)
Q_DECLARE_METATYPE(KImportOptions)
Q_DECLARE_METATYPE(KExportOptions)
Q_DECLARE_METATYPE(KVirtualSystemDescriptionType)
Q_DECLARE_METATYPE(KVirtualSystemDescriptionValueType)
Q_DECLARE_METATYPE(KGraphicsControllerType)
Q_DECLARE_METATYPE(KCleanupMode)
Q_DECLARE_METATYPE(KCloneMode)
Q_DECLARE_METATYPE(KCloneOptions)
Q_DECLARE_METATYPE(KAutostopType)
Q_DECLARE_METATYPE(KHostNetworkInterfaceMediumType)
Q_DECLARE_METATYPE(KHostNetworkInterfaceStatus)
Q_DECLARE_METATYPE(KHostNetworkInterfaceType)
Q_DECLARE_METATYPE(KAdditionsFacilityType)
Q_DECLARE_METATYPE(KAdditionsFacilityClass)
Q_DECLARE_METATYPE(KAdditionsFacilityStatus)
Q_DECLARE_METATYPE(KAdditionsRunLevelType)
Q_DECLARE_METATYPE(KAdditionsUpdateFlag)
Q_DECLARE_METATYPE(KGuestSessionStatus)
Q_DECLARE_METATYPE(KGuestSessionWaitForFlag)
Q_DECLARE_METATYPE(KGuestSessionWaitResult)
Q_DECLARE_METATYPE(KGuestUserState)
Q_DECLARE_METATYPE(KFileSeekType)
Q_DECLARE_METATYPE(KProcessInputFlag)
Q_DECLARE_METATYPE(KProcessOutputFlag)
Q_DECLARE_METATYPE(KProcessWaitForFlag)
Q_DECLARE_METATYPE(KProcessWaitResult)
Q_DECLARE_METATYPE(KCopyFileFlag)
Q_DECLARE_METATYPE(KDirectoryCreateFlag)
Q_DECLARE_METATYPE(KDirectoryRemoveRecFlag)
Q_DECLARE_METATYPE(KPathRenameFlag)
Q_DECLARE_METATYPE(KProcessCreateFlag)
Q_DECLARE_METATYPE(KProcessPriority)
Q_DECLARE_METATYPE(KSymlinkType)
Q_DECLARE_METATYPE(KSymlinkReadFlag)
Q_DECLARE_METATYPE(KProcessStatus)
Q_DECLARE_METATYPE(KProcessInputStatus)
Q_DECLARE_METATYPE(KFileStatus)
Q_DECLARE_METATYPE(KFsObjType)
Q_DECLARE_METATYPE(KDragAndDropAction)
Q_DECLARE_METATYPE(KDirectoryOpenFlag)
Q_DECLARE_METATYPE(KMediumState)
Q_DECLARE_METATYPE(KMediumType)
Q_DECLARE_METATYPE(KMediumVariant)
Q_DECLARE_METATYPE(KDataType)
Q_DECLARE_METATYPE(KDataFlags)
Q_DECLARE_METATYPE(KMediumFormatCapabilities)
Q_DECLARE_METATYPE(KMouseButtonState)
Q_DECLARE_METATYPE(KTouchContactState)
Q_DECLARE_METATYPE(KFramebufferPixelFormat)
Q_DECLARE_METATYPE(KNetworkAttachmentType)
Q_DECLARE_METATYPE(KNetworkAdapterType)
Q_DECLARE_METATYPE(KNetworkAdapterPromiscModePolicy)
Q_DECLARE_METATYPE(KPortMode)
Q_DECLARE_METATYPE(KUSBControllerType)
Q_DECLARE_METATYPE(KUSBDeviceState)
Q_DECLARE_METATYPE(KUSBDeviceFilterAction)
Q_DECLARE_METATYPE(KAudioDriverType)
Q_DECLARE_METATYPE(KAudioControllerType)
Q_DECLARE_METATYPE(KAuthType)
Q_DECLARE_METATYPE(KReason)
Q_DECLARE_METATYPE(KStorageBus)
Q_DECLARE_METATYPE(KStorageControllerType)
Q_DECLARE_METATYPE(KChipsetType)
Q_DECLARE_METATYPE(KNATAliasMode)
Q_DECLARE_METATYPE(KNATProtocol)
Q_DECLARE_METATYPE(KBandwidthGroupType)
Q_DECLARE_METATYPE(KVBoxEventType)
Q_DECLARE_METATYPE(KGuestMouseEventMode)
Q_DECLARE_METATYPE(KGuestMonitorChangedEventType)

#endif /* __COMEnums_h__ */


// ##### ENDFILE "COMEnums.h"


// ##### BEGINFILE "CVirtualBoxErrorInfo.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CVirtualBoxErrorInfo_h__
#define __CVirtualBoxErrorInfo_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CVirtualBoxErrorInfo : public CInterface<IVirtualBoxErrorInfo>
{
public:

    typedef CInterface<IVirtualBoxErrorInfo> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CVirtualBoxErrorInfo() {}

    template<class OI, class OB> explicit CVirtualBoxErrorInfo(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CVirtualBoxErrorInfo(const CVirtualBoxErrorInfo & that) : Base(that) {}

    template<class OI> explicit CVirtualBoxErrorInfo(OI * aIface) { attach(aIface); }

    explicit CVirtualBoxErrorInfo(IVirtualBoxErrorInfo * aIface) : Base(aIface) {}

    template<class OI, class OB> CVirtualBoxErrorInfo & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CVirtualBoxErrorInfo & operator=(const CVirtualBoxErrorInfo & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CVirtualBoxErrorInfo & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CVirtualBoxErrorInfo & operator=(IVirtualBoxErrorInfo * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    LONG GetResultCode() const;
    LONG GetResultDetail() const;
    QString GetInterfaceID() const;
    QString GetComponent() const;
    QString GetText() const;
    CVirtualBoxErrorInfo GetNext() const;

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CMachine;
    friend class CProgress;
    friend class CInternalSessionControl;
    friend class CGuestSessionStateChangedEvent;
    friend class CGuestProcessStateChangedEvent;
    friend class CGuestFileStateChangedEvent;
    friend class CUSBDeviceStateChangedEvent;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CVirtualBoxErrorInfo)

#endif /* __CVirtualBoxErrorInfo_h__ */


// ##### ENDFILE "CVirtualBoxErrorInfo.h"


// ##### BEGINFILE "CNATNetwork.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CNATNetwork_h__
#define __CNATNetwork_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CNATNetwork : public CInterface<INATNetwork, COMBaseWithEI>
{
public:

    typedef CInterface<INATNetwork, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CNATNetwork() {}

    template<class OI, class OB> explicit CNATNetwork(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CNATNetwork(const CNATNetwork & that) : Base(that) {}

    template<class OI> explicit CNATNetwork(OI * aIface) { attach(aIface); }

    explicit CNATNetwork(INATNetwork * aIface) : Base(aIface) {}

    template<class OI, class OB> CNATNetwork & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CNATNetwork & operator=(const CNATNetwork & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CNATNetwork & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CNATNetwork & operator=(INATNetwork * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetNetworkName() const;
    void SetNetworkName(const QString & aNetworkName);
    BOOL GetEnabled() const;
    void SetEnabled(BOOL aEnabled);
    QString GetNetwork() const;
    void SetNetwork(const QString & aNetwork);
    QString GetGateway() const;
    BOOL GetIPv6Enabled() const;
    void SetIPv6Enabled(BOOL aIPv6Enabled);
    QString GetIPv6Prefix() const;
    void SetIPv6Prefix(const QString & aIPv6Prefix);
    BOOL GetAdvertiseDefaultIPv6RouteEnabled() const;
    void SetAdvertiseDefaultIPv6RouteEnabled(BOOL aAdvertiseDefaultIPv6RouteEnabled);
    BOOL GetNeedDhcpServer() const;
    void SetNeedDhcpServer(BOOL aNeedDhcpServer);
    CEventSource GetEventSource() const;
    QVector<QString> GetPortForwardRules4() const;
    QVector<QString> GetLocalMappings() const;
    LONG GetLoopbackIp6() const;
    void SetLoopbackIp6(LONG aLoopbackIp6);
    QVector<QString> GetPortForwardRules6() const;

    /* Methods: */
    void AddLocalMapping(const QString & aHostid, LONG aOffset);
    void AddPortForwardRule(BOOL aIsIpv6, const QString & aRuleName, const KNATProtocol & aProto, const QString & aHostIP, USHORT aHostPort, const QString & aGuestIP, USHORT aGuestPort);
    void RemovePortForwardRule(BOOL aISipv6, const QString & aRuleName);
    void Start(const QString & aTrunkType);
    void Stop();

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CVirtualBox;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CNATNetwork)

/* Declare safe-array: */
typedef QVector<CNATNetwork> CNATNetworkVector;

#endif /* __CNATNetwork_h__ */


// ##### ENDFILE "CNATNetwork.h"


// ##### BEGINFILE "CDHCPServer.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CDHCPServer_h__
#define __CDHCPServer_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CDHCPServer : public CInterface<IDHCPServer, COMBaseWithEI>
{
public:

    typedef CInterface<IDHCPServer, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CDHCPServer() {}

    template<class OI, class OB> explicit CDHCPServer(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CDHCPServer(const CDHCPServer & that) : Base(that) {}

    template<class OI> explicit CDHCPServer(OI * aIface) { attach(aIface); }

    explicit CDHCPServer(IDHCPServer * aIface) : Base(aIface) {}

    template<class OI, class OB> CDHCPServer & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CDHCPServer & operator=(const CDHCPServer & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CDHCPServer & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CDHCPServer & operator=(IDHCPServer * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    CEventSource GetEventSource() const;
    BOOL GetEnabled() const;
    void SetEnabled(BOOL aEnabled);
    QString GetIPAddress() const;
    QString GetNetworkMask() const;
    QString GetNetworkName() const;
    QString GetLowerIP() const;
    QString GetUpperIP() const;
    QVector<QString> GetGlobalOptions() const;
    QVector<QString> GetVmConfigs() const;

    /* Methods: */
    void AddGlobalOption(const KDhcpOpt & aOption, const QString & aValue);
    void AddVmSlotOption(const QString & aVmname, LONG aSlot, const KDhcpOpt & aOption, const QString & aValue);
    void RemoveVmSlotOptions(const QString & aVmname, LONG aSlot);
    QVector<QString> GetVmSlotOptions(const QString & aVmname, LONG aSlot);
    QVector<QString> GetMacOptions(const QString & aMac);
    void SetConfiguration(const QString & aIPAddress, const QString & aNetworkMask, const QString & aFromIPAddress, const QString & aToIPAddress);
    void Start(const QString & aNetworkName, const QString & aTrunkName, const QString & aTrunkType);
    void Stop();

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CVirtualBox;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CDHCPServer)

/* Declare safe-array: */
typedef QVector<CDHCPServer> CDHCPServerVector;

#endif /* __CDHCPServer_h__ */


// ##### ENDFILE "CDHCPServer.h"


// ##### BEGINFILE "CVirtualBox.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CVirtualBox_h__
#define __CVirtualBox_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CVirtualBox : public CInterface<IVirtualBox, COMBaseWithEI>
{
public:

    typedef CInterface<IVirtualBox, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CVirtualBox() {}

    template<class OI, class OB> explicit CVirtualBox(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CVirtualBox(const CVirtualBox & that) : Base(that) {}

    template<class OI> explicit CVirtualBox(OI * aIface) { attach(aIface); }

    explicit CVirtualBox(IVirtualBox * aIface) : Base(aIface) {}

    template<class OI, class OB> CVirtualBox & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CVirtualBox & operator=(const CVirtualBox & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CVirtualBox & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CVirtualBox & operator=(IVirtualBox * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetVersion() const;
    QString GetVersionNormalized() const;
    ULONG GetRevision() const;
    QString GetPackageType() const;
    QString GetAPIVersion() const;
    QString GetHomeFolder() const;
    QString GetSettingsFilePath() const;
    CHost GetHost() const;
    CSystemProperties GetSystemProperties() const;
    QVector<CMachine> GetMachines() const;
    QVector<QString> GetMachineGroups() const;
    QVector<CMedium> GetHardDisks() const;
    QVector<CMedium> GetDVDImages() const;
    QVector<CMedium> GetFloppyImages() const;
    QVector<CProgress> GetProgressOperations() const;
    QVector<CGuestOSType> GetGuestOSTypes() const;
    QVector<CSharedFolder> GetSharedFolders() const;
    CPerformanceCollector GetPerformanceCollector() const;
    QVector<CDHCPServer> GetDHCPServers() const;
    QVector<CNATNetwork> GetNATNetworks() const;
    CEventSource GetEventSource() const;
    CExtPackManager GetExtensionPackManager() const;
    QVector<QString> GetInternalNetworks() const;
    QVector<QString> GetGenericNetworkDrivers() const;

    /* Methods: */
    QString ComposeMachineFilename(const QString & aName, const QString & aGroup, const QString & aCreateFlags, const QString & aBaseFolder);
    CMachine CreateMachine(const QString & aSettingsFile, const QString & aName, const QVector<QString> & aGroups, const QString & aOsTypeId, const QString & aFlags);
    CMachine OpenMachine(const QString & aSettingsFile);
    void RegisterMachine(const CMachine & aMachine);
    CMachine FindMachine(const QString & aNameOrId);
    QVector<CMachine> GetMachinesByGroups(const QVector<QString> & aGroups);
    QVector<KMachineState> GetMachineStates(const QVector<CMachine> & aMachines);
    CAppliance CreateAppliance();
    CMedium CreateHardDisk(const QString & aFormat, const QString & aLocation);
    CMedium OpenMedium(const QString & aLocation, const KDeviceType & aDeviceType, const KAccessMode & aAccessMode, BOOL aForceNewUuid);
    CGuestOSType GetGuestOSType(QString aId);
    void CreateSharedFolder(const QString & aName, const QString & aHostPath, BOOL aWritable, BOOL aAutomount);
    void RemoveSharedFolder(const QString & aName);
    QVector<QString> GetExtraDataKeys();
    QString GetExtraData(const QString & aKey);
    void SetExtraData(const QString & aKey, const QString & aValue);
    void SetSettingsSecret(const QString & aPassword);
    CDHCPServer CreateDHCPServer(const QString & aName);
    CDHCPServer FindDHCPServerByNetworkName(const QString & aName);
    void RemoveDHCPServer(const CDHCPServer & aServer);
    CNATNetwork CreateNATNetwork(const QString & aNetworkName);
    CNATNetwork FindNATNetworkByName(const QString & aNetworkName);
    void RemoveNATNetwork(const CNATNetwork & aNetwork);
    BOOL CheckFirmwarePresent(const KFirmwareType & aFirmwareType, const QString & aVersion, QString & aUrl, QString & aFile);

    /* ExtraData helpers: */
    void SetExtraDataBool(const QString &strKey, bool fValue);
    bool GetExtraDataBool(const QString &strKey, bool fDef = true);
    void SetExtraDataInt(const QString &strKey, int value);
    int GetExtraDataInt(const QString &strKey, int def = 0);
    void SetExtraDataRect(const QString &strKey, const QRect &value);
    QRect GetExtraDataRect(const QString &strKey, const QRect &def = QRect());
    void SetExtraDataStringList(const QString &strKey, const QStringList &value);
    QStringList GetExtraDataStringList(const QString &strKey, QStringList def = QStringList());
    void SetExtraDataIntList(const QString &strKey, const QList<int> &value);
    QList<int> GetExtraDataIntList(const QString &strKey, QList<int> def = QList<int>());

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CMachine;
    friend class CWebsessionManager;
    friend class CVirtualBoxClient;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CVirtualBox)

#endif /* __CVirtualBox_h__ */


// ##### ENDFILE "CVirtualBox.h"


// ##### BEGINFILE "CVFSExplorer.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CVFSExplorer_h__
#define __CVFSExplorer_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CVFSExplorer : public CInterface<IVFSExplorer, COMBaseWithEI>
{
public:

    typedef CInterface<IVFSExplorer, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CVFSExplorer() {}

    template<class OI, class OB> explicit CVFSExplorer(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CVFSExplorer(const CVFSExplorer & that) : Base(that) {}

    template<class OI> explicit CVFSExplorer(OI * aIface) { attach(aIface); }

    explicit CVFSExplorer(IVFSExplorer * aIface) : Base(aIface) {}

    template<class OI, class OB> CVFSExplorer & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CVFSExplorer & operator=(const CVFSExplorer & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CVFSExplorer & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CVFSExplorer & operator=(IVFSExplorer * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetPath() const;
    KVFSType GetType() const;

    /* Methods: */
    CProgress Update();
    CProgress Cd(const QString & aDir);
    CProgress CdUp();
    void EntryList(QVector<QString> & aNames, QVector<ULONG> & aTypes, QVector<LONG64> & aSizes, QVector<ULONG> & aModes);
    QVector<QString> Exists(const QVector<QString> & aNames);
    CProgress Remove(const QVector<QString> & aNames);

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CAppliance;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CVFSExplorer)

#endif /* __CVFSExplorer_h__ */


// ##### ENDFILE "CVFSExplorer.h"


// ##### BEGINFILE "CAppliance.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CAppliance_h__
#define __CAppliance_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CAppliance : public CInterface<IAppliance, COMBaseWithEI>
{
public:

    typedef CInterface<IAppliance, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CAppliance() {}

    template<class OI, class OB> explicit CAppliance(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CAppliance(const CAppliance & that) : Base(that) {}

    template<class OI> explicit CAppliance(OI * aIface) { attach(aIface); }

    explicit CAppliance(IAppliance * aIface) : Base(aIface) {}

    template<class OI, class OB> CAppliance & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CAppliance & operator=(const CAppliance & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CAppliance & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CAppliance & operator=(IAppliance * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetPath() const;
    QVector<QString> GetDisks() const;
    QVector<CVirtualSystemDescription> GetVirtualSystemDescriptions() const;
    QVector<QString> GetMachines() const;

    /* Methods: */
    CProgress Read(const QString & aFile);
    void Interpret();
    CProgress ImportMachines(const QVector<KImportOptions> & aOptions);
    CVFSExplorer CreateVFSExplorer(const QString & aURI);
    CProgress Write(const QString & aFormat, const QVector<KExportOptions> & aOptions, const QString & aPath);
    QVector<QString> GetWarnings();

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CVirtualBox;
    friend class CMachine;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CAppliance)

#endif /* __CAppliance_h__ */


// ##### ENDFILE "CAppliance.h"


// ##### BEGINFILE "CVirtualSystemDescription.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CVirtualSystemDescription_h__
#define __CVirtualSystemDescription_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CVirtualSystemDescription : public CInterface<IVirtualSystemDescription, COMBaseWithEI>
{
public:

    typedef CInterface<IVirtualSystemDescription, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CVirtualSystemDescription() {}

    template<class OI, class OB> explicit CVirtualSystemDescription(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CVirtualSystemDescription(const CVirtualSystemDescription & that) : Base(that) {}

    template<class OI> explicit CVirtualSystemDescription(OI * aIface) { attach(aIface); }

    explicit CVirtualSystemDescription(IVirtualSystemDescription * aIface) : Base(aIface) {}

    template<class OI, class OB> CVirtualSystemDescription & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CVirtualSystemDescription & operator=(const CVirtualSystemDescription & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CVirtualSystemDescription & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CVirtualSystemDescription & operator=(IVirtualSystemDescription * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    ULONG GetCount() const;

    /* Methods: */
    void GetDescription(QVector<KVirtualSystemDescriptionType> & aTypes, QVector<QString> & aRefs, QVector<QString> & aOVFValues, QVector<QString> & aVBoxValues, QVector<QString> & aExtraConfigValues);
    void GetDescriptionByType(const KVirtualSystemDescriptionType & aType, QVector<KVirtualSystemDescriptionType> & aTypes, QVector<QString> & aRefs, QVector<QString> & aOVFValues, QVector<QString> & aVBoxValues, QVector<QString> & aExtraConfigValues);
    QVector<QString> GetValuesByType(const KVirtualSystemDescriptionType & aType, const KVirtualSystemDescriptionValueType & aWhich);
    void SetFinalValues(const QVector<BOOL> & aEnabled, const QVector<QString> & aVBoxValues, const QVector<QString> & aExtraConfigValues);
    void AddDescription(const KVirtualSystemDescriptionType & aType, const QString & aVBoxValue, const QString & aExtraConfigValue);

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CAppliance;
    friend class CMachine;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CVirtualSystemDescription)

/* Declare safe-array: */
typedef QVector<CVirtualSystemDescription> CVirtualSystemDescriptionVector;

#endif /* __CVirtualSystemDescription_h__ */


// ##### ENDFILE "CVirtualSystemDescription.h"


// ##### BEGINFILE "CBIOSSettings.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CBIOSSettings_h__
#define __CBIOSSettings_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CBIOSSettings : public CInterface<IBIOSSettings, COMBaseWithEI>
{
public:

    typedef CInterface<IBIOSSettings, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CBIOSSettings() {}

    template<class OI, class OB> explicit CBIOSSettings(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CBIOSSettings(const CBIOSSettings & that) : Base(that) {}

    template<class OI> explicit CBIOSSettings(OI * aIface) { attach(aIface); }

    explicit CBIOSSettings(IBIOSSettings * aIface) : Base(aIface) {}

    template<class OI, class OB> CBIOSSettings & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CBIOSSettings & operator=(const CBIOSSettings & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CBIOSSettings & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CBIOSSettings & operator=(IBIOSSettings * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    BOOL GetLogoFadeIn() const;
    void SetLogoFadeIn(BOOL aLogoFadeIn);
    BOOL GetLogoFadeOut() const;
    void SetLogoFadeOut(BOOL aLogoFadeOut);
    ULONG GetLogoDisplayTime() const;
    void SetLogoDisplayTime(ULONG aLogoDisplayTime);
    QString GetLogoImagePath() const;
    void SetLogoImagePath(const QString & aLogoImagePath);
    KBIOSBootMenuMode GetBootMenuMode() const;
    void SetBootMenuMode(const KBIOSBootMenuMode & aBootMenuMode);
    BOOL GetACPIEnabled() const;
    void SetACPIEnabled(BOOL aACPIEnabled);
    BOOL GetIOAPICEnabled() const;
    void SetIOAPICEnabled(BOOL aIOAPICEnabled);
    LONG64 GetTimeOffset() const;
    void SetTimeOffset(LONG64 aTimeOffset);
    BOOL GetPXEDebugEnabled() const;
    void SetPXEDebugEnabled(BOOL aPXEDebugEnabled);
    QString GetNonVolatileStorageFile() const;

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CMachine;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CBIOSSettings)

#endif /* __CBIOSSettings_h__ */


// ##### ENDFILE "CBIOSSettings.h"


// ##### BEGINFILE "CPCIAddress.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CPCIAddress_h__
#define __CPCIAddress_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CPCIAddress : public CInterface<IPCIAddress, COMBaseWithEI>
{
public:

    typedef CInterface<IPCIAddress, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CPCIAddress() {}

    template<class OI, class OB> explicit CPCIAddress(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CPCIAddress(const CPCIAddress & that) : Base(that) {}

    template<class OI> explicit CPCIAddress(OI * aIface) { attach(aIface); }

    explicit CPCIAddress(IPCIAddress * aIface) : Base(aIface) {}

    template<class OI, class OB> CPCIAddress & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CPCIAddress & operator=(const CPCIAddress & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CPCIAddress & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CPCIAddress & operator=(IPCIAddress * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    SHORT GetBus() const;
    void SetBus(SHORT aBus);
    SHORT GetDevice() const;
    void SetDevice(SHORT aDevice);
    SHORT GetDevFunction() const;
    void SetDevFunction(SHORT aDevFunction);

    /* Methods: */
    LONG AsLong();
    void FromLong(LONG aNumber);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CPCIAddress)

#endif /* __CPCIAddress_h__ */


// ##### ENDFILE "CPCIAddress.h"


// ##### BEGINFILE "CPCIDeviceAttachment.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CPCIDeviceAttachment_h__
#define __CPCIDeviceAttachment_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CPCIDeviceAttachment : public CInterface<IPCIDeviceAttachment, COMBaseWithEI>
{
public:

    typedef CInterface<IPCIDeviceAttachment, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CPCIDeviceAttachment() {}

    template<class OI, class OB> explicit CPCIDeviceAttachment(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CPCIDeviceAttachment(const CPCIDeviceAttachment & that) : Base(that) {}

    template<class OI> explicit CPCIDeviceAttachment(OI * aIface) { attach(aIface); }

    explicit CPCIDeviceAttachment(IPCIDeviceAttachment * aIface) : Base(aIface) {}

    template<class OI, class OB> CPCIDeviceAttachment & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CPCIDeviceAttachment & operator=(const CPCIDeviceAttachment & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CPCIDeviceAttachment & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CPCIDeviceAttachment & operator=(IPCIDeviceAttachment * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetName() const;
    BOOL GetIsPhysicalDevice() const;
    LONG GetHostAddress() const;
    LONG GetGuestAddress() const;

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CMachine;
    friend class CConsole;
    friend class CHostPCIDevicePlugEvent;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CPCIDeviceAttachment)

/* Declare safe-array: */
typedef QVector<CPCIDeviceAttachment> CPCIDeviceAttachmentVector;

#endif /* __CPCIDeviceAttachment_h__ */


// ##### ENDFILE "CPCIDeviceAttachment.h"


// ##### BEGINFILE "CMachine.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CMachine_h__
#define __CMachine_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CMachine : public CInterface<IMachine, COMBaseWithEI>
{
public:

    typedef CInterface<IMachine, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CMachine() {}

    template<class OI, class OB> explicit CMachine(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CMachine(const CMachine & that) : Base(that) {}

    template<class OI> explicit CMachine(OI * aIface) { attach(aIface); }

    explicit CMachine(IMachine * aIface) : Base(aIface) {}

    template<class OI, class OB> CMachine & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CMachine & operator=(const CMachine & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CMachine & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CMachine & operator=(IMachine * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    CVirtualBox GetParent() const;
    QVector<BYTE> GetIcon() const;
    void SetIcon(const QVector<BYTE> & aIcon);
    BOOL GetAccessible() const;
    CVirtualBoxErrorInfo GetAccessError() const;
    QString GetName() const;
    void SetName(const QString & aName);
    QString GetDescription() const;
    void SetDescription(const QString & aDescription);
    QString GetId() const;
    QVector<QString> GetGroups() const;
    void SetGroups(const QVector<QString> & aGroups);
    QString GetOSTypeId() const;
    void SetOSTypeId(const QString & aOSTypeId);
    QString GetHardwareVersion() const;
    void SetHardwareVersion(const QString & aHardwareVersion);
    QString GetHardwareUUID() const;
    void SetHardwareUUID(QString aHardwareUUID);
    ULONG GetCPUCount() const;
    void SetCPUCount(ULONG aCPUCount);
    BOOL GetCPUHotPlugEnabled() const;
    void SetCPUHotPlugEnabled(BOOL aCPUHotPlugEnabled);
    ULONG GetCPUExecutionCap() const;
    void SetCPUExecutionCap(ULONG aCPUExecutionCap);
    ULONG GetMemorySize() const;
    void SetMemorySize(ULONG aMemorySize);
    ULONG GetMemoryBalloonSize() const;
    void SetMemoryBalloonSize(ULONG aMemoryBalloonSize);
    BOOL GetPageFusionEnabled() const;
    void SetPageFusionEnabled(BOOL aPageFusionEnabled);
    KGraphicsControllerType GetGraphicsControllerType() const;
    void SetGraphicsControllerType(const KGraphicsControllerType & aGraphicsControllerType);
    ULONG GetVRAMSize() const;
    void SetVRAMSize(ULONG aVRAMSize);
    BOOL GetAccelerate3DEnabled() const;
    void SetAccelerate3DEnabled(BOOL aAccelerate3DEnabled);
    BOOL GetAccelerate2DVideoEnabled() const;
    void SetAccelerate2DVideoEnabled(BOOL aAccelerate2DVideoEnabled);
    ULONG GetMonitorCount() const;
    void SetMonitorCount(ULONG aMonitorCount);
    BOOL GetVideoCaptureEnabled() const;
    void SetVideoCaptureEnabled(BOOL aVideoCaptureEnabled);
    QVector<BOOL> GetVideoCaptureScreens() const;
    void SetVideoCaptureScreens(const QVector<BOOL> & aVideoCaptureScreens);
    QString GetVideoCaptureFile() const;
    void SetVideoCaptureFile(const QString & aVideoCaptureFile);
    ULONG GetVideoCaptureWidth() const;
    void SetVideoCaptureWidth(ULONG aVideoCaptureWidth);
    ULONG GetVideoCaptureHeight() const;
    void SetVideoCaptureHeight(ULONG aVideoCaptureHeight);
    ULONG GetVideoCaptureRate() const;
    void SetVideoCaptureRate(ULONG aVideoCaptureRate);
    ULONG GetVideoCaptureFPS() const;
    void SetVideoCaptureFPS(ULONG aVideoCaptureFPS);
    CBIOSSettings GetBIOSSettings() const;
    KFirmwareType GetFirmwareType() const;
    void SetFirmwareType(const KFirmwareType & aFirmwareType);
    KPointingHIDType GetPointingHIDType() const;
    void SetPointingHIDType(const KPointingHIDType & aPointingHIDType);
    KKeyboardHIDType GetKeyboardHIDType() const;
    void SetKeyboardHIDType(const KKeyboardHIDType & aKeyboardHIDType);
    BOOL GetHPETEnabled() const;
    void SetHPETEnabled(BOOL aHPETEnabled);
    KChipsetType GetChipsetType() const;
    void SetChipsetType(const KChipsetType & aChipsetType);
    QString GetSnapshotFolder() const;
    void SetSnapshotFolder(const QString & aSnapshotFolder);
    CVRDEServer GetVRDEServer() const;
    BOOL GetEmulatedUSBCardReaderEnabled() const;
    void SetEmulatedUSBCardReaderEnabled(BOOL aEmulatedUSBCardReaderEnabled);
    QVector<CMediumAttachment> GetMediumAttachments() const;
    QVector<CUSBController> GetUSBControllers() const;
    CUSBDeviceFilters GetUSBDeviceFilters() const;
    CAudioAdapter GetAudioAdapter() const;
    QVector<CStorageController> GetStorageControllers() const;
    QString GetSettingsFilePath() const;
    BOOL GetSettingsModified() const;
    KSessionState GetSessionState() const;
    QString GetSessionType() const;
    ULONG GetSessionPID() const;
    KMachineState GetState() const;
    LONG64 GetLastStateChange() const;
    QString GetStateFilePath() const;
    QString GetLogFolder() const;
    CSnapshot GetCurrentSnapshot() const;
    ULONG GetSnapshotCount() const;
    BOOL GetCurrentStateModified() const;
    QVector<CSharedFolder> GetSharedFolders() const;
    KClipboardMode GetClipboardMode() const;
    void SetClipboardMode(const KClipboardMode & aClipboardMode);
    KDragAndDropMode GetDragAndDropMode() const;
    void SetDragAndDropMode(const KDragAndDropMode & aDragAndDropMode);
    QString GetGuestPropertyNotificationPatterns() const;
    void SetGuestPropertyNotificationPatterns(const QString & aGuestPropertyNotificationPatterns);
    BOOL GetTeleporterEnabled() const;
    void SetTeleporterEnabled(BOOL aTeleporterEnabled);
    ULONG GetTeleporterPort() const;
    void SetTeleporterPort(ULONG aTeleporterPort);
    QString GetTeleporterAddress() const;
    void SetTeleporterAddress(const QString & aTeleporterAddress);
    QString GetTeleporterPassword() const;
    void SetTeleporterPassword(const QString & aTeleporterPassword);
    KFaultToleranceState GetFaultToleranceState() const;
    void SetFaultToleranceState(const KFaultToleranceState & aFaultToleranceState);
    ULONG GetFaultTolerancePort() const;
    void SetFaultTolerancePort(ULONG aFaultTolerancePort);
    QString GetFaultToleranceAddress() const;
    void SetFaultToleranceAddress(const QString & aFaultToleranceAddress);
    QString GetFaultTolerancePassword() const;
    void SetFaultTolerancePassword(const QString & aFaultTolerancePassword);
    ULONG GetFaultToleranceSyncInterval() const;
    void SetFaultToleranceSyncInterval(ULONG aFaultToleranceSyncInterval);
    BOOL GetRTCUseUTC() const;
    void SetRTCUseUTC(BOOL aRTCUseUTC);
    BOOL GetIOCacheEnabled() const;
    void SetIOCacheEnabled(BOOL aIOCacheEnabled);
    ULONG GetIOCacheSize() const;
    void SetIOCacheSize(ULONG aIOCacheSize);
    QVector<CPCIDeviceAttachment> GetPCIDeviceAssignments() const;
    CBandwidthControl GetBandwidthControl() const;
    BOOL GetTracingEnabled() const;
    void SetTracingEnabled(BOOL aTracingEnabled);
    QString GetTracingConfig() const;
    void SetTracingConfig(const QString & aTracingConfig);
    BOOL GetAllowTracingToAccessVM() const;
    void SetAllowTracingToAccessVM(BOOL aAllowTracingToAccessVM);
    BOOL GetAutostartEnabled() const;
    void SetAutostartEnabled(BOOL aAutostartEnabled);
    ULONG GetAutostartDelay() const;
    void SetAutostartDelay(ULONG aAutostartDelay);
    KAutostopType GetAutostopType() const;
    void SetAutostopType(const KAutostopType & aAutostopType);
    QString GetDefaultFrontend() const;
    void SetDefaultFrontend(const QString & aDefaultFrontend);
    BOOL GetUSBProxyAvailable() const;

    /* Methods: */
    void LockMachine(const CSession & aSession, const KLockType & aLockType);
    CProgress LaunchVMProcess(const CSession & aSession, const QString & aType, const QString & aEnvironment);
    void SetBootOrder(ULONG aPosition, const KDeviceType & aDevice);
    KDeviceType GetBootOrder(ULONG aPosition) const;
    void AttachDevice(const QString & aName, LONG aControllerPort, LONG aDevice, const KDeviceType & aType, const CMedium & aMedium);
    void AttachDeviceWithoutMedium(const QString & aName, LONG aControllerPort, LONG aDevice, const KDeviceType & aType);
    void DetachDevice(const QString & aName, LONG aControllerPort, LONG aDevice);
    void PassthroughDevice(const QString & aName, LONG aControllerPort, LONG aDevice, BOOL aPassthrough);
    void TemporaryEjectDevice(const QString & aName, LONG aControllerPort, LONG aDevice, BOOL aTemporaryEject);
    void NonRotationalDevice(const QString & aName, LONG aControllerPort, LONG aDevice, BOOL aNonRotational);
    void SetAutoDiscardForDevice(const QString & aName, LONG aControllerPort, LONG aDevice, BOOL aDiscard);
    void SetHotPluggableForDevice(const QString & aName, LONG aControllerPort, LONG aDevice, BOOL aHotPluggable);
    void SetBandwidthGroupForDevice(const QString & aName, LONG aControllerPort, LONG aDevice, const CBandwidthGroup & aBandwidthGroup);
    void SetNoBandwidthGroupForDevice(const QString & aName, LONG aControllerPort, LONG aDevice);
    void UnmountMedium(const QString & aName, LONG aControllerPort, LONG aDevice, BOOL aForce);
    void MountMedium(const QString & aName, LONG aControllerPort, LONG aDevice, const CMedium & aMedium, BOOL aForce);
    CMedium GetMedium(const QString & aName, LONG aControllerPort, LONG aDevice) const;
    QVector<CMediumAttachment> GetMediumAttachmentsOfController(const QString & aName) const;
    CMediumAttachment GetMediumAttachment(const QString & aName, LONG aControllerPort, LONG aDevice) const;
    void AttachHostPCIDevice(LONG aHostAddress, LONG aDesiredGuestAddress, BOOL aTryToUnbind);
    void DetachHostPCIDevice(LONG aHostAddress);
    CNetworkAdapter GetNetworkAdapter(ULONG aSlot) const;
    CStorageController AddStorageController(const QString & aName, const KStorageBus & aConnectionType);
    CStorageController GetStorageControllerByName(const QString & aName) const;
    CStorageController GetStorageControllerByInstance(ULONG aInstance) const;
    void RemoveStorageController(const QString & aName);
    void SetStorageControllerBootable(const QString & aName, BOOL aBootable);
    CUSBController AddUSBController(const QString & aName, const KUSBControllerType & aType);
    void RemoveUSBController(const QString & aName);
    CUSBController GetUSBControllerByName(const QString & aName) const;
    ULONG GetUSBControllerCountByType(const KUSBControllerType & aType) const;
    CSerialPort GetSerialPort(ULONG aSlot) const;
    CParallelPort GetParallelPort(ULONG aSlot) const;
    QVector<QString> GetExtraDataKeys();
    QString GetExtraData(const QString & aKey);
    void SetExtraData(const QString & aKey, const QString & aValue);
    BOOL GetCPUProperty(const KCPUPropertyType & aProperty) const;
    void SetCPUProperty(const KCPUPropertyType & aProperty, BOOL aValue);
    void GetCPUIDLeaf(ULONG aId, ULONG & aValEax, ULONG & aValEbx, ULONG & aValEcx, ULONG & aValEdx) const;
    void SetCPUIDLeaf(ULONG aId, ULONG aValEax, ULONG aValEbx, ULONG aValEcx, ULONG aValEdx);
    void RemoveCPUIDLeaf(ULONG aId);
    void RemoveAllCPUIDLeaves();
    BOOL GetHWVirtExProperty(const KHWVirtExPropertyType & aProperty) const;
    void SetHWVirtExProperty(const KHWVirtExPropertyType & aProperty, BOOL aValue);
    CProgress SetSettingsFilePath(const QString & aSettingsFilePath);
    void SaveSettings();
    void DiscardSettings();
    QVector<CMedium> Unregister(const KCleanupMode & aCleanupMode);
    CProgress DeleteConfig(const QVector<CMedium> & aMedia);
    CVirtualSystemDescription ExportTo(const CAppliance & aAppliance, const QString & aLocation);
    CSnapshot FindSnapshot(const QString & aNameOrId);
    void CreateSharedFolder(const QString & aName, const QString & aHostPath, BOOL aWritable, BOOL aAutomount);
    void RemoveSharedFolder(const QString & aName);
    BOOL CanShowConsoleWindow();
    LONG64 ShowConsoleWindow();
    void GetGuestProperty(const QString & aName, QString & aValue, LONG64 & aTimestamp, QString & aFlags) const;
    QString GetGuestPropertyValue(const QString & aProperty) const;
    LONG64 GetGuestPropertyTimestamp(const QString & aProperty) const;
    void SetGuestProperty(const QString & aProperty, const QString & aValue, const QString & aFlags);
    void SetGuestPropertyValue(const QString & aProperty, const QString & aValue);
    void DeleteGuestProperty(const QString & aName) const;
    void EnumerateGuestProperties(const QString & aPatterns, QVector<QString> & aNames, QVector<QString> & aValues, QVector<LONG64> & aTimestamps, QVector<QString> & aFlags) const;
    void QuerySavedGuestScreenInfo(ULONG aScreenId, ULONG & aOriginX, ULONG & aOriginY, ULONG & aWidth, ULONG & aHeight, BOOL & aEnabled) const;
    void QuerySavedThumbnailSize(ULONG aScreenId, ULONG & aSize, ULONG & aWidth, ULONG & aHeight);
    QVector<BYTE> ReadSavedThumbnailToArray(ULONG aScreenId, BOOL aBGR, ULONG & aWidth, ULONG & aHeight);
    QVector<BYTE> ReadSavedThumbnailPNGToArray(ULONG aScreenId, ULONG & aWidth, ULONG & aHeight);
    void QuerySavedScreenshotPNGSize(ULONG aScreenId, ULONG & aSize, ULONG & aWidth, ULONG & aHeight);
    QVector<BYTE> ReadSavedScreenshotPNGToArray(ULONG aScreenId, ULONG & aWidth, ULONG & aHeight);
    void HotPlugCPU(ULONG aCpu);
    void HotUnplugCPU(ULONG aCpu);
    BOOL GetCPUStatus(ULONG aCpu);
    QString QueryLogFilename(ULONG aIdx);
    QVector<BYTE> ReadLog(ULONG aIdx, LONG64 aOffset, LONG64 aSize);
    CProgress CloneTo(const CMachine & aTarget, const KCloneMode & aMode, const QVector<KCloneOptions> & aOptions);

    /* ExtraData helpers: */
    void SetExtraDataBool(const QString &strKey, bool fValue);
    bool GetExtraDataBool(const QString &strKey, bool fDef = true);
    void SetExtraDataInt(const QString &strKey, int value);
    int GetExtraDataInt(const QString &strKey, int def = 0);
    void SetExtraDataRect(const QString &strKey, const QRect &value);
    QRect GetExtraDataRect(const QString &strKey, const QRect &def = QRect());
    void SetExtraDataStringList(const QString &strKey, const QStringList &value);
    QStringList GetExtraDataStringList(const QString &strKey, QStringList def = QStringList());
    void SetExtraDataIntList(const QString &strKey, const QList<int> &value);
    QList<int> GetExtraDataIntList(const QString &strKey, QList<int> def = QList<int>());

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CVirtualBox;
    friend class CConsole;
    friend class CSnapshot;
    friend class CInternalSessionControl;
    friend class CSession;
    friend class CVirtualBoxClient;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CMachine)

/* Declare safe-array: */
typedef QVector<CMachine> CMachineVector;

#endif /* __CMachine_h__ */


// ##### ENDFILE "CMachine.h"


// ##### BEGINFILE "CEmulatedUSB.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CEmulatedUSB_h__
#define __CEmulatedUSB_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CEmulatedUSB : public CInterface<IEmulatedUSB, COMBaseWithEI>
{
public:

    typedef CInterface<IEmulatedUSB, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CEmulatedUSB() {}

    template<class OI, class OB> explicit CEmulatedUSB(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CEmulatedUSB(const CEmulatedUSB & that) : Base(that) {}

    template<class OI> explicit CEmulatedUSB(OI * aIface) { attach(aIface); }

    explicit CEmulatedUSB(IEmulatedUSB * aIface) : Base(aIface) {}

    template<class OI, class OB> CEmulatedUSB & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CEmulatedUSB & operator=(const CEmulatedUSB & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CEmulatedUSB & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CEmulatedUSB & operator=(IEmulatedUSB * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QVector<QString> GetWebcams() const;

    /* Methods: */
    void WebcamAttach(const QString & aPath, const QString & aSettings);
    void WebcamDetach(const QString & aPath);

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CConsole;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CEmulatedUSB)

#endif /* __CEmulatedUSB_h__ */


// ##### ENDFILE "CEmulatedUSB.h"


// ##### BEGINFILE "CVRDEServerInfo.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CVRDEServerInfo_h__
#define __CVRDEServerInfo_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CVRDEServerInfo : public CInterface<IVRDEServerInfo, COMBaseWithEI>
{
public:

    typedef CInterface<IVRDEServerInfo, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CVRDEServerInfo() {}

    template<class OI, class OB> explicit CVRDEServerInfo(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CVRDEServerInfo(const CVRDEServerInfo & that) : Base(that) {}

    template<class OI> explicit CVRDEServerInfo(OI * aIface) { attach(aIface); }

    explicit CVRDEServerInfo(IVRDEServerInfo * aIface) : Base(aIface) {}

    template<class OI, class OB> CVRDEServerInfo & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CVRDEServerInfo & operator=(const CVRDEServerInfo & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CVRDEServerInfo & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CVRDEServerInfo & operator=(IVRDEServerInfo * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    BOOL GetActive() const;
    LONG GetPort() const;
    ULONG GetNumberOfClients() const;
    LONG64 GetBeginTime() const;
    LONG64 GetEndTime() const;
    LONG64 GetBytesSent() const;
    LONG64 GetBytesSentTotal() const;
    LONG64 GetBytesReceived() const;
    LONG64 GetBytesReceivedTotal() const;
    QString GetUser() const;
    QString GetDomain() const;
    QString GetClientName() const;
    QString GetClientIP() const;
    ULONG GetClientVersion() const;
    ULONG GetEncryptionStyle() const;

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CConsole;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CVRDEServerInfo)

#endif /* __CVRDEServerInfo_h__ */


// ##### ENDFILE "CVRDEServerInfo.h"


// ##### BEGINFILE "CConsole.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CConsole_h__
#define __CConsole_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CConsole : public CInterface<IConsole, COMBaseWithEI>
{
public:

    typedef CInterface<IConsole, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CConsole() {}

    template<class OI, class OB> explicit CConsole(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CConsole(const CConsole & that) : Base(that) {}

    template<class OI> explicit CConsole(OI * aIface) { attach(aIface); }

    explicit CConsole(IConsole * aIface) : Base(aIface) {}

    template<class OI, class OB> CConsole & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CConsole & operator=(const CConsole & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CConsole & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CConsole & operator=(IConsole * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    CMachine GetMachine() const;
    KMachineState GetState() const;
    CGuest GetGuest() const;
    CKeyboard GetKeyboard() const;
    CMouse GetMouse() const;
    CDisplay GetDisplay() const;
    CMachineDebugger GetDebugger() const;
    QVector<CUSBDevice> GetUSBDevices() const;
    QVector<CHostUSBDevice> GetRemoteUSBDevices() const;
    QVector<CSharedFolder> GetSharedFolders() const;
    CVRDEServerInfo GetVRDEServerInfo() const;
    CEventSource GetEventSource() const;
    QVector<CPCIDeviceAttachment> GetAttachedPCIDevices() const;
    BOOL GetUseHostClipboard() const;
    void SetUseHostClipboard(BOOL aUseHostClipboard);
    CEmulatedUSB GetEmulatedUSB() const;

    /* Methods: */
    CProgress PowerUp();
    CProgress PowerUpPaused();
    CProgress PowerDown();
    void Reset();
    void Pause();
    void Resume();
    void PowerButton();
    void SleepButton();
    BOOL GetPowerButtonHandled();
    BOOL GetGuestEnteredACPIMode();
    CProgress SaveState();
    void AdoptSavedState(const QString & aSavedStateFile);
    void DiscardSavedState(BOOL aFRemoveFile);
    KDeviceActivity GetDeviceActivity(const KDeviceType & aType);
    void AttachUSBDevice(QString aId);
    CUSBDevice DetachUSBDevice(QString aId);
    CUSBDevice FindUSBDeviceByAddress(const QString & aName);
    CUSBDevice FindUSBDeviceById(QString aId);
    void CreateSharedFolder(const QString & aName, const QString & aHostPath, BOOL aWritable, BOOL aAutomount);
    void RemoveSharedFolder(const QString & aName);
    CProgress TakeSnapshot(const QString & aName, const QString & aDescription);
    CProgress DeleteSnapshot(QString aId);
    CProgress DeleteSnapshotAndAllChildren(QString aId);
    CProgress DeleteSnapshotRange(QString aStartId, QString aEndId);
    CProgress RestoreSnapshot(const CSnapshot & aSnapshot);
    CProgress Teleport(const QString & aHostname, ULONG aTcpport, const QString & aPassword, ULONG aMaxDowntime);

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CInternalMachineControl;
    friend class CInternalSessionControl;
    friend class CSession;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CConsole)

#endif /* __CConsole_h__ */


// ##### ENDFILE "CConsole.h"


// ##### BEGINFILE "CHostNetworkInterface.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CHostNetworkInterface_h__
#define __CHostNetworkInterface_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CHostNetworkInterface : public CInterface<IHostNetworkInterface, COMBaseWithEI>
{
public:

    typedef CInterface<IHostNetworkInterface, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CHostNetworkInterface() {}

    template<class OI, class OB> explicit CHostNetworkInterface(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CHostNetworkInterface(const CHostNetworkInterface & that) : Base(that) {}

    template<class OI> explicit CHostNetworkInterface(OI * aIface) { attach(aIface); }

    explicit CHostNetworkInterface(IHostNetworkInterface * aIface) : Base(aIface) {}

    template<class OI, class OB> CHostNetworkInterface & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CHostNetworkInterface & operator=(const CHostNetworkInterface & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CHostNetworkInterface & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CHostNetworkInterface & operator=(IHostNetworkInterface * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetName() const;
    QString GetShortName() const;
    QString GetId() const;
    QString GetNetworkName() const;
    BOOL GetDHCPEnabled() const;
    QString GetIPAddress() const;
    QString GetNetworkMask() const;
    BOOL GetIPV6Supported() const;
    QString GetIPV6Address() const;
    ULONG GetIPV6NetworkMaskPrefixLength() const;
    QString GetHardwareAddress() const;
    KHostNetworkInterfaceMediumType GetMediumType() const;
    KHostNetworkInterfaceStatus GetStatus() const;
    KHostNetworkInterfaceType GetInterfaceType() const;

    /* Methods: */
    void EnableStaticIPConfig(const QString & aIPAddress, const QString & aNetworkMask);
    void EnableStaticIPConfigV6(const QString & aIPV6Address, ULONG aIPV6NetworkMaskPrefixLength);
    void EnableDynamicIPConfig();
    void DHCPRediscover();

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CHost;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CHostNetworkInterface)

/* Declare safe-array: */
typedef QVector<CHostNetworkInterface> CHostNetworkInterfaceVector;

#endif /* __CHostNetworkInterface_h__ */


// ##### ENDFILE "CHostNetworkInterface.h"


// ##### BEGINFILE "CHostVideoInputDevice.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CHostVideoInputDevice_h__
#define __CHostVideoInputDevice_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CHostVideoInputDevice : public CInterface<IHostVideoInputDevice, COMBaseWithEI>
{
public:

    typedef CInterface<IHostVideoInputDevice, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CHostVideoInputDevice() {}

    template<class OI, class OB> explicit CHostVideoInputDevice(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CHostVideoInputDevice(const CHostVideoInputDevice & that) : Base(that) {}

    template<class OI> explicit CHostVideoInputDevice(OI * aIface) { attach(aIface); }

    explicit CHostVideoInputDevice(IHostVideoInputDevice * aIface) : Base(aIface) {}

    template<class OI, class OB> CHostVideoInputDevice & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CHostVideoInputDevice & operator=(const CHostVideoInputDevice & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CHostVideoInputDevice & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CHostVideoInputDevice & operator=(IHostVideoInputDevice * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetName() const;
    QString GetPath() const;
    QString GetAlias() const;

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CHost;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CHostVideoInputDevice)

/* Declare safe-array: */
typedef QVector<CHostVideoInputDevice> CHostVideoInputDeviceVector;

#endif /* __CHostVideoInputDevice_h__ */


// ##### ENDFILE "CHostVideoInputDevice.h"


// ##### BEGINFILE "CHost.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CHost_h__
#define __CHost_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CHost : public CInterface<IHost, COMBaseWithEI>
{
public:

    typedef CInterface<IHost, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CHost() {}

    template<class OI, class OB> explicit CHost(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CHost(const CHost & that) : Base(that) {}

    template<class OI> explicit CHost(OI * aIface) { attach(aIface); }

    explicit CHost(IHost * aIface) : Base(aIface) {}

    template<class OI, class OB> CHost & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CHost & operator=(const CHost & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CHost & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CHost & operator=(IHost * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QVector<CMedium> GetDVDDrives() const;
    QVector<CMedium> GetFloppyDrives() const;
    QVector<CHostUSBDevice> GetUSBDevices() const;
    QVector<CHostUSBDeviceFilter> GetUSBDeviceFilters() const;
    QVector<CHostNetworkInterface> GetNetworkInterfaces() const;
    QVector<QString> GetNameServers() const;
    QString GetDomainName() const;
    QVector<QString> GetSearchStrings() const;
    ULONG GetProcessorCount() const;
    ULONG GetProcessorOnlineCount() const;
    ULONG GetProcessorCoreCount() const;
    ULONG GetProcessorOnlineCoreCount() const;
    ULONG GetMemorySize() const;
    ULONG GetMemoryAvailable() const;
    QString GetOperatingSystem() const;
    QString GetOSVersion() const;
    LONG64 GetUTCTime() const;
    BOOL GetAcceleration3DAvailable() const;
    QVector<CHostVideoInputDevice> GetVideoInputDevices() const;

    /* Methods: */
    ULONG GetProcessorSpeed(ULONG aCpuId);
    BOOL GetProcessorFeature(const KProcessorFeature & aFeature);
    QString GetProcessorDescription(ULONG aCpuId);
    void GetProcessorCPUIDLeaf(ULONG aCpuId, ULONG aLeaf, ULONG aSubLeaf, ULONG & aValEax, ULONG & aValEbx, ULONG & aValEcx, ULONG & aValEdx);
    CProgress CreateHostOnlyNetworkInterface(CHostNetworkInterface & aHostInterface);
    CProgress RemoveHostOnlyNetworkInterface(QString aId);
    CHostUSBDeviceFilter CreateUSBDeviceFilter(const QString & aName);
    void InsertUSBDeviceFilter(ULONG aPosition, const CHostUSBDeviceFilter & aFilter);
    void RemoveUSBDeviceFilter(ULONG aPosition);
    CMedium FindHostDVDDrive(const QString & aName);
    CMedium FindHostFloppyDrive(const QString & aName);
    CHostNetworkInterface FindHostNetworkInterfaceByName(const QString & aName);
    CHostNetworkInterface FindHostNetworkInterfaceById(QString aId);
    QVector<CHostNetworkInterface> FindHostNetworkInterfacesOfType(const KHostNetworkInterfaceType & aType);
    CHostUSBDevice FindUSBDeviceById(QString aId);
    CHostUSBDevice FindUSBDeviceByAddress(const QString & aName);
    QString GenerateMACAddress();

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CVirtualBox;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CHost)

#endif /* __CHost_h__ */


// ##### ENDFILE "CHost.h"


// ##### BEGINFILE "CSystemProperties.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CSystemProperties_h__
#define __CSystemProperties_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CSystemProperties : public CInterface<ISystemProperties, COMBaseWithEI>
{
public:

    typedef CInterface<ISystemProperties, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CSystemProperties() {}

    template<class OI, class OB> explicit CSystemProperties(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CSystemProperties(const CSystemProperties & that) : Base(that) {}

    template<class OI> explicit CSystemProperties(OI * aIface) { attach(aIface); }

    explicit CSystemProperties(ISystemProperties * aIface) : Base(aIface) {}

    template<class OI, class OB> CSystemProperties & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CSystemProperties & operator=(const CSystemProperties & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CSystemProperties & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CSystemProperties & operator=(ISystemProperties * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    ULONG GetMinGuestRAM() const;
    ULONG GetMaxGuestRAM() const;
    ULONG GetMinGuestVRAM() const;
    ULONG GetMaxGuestVRAM() const;
    ULONG GetMinGuestCPUCount() const;
    ULONG GetMaxGuestCPUCount() const;
    ULONG GetMaxGuestMonitors() const;
    LONG64 GetInfoVDSize() const;
    ULONG GetSerialPortCount() const;
    ULONG GetParallelPortCount() const;
    ULONG GetMaxBootPosition() const;
    BOOL GetExclusiveHwVirt() const;
    void SetExclusiveHwVirt(BOOL aExclusiveHwVirt);
    QString GetDefaultMachineFolder() const;
    void SetDefaultMachineFolder(const QString & aDefaultMachineFolder);
    QString GetLoggingLevel() const;
    void SetLoggingLevel(const QString & aLoggingLevel);
    QVector<CMediumFormat> GetMediumFormats() const;
    QString GetDefaultHardDiskFormat() const;
    void SetDefaultHardDiskFormat(const QString & aDefaultHardDiskFormat);
    LONG64 GetFreeDiskSpaceWarning() const;
    void SetFreeDiskSpaceWarning(LONG64 aFreeDiskSpaceWarning);
    ULONG GetFreeDiskSpacePercentWarning() const;
    void SetFreeDiskSpacePercentWarning(ULONG aFreeDiskSpacePercentWarning);
    LONG64 GetFreeDiskSpaceError() const;
    void SetFreeDiskSpaceError(LONG64 aFreeDiskSpaceError);
    ULONG GetFreeDiskSpacePercentError() const;
    void SetFreeDiskSpacePercentError(ULONG aFreeDiskSpacePercentError);
    QString GetVRDEAuthLibrary() const;
    void SetVRDEAuthLibrary(const QString & aVRDEAuthLibrary);
    QString GetWebServiceAuthLibrary() const;
    void SetWebServiceAuthLibrary(const QString & aWebServiceAuthLibrary);
    QString GetDefaultVRDEExtPack() const;
    void SetDefaultVRDEExtPack(const QString & aDefaultVRDEExtPack);
    ULONG GetLogHistoryCount() const;
    void SetLogHistoryCount(ULONG aLogHistoryCount);
    KAudioDriverType GetDefaultAudioDriver() const;
    QString GetAutostartDatabasePath() const;
    void SetAutostartDatabasePath(const QString & aAutostartDatabasePath);
    QString GetDefaultAdditionsISO() const;
    void SetDefaultAdditionsISO(const QString & aDefaultAdditionsISO);
    QString GetDefaultFrontend() const;
    void SetDefaultFrontend(const QString & aDefaultFrontend);

    /* Methods: */
    ULONG GetMaxNetworkAdapters(const KChipsetType & aChipset);
    ULONG GetMaxNetworkAdaptersOfType(const KChipsetType & aChipset, const KNetworkAttachmentType & aType);
    ULONG GetMaxDevicesPerPortForStorageBus(const KStorageBus & aBus);
    ULONG GetMinPortCountForStorageBus(const KStorageBus & aBus);
    ULONG GetMaxPortCountForStorageBus(const KStorageBus & aBus);
    ULONG GetMaxInstancesOfStorageBus(const KChipsetType & aChipset, const KStorageBus & aBus);
    QVector<KDeviceType> GetDeviceTypesForStorageBus(const KStorageBus & aBus);
    BOOL GetDefaultIoCacheSettingForStorageController(const KStorageControllerType & aControllerType);
    ULONG GetMaxInstancesOfUSBControllerType(const KChipsetType & aChipset, const KUSBControllerType & aType);

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CVirtualBox;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CSystemProperties)

#endif /* __CSystemProperties_h__ */


// ##### ENDFILE "CSystemProperties.h"


// ##### BEGINFILE "CGuestOSType.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestOSType_h__
#define __CGuestOSType_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestOSType : public CInterface<IGuestOSType, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestOSType, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestOSType() {}

    template<class OI, class OB> explicit CGuestOSType(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestOSType(const CGuestOSType & that) : Base(that) {}

    template<class OI> explicit CGuestOSType(OI * aIface) { attach(aIface); }

    explicit CGuestOSType(IGuestOSType * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestOSType & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestOSType & operator=(const CGuestOSType & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestOSType & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestOSType & operator=(IGuestOSType * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetFamilyId() const;
    QString GetFamilyDescription() const;
    QString GetId() const;
    QString GetDescription() const;
    BOOL GetIs64Bit() const;
    BOOL GetRecommendedIOAPIC() const;
    BOOL GetRecommendedVirtEx() const;
    ULONG GetRecommendedRAM() const;
    ULONG GetRecommendedVRAM() const;
    BOOL GetRecommended2DVideoAcceleration() const;
    BOOL GetRecommended3DAcceleration() const;
    LONG64 GetRecommendedHDD() const;
    KNetworkAdapterType GetAdapterType() const;
    BOOL GetRecommendedPAE() const;
    KStorageControllerType GetRecommendedDVDStorageController() const;
    KStorageBus GetRecommendedDVDStorageBus() const;
    KStorageControllerType GetRecommendedHDStorageController() const;
    KStorageBus GetRecommendedHDStorageBus() const;
    KFirmwareType GetRecommendedFirmware() const;
    BOOL GetRecommendedUSBHID() const;
    BOOL GetRecommendedHPET() const;
    BOOL GetRecommendedUSBTablet() const;
    BOOL GetRecommendedRTCUseUTC() const;
    KChipsetType GetRecommendedChipset() const;
    KAudioControllerType GetRecommendedAudioController() const;
    BOOL GetRecommendedFloppy() const;
    BOOL GetRecommendedUSB() const;

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CVirtualBox;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestOSType)

/* Declare safe-array: */
typedef QVector<CGuestOSType> CGuestOSTypeVector;

#endif /* __CGuestOSType_h__ */


// ##### ENDFILE "CGuestOSType.h"


// ##### BEGINFILE "CAdditionsFacility.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CAdditionsFacility_h__
#define __CAdditionsFacility_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CAdditionsFacility : public CInterface<IAdditionsFacility, COMBaseWithEI>
{
public:

    typedef CInterface<IAdditionsFacility, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CAdditionsFacility() {}

    template<class OI, class OB> explicit CAdditionsFacility(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CAdditionsFacility(const CAdditionsFacility & that) : Base(that) {}

    template<class OI> explicit CAdditionsFacility(OI * aIface) { attach(aIface); }

    explicit CAdditionsFacility(IAdditionsFacility * aIface) : Base(aIface) {}

    template<class OI, class OB> CAdditionsFacility & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CAdditionsFacility & operator=(const CAdditionsFacility & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CAdditionsFacility & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CAdditionsFacility & operator=(IAdditionsFacility * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KAdditionsFacilityClass GetClassType() const;
    LONG64 GetLastUpdated() const;
    QString GetName() const;
    KAdditionsFacilityStatus GetStatus() const;
    KAdditionsFacilityType GetType() const;

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CGuest;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CAdditionsFacility)

/* Declare safe-array: */
typedef QVector<CAdditionsFacility> CAdditionsFacilityVector;

#endif /* __CAdditionsFacility_h__ */


// ##### ENDFILE "CAdditionsFacility.h"


// ##### BEGINFILE "CGuestSession.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestSession_h__
#define __CGuestSession_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestSession : public CInterface<IGuestSession, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestSession, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestSession() {}

    template<class OI, class OB> explicit CGuestSession(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestSession(const CGuestSession & that) : Base(that) {}

    template<class OI> explicit CGuestSession(OI * aIface) { attach(aIface); }

    explicit CGuestSession(IGuestSession * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestSession & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestSession & operator=(const CGuestSession & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestSession & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestSession & operator=(IGuestSession * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetUser() const;
    QString GetDomain() const;
    QString GetName() const;
    ULONG GetId() const;
    ULONG GetTimeout() const;
    void SetTimeout(ULONG aTimeout);
    ULONG GetProtocolVersion() const;
    KGuestSessionStatus GetStatus() const;
    QVector<QString> GetEnvironment() const;
    void SetEnvironment(const QVector<QString> & aEnvironment);
    QVector<CGuestProcess> GetProcesses() const;
    QVector<CGuestDirectory> GetDirectories() const;
    QVector<CGuestFile> GetFiles() const;
    CEventSource GetEventSource() const;

    /* Methods: */
    void Close();
    CProgress CopyFrom(const QString & aSource, const QString & aDest, const QVector<KCopyFileFlag> & aFlags);
    CProgress CopyTo(const QString & aSource, const QString & aDest, const QVector<KCopyFileFlag> & aFlags);
    void DirectoryCreate(const QString & aPath, ULONG aMode, const QVector<KDirectoryCreateFlag> & aFlags);
    QString DirectoryCreateTemp(const QString & aTemplateName, ULONG aMode, const QString & aPath, BOOL aSecure);
    BOOL DirectoryExists(const QString & aPath);
    CGuestDirectory DirectoryOpen(const QString & aPath, const QString & aFilter, const QVector<KDirectoryOpenFlag> & aFlags);
    CGuestFsObjInfo DirectoryQueryInfo(const QString & aPath);
    void DirectoryRemove(const QString & aPath);
    CProgress DirectoryRemoveRecursive(const QString & aPath, const QVector<KDirectoryRemoveRecFlag> & aFlags);
    void DirectoryRename(const QString & aSource, const QString & aDest, const QVector<KPathRenameFlag> & aFlags);
    void DirectorySetACL(const QString & aPath, const QString & aAcl);
    void EnvironmentClear();
    QString EnvironmentGet(const QString & aName);
    void EnvironmentSet(const QString & aName, const QString & aValue);
    void EnvironmentUnset(const QString & aName);
    CGuestFile FileCreateTemp(const QString & aTemplateName, ULONG aMode, const QString & aPath, BOOL aSecure);
    BOOL FileExists(const QString & aPath);
    void FileRemove(const QString & aPath);
    CGuestFile FileOpen(const QString & aPath, const QString & aOpenMode, const QString & aDisposition, ULONG aCreationMode);
    CGuestFile FileOpenEx(const QString & aPath, const QString & aOpenMode, const QString & aDisposition, const QString & aSharingMode, ULONG aCreationMode, LONG64 aOffset);
    CGuestFsObjInfo FileQueryInfo(const QString & aPath);
    LONG64 FileQuerySize(const QString & aPath);
    void FileRename(const QString & aSource, const QString & aDest, const QVector<KPathRenameFlag> & aFlags);
    void FileSetACL(const QString & aFile, const QString & aAcl);
    CGuestProcess ProcessCreate(const QString & aCommand, const QVector<QString> & aArguments, const QVector<QString> & aEnvironment, const QVector<KProcessCreateFlag> & aFlags, ULONG aTimeoutMS);
    CGuestProcess ProcessCreateEx(const QString & aCommand, const QVector<QString> & aArguments, const QVector<QString> & aEnvironment, const QVector<KProcessCreateFlag> & aFlags, ULONG aTimeoutMS, const KProcessPriority & aPriority, const QVector<LONG> & aAffinity);
    CGuestProcess ProcessGet(ULONG aPid);
    void SymlinkCreate(const QString & aSource, const QString & aTarget, const KSymlinkType & aType);
    BOOL SymlinkExists(const QString & aSymlink);
    QString SymlinkRead(const QString & aSymlink, const QVector<KSymlinkReadFlag> & aFlags);
    void SymlinkRemoveDirectory(const QString & aPath);
    void SymlinkRemoveFile(const QString & aFile);
    KGuestSessionWaitResult WaitFor(ULONG aWaitFor, ULONG aTimeoutMS);
    KGuestSessionWaitResult WaitForArray(const QVector<KGuestSessionWaitForFlag> & aWaitFor, ULONG aTimeoutMS);

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CGuest;
    friend class CGuestSessionEvent;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestSession)

/* Declare safe-array: */
typedef QVector<CGuestSession> CGuestSessionVector;

#endif /* __CGuestSession_h__ */


// ##### ENDFILE "CGuestSession.h"


// ##### BEGINFILE "CProcess.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CProcess_h__
#define __CProcess_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CProcess : public CInterface<IProcess, COMBaseWithEI>
{
public:

    typedef CInterface<IProcess, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CProcess() {}

    template<class OI, class OB> explicit CProcess(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CProcess(const CProcess & that) : Base(that) {}

    template<class OI> explicit CProcess(OI * aIface) { attach(aIface); }

    explicit CProcess(IProcess * aIface) : Base(aIface) {}

    template<class OI, class OB> CProcess & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CProcess & operator=(const CProcess & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CProcess & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CProcess & operator=(IProcess * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QVector<QString> GetArguments() const;
    QVector<QString> GetEnvironment() const;
    CEventSource GetEventSource() const;
    QString GetExecutablePath() const;
    LONG GetExitCode() const;
    QString GetName() const;
    ULONG GetPID() const;
    KProcessStatus GetStatus() const;

    /* Methods: */
    KProcessWaitResult WaitFor(ULONG aWaitFor, ULONG aTimeoutMS);
    KProcessWaitResult WaitForArray(const QVector<KProcessWaitForFlag> & aWaitFor, ULONG aTimeoutMS);
    QVector<BYTE> Read(ULONG aHandle, ULONG aToRead, ULONG aTimeoutMS);
    ULONG Write(ULONG aHandle, ULONG aFlags, const QVector<BYTE> & aData, ULONG aTimeoutMS);
    ULONG WriteArray(ULONG aHandle, const QVector<KProcessInputFlag> & aFlags, const QVector<BYTE> & aData, ULONG aTimeoutMS);
    void Terminate();

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CProcess)

#endif /* __CProcess_h__ */


// ##### ENDFILE "CProcess.h"


// ##### BEGINFILE "CGuestProcess.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestProcess_h__
#define __CGuestProcess_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestProcess : public CInterface<IGuestProcess, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestProcess, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestProcess() {}

    template<class OI, class OB> explicit CGuestProcess(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestProcess(const CGuestProcess & that) : Base(that) {}

    template<class OI> explicit CGuestProcess(OI * aIface) { attach(aIface); }

    explicit CGuestProcess(IGuestProcess * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestProcess & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestProcess & operator=(const CGuestProcess & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestProcess & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestProcess & operator=(IGuestProcess * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QVector<QString> GetArguments() const;
    QVector<QString> GetEnvironment() const;
    CEventSource GetEventSource() const;
    QString GetExecutablePath() const;
    LONG GetExitCode() const;
    QString GetName() const;
    ULONG GetPID() const;
    KProcessStatus GetStatus() const;

    /* Methods: */
    KProcessWaitResult WaitFor(ULONG aWaitFor, ULONG aTimeoutMS);
    KProcessWaitResult WaitForArray(const QVector<KProcessWaitForFlag> & aWaitFor, ULONG aTimeoutMS);
    QVector<BYTE> Read(ULONG aHandle, ULONG aToRead, ULONG aTimeoutMS);
    ULONG Write(ULONG aHandle, ULONG aFlags, const QVector<BYTE> & aData, ULONG aTimeoutMS);
    ULONG WriteArray(ULONG aHandle, const QVector<KProcessInputFlag> & aFlags, const QVector<BYTE> & aData, ULONG aTimeoutMS);
    void Terminate();

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CGuestSession;
    friend class CGuestProcessEvent;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestProcess)

/* Declare safe-array: */
typedef QVector<CGuestProcess> CGuestProcessVector;

#endif /* __CGuestProcess_h__ */


// ##### ENDFILE "CGuestProcess.h"


// ##### BEGINFILE "CDirectory.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CDirectory_h__
#define __CDirectory_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CDirectory : public CInterface<IDirectory, COMBaseWithEI>
{
public:

    typedef CInterface<IDirectory, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CDirectory() {}

    template<class OI, class OB> explicit CDirectory(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CDirectory(const CDirectory & that) : Base(that) {}

    template<class OI> explicit CDirectory(OI * aIface) { attach(aIface); }

    explicit CDirectory(IDirectory * aIface) : Base(aIface) {}

    template<class OI, class OB> CDirectory & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CDirectory & operator=(const CDirectory & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CDirectory & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CDirectory & operator=(IDirectory * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetDirectoryName() const;
    QString GetFilter() const;

    /* Methods: */
    void Close();
    CFsObjInfo Read();

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CDirectory)

#endif /* __CDirectory_h__ */


// ##### ENDFILE "CDirectory.h"


// ##### BEGINFILE "CGuestDirectory.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestDirectory_h__
#define __CGuestDirectory_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestDirectory : public CInterface<IGuestDirectory, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestDirectory, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestDirectory() {}

    template<class OI, class OB> explicit CGuestDirectory(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestDirectory(const CGuestDirectory & that) : Base(that) {}

    template<class OI> explicit CGuestDirectory(OI * aIface) { attach(aIface); }

    explicit CGuestDirectory(IGuestDirectory * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestDirectory & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestDirectory & operator=(const CGuestDirectory & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestDirectory & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestDirectory & operator=(IGuestDirectory * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetDirectoryName() const;
    QString GetFilter() const;

    /* Methods: */
    void Close();
    CFsObjInfo Read();

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CGuestSession;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestDirectory)

/* Declare safe-array: */
typedef QVector<CGuestDirectory> CGuestDirectoryVector;

#endif /* __CGuestDirectory_h__ */


// ##### ENDFILE "CGuestDirectory.h"


// ##### BEGINFILE "CFile.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CFile_h__
#define __CFile_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CFile : public CInterface<IFile, COMBaseWithEI>
{
public:

    typedef CInterface<IFile, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CFile() {}

    template<class OI, class OB> explicit CFile(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CFile(const CFile & that) : Base(that) {}

    template<class OI> explicit CFile(OI * aIface) { attach(aIface); }

    explicit CFile(IFile * aIface) : Base(aIface) {}

    template<class OI, class OB> CFile & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CFile & operator=(const CFile & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CFile & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CFile & operator=(IFile * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    ULONG GetCreationMode() const;
    QString GetDisposition() const;
    CEventSource GetEventSource() const;
    QString GetFileName() const;
    ULONG GetId() const;
    LONG64 GetInitialSize() const;
    QString GetOpenMode() const;
    LONG64 GetOffset() const;
    KFileStatus GetStatus() const;

    /* Methods: */
    void Close();
    CFsObjInfo QueryInfo();
    QVector<BYTE> Read(ULONG aToRead, ULONG aTimeoutMS);
    QVector<BYTE> ReadAt(LONG64 aOffset, ULONG aToRead, ULONG aTimeoutMS);
    void Seek(LONG64 aOffset, const KFileSeekType & aWhence);
    void SetACL(const QString & aAcl);
    ULONG Write(const QVector<BYTE> & aData, ULONG aTimeoutMS);
    ULONG WriteAt(LONG64 aOffset, const QVector<BYTE> & aData, ULONG aTimeoutMS);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CFile)

#endif /* __CFile_h__ */


// ##### ENDFILE "CFile.h"


// ##### BEGINFILE "CGuestFile.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestFile_h__
#define __CGuestFile_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestFile : public CInterface<IGuestFile, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestFile, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestFile() {}

    template<class OI, class OB> explicit CGuestFile(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestFile(const CGuestFile & that) : Base(that) {}

    template<class OI> explicit CGuestFile(OI * aIface) { attach(aIface); }

    explicit CGuestFile(IGuestFile * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestFile & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestFile & operator=(const CGuestFile & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestFile & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestFile & operator=(IGuestFile * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    ULONG GetCreationMode() const;
    QString GetDisposition() const;
    CEventSource GetEventSource() const;
    QString GetFileName() const;
    ULONG GetId() const;
    LONG64 GetInitialSize() const;
    QString GetOpenMode() const;
    LONG64 GetOffset() const;
    KFileStatus GetStatus() const;

    /* Methods: */
    void Close();
    CFsObjInfo QueryInfo();
    QVector<BYTE> Read(ULONG aToRead, ULONG aTimeoutMS);
    QVector<BYTE> ReadAt(LONG64 aOffset, ULONG aToRead, ULONG aTimeoutMS);
    void Seek(LONG64 aOffset, const KFileSeekType & aWhence);
    void SetACL(const QString & aAcl);
    ULONG Write(const QVector<BYTE> & aData, ULONG aTimeoutMS);
    ULONG WriteAt(LONG64 aOffset, const QVector<BYTE> & aData, ULONG aTimeoutMS);

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CGuestSession;
    friend class CGuestFileEvent;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestFile)

/* Declare safe-array: */
typedef QVector<CGuestFile> CGuestFileVector;

#endif /* __CGuestFile_h__ */


// ##### ENDFILE "CGuestFile.h"


// ##### BEGINFILE "CFsObjInfo.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CFsObjInfo_h__
#define __CFsObjInfo_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CFsObjInfo : public CInterface<IFsObjInfo, COMBaseWithEI>
{
public:

    typedef CInterface<IFsObjInfo, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CFsObjInfo() {}

    template<class OI, class OB> explicit CFsObjInfo(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CFsObjInfo(const CFsObjInfo & that) : Base(that) {}

    template<class OI> explicit CFsObjInfo(OI * aIface) { attach(aIface); }

    explicit CFsObjInfo(IFsObjInfo * aIface) : Base(aIface) {}

    template<class OI, class OB> CFsObjInfo & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CFsObjInfo & operator=(const CFsObjInfo & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CFsObjInfo & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CFsObjInfo & operator=(IFsObjInfo * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    LONG64 GetAccessTime() const;
    LONG64 GetAllocatedSize() const;
    LONG64 GetBirthTime() const;
    LONG64 GetChangeTime() const;
    ULONG GetDeviceNumber() const;
    QString GetFileAttributes() const;
    ULONG GetGenerationId() const;
    ULONG GetGID() const;
    QString GetGroupName() const;
    ULONG GetHardLinks() const;
    LONG64 GetModificationTime() const;
    QString GetName() const;
    LONG64 GetNodeId() const;
    ULONG GetNodeIdDevice() const;
    LONG64 GetObjectSize() const;
    KFsObjType GetType() const;
    ULONG GetUID() const;
    ULONG GetUserFlags() const;
    QString GetUserName() const;

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CDirectory;
    friend class CFile;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CFsObjInfo)

#endif /* __CFsObjInfo_h__ */


// ##### ENDFILE "CFsObjInfo.h"


// ##### BEGINFILE "CGuestFsObjInfo.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestFsObjInfo_h__
#define __CGuestFsObjInfo_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestFsObjInfo : public CInterface<IGuestFsObjInfo, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestFsObjInfo, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestFsObjInfo() {}

    template<class OI, class OB> explicit CGuestFsObjInfo(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestFsObjInfo(const CGuestFsObjInfo & that) : Base(that) {}

    template<class OI> explicit CGuestFsObjInfo(OI * aIface) { attach(aIface); }

    explicit CGuestFsObjInfo(IGuestFsObjInfo * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestFsObjInfo & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestFsObjInfo & operator=(const CGuestFsObjInfo & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestFsObjInfo & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestFsObjInfo & operator=(IGuestFsObjInfo * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    LONG64 GetAccessTime() const;
    LONG64 GetAllocatedSize() const;
    LONG64 GetBirthTime() const;
    LONG64 GetChangeTime() const;
    ULONG GetDeviceNumber() const;
    QString GetFileAttributes() const;
    ULONG GetGenerationId() const;
    ULONG GetGID() const;
    QString GetGroupName() const;
    ULONG GetHardLinks() const;
    LONG64 GetModificationTime() const;
    QString GetName() const;
    LONG64 GetNodeId() const;
    ULONG GetNodeIdDevice() const;
    LONG64 GetObjectSize() const;
    KFsObjType GetType() const;
    ULONG GetUID() const;
    ULONG GetUserFlags() const;
    QString GetUserName() const;

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CGuestSession;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestFsObjInfo)

#endif /* __CGuestFsObjInfo_h__ */


// ##### ENDFILE "CGuestFsObjInfo.h"


// ##### BEGINFILE "CGuest.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuest_h__
#define __CGuest_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuest : public CInterface<IGuest, COMBaseWithEI>
{
public:

    typedef CInterface<IGuest, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuest() {}

    template<class OI, class OB> explicit CGuest(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuest(const CGuest & that) : Base(that) {}

    template<class OI> explicit CGuest(OI * aIface) { attach(aIface); }

    explicit CGuest(IGuest * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuest & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuest & operator=(const CGuest & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuest & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuest & operator=(IGuest * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetOSTypeId() const;
    KAdditionsRunLevelType GetAdditionsRunLevel() const;
    QString GetAdditionsVersion() const;
    ULONG GetAdditionsRevision() const;
    CEventSource GetEventSource() const;
    QVector<CAdditionsFacility> GetFacilities() const;
    QVector<CGuestSession> GetSessions() const;
    ULONG GetMemoryBalloonSize() const;
    void SetMemoryBalloonSize(ULONG aMemoryBalloonSize);
    ULONG GetStatisticsUpdateInterval() const;
    void SetStatisticsUpdateInterval(ULONG aStatisticsUpdateInterval);

    /* Methods: */
    void InternalGetStatistics(ULONG & aCpuUser, ULONG & aCpuKernel, ULONG & aCpuIdle, ULONG & aMemTotal, ULONG & aMemFree, ULONG & aMemBalloon, ULONG & aMemShared, ULONG & aMemCache, ULONG & aPagedTotal, ULONG & aMemAllocTotal, ULONG & aMemFreeTotal, ULONG & aMemBalloonTotal, ULONG & aMemSharedTotal);
    KAdditionsFacilityStatus GetFacilityStatus(const KAdditionsFacilityType & aFacility, LONG64 & aTimestamp);
    BOOL GetAdditionsStatus(const KAdditionsRunLevelType & aLevel);
    void SetCredentials(const QString & aUserName, const QString & aPassword, const QString & aDomain, BOOL aAllowInteractiveLogon);
    KDragAndDropAction DragHGEnter(ULONG aScreenId, ULONG aY, ULONG aX, const KDragAndDropAction & aDefaultAction, const QVector<KDragAndDropAction> & aAllowedActions, const QVector<QString> & aFormats);
    KDragAndDropAction DragHGMove(ULONG aScreenId, ULONG aX, ULONG aY, const KDragAndDropAction & aDefaultAction, const QVector<KDragAndDropAction> & aAllowedActions, const QVector<QString> & aFormats);
    void DragHGLeave(ULONG aScreenId);
    KDragAndDropAction DragHGDrop(ULONG aScreenId, ULONG aX, ULONG aY, const KDragAndDropAction & aDefaultAction, const QVector<KDragAndDropAction> & aAllowedActions, const QVector<QString> & aFormats, QString & aFormat);
    CProgress DragHGPutData(ULONG aScreenId, const QString & aFormat, const QVector<BYTE> & aData);
    KDragAndDropAction DragGHPending(ULONG aScreenId, QVector<QString> & aFormats, QVector<KDragAndDropAction> & aAllowedActions);
    CProgress DragGHDropped(const QString & aFormat, const KDragAndDropAction & aAction);
    QVector<BYTE> DragGHGetData();
    CGuestSession CreateSession(const QString & aUser, const QString & aPassword, const QString & aDomain, const QString & aSessionName);
    QVector<CGuestSession> FindSession(const QString & aSessionName);
    CProgress UpdateGuestAdditions(const QString & aSource, const QVector<QString> & aArguments, const QVector<KAdditionsUpdateFlag> & aFlags);

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CConsole;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuest)

#endif /* __CGuest_h__ */


// ##### ENDFILE "CGuest.h"


// ##### BEGINFILE "CProgress.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CProgress_h__
#define __CProgress_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CProgress : public CInterface<IProgress, COMBaseWithEI>
{
public:

    typedef CInterface<IProgress, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CProgress() {}

    template<class OI, class OB> explicit CProgress(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CProgress(const CProgress & that) : Base(that) {}

    template<class OI> explicit CProgress(OI * aIface) { attach(aIface); }

    explicit CProgress(IProgress * aIface) : Base(aIface) {}

    template<class OI, class OB> CProgress & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CProgress & operator=(const CProgress & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CProgress & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CProgress & operator=(IProgress * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetId() const;
    QString GetDescription() const;
    CUnknown GetInitiator() const;
    BOOL GetCancelable() const;
    ULONG GetPercent() const;
    LONG GetTimeRemaining() const;
    BOOL GetCompleted() const;
    BOOL GetCanceled() const;
    LONG GetResultCode() const;
    CVirtualBoxErrorInfo GetErrorInfo() const;
    ULONG GetOperationCount() const;
    ULONG GetOperation() const;
    QString GetOperationDescription() const;
    ULONG GetOperationPercent() const;
    ULONG GetOperationWeight() const;
    ULONG GetTimeout() const;
    void SetTimeout(ULONG aTimeout);

    /* Methods: */
    void SetCurrentOperationProgress(ULONG aPercent);
    void SetNextOperation(const QString & aNextOperationDescription, ULONG aNextOperationsWeight);
    void WaitForCompletion(LONG aTimeout);
    void WaitForOperationCompletion(ULONG aOperation, LONG aTimeout);
    void WaitForAsyncProgressCompletion(const CProgress & aPProgressAsync);
    void Cancel();

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CVirtualBox;
    friend class CVFSExplorer;
    friend class CAppliance;
    friend class CInternalMachineControl;
    friend class CMachine;
    friend class CConsole;
    friend class CHost;
    friend class CGuestSession;
    friend class CGuest;
    friend class CMedium;
    friend class CInternalSessionControl;
    friend class CExtPackFile;
    friend class CExtPackManager;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CProgress)

/* Declare safe-array: */
typedef QVector<CProgress> CProgressVector;

#endif /* __CProgress_h__ */


// ##### ENDFILE "CProgress.h"


// ##### BEGINFILE "CSnapshot.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CSnapshot_h__
#define __CSnapshot_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CSnapshot : public CInterface<ISnapshot, COMBaseWithEI>
{
public:

    typedef CInterface<ISnapshot, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CSnapshot() {}

    template<class OI, class OB> explicit CSnapshot(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CSnapshot(const CSnapshot & that) : Base(that) {}

    template<class OI> explicit CSnapshot(OI * aIface) { attach(aIface); }

    explicit CSnapshot(ISnapshot * aIface) : Base(aIface) {}

    template<class OI, class OB> CSnapshot & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CSnapshot & operator=(const CSnapshot & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CSnapshot & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CSnapshot & operator=(ISnapshot * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetId() const;
    QString GetName() const;
    void SetName(const QString & aName);
    QString GetDescription() const;
    void SetDescription(const QString & aDescription);
    LONG64 GetTimeStamp() const;
    BOOL GetOnline() const;
    CMachine GetMachine() const;
    CSnapshot GetParent() const;
    QVector<CSnapshot> GetChildren() const;

    /* Methods: */
    ULONG GetChildrenCount() const;

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CInternalMachineControl;
    friend class CMachine;
    friend class CConsole;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CSnapshot)

/* Declare safe-array: */
typedef QVector<CSnapshot> CSnapshotVector;

#endif /* __CSnapshot_h__ */


// ##### ENDFILE "CSnapshot.h"


// ##### BEGINFILE "CMediumAttachment.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CMediumAttachment_h__
#define __CMediumAttachment_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CMediumAttachment : public CInterface<IMediumAttachment, COMBaseWithEI>
{
public:

    typedef CInterface<IMediumAttachment, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CMediumAttachment() {}

    template<class OI, class OB> explicit CMediumAttachment(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CMediumAttachment(const CMediumAttachment & that) : Base(that) {}

    template<class OI> explicit CMediumAttachment(OI * aIface) { attach(aIface); }

    explicit CMediumAttachment(IMediumAttachment * aIface) : Base(aIface) {}

    template<class OI, class OB> CMediumAttachment & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CMediumAttachment & operator=(const CMediumAttachment & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CMediumAttachment & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CMediumAttachment & operator=(IMediumAttachment * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    CMedium GetMedium() const;
    QString GetController() const;
    LONG GetPort() const;
    LONG GetDevice() const;
    KDeviceType GetType() const;
    BOOL GetPassthrough() const;
    BOOL GetTemporaryEject() const;
    BOOL GetIsEjected() const;
    BOOL GetNonRotational() const;
    BOOL GetDiscard() const;
    BOOL GetHotPluggable() const;
    CBandwidthGroup GetBandwidthGroup() const;

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CInternalMachineControl;
    friend class CMachine;
    friend class CInternalSessionControl;
    friend class CMediumChangedEvent;
    friend class CStorageDeviceChangedEvent;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CMediumAttachment)

/* Declare safe-array: */
typedef QVector<CMediumAttachment> CMediumAttachmentVector;

#endif /* __CMediumAttachment_h__ */


// ##### ENDFILE "CMediumAttachment.h"


// ##### BEGINFILE "CMedium.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CMedium_h__
#define __CMedium_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CMedium : public CInterface<IMedium, COMBaseWithEI>
{
public:

    typedef CInterface<IMedium, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CMedium() {}

    template<class OI, class OB> explicit CMedium(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CMedium(const CMedium & that) : Base(that) {}

    template<class OI> explicit CMedium(OI * aIface) { attach(aIface); }

    explicit CMedium(IMedium * aIface) : Base(aIface) {}

    template<class OI, class OB> CMedium & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CMedium & operator=(const CMedium & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CMedium & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CMedium & operator=(IMedium * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetId() const;
    QString GetDescription() const;
    void SetDescription(const QString & aDescription);
    KMediumState GetState() const;
    QVector<KMediumVariant> GetVariant() const;
    QString GetLocation() const;
    QString GetName() const;
    KDeviceType GetDeviceType() const;
    BOOL GetHostDrive() const;
    LONG64 GetSize() const;
    QString GetFormat() const;
    CMediumFormat GetMediumFormat() const;
    KMediumType GetType() const;
    void SetType(const KMediumType & aType);
    QVector<KMediumType> GetAllowedTypes() const;
    CMedium GetParent() const;
    QVector<CMedium> GetChildren() const;
    CMedium GetBase() const;
    BOOL GetReadOnly() const;
    LONG64 GetLogicalSize() const;
    BOOL GetAutoReset() const;
    void SetAutoReset(BOOL aAutoReset);
    QString GetLastAccessError() const;
    QVector<QString> GetMachineIds() const;

    /* Methods: */
    void SetIds(BOOL aSetImageId, QString aImageId, BOOL aSetParentId, QString aParentId);
    KMediumState RefreshState();
    QVector<QString> GetSnapshotIds(QString aMachineId);
    CToken LockRead();
    CToken LockWrite();
    void Close();
    QString GetProperty(const QString & aName) const;
    void SetProperty(const QString & aName, const QString & aValue);
    QVector<QString> GetProperties(const QString & aNames, QVector<QString> & aReturnNames) const;
    void SetProperties(const QVector<QString> & aNames, const QVector<QString> & aValues);
    CProgress CreateBaseStorage(LONG64 aLogicalSize, const QVector<KMediumVariant> & aVariant);
    CProgress DeleteStorage();
    CProgress CreateDiffStorage(const CMedium & aTarget, const QVector<KMediumVariant> & aVariant);
    CProgress MergeTo(const CMedium & aTarget);
    CProgress CloneTo(const CMedium & aTarget, const QVector<KMediumVariant> & aVariant, const CMedium & aParent);
    CProgress CloneToBase(const CMedium & aTarget, const QVector<KMediumVariant> & aVariant);
    CProgress SetLocation(const QString & aLocation);
    CProgress Compact();
    CProgress Resize(LONG64 aLogicalSize);
    CProgress Reset();

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CVirtualBox;
    friend class CMachine;
    friend class CHost;
    friend class CMediumAttachment;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CMedium)

/* Declare safe-array: */
typedef QVector<CMedium> CMediumVector;

#endif /* __CMedium_h__ */


// ##### ENDFILE "CMedium.h"


// ##### BEGINFILE "CMediumFormat.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CMediumFormat_h__
#define __CMediumFormat_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CMediumFormat : public CInterface<IMediumFormat, COMBaseWithEI>
{
public:

    typedef CInterface<IMediumFormat, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CMediumFormat() {}

    template<class OI, class OB> explicit CMediumFormat(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CMediumFormat(const CMediumFormat & that) : Base(that) {}

    template<class OI> explicit CMediumFormat(OI * aIface) { attach(aIface); }

    explicit CMediumFormat(IMediumFormat * aIface) : Base(aIface) {}

    template<class OI, class OB> CMediumFormat & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CMediumFormat & operator=(const CMediumFormat & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CMediumFormat & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CMediumFormat & operator=(IMediumFormat * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetId() const;
    QString GetName() const;
    QVector<KMediumFormatCapabilities> GetCapabilities() const;

    /* Methods: */
    void DescribeFileExtensions(QVector<QString> & aExtensions, QVector<KDeviceType> & aTypes);
    void DescribeProperties(QVector<QString> & aNames, QVector<QString> & aDescriptions, QVector<KDataType> & aTypes, QVector<ULONG> & aFlags, QVector<QString> & aDefaults) const;

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CSystemProperties;
    friend class CMedium;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CMediumFormat)

/* Declare safe-array: */
typedef QVector<CMediumFormat> CMediumFormatVector;

#endif /* __CMediumFormat_h__ */


// ##### ENDFILE "CMediumFormat.h"


// ##### BEGINFILE "CToken.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CToken_h__
#define __CToken_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CToken : public CInterface<IToken, COMBaseWithEI>
{
public:

    typedef CInterface<IToken, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CToken() {}

    template<class OI, class OB> explicit CToken(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CToken(const CToken & that) : Base(that) {}

    template<class OI> explicit CToken(OI * aIface) { attach(aIface); }

    explicit CToken(IToken * aIface) : Base(aIface) {}

    template<class OI, class OB> CToken & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CToken & operator=(const CToken & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CToken & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CToken & operator=(IToken * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    /* Methods: */
    void Abandon();
    void Dummy();

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CMedium;
    friend class CInternalSessionControl;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CToken)

#endif /* __CToken_h__ */


// ##### ENDFILE "CToken.h"


// ##### BEGINFILE "CKeyboard.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CKeyboard_h__
#define __CKeyboard_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CKeyboard : public CInterface<IKeyboard, COMBaseWithEI>
{
public:

    typedef CInterface<IKeyboard, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CKeyboard() {}

    template<class OI, class OB> explicit CKeyboard(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CKeyboard(const CKeyboard & that) : Base(that) {}

    template<class OI> explicit CKeyboard(OI * aIface) { attach(aIface); }

    explicit CKeyboard(IKeyboard * aIface) : Base(aIface) {}

    template<class OI, class OB> CKeyboard & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CKeyboard & operator=(const CKeyboard & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CKeyboard & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CKeyboard & operator=(IKeyboard * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    CEventSource GetEventSource() const;

    /* Methods: */
    void PutScancode(LONG aScancode);
    ULONG PutScancodes(const QVector<LONG> & aScancodes);
    void PutCAD();

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CConsole;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CKeyboard)

#endif /* __CKeyboard_h__ */


// ##### ENDFILE "CKeyboard.h"


// ##### BEGINFILE "CMouse.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CMouse_h__
#define __CMouse_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CMouse : public CInterface<IMouse, COMBaseWithEI>
{
public:

    typedef CInterface<IMouse, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CMouse() {}

    template<class OI, class OB> explicit CMouse(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CMouse(const CMouse & that) : Base(that) {}

    template<class OI> explicit CMouse(OI * aIface) { attach(aIface); }

    explicit CMouse(IMouse * aIface) : Base(aIface) {}

    template<class OI, class OB> CMouse & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CMouse & operator=(const CMouse & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CMouse & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CMouse & operator=(IMouse * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    BOOL GetAbsoluteSupported() const;
    BOOL GetRelativeSupported() const;
    BOOL GetMultiTouchSupported() const;
    BOOL GetNeedsHostCursor() const;
    CEventSource GetEventSource() const;

    /* Methods: */
    void PutMouseEvent(LONG aDx, LONG aDy, LONG aDz, LONG aDw, LONG aButtonState);
    void PutMouseEventAbsolute(LONG aX, LONG aY, LONG aDz, LONG aDw, LONG aButtonState);
    void PutEventMultiTouch(LONG aCount, const QVector<LONG64> & aContacts, ULONG aScanTime);
    void PutEventMultiTouchString(LONG aCount, const QString & aContacts, ULONG aScanTime);

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CConsole;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CMouse)

#endif /* __CMouse_h__ */


// ##### ENDFILE "CMouse.h"


// ##### BEGINFILE "CFramebuffer.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CFramebuffer_h__
#define __CFramebuffer_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CFramebuffer : public CInterface<IFramebuffer, COMBaseWithEI>
{
public:

    typedef CInterface<IFramebuffer, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CFramebuffer() {}

    template<class OI, class OB> explicit CFramebuffer(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CFramebuffer(const CFramebuffer & that) : Base(that) {}

    template<class OI> explicit CFramebuffer(OI * aIface) { attach(aIface); }

    explicit CFramebuffer(IFramebuffer * aIface) : Base(aIface) {}

    template<class OI, class OB> CFramebuffer & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CFramebuffer & operator=(const CFramebuffer & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CFramebuffer & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CFramebuffer & operator=(IFramebuffer * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    BYTE * GetAddress() const;
    ULONG GetWidth() const;
    ULONG GetHeight() const;
    ULONG GetBitsPerPixel() const;
    ULONG GetBytesPerLine() const;
    ULONG GetPixelFormat() const;
    BOOL GetUsesGuestVRAM() const;
    ULONG GetHeightReduction() const;
    CFramebufferOverlay GetOverlay() const;
    LONG64 GetWinId() const;

    /* Methods: */
    void Lock();
    void Unlock();
    void NotifyUpdate(ULONG aX, ULONG aY, ULONG aWidth, ULONG aHeight);
    BOOL RequestResize(ULONG aScreenId, ULONG aPixelFormat, BYTE * aVRAM, ULONG aBitsPerPixel, ULONG aBytesPerLine, ULONG aWidth, ULONG aHeight);
    BOOL VideoModeSupported(ULONG aWidth, ULONG aHeight, ULONG aBpp);
    ULONG GetVisibleRegion(BYTE * aRectangles, ULONG aCount);
    void SetVisibleRegion(BYTE * aRectangles, ULONG aCount);
    void ProcessVHWACommand(BYTE * aCommand);
    void Notify3DEvent(ULONG aType, BYTE * aData);

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CDisplay;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CFramebuffer)

#endif /* __CFramebuffer_h__ */


// ##### ENDFILE "CFramebuffer.h"


// ##### BEGINFILE "CFramebufferOverlay.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CFramebufferOverlay_h__
#define __CFramebufferOverlay_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CFramebufferOverlay : public CInterface<IFramebufferOverlay, COMBaseWithEI>
{
public:

    typedef CInterface<IFramebufferOverlay, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CFramebufferOverlay() {}

    template<class OI, class OB> explicit CFramebufferOverlay(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CFramebufferOverlay(const CFramebufferOverlay & that) : Base(that) {}

    template<class OI> explicit CFramebufferOverlay(OI * aIface) { attach(aIface); }

    explicit CFramebufferOverlay(IFramebufferOverlay * aIface) : Base(aIface) {}

    template<class OI, class OB> CFramebufferOverlay & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CFramebufferOverlay & operator=(const CFramebufferOverlay & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CFramebufferOverlay & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CFramebufferOverlay & operator=(IFramebufferOverlay * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    ULONG GetX() const;
    ULONG GetY() const;
    BOOL GetVisible() const;
    void SetVisible(BOOL aVisible);
    ULONG GetAlpha() const;
    void SetAlpha(ULONG aAlpha);

    BYTE * GetAddress() const;
    ULONG GetWidth() const;
    ULONG GetHeight() const;
    ULONG GetBitsPerPixel() const;
    ULONG GetBytesPerLine() const;
    ULONG GetPixelFormat() const;
    BOOL GetUsesGuestVRAM() const;
    ULONG GetHeightReduction() const;
    CFramebufferOverlay GetOverlay() const;
    LONG64 GetWinId() const;

    /* Methods: */
    void Move(ULONG aX, ULONG aY);

    void Lock();
    void Unlock();
    void NotifyUpdate(ULONG aX, ULONG aY, ULONG aWidth, ULONG aHeight);
    BOOL RequestResize(ULONG aScreenId, ULONG aPixelFormat, BYTE * aVRAM, ULONG aBitsPerPixel, ULONG aBytesPerLine, ULONG aWidth, ULONG aHeight);
    BOOL VideoModeSupported(ULONG aWidth, ULONG aHeight, ULONG aBpp);
    ULONG GetVisibleRegion(BYTE * aRectangles, ULONG aCount);
    void SetVisibleRegion(BYTE * aRectangles, ULONG aCount);
    void ProcessVHWACommand(BYTE * aCommand);
    void Notify3DEvent(ULONG aType, BYTE * aData);

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CFramebuffer;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CFramebufferOverlay)

#endif /* __CFramebufferOverlay_h__ */


// ##### ENDFILE "CFramebufferOverlay.h"


// ##### BEGINFILE "CDisplay.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CDisplay_h__
#define __CDisplay_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CDisplay : public CInterface<IDisplay, COMBaseWithEI>
{
public:

    typedef CInterface<IDisplay, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CDisplay() {}

    template<class OI, class OB> explicit CDisplay(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CDisplay(const CDisplay & that) : Base(that) {}

    template<class OI> explicit CDisplay(OI * aIface) { attach(aIface); }

    explicit CDisplay(IDisplay * aIface) : Base(aIface) {}

    template<class OI, class OB> CDisplay & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CDisplay & operator=(const CDisplay & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CDisplay & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CDisplay & operator=(IDisplay * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    /* Methods: */
    void GetScreenResolution(ULONG aScreenId, ULONG & aWidth, ULONG & aHeight, ULONG & aBitsPerPixel, LONG & aXOrigin, LONG & aYOrigin);
    void SetFramebuffer(ULONG aScreenId, const CFramebuffer & aFramebuffer);
    void GetFramebuffer(ULONG aScreenId, CFramebuffer & aFramebuffer, LONG & aXOrigin, LONG & aYOrigin);
    void SetVideoModeHint(ULONG aDisplay, BOOL aEnabled, BOOL aChangeOrigin, LONG aOriginX, LONG aOriginY, ULONG aWidth, ULONG aHeight, ULONG aBitsPerPixel);
    void SetSeamlessMode(BOOL aEnabled);
    void TakeScreenShot(ULONG aScreenId, BYTE * aAddress, ULONG aWidth, ULONG aHeight);
    QVector<BYTE> TakeScreenShotToArray(ULONG aScreenId, ULONG aWidth, ULONG aHeight);
    QVector<BYTE> TakeScreenShotPNGToArray(ULONG aScreenId, ULONG aWidth, ULONG aHeight);
    void DrawToScreen(ULONG aScreenId, BYTE * aAddress, ULONG aX, ULONG aY, ULONG aWidth, ULONG aHeight);
    void InvalidateAndUpdate();
    void ResizeCompleted(ULONG aScreenId);
    void CompleteVHWACommand(BYTE * aCommand);
    void ViewportChanged(ULONG aScreenId, ULONG aX, ULONG aY, ULONG aWidth, ULONG aHeight);

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CConsole;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CDisplay)

#endif /* __CDisplay_h__ */


// ##### ENDFILE "CDisplay.h"


// ##### BEGINFILE "CNetworkAdapter.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CNetworkAdapter_h__
#define __CNetworkAdapter_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CNetworkAdapter : public CInterface<INetworkAdapter, COMBaseWithEI>
{
public:

    typedef CInterface<INetworkAdapter, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CNetworkAdapter() {}

    template<class OI, class OB> explicit CNetworkAdapter(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CNetworkAdapter(const CNetworkAdapter & that) : Base(that) {}

    template<class OI> explicit CNetworkAdapter(OI * aIface) { attach(aIface); }

    explicit CNetworkAdapter(INetworkAdapter * aIface) : Base(aIface) {}

    template<class OI, class OB> CNetworkAdapter & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CNetworkAdapter & operator=(const CNetworkAdapter & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CNetworkAdapter & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CNetworkAdapter & operator=(INetworkAdapter * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KNetworkAdapterType GetAdapterType() const;
    void SetAdapterType(const KNetworkAdapterType & aAdapterType);
    ULONG GetSlot() const;
    BOOL GetEnabled() const;
    void SetEnabled(BOOL aEnabled);
    QString GetMACAddress() const;
    void SetMACAddress(const QString & aMACAddress);
    KNetworkAttachmentType GetAttachmentType() const;
    void SetAttachmentType(const KNetworkAttachmentType & aAttachmentType);
    QString GetBridgedInterface() const;
    void SetBridgedInterface(const QString & aBridgedInterface);
    QString GetHostOnlyInterface() const;
    void SetHostOnlyInterface(const QString & aHostOnlyInterface);
    QString GetInternalNetwork() const;
    void SetInternalNetwork(const QString & aInternalNetwork);
    QString GetNATNetwork() const;
    void SetNATNetwork(const QString & aNATNetwork);
    QString GetGenericDriver() const;
    void SetGenericDriver(const QString & aGenericDriver);
    BOOL GetCableConnected() const;
    void SetCableConnected(BOOL aCableConnected);
    ULONG GetLineSpeed() const;
    void SetLineSpeed(ULONG aLineSpeed);
    KNetworkAdapterPromiscModePolicy GetPromiscModePolicy() const;
    void SetPromiscModePolicy(const KNetworkAdapterPromiscModePolicy & aPromiscModePolicy);
    BOOL GetTraceEnabled() const;
    void SetTraceEnabled(BOOL aTraceEnabled);
    QString GetTraceFile() const;
    void SetTraceFile(const QString & aTraceFile);
    CNATEngine GetNATEngine() const;
    ULONG GetBootPriority() const;
    void SetBootPriority(ULONG aBootPriority);
    CBandwidthGroup GetBandwidthGroup() const;
    void SetBandwidthGroup(const CBandwidthGroup & aBandwidthGroup);

    /* Methods: */
    QString GetProperty(const QString & aKey) const;
    void SetProperty(const QString & aKey, const QString & aValue);
    QVector<QString> GetProperties(const QString & aNames, QVector<QString> & aReturnNames) const;

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CMachine;
    friend class CInternalSessionControl;
    friend class CNetworkAdapterChangedEvent;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CNetworkAdapter)

#endif /* __CNetworkAdapter_h__ */


// ##### ENDFILE "CNetworkAdapter.h"


// ##### BEGINFILE "CSerialPort.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CSerialPort_h__
#define __CSerialPort_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CSerialPort : public CInterface<ISerialPort, COMBaseWithEI>
{
public:

    typedef CInterface<ISerialPort, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CSerialPort() {}

    template<class OI, class OB> explicit CSerialPort(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CSerialPort(const CSerialPort & that) : Base(that) {}

    template<class OI> explicit CSerialPort(OI * aIface) { attach(aIface); }

    explicit CSerialPort(ISerialPort * aIface) : Base(aIface) {}

    template<class OI, class OB> CSerialPort & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CSerialPort & operator=(const CSerialPort & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CSerialPort & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CSerialPort & operator=(ISerialPort * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    ULONG GetSlot() const;
    BOOL GetEnabled() const;
    void SetEnabled(BOOL aEnabled);
    ULONG GetIOBase() const;
    void SetIOBase(ULONG aIOBase);
    ULONG GetIRQ() const;
    void SetIRQ(ULONG aIRQ);
    KPortMode GetHostMode() const;
    void SetHostMode(const KPortMode & aHostMode);
    BOOL GetServer() const;
    void SetServer(BOOL aServer);
    QString GetPath() const;
    void SetPath(const QString & aPath);

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CMachine;
    friend class CInternalSessionControl;
    friend class CSerialPortChangedEvent;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CSerialPort)

#endif /* __CSerialPort_h__ */


// ##### ENDFILE "CSerialPort.h"


// ##### BEGINFILE "CParallelPort.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CParallelPort_h__
#define __CParallelPort_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CParallelPort : public CInterface<IParallelPort, COMBaseWithEI>
{
public:

    typedef CInterface<IParallelPort, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CParallelPort() {}

    template<class OI, class OB> explicit CParallelPort(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CParallelPort(const CParallelPort & that) : Base(that) {}

    template<class OI> explicit CParallelPort(OI * aIface) { attach(aIface); }

    explicit CParallelPort(IParallelPort * aIface) : Base(aIface) {}

    template<class OI, class OB> CParallelPort & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CParallelPort & operator=(const CParallelPort & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CParallelPort & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CParallelPort & operator=(IParallelPort * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    ULONG GetSlot() const;
    BOOL GetEnabled() const;
    void SetEnabled(BOOL aEnabled);
    ULONG GetIOBase() const;
    void SetIOBase(ULONG aIOBase);
    ULONG GetIRQ() const;
    void SetIRQ(ULONG aIRQ);
    QString GetPath() const;
    void SetPath(const QString & aPath);

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CMachine;
    friend class CInternalSessionControl;
    friend class CParallelPortChangedEvent;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CParallelPort)

#endif /* __CParallelPort_h__ */


// ##### ENDFILE "CParallelPort.h"


// ##### BEGINFILE "CMachineDebugger.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CMachineDebugger_h__
#define __CMachineDebugger_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CMachineDebugger : public CInterface<IMachineDebugger, COMBaseWithEI>
{
public:

    typedef CInterface<IMachineDebugger, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CMachineDebugger() {}

    template<class OI, class OB> explicit CMachineDebugger(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CMachineDebugger(const CMachineDebugger & that) : Base(that) {}

    template<class OI> explicit CMachineDebugger(OI * aIface) { attach(aIface); }

    explicit CMachineDebugger(IMachineDebugger * aIface) : Base(aIface) {}

    template<class OI, class OB> CMachineDebugger & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CMachineDebugger & operator=(const CMachineDebugger & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CMachineDebugger & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CMachineDebugger & operator=(IMachineDebugger * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    BOOL GetSingleStep() const;
    void SetSingleStep(BOOL aSingleStep);
    BOOL GetRecompileUser() const;
    void SetRecompileUser(BOOL aRecompileUser);
    BOOL GetRecompileSupervisor() const;
    void SetRecompileSupervisor(BOOL aRecompileSupervisor);
    BOOL GetExecuteAllInIEM() const;
    void SetExecuteAllInIEM(BOOL aExecuteAllInIEM);
    BOOL GetPATMEnabled() const;
    void SetPATMEnabled(BOOL aPATMEnabled);
    BOOL GetCSAMEnabled() const;
    void SetCSAMEnabled(BOOL aCSAMEnabled);
    BOOL GetLogEnabled() const;
    void SetLogEnabled(BOOL aLogEnabled);
    QString GetLogDbgFlags() const;
    QString GetLogDbgGroups() const;
    QString GetLogDbgDestinations() const;
    QString GetLogRelFlags() const;
    QString GetLogRelGroups() const;
    QString GetLogRelDestinations() const;
    BOOL GetHWVirtExEnabled() const;
    BOOL GetHWVirtExNestedPagingEnabled() const;
    BOOL GetHWVirtExVPIDEnabled() const;
    BOOL GetHWVirtExUXEnabled() const;
    QString GetOSName() const;
    QString GetOSVersion() const;
    BOOL GetPAEEnabled() const;
    ULONG GetVirtualTimeRate() const;
    void SetVirtualTimeRate(ULONG aVirtualTimeRate);
    LONG64 GetVM() const;

    /* Methods: */
    void DumpGuestCore(const QString & aFilename, const QString & aCompression);
    void DumpHostProcessCore(const QString & aFilename, const QString & aCompression);
    QString Info(const QString & aName, const QString & aArgs);
    void InjectNMI();
    void ModifyLogGroups(const QString & aSettings);
    void ModifyLogFlags(const QString & aSettings);
    void ModifyLogDestinations(const QString & aSettings);
    QVector<BYTE> ReadPhysicalMemory(LONG64 aAddress, ULONG aSize);
    void WritePhysicalMemory(LONG64 aAddress, ULONG aSize, const QVector<BYTE> & aBytes);
    QVector<BYTE> ReadVirtualMemory(ULONG aCpuId, LONG64 aAddress, ULONG aSize);
    void WriteVirtualMemory(ULONG aCpuId, LONG64 aAddress, ULONG aSize, const QVector<BYTE> & aBytes);
    QString DetectOS();
    QString GetRegister(ULONG aCpuId, const QString & aName);
    void GetRegisters(ULONG aCpuId, QVector<QString> & aNames, QVector<QString> & aValues);
    void SetRegister(ULONG aCpuId, const QString & aName, const QString & aValue);
    void SetRegisters(ULONG aCpuId, const QVector<QString> & aNames, const QVector<QString> & aValues);
    QString DumpGuestStack(ULONG aCpuId);
    void ResetStats(const QString & aPattern);
    void DumpStats(const QString & aPattern);
    QString GetStats(const QString & aPattern, BOOL aWithDescriptions);

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CConsole;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CMachineDebugger)

#endif /* __CMachineDebugger_h__ */


// ##### ENDFILE "CMachineDebugger.h"


// ##### BEGINFILE "CUSBDeviceFilters.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CUSBDeviceFilters_h__
#define __CUSBDeviceFilters_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CUSBDeviceFilters : public CInterface<IUSBDeviceFilters, COMBaseWithEI>
{
public:

    typedef CInterface<IUSBDeviceFilters, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CUSBDeviceFilters() {}

    template<class OI, class OB> explicit CUSBDeviceFilters(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CUSBDeviceFilters(const CUSBDeviceFilters & that) : Base(that) {}

    template<class OI> explicit CUSBDeviceFilters(OI * aIface) { attach(aIface); }

    explicit CUSBDeviceFilters(IUSBDeviceFilters * aIface) : Base(aIface) {}

    template<class OI, class OB> CUSBDeviceFilters & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CUSBDeviceFilters & operator=(const CUSBDeviceFilters & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CUSBDeviceFilters & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CUSBDeviceFilters & operator=(IUSBDeviceFilters * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QVector<CUSBDeviceFilter> GetDeviceFilters() const;

    /* Methods: */
    CUSBDeviceFilter CreateDeviceFilter(const QString & aName);
    void InsertDeviceFilter(ULONG aPosition, const CUSBDeviceFilter & aFilter);
    CUSBDeviceFilter RemoveDeviceFilter(ULONG aPosition);

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CMachine;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CUSBDeviceFilters)

#endif /* __CUSBDeviceFilters_h__ */


// ##### ENDFILE "CUSBDeviceFilters.h"


// ##### BEGINFILE "CUSBController.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CUSBController_h__
#define __CUSBController_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CUSBController : public CInterface<IUSBController, COMBaseWithEI>
{
public:

    typedef CInterface<IUSBController, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CUSBController() {}

    template<class OI, class OB> explicit CUSBController(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CUSBController(const CUSBController & that) : Base(that) {}

    template<class OI> explicit CUSBController(OI * aIface) { attach(aIface); }

    explicit CUSBController(IUSBController * aIface) : Base(aIface) {}

    template<class OI, class OB> CUSBController & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CUSBController & operator=(const CUSBController & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CUSBController & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CUSBController & operator=(IUSBController * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetName() const;
    KUSBControllerType GetType() const;
    USHORT GetUSBStandard() const;

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CMachine;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CUSBController)

/* Declare safe-array: */
typedef QVector<CUSBController> CUSBControllerVector;

#endif /* __CUSBController_h__ */


// ##### ENDFILE "CUSBController.h"


// ##### BEGINFILE "CUSBDevice.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CUSBDevice_h__
#define __CUSBDevice_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CUSBDevice : public CInterface<IUSBDevice, COMBaseWithEI>
{
public:

    typedef CInterface<IUSBDevice, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CUSBDevice() {}

    template<class OI, class OB> explicit CUSBDevice(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CUSBDevice(const CUSBDevice & that) : Base(that) {}

    template<class OI> explicit CUSBDevice(OI * aIface) { attach(aIface); }

    explicit CUSBDevice(IUSBDevice * aIface) : Base(aIface) {}

    template<class OI, class OB> CUSBDevice & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CUSBDevice & operator=(const CUSBDevice & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CUSBDevice & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CUSBDevice & operator=(IUSBDevice * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetId() const;
    USHORT GetVendorId() const;
    USHORT GetProductId() const;
    USHORT GetRevision() const;
    QString GetManufacturer() const;
    QString GetProduct() const;
    QString GetSerialNumber() const;
    QString GetAddress() const;
    USHORT GetPort() const;
    USHORT GetVersion() const;
    USHORT GetPortVersion() const;
    BOOL GetRemote() const;

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CInternalMachineControl;
    friend class CConsole;
    friend class CInternalSessionControl;
    friend class CUSBDeviceStateChangedEvent;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CUSBDevice)

/* Declare safe-array: */
typedef QVector<CUSBDevice> CUSBDeviceVector;

#endif /* __CUSBDevice_h__ */


// ##### ENDFILE "CUSBDevice.h"


// ##### BEGINFILE "CUSBDeviceFilter.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CUSBDeviceFilter_h__
#define __CUSBDeviceFilter_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CUSBDeviceFilter : public CInterface<IUSBDeviceFilter, COMBaseWithEI>
{
public:

    typedef CInterface<IUSBDeviceFilter, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CUSBDeviceFilter() {}

    template<class OI, class OB> explicit CUSBDeviceFilter(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CUSBDeviceFilter(const CUSBDeviceFilter & that) : Base(that) {}

    template<class OI> explicit CUSBDeviceFilter(OI * aIface) { attach(aIface); }

    explicit CUSBDeviceFilter(IUSBDeviceFilter * aIface) : Base(aIface) {}

    template<class OI, class OB> CUSBDeviceFilter & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CUSBDeviceFilter & operator=(const CUSBDeviceFilter & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CUSBDeviceFilter & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CUSBDeviceFilter & operator=(IUSBDeviceFilter * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetName() const;
    void SetName(const QString & aName);
    BOOL GetActive() const;
    void SetActive(BOOL aActive);
    QString GetVendorId() const;
    void SetVendorId(const QString & aVendorId);
    QString GetProductId() const;
    void SetProductId(const QString & aProductId);
    QString GetRevision() const;
    void SetRevision(const QString & aRevision);
    QString GetManufacturer() const;
    void SetManufacturer(const QString & aManufacturer);
    QString GetProduct() const;
    void SetProduct(const QString & aProduct);
    QString GetSerialNumber() const;
    void SetSerialNumber(const QString & aSerialNumber);
    QString GetPort() const;
    void SetPort(const QString & aPort);
    QString GetRemote() const;
    void SetRemote(const QString & aRemote);
    ULONG GetMaskedInterfaces() const;
    void SetMaskedInterfaces(ULONG aMaskedInterfaces);

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CUSBDeviceFilters;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CUSBDeviceFilter)

/* Declare safe-array: */
typedef QVector<CUSBDeviceFilter> CUSBDeviceFilterVector;

#endif /* __CUSBDeviceFilter_h__ */


// ##### ENDFILE "CUSBDeviceFilter.h"


// ##### BEGINFILE "CHostUSBDevice.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CHostUSBDevice_h__
#define __CHostUSBDevice_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CHostUSBDevice : public CInterface<IHostUSBDevice, COMBaseWithEI>
{
public:

    typedef CInterface<IHostUSBDevice, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CHostUSBDevice() {}

    template<class OI, class OB> explicit CHostUSBDevice(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CHostUSBDevice(const CHostUSBDevice & that) : Base(that) {}

    template<class OI> explicit CHostUSBDevice(OI * aIface) { attach(aIface); }

    explicit CHostUSBDevice(IHostUSBDevice * aIface) : Base(aIface) {}

    template<class OI, class OB> CHostUSBDevice & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CHostUSBDevice & operator=(const CHostUSBDevice & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CHostUSBDevice & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CHostUSBDevice & operator=(IHostUSBDevice * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KUSBDeviceState GetState() const;

    QString GetId() const;
    USHORT GetVendorId() const;
    USHORT GetProductId() const;
    USHORT GetRevision() const;
    QString GetManufacturer() const;
    QString GetProduct() const;
    QString GetSerialNumber() const;
    QString GetAddress() const;
    USHORT GetPort() const;
    USHORT GetVersion() const;
    USHORT GetPortVersion() const;
    BOOL GetRemote() const;

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CConsole;
    friend class CHost;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CHostUSBDevice)

/* Declare safe-array: */
typedef QVector<CHostUSBDevice> CHostUSBDeviceVector;

#endif /* __CHostUSBDevice_h__ */


// ##### ENDFILE "CHostUSBDevice.h"


// ##### BEGINFILE "CHostUSBDeviceFilter.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CHostUSBDeviceFilter_h__
#define __CHostUSBDeviceFilter_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CHostUSBDeviceFilter : public CInterface<IHostUSBDeviceFilter, COMBaseWithEI>
{
public:

    typedef CInterface<IHostUSBDeviceFilter, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CHostUSBDeviceFilter() {}

    template<class OI, class OB> explicit CHostUSBDeviceFilter(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CHostUSBDeviceFilter(const CHostUSBDeviceFilter & that) : Base(that) {}

    template<class OI> explicit CHostUSBDeviceFilter(OI * aIface) { attach(aIface); }

    explicit CHostUSBDeviceFilter(IHostUSBDeviceFilter * aIface) : Base(aIface) {}

    template<class OI, class OB> CHostUSBDeviceFilter & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CHostUSBDeviceFilter & operator=(const CHostUSBDeviceFilter & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CHostUSBDeviceFilter & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CHostUSBDeviceFilter & operator=(IHostUSBDeviceFilter * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KUSBDeviceFilterAction GetAction() const;
    void SetAction(const KUSBDeviceFilterAction & aAction);

    QString GetName() const;
    void SetName(const QString & aName);
    BOOL GetActive() const;
    void SetActive(BOOL aActive);
    QString GetVendorId() const;
    void SetVendorId(const QString & aVendorId);
    QString GetProductId() const;
    void SetProductId(const QString & aProductId);
    QString GetRevision() const;
    void SetRevision(const QString & aRevision);
    QString GetManufacturer() const;
    void SetManufacturer(const QString & aManufacturer);
    QString GetProduct() const;
    void SetProduct(const QString & aProduct);
    QString GetSerialNumber() const;
    void SetSerialNumber(const QString & aSerialNumber);
    QString GetPort() const;
    void SetPort(const QString & aPort);
    QString GetRemote() const;
    void SetRemote(const QString & aRemote);
    ULONG GetMaskedInterfaces() const;
    void SetMaskedInterfaces(ULONG aMaskedInterfaces);

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CHost;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CHostUSBDeviceFilter)

/* Declare safe-array: */
typedef QVector<CHostUSBDeviceFilter> CHostUSBDeviceFilterVector;

#endif /* __CHostUSBDeviceFilter_h__ */


// ##### ENDFILE "CHostUSBDeviceFilter.h"


// ##### BEGINFILE "CAudioAdapter.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CAudioAdapter_h__
#define __CAudioAdapter_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CAudioAdapter : public CInterface<IAudioAdapter, COMBaseWithEI>
{
public:

    typedef CInterface<IAudioAdapter, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CAudioAdapter() {}

    template<class OI, class OB> explicit CAudioAdapter(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CAudioAdapter(const CAudioAdapter & that) : Base(that) {}

    template<class OI> explicit CAudioAdapter(OI * aIface) { attach(aIface); }

    explicit CAudioAdapter(IAudioAdapter * aIface) : Base(aIface) {}

    template<class OI, class OB> CAudioAdapter & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CAudioAdapter & operator=(const CAudioAdapter & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CAudioAdapter & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CAudioAdapter & operator=(IAudioAdapter * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    BOOL GetEnabled() const;
    void SetEnabled(BOOL aEnabled);
    KAudioControllerType GetAudioController() const;
    void SetAudioController(const KAudioControllerType & aAudioController);
    KAudioDriverType GetAudioDriver() const;
    void SetAudioDriver(const KAudioDriverType & aAudioDriver);

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CMachine;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CAudioAdapter)

#endif /* __CAudioAdapter_h__ */


// ##### ENDFILE "CAudioAdapter.h"


// ##### BEGINFILE "CVRDEServer.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CVRDEServer_h__
#define __CVRDEServer_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CVRDEServer : public CInterface<IVRDEServer, COMBaseWithEI>
{
public:

    typedef CInterface<IVRDEServer, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CVRDEServer() {}

    template<class OI, class OB> explicit CVRDEServer(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CVRDEServer(const CVRDEServer & that) : Base(that) {}

    template<class OI> explicit CVRDEServer(OI * aIface) { attach(aIface); }

    explicit CVRDEServer(IVRDEServer * aIface) : Base(aIface) {}

    template<class OI, class OB> CVRDEServer & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CVRDEServer & operator=(const CVRDEServer & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CVRDEServer & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CVRDEServer & operator=(IVRDEServer * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    BOOL GetEnabled() const;
    void SetEnabled(BOOL aEnabled);
    KAuthType GetAuthType() const;
    void SetAuthType(const KAuthType & aAuthType);
    ULONG GetAuthTimeout() const;
    void SetAuthTimeout(ULONG aAuthTimeout);
    BOOL GetAllowMultiConnection() const;
    void SetAllowMultiConnection(BOOL aAllowMultiConnection);
    BOOL GetReuseSingleConnection() const;
    void SetReuseSingleConnection(BOOL aReuseSingleConnection);
    QString GetVRDEExtPack() const;
    void SetVRDEExtPack(const QString & aVRDEExtPack);
    QString GetAuthLibrary() const;
    void SetAuthLibrary(const QString & aAuthLibrary);
    QVector<QString> GetVRDEProperties() const;

    /* Methods: */
    void SetVRDEProperty(const QString & aKey, const QString & aValue);
    QString GetVRDEProperty(const QString & aKey) const;

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CMachine;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CVRDEServer)

#endif /* __CVRDEServer_h__ */


// ##### ENDFILE "CVRDEServer.h"


// ##### BEGINFILE "CSharedFolder.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CSharedFolder_h__
#define __CSharedFolder_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CSharedFolder : public CInterface<ISharedFolder, COMBaseWithEI>
{
public:

    typedef CInterface<ISharedFolder, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CSharedFolder() {}

    template<class OI, class OB> explicit CSharedFolder(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CSharedFolder(const CSharedFolder & that) : Base(that) {}

    template<class OI> explicit CSharedFolder(OI * aIface) { attach(aIface); }

    explicit CSharedFolder(ISharedFolder * aIface) : Base(aIface) {}

    template<class OI, class OB> CSharedFolder & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CSharedFolder & operator=(const CSharedFolder & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CSharedFolder & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CSharedFolder & operator=(ISharedFolder * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetName() const;
    QString GetHostPath() const;
    BOOL GetAccessible() const;
    BOOL GetWritable() const;
    BOOL GetAutoMount() const;
    QString GetLastAccessError() const;

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CVirtualBox;
    friend class CMachine;
    friend class CConsole;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CSharedFolder)

/* Declare safe-array: */
typedef QVector<CSharedFolder> CSharedFolderVector;

#endif /* __CSharedFolder_h__ */


// ##### ENDFILE "CSharedFolder.h"


// ##### BEGINFILE "CSession.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CSession_h__
#define __CSession_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CSession : public CInterface<ISession, COMBaseWithEI>
{
public:

    typedef CInterface<ISession, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CSession() {}

    template<class OI, class OB> explicit CSession(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CSession(const CSession & that) : Base(that) {}

    template<class OI> explicit CSession(OI * aIface) { attach(aIface); }

    explicit CSession(ISession * aIface) : Base(aIface) {}

    template<class OI, class OB> CSession & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CSession & operator=(const CSession & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CSession & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CSession & operator=(ISession * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KSessionState GetState() const;
    KSessionType GetType() const;
    CMachine GetMachine() const;
    CConsole GetConsole() const;

    /* Methods: */
    void UnlockMachine();

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CInternalMachineControl;
    friend class CMachine;
    friend class CWebsessionManager;
    friend class CVirtualBoxClient;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CSession)

#endif /* __CSession_h__ */


// ##### ENDFILE "CSession.h"


// ##### BEGINFILE "CStorageController.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CStorageController_h__
#define __CStorageController_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CStorageController : public CInterface<IStorageController, COMBaseWithEI>
{
public:

    typedef CInterface<IStorageController, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CStorageController() {}

    template<class OI, class OB> explicit CStorageController(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CStorageController(const CStorageController & that) : Base(that) {}

    template<class OI> explicit CStorageController(OI * aIface) { attach(aIface); }

    explicit CStorageController(IStorageController * aIface) : Base(aIface) {}

    template<class OI, class OB> CStorageController & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CStorageController & operator=(const CStorageController & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CStorageController & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CStorageController & operator=(IStorageController * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetName() const;
    ULONG GetMaxDevicesPerPortCount() const;
    ULONG GetMinPortCount() const;
    ULONG GetMaxPortCount() const;
    ULONG GetInstance() const;
    void SetInstance(ULONG aInstance);
    ULONG GetPortCount() const;
    void SetPortCount(ULONG aPortCount);
    KStorageBus GetBus() const;
    KStorageControllerType GetControllerType() const;
    void SetControllerType(const KStorageControllerType & aControllerType);
    BOOL GetUseHostIOCache() const;
    void SetUseHostIOCache(BOOL aUseHostIOCache);
    BOOL GetBootable() const;

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CMachine;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CStorageController)

/* Declare safe-array: */
typedef QVector<CStorageController> CStorageControllerVector;

#endif /* __CStorageController_h__ */


// ##### ENDFILE "CStorageController.h"


// ##### BEGINFILE "CPerformanceMetric.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CPerformanceMetric_h__
#define __CPerformanceMetric_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CPerformanceMetric : public CInterface<IPerformanceMetric, COMBaseWithEI>
{
public:

    typedef CInterface<IPerformanceMetric, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CPerformanceMetric() {}

    template<class OI, class OB> explicit CPerformanceMetric(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CPerformanceMetric(const CPerformanceMetric & that) : Base(that) {}

    template<class OI> explicit CPerformanceMetric(OI * aIface) { attach(aIface); }

    explicit CPerformanceMetric(IPerformanceMetric * aIface) : Base(aIface) {}

    template<class OI, class OB> CPerformanceMetric & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CPerformanceMetric & operator=(const CPerformanceMetric & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CPerformanceMetric & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CPerformanceMetric & operator=(IPerformanceMetric * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetMetricName() const;
    CUnknown GetObject() const;
    QString GetDescription() const;
    ULONG GetPeriod() const;
    ULONG GetCount() const;
    QString GetUnit() const;
    LONG GetMinimumValue() const;
    LONG GetMaximumValue() const;

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CPerformanceCollector;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CPerformanceMetric)

/* Declare safe-array: */
typedef QVector<CPerformanceMetric> CPerformanceMetricVector;

#endif /* __CPerformanceMetric_h__ */


// ##### ENDFILE "CPerformanceMetric.h"


// ##### BEGINFILE "CPerformanceCollector.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CPerformanceCollector_h__
#define __CPerformanceCollector_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CPerformanceCollector : public CInterface<IPerformanceCollector, COMBaseWithEI>
{
public:

    typedef CInterface<IPerformanceCollector, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CPerformanceCollector() {}

    template<class OI, class OB> explicit CPerformanceCollector(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CPerformanceCollector(const CPerformanceCollector & that) : Base(that) {}

    template<class OI> explicit CPerformanceCollector(OI * aIface) { attach(aIface); }

    explicit CPerformanceCollector(IPerformanceCollector * aIface) : Base(aIface) {}

    template<class OI, class OB> CPerformanceCollector & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CPerformanceCollector & operator=(const CPerformanceCollector & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CPerformanceCollector & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CPerformanceCollector & operator=(IPerformanceCollector * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QVector<QString> GetMetricNames() const;

    /* Methods: */
    QVector<CPerformanceMetric> GetMetrics(const QVector<QString> & aMetricNames, const QVector<CUnknown> & aObjects);
    QVector<CPerformanceMetric> SetupMetrics(const QVector<QString> & aMetricNames, const QVector<CUnknown> & aObjects, ULONG aPeriod, ULONG aCount);
    QVector<CPerformanceMetric> EnableMetrics(const QVector<QString> & aMetricNames, const QVector<CUnknown> & aObjects);
    QVector<CPerformanceMetric> DisableMetrics(const QVector<QString> & aMetricNames, const QVector<CUnknown> & aObjects);
    QVector<LONG> QueryMetricsData(const QVector<QString> & aMetricNames, const QVector<CUnknown> & aObjects, QVector<QString> & aReturnMetricNames, QVector<CUnknown> & aReturnObjects, QVector<QString> & aReturnUnits, QVector<ULONG> & aReturnScales, QVector<ULONG> & aReturnSequenceNumbers, QVector<ULONG> & aReturnDataIndices, QVector<ULONG> & aReturnDataLengths);

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CVirtualBox;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CPerformanceCollector)

#endif /* __CPerformanceCollector_h__ */


// ##### ENDFILE "CPerformanceCollector.h"


// ##### BEGINFILE "CNATEngine.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CNATEngine_h__
#define __CNATEngine_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CNATEngine : public CInterface<INATEngine, COMBaseWithEI>
{
public:

    typedef CInterface<INATEngine, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CNATEngine() {}

    template<class OI, class OB> explicit CNATEngine(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CNATEngine(const CNATEngine & that) : Base(that) {}

    template<class OI> explicit CNATEngine(OI * aIface) { attach(aIface); }

    explicit CNATEngine(INATEngine * aIface) : Base(aIface) {}

    template<class OI, class OB> CNATEngine & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CNATEngine & operator=(const CNATEngine & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CNATEngine & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CNATEngine & operator=(INATEngine * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetNetwork() const;
    void SetNetwork(const QString & aNetwork);
    QString GetHostIP() const;
    void SetHostIP(const QString & aHostIP);
    QString GetTFTPPrefix() const;
    void SetTFTPPrefix(const QString & aTFTPPrefix);
    QString GetTFTPBootFile() const;
    void SetTFTPBootFile(const QString & aTFTPBootFile);
    QString GetTFTPNextServer() const;
    void SetTFTPNextServer(const QString & aTFTPNextServer);
    ULONG GetAliasMode() const;
    void SetAliasMode(ULONG aAliasMode);
    BOOL GetDNSPassDomain() const;
    void SetDNSPassDomain(BOOL aDNSPassDomain);
    BOOL GetDNSProxy() const;
    void SetDNSProxy(BOOL aDNSProxy);
    BOOL GetDNSUseHostResolver() const;
    void SetDNSUseHostResolver(BOOL aDNSUseHostResolver);
    QVector<QString> GetRedirects() const;

    /* Methods: */
    void SetNetworkSettings(ULONG aMtu, ULONG aSockSnd, ULONG aSockRcv, ULONG aTcpWndSnd, ULONG aTcpWndRcv);
    void GetNetworkSettings(ULONG & aMtu, ULONG & aSockSnd, ULONG & aSockRcv, ULONG & aTcpWndSnd, ULONG & aTcpWndRcv);
    void AddRedirect(const QString & aName, const KNATProtocol & aProto, const QString & aHostIP, USHORT aHostPort, const QString & aGuestIP, USHORT aGuestPort);
    void RemoveRedirect(const QString & aName);

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CNetworkAdapter;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CNATEngine)

#endif /* __CNATEngine_h__ */


// ##### ENDFILE "CNATEngine.h"


// ##### BEGINFILE "CExtPackPlugIn.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CExtPackPlugIn_h__
#define __CExtPackPlugIn_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CExtPackPlugIn : public CInterface<IExtPackPlugIn, COMBaseWithEI>
{
public:

    typedef CInterface<IExtPackPlugIn, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CExtPackPlugIn() {}

    template<class OI, class OB> explicit CExtPackPlugIn(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CExtPackPlugIn(const CExtPackPlugIn & that) : Base(that) {}

    template<class OI> explicit CExtPackPlugIn(OI * aIface) { attach(aIface); }

    explicit CExtPackPlugIn(IExtPackPlugIn * aIface) : Base(aIface) {}

    template<class OI, class OB> CExtPackPlugIn & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CExtPackPlugIn & operator=(const CExtPackPlugIn & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CExtPackPlugIn & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CExtPackPlugIn & operator=(IExtPackPlugIn * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetName() const;
    QString GetDescription() const;
    QString GetFrontend() const;
    QString GetModulePath() const;

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CExtPackBase;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CExtPackPlugIn)

/* Declare safe-array: */
typedef QVector<CExtPackPlugIn> CExtPackPlugInVector;

#endif /* __CExtPackPlugIn_h__ */


// ##### ENDFILE "CExtPackPlugIn.h"


// ##### BEGINFILE "CExtPackBase.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CExtPackBase_h__
#define __CExtPackBase_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CExtPackBase : public CInterface<IExtPackBase, COMBaseWithEI>
{
public:

    typedef CInterface<IExtPackBase, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CExtPackBase() {}

    template<class OI, class OB> explicit CExtPackBase(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CExtPackBase(const CExtPackBase & that) : Base(that) {}

    template<class OI> explicit CExtPackBase(OI * aIface) { attach(aIface); }

    explicit CExtPackBase(IExtPackBase * aIface) : Base(aIface) {}

    template<class OI, class OB> CExtPackBase & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CExtPackBase & operator=(const CExtPackBase & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CExtPackBase & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CExtPackBase & operator=(IExtPackBase * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetName() const;
    QString GetDescription() const;
    QString GetVersion() const;
    ULONG GetRevision() const;
    QString GetEdition() const;
    QString GetVRDEModule() const;
    QVector<CExtPackPlugIn> GetPlugIns() const;
    BOOL GetUsable() const;
    QString GetWhyUnusable() const;
    BOOL GetShowLicense() const;
    QString GetLicense() const;

    /* Methods: */
    QString QueryLicense(const QString & aPreferredLocale, const QString & aPreferredLanguage, const QString & aFormat);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CExtPackBase)

#endif /* __CExtPackBase_h__ */


// ##### ENDFILE "CExtPackBase.h"


// ##### BEGINFILE "CExtPack.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CExtPack_h__
#define __CExtPack_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CExtPack : public CInterface<IExtPack, COMBaseWithEI>
{
public:

    typedef CInterface<IExtPack, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CExtPack() {}

    template<class OI, class OB> explicit CExtPack(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CExtPack(const CExtPack & that) : Base(that) {}

    template<class OI> explicit CExtPack(OI * aIface) { attach(aIface); }

    explicit CExtPack(IExtPack * aIface) : Base(aIface) {}

    template<class OI, class OB> CExtPack & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CExtPack & operator=(const CExtPack & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CExtPack & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CExtPack & operator=(IExtPack * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetName() const;
    QString GetDescription() const;
    QString GetVersion() const;
    ULONG GetRevision() const;
    QString GetEdition() const;
    QString GetVRDEModule() const;
    QVector<CExtPackPlugIn> GetPlugIns() const;
    BOOL GetUsable() const;
    QString GetWhyUnusable() const;
    BOOL GetShowLicense() const;
    QString GetLicense() const;

    /* Methods: */
    CUnknown QueryObject(const QString & aObjUuid);

    QString QueryLicense(const QString & aPreferredLocale, const QString & aPreferredLanguage, const QString & aFormat);

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CExtPackManager;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CExtPack)

/* Declare safe-array: */
typedef QVector<CExtPack> CExtPackVector;

#endif /* __CExtPack_h__ */


// ##### ENDFILE "CExtPack.h"


// ##### BEGINFILE "CExtPackFile.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CExtPackFile_h__
#define __CExtPackFile_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CExtPackFile : public CInterface<IExtPackFile, COMBaseWithEI>
{
public:

    typedef CInterface<IExtPackFile, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CExtPackFile() {}

    template<class OI, class OB> explicit CExtPackFile(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CExtPackFile(const CExtPackFile & that) : Base(that) {}

    template<class OI> explicit CExtPackFile(OI * aIface) { attach(aIface); }

    explicit CExtPackFile(IExtPackFile * aIface) : Base(aIface) {}

    template<class OI, class OB> CExtPackFile & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CExtPackFile & operator=(const CExtPackFile & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CExtPackFile & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CExtPackFile & operator=(IExtPackFile * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetFilePath() const;

    QString GetName() const;
    QString GetDescription() const;
    QString GetVersion() const;
    ULONG GetRevision() const;
    QString GetEdition() const;
    QString GetVRDEModule() const;
    QVector<CExtPackPlugIn> GetPlugIns() const;
    BOOL GetUsable() const;
    QString GetWhyUnusable() const;
    BOOL GetShowLicense() const;
    QString GetLicense() const;

    /* Methods: */
    CProgress Install(BOOL aReplace, const QString & aDisplayInfo);

    QString QueryLicense(const QString & aPreferredLocale, const QString & aPreferredLanguage, const QString & aFormat);

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CExtPackManager;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CExtPackFile)

#endif /* __CExtPackFile_h__ */


// ##### ENDFILE "CExtPackFile.h"


// ##### BEGINFILE "CExtPackManager.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CExtPackManager_h__
#define __CExtPackManager_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CExtPackManager : public CInterface<IExtPackManager, COMBaseWithEI>
{
public:

    typedef CInterface<IExtPackManager, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CExtPackManager() {}

    template<class OI, class OB> explicit CExtPackManager(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CExtPackManager(const CExtPackManager & that) : Base(that) {}

    template<class OI> explicit CExtPackManager(OI * aIface) { attach(aIface); }

    explicit CExtPackManager(IExtPackManager * aIface) : Base(aIface) {}

    template<class OI, class OB> CExtPackManager & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CExtPackManager & operator=(const CExtPackManager & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CExtPackManager & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CExtPackManager & operator=(IExtPackManager * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QVector<CExtPack> GetInstalledExtPacks() const;

    /* Methods: */
    CExtPack Find(const QString & aName);
    CExtPackFile OpenExtPackFile(const QString & aPath);
    CProgress Uninstall(const QString & aName, BOOL aForcedRemoval, const QString & aDisplayInfo);
    void Cleanup();
    QVector<QString> QueryAllPlugInsForFrontend(const QString & aFrontendName);
    BOOL IsExtPackUsable(const QString & aName);

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CVirtualBox;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CExtPackManager)

#endif /* __CExtPackManager_h__ */


// ##### ENDFILE "CExtPackManager.h"


// ##### BEGINFILE "CBandwidthGroup.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CBandwidthGroup_h__
#define __CBandwidthGroup_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CBandwidthGroup : public CInterface<IBandwidthGroup, COMBaseWithEI>
{
public:

    typedef CInterface<IBandwidthGroup, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CBandwidthGroup() {}

    template<class OI, class OB> explicit CBandwidthGroup(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CBandwidthGroup(const CBandwidthGroup & that) : Base(that) {}

    template<class OI> explicit CBandwidthGroup(OI * aIface) { attach(aIface); }

    explicit CBandwidthGroup(IBandwidthGroup * aIface) : Base(aIface) {}

    template<class OI, class OB> CBandwidthGroup & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CBandwidthGroup & operator=(const CBandwidthGroup & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CBandwidthGroup & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CBandwidthGroup & operator=(IBandwidthGroup * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetName() const;
    KBandwidthGroupType GetType() const;
    ULONG GetReference() const;
    LONG64 GetMaxBytesPerSec() const;
    void SetMaxBytesPerSec(LONG64 aMaxBytesPerSec);

    /* Methods: */
    /* Friend wrappers: */
    friend class CUnknown;
    friend class CMachine;
    friend class CMediumAttachment;
    friend class CNetworkAdapter;
    friend class CInternalSessionControl;
    friend class CBandwidthControl;
    friend class CBandwidthGroupChangedEvent;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CBandwidthGroup)

/* Declare safe-array: */
typedef QVector<CBandwidthGroup> CBandwidthGroupVector;

#endif /* __CBandwidthGroup_h__ */


// ##### ENDFILE "CBandwidthGroup.h"


// ##### BEGINFILE "CBandwidthControl.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CBandwidthControl_h__
#define __CBandwidthControl_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CBandwidthControl : public CInterface<IBandwidthControl, COMBaseWithEI>
{
public:

    typedef CInterface<IBandwidthControl, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CBandwidthControl() {}

    template<class OI, class OB> explicit CBandwidthControl(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CBandwidthControl(const CBandwidthControl & that) : Base(that) {}

    template<class OI> explicit CBandwidthControl(OI * aIface) { attach(aIface); }

    explicit CBandwidthControl(IBandwidthControl * aIface) : Base(aIface) {}

    template<class OI, class OB> CBandwidthControl & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CBandwidthControl & operator=(const CBandwidthControl & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CBandwidthControl & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CBandwidthControl & operator=(IBandwidthControl * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    ULONG GetNumGroups() const;

    /* Methods: */
    void CreateBandwidthGroup(const QString & aName, const KBandwidthGroupType & aType, LONG64 aMaxBytesPerSec);
    void DeleteBandwidthGroup(const QString & aName);
    CBandwidthGroup GetBandwidthGroup(const QString & aName) const;
    QVector<CBandwidthGroup> GetAllBandwidthGroups() const;

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CMachine;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CBandwidthControl)

#endif /* __CBandwidthControl_h__ */


// ##### ENDFILE "CBandwidthControl.h"


// ##### BEGINFILE "CVirtualBoxClient.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CVirtualBoxClient_h__
#define __CVirtualBoxClient_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CVirtualBoxClient : public CInterface<IVirtualBoxClient, COMBaseWithEI>
{
public:

    typedef CInterface<IVirtualBoxClient, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CVirtualBoxClient() {}

    template<class OI, class OB> explicit CVirtualBoxClient(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CVirtualBoxClient(const CVirtualBoxClient & that) : Base(that) {}

    template<class OI> explicit CVirtualBoxClient(OI * aIface) { attach(aIface); }

    explicit CVirtualBoxClient(IVirtualBoxClient * aIface) : Base(aIface) {}

    template<class OI, class OB> CVirtualBoxClient & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CVirtualBoxClient & operator=(const CVirtualBoxClient & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CVirtualBoxClient & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CVirtualBoxClient & operator=(IVirtualBoxClient * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    CVirtualBox GetVirtualBox() const;
    CSession GetSession() const;
    CEventSource GetEventSource() const;

    /* Methods: */
    void CheckMachineError(const CMachine & aMachine);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CVirtualBoxClient)

#endif /* __CVirtualBoxClient_h__ */


// ##### ENDFILE "CVirtualBoxClient.h"


// ##### BEGINFILE "CEventSource.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CEventSource_h__
#define __CEventSource_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CEventSource : public CInterface<IEventSource, COMBaseWithEI>
{
public:

    typedef CInterface<IEventSource, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CEventSource() {}

    template<class OI, class OB> explicit CEventSource(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CEventSource(const CEventSource & that) : Base(that) {}

    template<class OI> explicit CEventSource(OI * aIface) { attach(aIface); }

    explicit CEventSource(IEventSource * aIface) : Base(aIface) {}

    template<class OI, class OB> CEventSource & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CEventSource & operator=(const CEventSource & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CEventSource & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CEventSource & operator=(IEventSource * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    /* Methods: */
    CEventListener CreateListener();
    CEventSource CreateAggregator(const QVector<CEventSource> & aSubordinates);
    void RegisterListener(const CEventListener & aListener, const QVector<KVBoxEventType> & aInteresting, BOOL aActive);
    void UnregisterListener(const CEventListener & aListener);
    BOOL FireEvent(const CEvent & aEvent, LONG aTimeout);
    CEvent GetEvent(const CEventListener & aListener, LONG aTimeout);
    void EventProcessed(const CEventListener & aListener, const CEvent & aEvent);

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CNATNetwork;
    friend class CDHCPServer;
    friend class CVirtualBox;
    friend class CConsole;
    friend class CGuestSession;
    friend class CProcess;
    friend class CFile;
    friend class CGuest;
    friend class CKeyboard;
    friend class CMouse;
    friend class CVirtualBoxClient;
    friend class CEvent;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CEventSource)

/* Declare safe-array: */
typedef QVector<CEventSource> CEventSourceVector;

#endif /* __CEventSource_h__ */


// ##### ENDFILE "CEventSource.h"


// ##### BEGINFILE "CEventListener.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CEventListener_h__
#define __CEventListener_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CEventListener : public CInterface<IEventListener, COMBaseWithEI>
{
public:

    typedef CInterface<IEventListener, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CEventListener() {}

    template<class OI, class OB> explicit CEventListener(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CEventListener(const CEventListener & that) : Base(that) {}

    template<class OI> explicit CEventListener(OI * aIface) { attach(aIface); }

    explicit CEventListener(IEventListener * aIface) : Base(aIface) {}

    template<class OI, class OB> CEventListener & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CEventListener & operator=(const CEventListener & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CEventListener & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CEventListener & operator=(IEventListener * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    /* Methods: */
    void HandleEvent(const CEvent & aEvent);

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CEventSource;
    friend class CEventSourceChangedEvent;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CEventListener)

#endif /* __CEventListener_h__ */


// ##### ENDFILE "CEventListener.h"


// ##### BEGINFILE "CEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CEvent_h__
#define __CEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CEvent : public CInterface<IEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CEvent() {}

    template<class OI, class OB> explicit CEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CEvent(const CEvent & that) : Base(that) {}

    template<class OI> explicit CEvent(OI * aIface) { attach(aIface); }

    explicit CEvent(IEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CEvent & operator=(const CEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CEvent & operator=(IEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
    friend class CEventSource;
    friend class CEventListener;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CEvent)

#endif /* __CEvent_h__ */


// ##### ENDFILE "CEvent.h"


// ##### BEGINFILE "CReusableEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CReusableEvent_h__
#define __CReusableEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CReusableEvent : public CInterface<IReusableEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IReusableEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CReusableEvent() {}

    template<class OI, class OB> explicit CReusableEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CReusableEvent(const CReusableEvent & that) : Base(that) {}

    template<class OI> explicit CReusableEvent(OI * aIface) { attach(aIface); }

    explicit CReusableEvent(IReusableEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CReusableEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CReusableEvent & operator=(const CReusableEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CReusableEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CReusableEvent & operator=(IReusableEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    ULONG GetGeneration() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void Reuse();

    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CReusableEvent)

#endif /* __CReusableEvent_h__ */


// ##### ENDFILE "CReusableEvent.h"


// ##### BEGINFILE "CMachineEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CMachineEvent_h__
#define __CMachineEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CMachineEvent : public CInterface<IMachineEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IMachineEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CMachineEvent() {}

    template<class OI, class OB> explicit CMachineEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CMachineEvent(const CMachineEvent & that) : Base(that) {}

    template<class OI> explicit CMachineEvent(OI * aIface) { attach(aIface); }

    explicit CMachineEvent(IMachineEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CMachineEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CMachineEvent & operator=(const CMachineEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CMachineEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CMachineEvent & operator=(IMachineEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetMachineId() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CMachineEvent)

#endif /* __CMachineEvent_h__ */


// ##### ENDFILE "CMachineEvent.h"


// ##### BEGINFILE "CMachineStateChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CMachineStateChangedEvent_h__
#define __CMachineStateChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CMachineStateChangedEvent : public CInterface<IMachineStateChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IMachineStateChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CMachineStateChangedEvent() {}

    template<class OI, class OB> explicit CMachineStateChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CMachineStateChangedEvent(const CMachineStateChangedEvent & that) : Base(that) {}

    template<class OI> explicit CMachineStateChangedEvent(OI * aIface) { attach(aIface); }

    explicit CMachineStateChangedEvent(IMachineStateChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CMachineStateChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CMachineStateChangedEvent & operator=(const CMachineStateChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CMachineStateChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CMachineStateChangedEvent & operator=(IMachineStateChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KMachineState GetState() const;

    QString GetMachineId() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CMachineStateChangedEvent)

#endif /* __CMachineStateChangedEvent_h__ */


// ##### ENDFILE "CMachineStateChangedEvent.h"


// ##### BEGINFILE "CMachineDataChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CMachineDataChangedEvent_h__
#define __CMachineDataChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CMachineDataChangedEvent : public CInterface<IMachineDataChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IMachineDataChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CMachineDataChangedEvent() {}

    template<class OI, class OB> explicit CMachineDataChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CMachineDataChangedEvent(const CMachineDataChangedEvent & that) : Base(that) {}

    template<class OI> explicit CMachineDataChangedEvent(OI * aIface) { attach(aIface); }

    explicit CMachineDataChangedEvent(IMachineDataChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CMachineDataChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CMachineDataChangedEvent & operator=(const CMachineDataChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CMachineDataChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CMachineDataChangedEvent & operator=(IMachineDataChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    BOOL GetTemporary() const;

    QString GetMachineId() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CMachineDataChangedEvent)

#endif /* __CMachineDataChangedEvent_h__ */


// ##### ENDFILE "CMachineDataChangedEvent.h"


// ##### BEGINFILE "CMediumRegisteredEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CMediumRegisteredEvent_h__
#define __CMediumRegisteredEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CMediumRegisteredEvent : public CInterface<IMediumRegisteredEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IMediumRegisteredEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CMediumRegisteredEvent() {}

    template<class OI, class OB> explicit CMediumRegisteredEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CMediumRegisteredEvent(const CMediumRegisteredEvent & that) : Base(that) {}

    template<class OI> explicit CMediumRegisteredEvent(OI * aIface) { attach(aIface); }

    explicit CMediumRegisteredEvent(IMediumRegisteredEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CMediumRegisteredEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CMediumRegisteredEvent & operator=(const CMediumRegisteredEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CMediumRegisteredEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CMediumRegisteredEvent & operator=(IMediumRegisteredEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetMediumId() const;
    KDeviceType GetMediumType() const;
    BOOL GetRegistered() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CMediumRegisteredEvent)

#endif /* __CMediumRegisteredEvent_h__ */


// ##### ENDFILE "CMediumRegisteredEvent.h"


// ##### BEGINFILE "CMachineRegisteredEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CMachineRegisteredEvent_h__
#define __CMachineRegisteredEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CMachineRegisteredEvent : public CInterface<IMachineRegisteredEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IMachineRegisteredEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CMachineRegisteredEvent() {}

    template<class OI, class OB> explicit CMachineRegisteredEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CMachineRegisteredEvent(const CMachineRegisteredEvent & that) : Base(that) {}

    template<class OI> explicit CMachineRegisteredEvent(OI * aIface) { attach(aIface); }

    explicit CMachineRegisteredEvent(IMachineRegisteredEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CMachineRegisteredEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CMachineRegisteredEvent & operator=(const CMachineRegisteredEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CMachineRegisteredEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CMachineRegisteredEvent & operator=(IMachineRegisteredEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    BOOL GetRegistered() const;

    QString GetMachineId() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CMachineRegisteredEvent)

#endif /* __CMachineRegisteredEvent_h__ */


// ##### ENDFILE "CMachineRegisteredEvent.h"


// ##### BEGINFILE "CSessionStateChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CSessionStateChangedEvent_h__
#define __CSessionStateChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CSessionStateChangedEvent : public CInterface<ISessionStateChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<ISessionStateChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CSessionStateChangedEvent() {}

    template<class OI, class OB> explicit CSessionStateChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CSessionStateChangedEvent(const CSessionStateChangedEvent & that) : Base(that) {}

    template<class OI> explicit CSessionStateChangedEvent(OI * aIface) { attach(aIface); }

    explicit CSessionStateChangedEvent(ISessionStateChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CSessionStateChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CSessionStateChangedEvent & operator=(const CSessionStateChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CSessionStateChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CSessionStateChangedEvent & operator=(ISessionStateChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KSessionState GetState() const;

    QString GetMachineId() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CSessionStateChangedEvent)

#endif /* __CSessionStateChangedEvent_h__ */


// ##### ENDFILE "CSessionStateChangedEvent.h"


// ##### BEGINFILE "CGuestPropertyChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestPropertyChangedEvent_h__
#define __CGuestPropertyChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestPropertyChangedEvent : public CInterface<IGuestPropertyChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestPropertyChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestPropertyChangedEvent() {}

    template<class OI, class OB> explicit CGuestPropertyChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestPropertyChangedEvent(const CGuestPropertyChangedEvent & that) : Base(that) {}

    template<class OI> explicit CGuestPropertyChangedEvent(OI * aIface) { attach(aIface); }

    explicit CGuestPropertyChangedEvent(IGuestPropertyChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestPropertyChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestPropertyChangedEvent & operator=(const CGuestPropertyChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestPropertyChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestPropertyChangedEvent & operator=(IGuestPropertyChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetName() const;
    QString GetValue() const;
    QString GetFlags() const;

    QString GetMachineId() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestPropertyChangedEvent)

#endif /* __CGuestPropertyChangedEvent_h__ */


// ##### ENDFILE "CGuestPropertyChangedEvent.h"


// ##### BEGINFILE "CSnapshotEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CSnapshotEvent_h__
#define __CSnapshotEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CSnapshotEvent : public CInterface<ISnapshotEvent, COMBaseWithEI>
{
public:

    typedef CInterface<ISnapshotEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CSnapshotEvent() {}

    template<class OI, class OB> explicit CSnapshotEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CSnapshotEvent(const CSnapshotEvent & that) : Base(that) {}

    template<class OI> explicit CSnapshotEvent(OI * aIface) { attach(aIface); }

    explicit CSnapshotEvent(ISnapshotEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CSnapshotEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CSnapshotEvent & operator=(const CSnapshotEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CSnapshotEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CSnapshotEvent & operator=(ISnapshotEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetSnapshotId() const;

    QString GetMachineId() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CSnapshotEvent)

#endif /* __CSnapshotEvent_h__ */


// ##### ENDFILE "CSnapshotEvent.h"


// ##### BEGINFILE "CSnapshotTakenEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CSnapshotTakenEvent_h__
#define __CSnapshotTakenEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CSnapshotTakenEvent : public CInterface<ISnapshotTakenEvent, COMBaseWithEI>
{
public:

    typedef CInterface<ISnapshotTakenEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CSnapshotTakenEvent() {}

    template<class OI, class OB> explicit CSnapshotTakenEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CSnapshotTakenEvent(const CSnapshotTakenEvent & that) : Base(that) {}

    template<class OI> explicit CSnapshotTakenEvent(OI * aIface) { attach(aIface); }

    explicit CSnapshotTakenEvent(ISnapshotTakenEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CSnapshotTakenEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CSnapshotTakenEvent & operator=(const CSnapshotTakenEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CSnapshotTakenEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CSnapshotTakenEvent & operator=(ISnapshotTakenEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetSnapshotId() const;

    QString GetMachineId() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CSnapshotTakenEvent)

#endif /* __CSnapshotTakenEvent_h__ */


// ##### ENDFILE "CSnapshotTakenEvent.h"


// ##### BEGINFILE "CSnapshotDeletedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CSnapshotDeletedEvent_h__
#define __CSnapshotDeletedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CSnapshotDeletedEvent : public CInterface<ISnapshotDeletedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<ISnapshotDeletedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CSnapshotDeletedEvent() {}

    template<class OI, class OB> explicit CSnapshotDeletedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CSnapshotDeletedEvent(const CSnapshotDeletedEvent & that) : Base(that) {}

    template<class OI> explicit CSnapshotDeletedEvent(OI * aIface) { attach(aIface); }

    explicit CSnapshotDeletedEvent(ISnapshotDeletedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CSnapshotDeletedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CSnapshotDeletedEvent & operator=(const CSnapshotDeletedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CSnapshotDeletedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CSnapshotDeletedEvent & operator=(ISnapshotDeletedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetSnapshotId() const;

    QString GetMachineId() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CSnapshotDeletedEvent)

#endif /* __CSnapshotDeletedEvent_h__ */


// ##### ENDFILE "CSnapshotDeletedEvent.h"


// ##### BEGINFILE "CSnapshotChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CSnapshotChangedEvent_h__
#define __CSnapshotChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CSnapshotChangedEvent : public CInterface<ISnapshotChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<ISnapshotChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CSnapshotChangedEvent() {}

    template<class OI, class OB> explicit CSnapshotChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CSnapshotChangedEvent(const CSnapshotChangedEvent & that) : Base(that) {}

    template<class OI> explicit CSnapshotChangedEvent(OI * aIface) { attach(aIface); }

    explicit CSnapshotChangedEvent(ISnapshotChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CSnapshotChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CSnapshotChangedEvent & operator=(const CSnapshotChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CSnapshotChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CSnapshotChangedEvent & operator=(ISnapshotChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetSnapshotId() const;

    QString GetMachineId() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CSnapshotChangedEvent)

#endif /* __CSnapshotChangedEvent_h__ */


// ##### ENDFILE "CSnapshotChangedEvent.h"


// ##### BEGINFILE "CMousePointerShapeChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CMousePointerShapeChangedEvent_h__
#define __CMousePointerShapeChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CMousePointerShapeChangedEvent : public CInterface<IMousePointerShapeChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IMousePointerShapeChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CMousePointerShapeChangedEvent() {}

    template<class OI, class OB> explicit CMousePointerShapeChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CMousePointerShapeChangedEvent(const CMousePointerShapeChangedEvent & that) : Base(that) {}

    template<class OI> explicit CMousePointerShapeChangedEvent(OI * aIface) { attach(aIface); }

    explicit CMousePointerShapeChangedEvent(IMousePointerShapeChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CMousePointerShapeChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CMousePointerShapeChangedEvent & operator=(const CMousePointerShapeChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CMousePointerShapeChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CMousePointerShapeChangedEvent & operator=(IMousePointerShapeChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    BOOL GetVisible() const;
    BOOL GetAlpha() const;
    ULONG GetXhot() const;
    ULONG GetYhot() const;
    ULONG GetWidth() const;
    ULONG GetHeight() const;
    QVector<BYTE> GetShape() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CMousePointerShapeChangedEvent)

#endif /* __CMousePointerShapeChangedEvent_h__ */


// ##### ENDFILE "CMousePointerShapeChangedEvent.h"


// ##### BEGINFILE "CMouseCapabilityChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CMouseCapabilityChangedEvent_h__
#define __CMouseCapabilityChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CMouseCapabilityChangedEvent : public CInterface<IMouseCapabilityChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IMouseCapabilityChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CMouseCapabilityChangedEvent() {}

    template<class OI, class OB> explicit CMouseCapabilityChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CMouseCapabilityChangedEvent(const CMouseCapabilityChangedEvent & that) : Base(that) {}

    template<class OI> explicit CMouseCapabilityChangedEvent(OI * aIface) { attach(aIface); }

    explicit CMouseCapabilityChangedEvent(IMouseCapabilityChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CMouseCapabilityChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CMouseCapabilityChangedEvent & operator=(const CMouseCapabilityChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CMouseCapabilityChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CMouseCapabilityChangedEvent & operator=(IMouseCapabilityChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    BOOL GetSupportsAbsolute() const;
    BOOL GetSupportsRelative() const;
    BOOL GetSupportsMultiTouch() const;
    BOOL GetNeedsHostCursor() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CMouseCapabilityChangedEvent)

#endif /* __CMouseCapabilityChangedEvent_h__ */


// ##### ENDFILE "CMouseCapabilityChangedEvent.h"


// ##### BEGINFILE "CKeyboardLedsChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CKeyboardLedsChangedEvent_h__
#define __CKeyboardLedsChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CKeyboardLedsChangedEvent : public CInterface<IKeyboardLedsChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IKeyboardLedsChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CKeyboardLedsChangedEvent() {}

    template<class OI, class OB> explicit CKeyboardLedsChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CKeyboardLedsChangedEvent(const CKeyboardLedsChangedEvent & that) : Base(that) {}

    template<class OI> explicit CKeyboardLedsChangedEvent(OI * aIface) { attach(aIface); }

    explicit CKeyboardLedsChangedEvent(IKeyboardLedsChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CKeyboardLedsChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CKeyboardLedsChangedEvent & operator=(const CKeyboardLedsChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CKeyboardLedsChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CKeyboardLedsChangedEvent & operator=(IKeyboardLedsChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    BOOL GetNumLock() const;
    BOOL GetCapsLock() const;
    BOOL GetScrollLock() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CKeyboardLedsChangedEvent)

#endif /* __CKeyboardLedsChangedEvent_h__ */


// ##### ENDFILE "CKeyboardLedsChangedEvent.h"


// ##### BEGINFILE "CStateChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CStateChangedEvent_h__
#define __CStateChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CStateChangedEvent : public CInterface<IStateChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IStateChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CStateChangedEvent() {}

    template<class OI, class OB> explicit CStateChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CStateChangedEvent(const CStateChangedEvent & that) : Base(that) {}

    template<class OI> explicit CStateChangedEvent(OI * aIface) { attach(aIface); }

    explicit CStateChangedEvent(IStateChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CStateChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CStateChangedEvent & operator=(const CStateChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CStateChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CStateChangedEvent & operator=(IStateChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KMachineState GetState() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CStateChangedEvent)

#endif /* __CStateChangedEvent_h__ */


// ##### ENDFILE "CStateChangedEvent.h"


// ##### BEGINFILE "CAdditionsStateChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CAdditionsStateChangedEvent_h__
#define __CAdditionsStateChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CAdditionsStateChangedEvent : public CInterface<IAdditionsStateChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IAdditionsStateChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CAdditionsStateChangedEvent() {}

    template<class OI, class OB> explicit CAdditionsStateChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CAdditionsStateChangedEvent(const CAdditionsStateChangedEvent & that) : Base(that) {}

    template<class OI> explicit CAdditionsStateChangedEvent(OI * aIface) { attach(aIface); }

    explicit CAdditionsStateChangedEvent(IAdditionsStateChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CAdditionsStateChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CAdditionsStateChangedEvent & operator=(const CAdditionsStateChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CAdditionsStateChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CAdditionsStateChangedEvent & operator=(IAdditionsStateChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CAdditionsStateChangedEvent)

#endif /* __CAdditionsStateChangedEvent_h__ */


// ##### ENDFILE "CAdditionsStateChangedEvent.h"


// ##### BEGINFILE "CNetworkAdapterChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CNetworkAdapterChangedEvent_h__
#define __CNetworkAdapterChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CNetworkAdapterChangedEvent : public CInterface<INetworkAdapterChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<INetworkAdapterChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CNetworkAdapterChangedEvent() {}

    template<class OI, class OB> explicit CNetworkAdapterChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CNetworkAdapterChangedEvent(const CNetworkAdapterChangedEvent & that) : Base(that) {}

    template<class OI> explicit CNetworkAdapterChangedEvent(OI * aIface) { attach(aIface); }

    explicit CNetworkAdapterChangedEvent(INetworkAdapterChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CNetworkAdapterChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CNetworkAdapterChangedEvent & operator=(const CNetworkAdapterChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CNetworkAdapterChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CNetworkAdapterChangedEvent & operator=(INetworkAdapterChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    CNetworkAdapter GetNetworkAdapter() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CNetworkAdapterChangedEvent)

#endif /* __CNetworkAdapterChangedEvent_h__ */


// ##### ENDFILE "CNetworkAdapterChangedEvent.h"


// ##### BEGINFILE "CSerialPortChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CSerialPortChangedEvent_h__
#define __CSerialPortChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CSerialPortChangedEvent : public CInterface<ISerialPortChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<ISerialPortChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CSerialPortChangedEvent() {}

    template<class OI, class OB> explicit CSerialPortChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CSerialPortChangedEvent(const CSerialPortChangedEvent & that) : Base(that) {}

    template<class OI> explicit CSerialPortChangedEvent(OI * aIface) { attach(aIface); }

    explicit CSerialPortChangedEvent(ISerialPortChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CSerialPortChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CSerialPortChangedEvent & operator=(const CSerialPortChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CSerialPortChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CSerialPortChangedEvent & operator=(ISerialPortChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    CSerialPort GetSerialPort() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CSerialPortChangedEvent)

#endif /* __CSerialPortChangedEvent_h__ */


// ##### ENDFILE "CSerialPortChangedEvent.h"


// ##### BEGINFILE "CParallelPortChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CParallelPortChangedEvent_h__
#define __CParallelPortChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CParallelPortChangedEvent : public CInterface<IParallelPortChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IParallelPortChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CParallelPortChangedEvent() {}

    template<class OI, class OB> explicit CParallelPortChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CParallelPortChangedEvent(const CParallelPortChangedEvent & that) : Base(that) {}

    template<class OI> explicit CParallelPortChangedEvent(OI * aIface) { attach(aIface); }

    explicit CParallelPortChangedEvent(IParallelPortChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CParallelPortChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CParallelPortChangedEvent & operator=(const CParallelPortChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CParallelPortChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CParallelPortChangedEvent & operator=(IParallelPortChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    CParallelPort GetParallelPort() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CParallelPortChangedEvent)

#endif /* __CParallelPortChangedEvent_h__ */


// ##### ENDFILE "CParallelPortChangedEvent.h"


// ##### BEGINFILE "CStorageControllerChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CStorageControllerChangedEvent_h__
#define __CStorageControllerChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CStorageControllerChangedEvent : public CInterface<IStorageControllerChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IStorageControllerChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CStorageControllerChangedEvent() {}

    template<class OI, class OB> explicit CStorageControllerChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CStorageControllerChangedEvent(const CStorageControllerChangedEvent & that) : Base(that) {}

    template<class OI> explicit CStorageControllerChangedEvent(OI * aIface) { attach(aIface); }

    explicit CStorageControllerChangedEvent(IStorageControllerChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CStorageControllerChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CStorageControllerChangedEvent & operator=(const CStorageControllerChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CStorageControllerChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CStorageControllerChangedEvent & operator=(IStorageControllerChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CStorageControllerChangedEvent)

#endif /* __CStorageControllerChangedEvent_h__ */


// ##### ENDFILE "CStorageControllerChangedEvent.h"


// ##### BEGINFILE "CMediumChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CMediumChangedEvent_h__
#define __CMediumChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CMediumChangedEvent : public CInterface<IMediumChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IMediumChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CMediumChangedEvent() {}

    template<class OI, class OB> explicit CMediumChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CMediumChangedEvent(const CMediumChangedEvent & that) : Base(that) {}

    template<class OI> explicit CMediumChangedEvent(OI * aIface) { attach(aIface); }

    explicit CMediumChangedEvent(IMediumChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CMediumChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CMediumChangedEvent & operator=(const CMediumChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CMediumChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CMediumChangedEvent & operator=(IMediumChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    CMediumAttachment GetMediumAttachment() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CMediumChangedEvent)

#endif /* __CMediumChangedEvent_h__ */


// ##### ENDFILE "CMediumChangedEvent.h"


// ##### BEGINFILE "CClipboardModeChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CClipboardModeChangedEvent_h__
#define __CClipboardModeChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CClipboardModeChangedEvent : public CInterface<IClipboardModeChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IClipboardModeChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CClipboardModeChangedEvent() {}

    template<class OI, class OB> explicit CClipboardModeChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CClipboardModeChangedEvent(const CClipboardModeChangedEvent & that) : Base(that) {}

    template<class OI> explicit CClipboardModeChangedEvent(OI * aIface) { attach(aIface); }

    explicit CClipboardModeChangedEvent(IClipboardModeChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CClipboardModeChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CClipboardModeChangedEvent & operator=(const CClipboardModeChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CClipboardModeChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CClipboardModeChangedEvent & operator=(IClipboardModeChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KClipboardMode GetClipboardMode() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CClipboardModeChangedEvent)

#endif /* __CClipboardModeChangedEvent_h__ */


// ##### ENDFILE "CClipboardModeChangedEvent.h"


// ##### BEGINFILE "CDragAndDropModeChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CDragAndDropModeChangedEvent_h__
#define __CDragAndDropModeChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CDragAndDropModeChangedEvent : public CInterface<IDragAndDropModeChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IDragAndDropModeChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CDragAndDropModeChangedEvent() {}

    template<class OI, class OB> explicit CDragAndDropModeChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CDragAndDropModeChangedEvent(const CDragAndDropModeChangedEvent & that) : Base(that) {}

    template<class OI> explicit CDragAndDropModeChangedEvent(OI * aIface) { attach(aIface); }

    explicit CDragAndDropModeChangedEvent(IDragAndDropModeChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CDragAndDropModeChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CDragAndDropModeChangedEvent & operator=(const CDragAndDropModeChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CDragAndDropModeChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CDragAndDropModeChangedEvent & operator=(IDragAndDropModeChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KDragAndDropMode GetDragAndDropMode() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CDragAndDropModeChangedEvent)

#endif /* __CDragAndDropModeChangedEvent_h__ */


// ##### ENDFILE "CDragAndDropModeChangedEvent.h"


// ##### BEGINFILE "CCPUChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CCPUChangedEvent_h__
#define __CCPUChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CCPUChangedEvent : public CInterface<ICPUChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<ICPUChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CCPUChangedEvent() {}

    template<class OI, class OB> explicit CCPUChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CCPUChangedEvent(const CCPUChangedEvent & that) : Base(that) {}

    template<class OI> explicit CCPUChangedEvent(OI * aIface) { attach(aIface); }

    explicit CCPUChangedEvent(ICPUChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CCPUChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CCPUChangedEvent & operator=(const CCPUChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CCPUChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CCPUChangedEvent & operator=(ICPUChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    ULONG GetCPU() const;
    BOOL GetAdd() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CCPUChangedEvent)

#endif /* __CCPUChangedEvent_h__ */


// ##### ENDFILE "CCPUChangedEvent.h"


// ##### BEGINFILE "CCPUExecutionCapChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CCPUExecutionCapChangedEvent_h__
#define __CCPUExecutionCapChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CCPUExecutionCapChangedEvent : public CInterface<ICPUExecutionCapChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<ICPUExecutionCapChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CCPUExecutionCapChangedEvent() {}

    template<class OI, class OB> explicit CCPUExecutionCapChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CCPUExecutionCapChangedEvent(const CCPUExecutionCapChangedEvent & that) : Base(that) {}

    template<class OI> explicit CCPUExecutionCapChangedEvent(OI * aIface) { attach(aIface); }

    explicit CCPUExecutionCapChangedEvent(ICPUExecutionCapChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CCPUExecutionCapChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CCPUExecutionCapChangedEvent & operator=(const CCPUExecutionCapChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CCPUExecutionCapChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CCPUExecutionCapChangedEvent & operator=(ICPUExecutionCapChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    ULONG GetExecutionCap() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CCPUExecutionCapChangedEvent)

#endif /* __CCPUExecutionCapChangedEvent_h__ */


// ##### ENDFILE "CCPUExecutionCapChangedEvent.h"


// ##### BEGINFILE "CGuestKeyboardEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestKeyboardEvent_h__
#define __CGuestKeyboardEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestKeyboardEvent : public CInterface<IGuestKeyboardEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestKeyboardEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestKeyboardEvent() {}

    template<class OI, class OB> explicit CGuestKeyboardEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestKeyboardEvent(const CGuestKeyboardEvent & that) : Base(that) {}

    template<class OI> explicit CGuestKeyboardEvent(OI * aIface) { attach(aIface); }

    explicit CGuestKeyboardEvent(IGuestKeyboardEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestKeyboardEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestKeyboardEvent & operator=(const CGuestKeyboardEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestKeyboardEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestKeyboardEvent & operator=(IGuestKeyboardEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QVector<LONG> GetScancodes() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestKeyboardEvent)

#endif /* __CGuestKeyboardEvent_h__ */


// ##### ENDFILE "CGuestKeyboardEvent.h"


// ##### BEGINFILE "CGuestMouseEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestMouseEvent_h__
#define __CGuestMouseEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestMouseEvent : public CInterface<IGuestMouseEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestMouseEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestMouseEvent() {}

    template<class OI, class OB> explicit CGuestMouseEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestMouseEvent(const CGuestMouseEvent & that) : Base(that) {}

    template<class OI> explicit CGuestMouseEvent(OI * aIface) { attach(aIface); }

    explicit CGuestMouseEvent(IGuestMouseEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestMouseEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestMouseEvent & operator=(const CGuestMouseEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestMouseEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestMouseEvent & operator=(IGuestMouseEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KGuestMouseEventMode GetMode() const;
    LONG GetX() const;
    LONG GetY() const;
    LONG GetZ() const;
    LONG GetW() const;
    LONG GetButtons() const;

    ULONG GetGeneration() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void Reuse();

    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestMouseEvent)

#endif /* __CGuestMouseEvent_h__ */


// ##### ENDFILE "CGuestMouseEvent.h"


// ##### BEGINFILE "CGuestMultiTouchEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestMultiTouchEvent_h__
#define __CGuestMultiTouchEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestMultiTouchEvent : public CInterface<IGuestMultiTouchEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestMultiTouchEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestMultiTouchEvent() {}

    template<class OI, class OB> explicit CGuestMultiTouchEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestMultiTouchEvent(const CGuestMultiTouchEvent & that) : Base(that) {}

    template<class OI> explicit CGuestMultiTouchEvent(OI * aIface) { attach(aIface); }

    explicit CGuestMultiTouchEvent(IGuestMultiTouchEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestMultiTouchEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestMultiTouchEvent & operator=(const CGuestMultiTouchEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestMultiTouchEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestMultiTouchEvent & operator=(IGuestMultiTouchEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    LONG GetContactCount() const;
    QVector<SHORT> GetXPositions() const;
    QVector<SHORT> GetYPositions() const;
    QVector<USHORT> GetContactIds() const;
    QVector<USHORT> GetContactFlags() const;
    ULONG GetScanTime() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestMultiTouchEvent)

#endif /* __CGuestMultiTouchEvent_h__ */


// ##### ENDFILE "CGuestMultiTouchEvent.h"


// ##### BEGINFILE "CGuestSessionEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestSessionEvent_h__
#define __CGuestSessionEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestSessionEvent : public CInterface<IGuestSessionEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestSessionEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestSessionEvent() {}

    template<class OI, class OB> explicit CGuestSessionEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestSessionEvent(const CGuestSessionEvent & that) : Base(that) {}

    template<class OI> explicit CGuestSessionEvent(OI * aIface) { attach(aIface); }

    explicit CGuestSessionEvent(IGuestSessionEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestSessionEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestSessionEvent & operator=(const CGuestSessionEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestSessionEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestSessionEvent & operator=(IGuestSessionEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    CGuestSession GetSession() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestSessionEvent)

#endif /* __CGuestSessionEvent_h__ */


// ##### ENDFILE "CGuestSessionEvent.h"


// ##### BEGINFILE "CGuestSessionStateChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestSessionStateChangedEvent_h__
#define __CGuestSessionStateChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestSessionStateChangedEvent : public CInterface<IGuestSessionStateChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestSessionStateChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestSessionStateChangedEvent() {}

    template<class OI, class OB> explicit CGuestSessionStateChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestSessionStateChangedEvent(const CGuestSessionStateChangedEvent & that) : Base(that) {}

    template<class OI> explicit CGuestSessionStateChangedEvent(OI * aIface) { attach(aIface); }

    explicit CGuestSessionStateChangedEvent(IGuestSessionStateChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestSessionStateChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestSessionStateChangedEvent & operator=(const CGuestSessionStateChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestSessionStateChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestSessionStateChangedEvent & operator=(IGuestSessionStateChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    ULONG GetId() const;
    KGuestSessionStatus GetStatus() const;
    CVirtualBoxErrorInfo GetError() const;

    CGuestSession GetSession() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestSessionStateChangedEvent)

#endif /* __CGuestSessionStateChangedEvent_h__ */


// ##### ENDFILE "CGuestSessionStateChangedEvent.h"


// ##### BEGINFILE "CGuestSessionRegisteredEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestSessionRegisteredEvent_h__
#define __CGuestSessionRegisteredEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestSessionRegisteredEvent : public CInterface<IGuestSessionRegisteredEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestSessionRegisteredEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestSessionRegisteredEvent() {}

    template<class OI, class OB> explicit CGuestSessionRegisteredEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestSessionRegisteredEvent(const CGuestSessionRegisteredEvent & that) : Base(that) {}

    template<class OI> explicit CGuestSessionRegisteredEvent(OI * aIface) { attach(aIface); }

    explicit CGuestSessionRegisteredEvent(IGuestSessionRegisteredEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestSessionRegisteredEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestSessionRegisteredEvent & operator=(const CGuestSessionRegisteredEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestSessionRegisteredEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestSessionRegisteredEvent & operator=(IGuestSessionRegisteredEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    BOOL GetRegistered() const;

    CGuestSession GetSession() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestSessionRegisteredEvent)

#endif /* __CGuestSessionRegisteredEvent_h__ */


// ##### ENDFILE "CGuestSessionRegisteredEvent.h"


// ##### BEGINFILE "CGuestProcessEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestProcessEvent_h__
#define __CGuestProcessEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestProcessEvent : public CInterface<IGuestProcessEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestProcessEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestProcessEvent() {}

    template<class OI, class OB> explicit CGuestProcessEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestProcessEvent(const CGuestProcessEvent & that) : Base(that) {}

    template<class OI> explicit CGuestProcessEvent(OI * aIface) { attach(aIface); }

    explicit CGuestProcessEvent(IGuestProcessEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestProcessEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestProcessEvent & operator=(const CGuestProcessEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestProcessEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestProcessEvent & operator=(IGuestProcessEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    CGuestProcess GetProcess() const;
    ULONG GetPid() const;

    CGuestSession GetSession() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestProcessEvent)

#endif /* __CGuestProcessEvent_h__ */


// ##### ENDFILE "CGuestProcessEvent.h"


// ##### BEGINFILE "CGuestProcessRegisteredEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestProcessRegisteredEvent_h__
#define __CGuestProcessRegisteredEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestProcessRegisteredEvent : public CInterface<IGuestProcessRegisteredEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestProcessRegisteredEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestProcessRegisteredEvent() {}

    template<class OI, class OB> explicit CGuestProcessRegisteredEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestProcessRegisteredEvent(const CGuestProcessRegisteredEvent & that) : Base(that) {}

    template<class OI> explicit CGuestProcessRegisteredEvent(OI * aIface) { attach(aIface); }

    explicit CGuestProcessRegisteredEvent(IGuestProcessRegisteredEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestProcessRegisteredEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestProcessRegisteredEvent & operator=(const CGuestProcessRegisteredEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestProcessRegisteredEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestProcessRegisteredEvent & operator=(IGuestProcessRegisteredEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    BOOL GetRegistered() const;

    CGuestProcess GetProcess() const;
    ULONG GetPid() const;

    CGuestSession GetSession() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestProcessRegisteredEvent)

#endif /* __CGuestProcessRegisteredEvent_h__ */


// ##### ENDFILE "CGuestProcessRegisteredEvent.h"


// ##### BEGINFILE "CGuestProcessStateChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestProcessStateChangedEvent_h__
#define __CGuestProcessStateChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestProcessStateChangedEvent : public CInterface<IGuestProcessStateChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestProcessStateChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestProcessStateChangedEvent() {}

    template<class OI, class OB> explicit CGuestProcessStateChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestProcessStateChangedEvent(const CGuestProcessStateChangedEvent & that) : Base(that) {}

    template<class OI> explicit CGuestProcessStateChangedEvent(OI * aIface) { attach(aIface); }

    explicit CGuestProcessStateChangedEvent(IGuestProcessStateChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestProcessStateChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestProcessStateChangedEvent & operator=(const CGuestProcessStateChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestProcessStateChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestProcessStateChangedEvent & operator=(IGuestProcessStateChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KProcessStatus GetStatus() const;
    CVirtualBoxErrorInfo GetError() const;

    CGuestProcess GetProcess() const;
    ULONG GetPid() const;

    CGuestSession GetSession() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestProcessStateChangedEvent)

#endif /* __CGuestProcessStateChangedEvent_h__ */


// ##### ENDFILE "CGuestProcessStateChangedEvent.h"


// ##### BEGINFILE "CGuestProcessIOEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestProcessIOEvent_h__
#define __CGuestProcessIOEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestProcessIOEvent : public CInterface<IGuestProcessIOEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestProcessIOEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestProcessIOEvent() {}

    template<class OI, class OB> explicit CGuestProcessIOEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestProcessIOEvent(const CGuestProcessIOEvent & that) : Base(that) {}

    template<class OI> explicit CGuestProcessIOEvent(OI * aIface) { attach(aIface); }

    explicit CGuestProcessIOEvent(IGuestProcessIOEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestProcessIOEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestProcessIOEvent & operator=(const CGuestProcessIOEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestProcessIOEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestProcessIOEvent & operator=(IGuestProcessIOEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    ULONG GetHandle() const;
    ULONG GetProcessed() const;

    CGuestProcess GetProcess() const;
    ULONG GetPid() const;

    CGuestSession GetSession() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestProcessIOEvent)

#endif /* __CGuestProcessIOEvent_h__ */


// ##### ENDFILE "CGuestProcessIOEvent.h"


// ##### BEGINFILE "CGuestProcessInputNotifyEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestProcessInputNotifyEvent_h__
#define __CGuestProcessInputNotifyEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestProcessInputNotifyEvent : public CInterface<IGuestProcessInputNotifyEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestProcessInputNotifyEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestProcessInputNotifyEvent() {}

    template<class OI, class OB> explicit CGuestProcessInputNotifyEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestProcessInputNotifyEvent(const CGuestProcessInputNotifyEvent & that) : Base(that) {}

    template<class OI> explicit CGuestProcessInputNotifyEvent(OI * aIface) { attach(aIface); }

    explicit CGuestProcessInputNotifyEvent(IGuestProcessInputNotifyEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestProcessInputNotifyEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestProcessInputNotifyEvent & operator=(const CGuestProcessInputNotifyEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestProcessInputNotifyEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestProcessInputNotifyEvent & operator=(IGuestProcessInputNotifyEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KProcessInputStatus GetStatus() const;

    ULONG GetHandle() const;
    ULONG GetProcessed() const;

    CGuestProcess GetProcess() const;
    ULONG GetPid() const;

    CGuestSession GetSession() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestProcessInputNotifyEvent)

#endif /* __CGuestProcessInputNotifyEvent_h__ */


// ##### ENDFILE "CGuestProcessInputNotifyEvent.h"


// ##### BEGINFILE "CGuestProcessOutputEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestProcessOutputEvent_h__
#define __CGuestProcessOutputEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestProcessOutputEvent : public CInterface<IGuestProcessOutputEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestProcessOutputEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestProcessOutputEvent() {}

    template<class OI, class OB> explicit CGuestProcessOutputEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestProcessOutputEvent(const CGuestProcessOutputEvent & that) : Base(that) {}

    template<class OI> explicit CGuestProcessOutputEvent(OI * aIface) { attach(aIface); }

    explicit CGuestProcessOutputEvent(IGuestProcessOutputEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestProcessOutputEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestProcessOutputEvent & operator=(const CGuestProcessOutputEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestProcessOutputEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestProcessOutputEvent & operator=(IGuestProcessOutputEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QVector<BYTE> GetData() const;

    ULONG GetHandle() const;
    ULONG GetProcessed() const;

    CGuestProcess GetProcess() const;
    ULONG GetPid() const;

    CGuestSession GetSession() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestProcessOutputEvent)

#endif /* __CGuestProcessOutputEvent_h__ */


// ##### ENDFILE "CGuestProcessOutputEvent.h"


// ##### BEGINFILE "CGuestFileEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestFileEvent_h__
#define __CGuestFileEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestFileEvent : public CInterface<IGuestFileEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestFileEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestFileEvent() {}

    template<class OI, class OB> explicit CGuestFileEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestFileEvent(const CGuestFileEvent & that) : Base(that) {}

    template<class OI> explicit CGuestFileEvent(OI * aIface) { attach(aIface); }

    explicit CGuestFileEvent(IGuestFileEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestFileEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestFileEvent & operator=(const CGuestFileEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestFileEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestFileEvent & operator=(IGuestFileEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    CGuestFile GetFile() const;

    CGuestSession GetSession() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestFileEvent)

#endif /* __CGuestFileEvent_h__ */


// ##### ENDFILE "CGuestFileEvent.h"


// ##### BEGINFILE "CGuestFileRegisteredEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestFileRegisteredEvent_h__
#define __CGuestFileRegisteredEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestFileRegisteredEvent : public CInterface<IGuestFileRegisteredEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestFileRegisteredEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestFileRegisteredEvent() {}

    template<class OI, class OB> explicit CGuestFileRegisteredEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestFileRegisteredEvent(const CGuestFileRegisteredEvent & that) : Base(that) {}

    template<class OI> explicit CGuestFileRegisteredEvent(OI * aIface) { attach(aIface); }

    explicit CGuestFileRegisteredEvent(IGuestFileRegisteredEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestFileRegisteredEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestFileRegisteredEvent & operator=(const CGuestFileRegisteredEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestFileRegisteredEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestFileRegisteredEvent & operator=(IGuestFileRegisteredEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    BOOL GetRegistered() const;

    CGuestFile GetFile() const;

    CGuestSession GetSession() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestFileRegisteredEvent)

#endif /* __CGuestFileRegisteredEvent_h__ */


// ##### ENDFILE "CGuestFileRegisteredEvent.h"


// ##### BEGINFILE "CGuestFileStateChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestFileStateChangedEvent_h__
#define __CGuestFileStateChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestFileStateChangedEvent : public CInterface<IGuestFileStateChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestFileStateChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestFileStateChangedEvent() {}

    template<class OI, class OB> explicit CGuestFileStateChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestFileStateChangedEvent(const CGuestFileStateChangedEvent & that) : Base(that) {}

    template<class OI> explicit CGuestFileStateChangedEvent(OI * aIface) { attach(aIface); }

    explicit CGuestFileStateChangedEvent(IGuestFileStateChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestFileStateChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestFileStateChangedEvent & operator=(const CGuestFileStateChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestFileStateChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestFileStateChangedEvent & operator=(IGuestFileStateChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KFileStatus GetStatus() const;
    CVirtualBoxErrorInfo GetError() const;

    CGuestFile GetFile() const;

    CGuestSession GetSession() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestFileStateChangedEvent)

#endif /* __CGuestFileStateChangedEvent_h__ */


// ##### ENDFILE "CGuestFileStateChangedEvent.h"


// ##### BEGINFILE "CGuestFileIOEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestFileIOEvent_h__
#define __CGuestFileIOEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestFileIOEvent : public CInterface<IGuestFileIOEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestFileIOEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestFileIOEvent() {}

    template<class OI, class OB> explicit CGuestFileIOEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestFileIOEvent(const CGuestFileIOEvent & that) : Base(that) {}

    template<class OI> explicit CGuestFileIOEvent(OI * aIface) { attach(aIface); }

    explicit CGuestFileIOEvent(IGuestFileIOEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestFileIOEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestFileIOEvent & operator=(const CGuestFileIOEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestFileIOEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestFileIOEvent & operator=(IGuestFileIOEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    LONG64 GetOffset() const;
    ULONG GetProcessed() const;

    CGuestFile GetFile() const;

    CGuestSession GetSession() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestFileIOEvent)

#endif /* __CGuestFileIOEvent_h__ */


// ##### ENDFILE "CGuestFileIOEvent.h"


// ##### BEGINFILE "CGuestFileOffsetChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestFileOffsetChangedEvent_h__
#define __CGuestFileOffsetChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestFileOffsetChangedEvent : public CInterface<IGuestFileOffsetChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestFileOffsetChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestFileOffsetChangedEvent() {}

    template<class OI, class OB> explicit CGuestFileOffsetChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestFileOffsetChangedEvent(const CGuestFileOffsetChangedEvent & that) : Base(that) {}

    template<class OI> explicit CGuestFileOffsetChangedEvent(OI * aIface) { attach(aIface); }

    explicit CGuestFileOffsetChangedEvent(IGuestFileOffsetChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestFileOffsetChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestFileOffsetChangedEvent & operator=(const CGuestFileOffsetChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestFileOffsetChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestFileOffsetChangedEvent & operator=(IGuestFileOffsetChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    LONG64 GetOffset() const;
    ULONG GetProcessed() const;

    CGuestFile GetFile() const;

    CGuestSession GetSession() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestFileOffsetChangedEvent)

#endif /* __CGuestFileOffsetChangedEvent_h__ */


// ##### ENDFILE "CGuestFileOffsetChangedEvent.h"


// ##### BEGINFILE "CGuestFileReadEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestFileReadEvent_h__
#define __CGuestFileReadEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestFileReadEvent : public CInterface<IGuestFileReadEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestFileReadEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestFileReadEvent() {}

    template<class OI, class OB> explicit CGuestFileReadEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestFileReadEvent(const CGuestFileReadEvent & that) : Base(that) {}

    template<class OI> explicit CGuestFileReadEvent(OI * aIface) { attach(aIface); }

    explicit CGuestFileReadEvent(IGuestFileReadEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestFileReadEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestFileReadEvent & operator=(const CGuestFileReadEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestFileReadEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestFileReadEvent & operator=(IGuestFileReadEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QVector<BYTE> GetData() const;

    LONG64 GetOffset() const;
    ULONG GetProcessed() const;

    CGuestFile GetFile() const;

    CGuestSession GetSession() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestFileReadEvent)

#endif /* __CGuestFileReadEvent_h__ */


// ##### ENDFILE "CGuestFileReadEvent.h"


// ##### BEGINFILE "CGuestFileWriteEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestFileWriteEvent_h__
#define __CGuestFileWriteEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestFileWriteEvent : public CInterface<IGuestFileWriteEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestFileWriteEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestFileWriteEvent() {}

    template<class OI, class OB> explicit CGuestFileWriteEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestFileWriteEvent(const CGuestFileWriteEvent & that) : Base(that) {}

    template<class OI> explicit CGuestFileWriteEvent(OI * aIface) { attach(aIface); }

    explicit CGuestFileWriteEvent(IGuestFileWriteEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestFileWriteEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestFileWriteEvent & operator=(const CGuestFileWriteEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestFileWriteEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestFileWriteEvent & operator=(IGuestFileWriteEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    LONG64 GetOffset() const;
    ULONG GetProcessed() const;

    CGuestFile GetFile() const;

    CGuestSession GetSession() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestFileWriteEvent)

#endif /* __CGuestFileWriteEvent_h__ */


// ##### ENDFILE "CGuestFileWriteEvent.h"


// ##### BEGINFILE "CVRDEServerChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CVRDEServerChangedEvent_h__
#define __CVRDEServerChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CVRDEServerChangedEvent : public CInterface<IVRDEServerChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IVRDEServerChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CVRDEServerChangedEvent() {}

    template<class OI, class OB> explicit CVRDEServerChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CVRDEServerChangedEvent(const CVRDEServerChangedEvent & that) : Base(that) {}

    template<class OI> explicit CVRDEServerChangedEvent(OI * aIface) { attach(aIface); }

    explicit CVRDEServerChangedEvent(IVRDEServerChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CVRDEServerChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CVRDEServerChangedEvent & operator=(const CVRDEServerChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CVRDEServerChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CVRDEServerChangedEvent & operator=(IVRDEServerChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CVRDEServerChangedEvent)

#endif /* __CVRDEServerChangedEvent_h__ */


// ##### ENDFILE "CVRDEServerChangedEvent.h"


// ##### BEGINFILE "CVRDEServerInfoChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CVRDEServerInfoChangedEvent_h__
#define __CVRDEServerInfoChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CVRDEServerInfoChangedEvent : public CInterface<IVRDEServerInfoChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IVRDEServerInfoChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CVRDEServerInfoChangedEvent() {}

    template<class OI, class OB> explicit CVRDEServerInfoChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CVRDEServerInfoChangedEvent(const CVRDEServerInfoChangedEvent & that) : Base(that) {}

    template<class OI> explicit CVRDEServerInfoChangedEvent(OI * aIface) { attach(aIface); }

    explicit CVRDEServerInfoChangedEvent(IVRDEServerInfoChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CVRDEServerInfoChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CVRDEServerInfoChangedEvent & operator=(const CVRDEServerInfoChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CVRDEServerInfoChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CVRDEServerInfoChangedEvent & operator=(IVRDEServerInfoChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CVRDEServerInfoChangedEvent)

#endif /* __CVRDEServerInfoChangedEvent_h__ */


// ##### ENDFILE "CVRDEServerInfoChangedEvent.h"


// ##### BEGINFILE "CVideoCaptureChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CVideoCaptureChangedEvent_h__
#define __CVideoCaptureChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CVideoCaptureChangedEvent : public CInterface<IVideoCaptureChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IVideoCaptureChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CVideoCaptureChangedEvent() {}

    template<class OI, class OB> explicit CVideoCaptureChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CVideoCaptureChangedEvent(const CVideoCaptureChangedEvent & that) : Base(that) {}

    template<class OI> explicit CVideoCaptureChangedEvent(OI * aIface) { attach(aIface); }

    explicit CVideoCaptureChangedEvent(IVideoCaptureChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CVideoCaptureChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CVideoCaptureChangedEvent & operator=(const CVideoCaptureChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CVideoCaptureChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CVideoCaptureChangedEvent & operator=(IVideoCaptureChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CVideoCaptureChangedEvent)

#endif /* __CVideoCaptureChangedEvent_h__ */


// ##### ENDFILE "CVideoCaptureChangedEvent.h"


// ##### BEGINFILE "CUSBControllerChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CUSBControllerChangedEvent_h__
#define __CUSBControllerChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CUSBControllerChangedEvent : public CInterface<IUSBControllerChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IUSBControllerChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CUSBControllerChangedEvent() {}

    template<class OI, class OB> explicit CUSBControllerChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CUSBControllerChangedEvent(const CUSBControllerChangedEvent & that) : Base(that) {}

    template<class OI> explicit CUSBControllerChangedEvent(OI * aIface) { attach(aIface); }

    explicit CUSBControllerChangedEvent(IUSBControllerChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CUSBControllerChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CUSBControllerChangedEvent & operator=(const CUSBControllerChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CUSBControllerChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CUSBControllerChangedEvent & operator=(IUSBControllerChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CUSBControllerChangedEvent)

#endif /* __CUSBControllerChangedEvent_h__ */


// ##### ENDFILE "CUSBControllerChangedEvent.h"


// ##### BEGINFILE "CUSBDeviceStateChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CUSBDeviceStateChangedEvent_h__
#define __CUSBDeviceStateChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CUSBDeviceStateChangedEvent : public CInterface<IUSBDeviceStateChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IUSBDeviceStateChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CUSBDeviceStateChangedEvent() {}

    template<class OI, class OB> explicit CUSBDeviceStateChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CUSBDeviceStateChangedEvent(const CUSBDeviceStateChangedEvent & that) : Base(that) {}

    template<class OI> explicit CUSBDeviceStateChangedEvent(OI * aIface) { attach(aIface); }

    explicit CUSBDeviceStateChangedEvent(IUSBDeviceStateChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CUSBDeviceStateChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CUSBDeviceStateChangedEvent & operator=(const CUSBDeviceStateChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CUSBDeviceStateChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CUSBDeviceStateChangedEvent & operator=(IUSBDeviceStateChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    CUSBDevice GetDevice() const;
    BOOL GetAttached() const;
    CVirtualBoxErrorInfo GetError() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CUSBDeviceStateChangedEvent)

#endif /* __CUSBDeviceStateChangedEvent_h__ */


// ##### ENDFILE "CUSBDeviceStateChangedEvent.h"


// ##### BEGINFILE "CSharedFolderChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CSharedFolderChangedEvent_h__
#define __CSharedFolderChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CSharedFolderChangedEvent : public CInterface<ISharedFolderChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<ISharedFolderChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CSharedFolderChangedEvent() {}

    template<class OI, class OB> explicit CSharedFolderChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CSharedFolderChangedEvent(const CSharedFolderChangedEvent & that) : Base(that) {}

    template<class OI> explicit CSharedFolderChangedEvent(OI * aIface) { attach(aIface); }

    explicit CSharedFolderChangedEvent(ISharedFolderChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CSharedFolderChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CSharedFolderChangedEvent & operator=(const CSharedFolderChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CSharedFolderChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CSharedFolderChangedEvent & operator=(ISharedFolderChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KScope GetScope() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CSharedFolderChangedEvent)

#endif /* __CSharedFolderChangedEvent_h__ */


// ##### ENDFILE "CSharedFolderChangedEvent.h"


// ##### BEGINFILE "CRuntimeErrorEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CRuntimeErrorEvent_h__
#define __CRuntimeErrorEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CRuntimeErrorEvent : public CInterface<IRuntimeErrorEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IRuntimeErrorEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CRuntimeErrorEvent() {}

    template<class OI, class OB> explicit CRuntimeErrorEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CRuntimeErrorEvent(const CRuntimeErrorEvent & that) : Base(that) {}

    template<class OI> explicit CRuntimeErrorEvent(OI * aIface) { attach(aIface); }

    explicit CRuntimeErrorEvent(IRuntimeErrorEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CRuntimeErrorEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CRuntimeErrorEvent & operator=(const CRuntimeErrorEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CRuntimeErrorEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CRuntimeErrorEvent & operator=(IRuntimeErrorEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    BOOL GetFatal() const;
    QString GetId() const;
    QString GetMessage() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CRuntimeErrorEvent)

#endif /* __CRuntimeErrorEvent_h__ */


// ##### ENDFILE "CRuntimeErrorEvent.h"


// ##### BEGINFILE "CEventSourceChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CEventSourceChangedEvent_h__
#define __CEventSourceChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CEventSourceChangedEvent : public CInterface<IEventSourceChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IEventSourceChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CEventSourceChangedEvent() {}

    template<class OI, class OB> explicit CEventSourceChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CEventSourceChangedEvent(const CEventSourceChangedEvent & that) : Base(that) {}

    template<class OI> explicit CEventSourceChangedEvent(OI * aIface) { attach(aIface); }

    explicit CEventSourceChangedEvent(IEventSourceChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CEventSourceChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CEventSourceChangedEvent & operator=(const CEventSourceChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CEventSourceChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CEventSourceChangedEvent & operator=(IEventSourceChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    CEventListener GetListener() const;
    BOOL GetAdd() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CEventSourceChangedEvent)

#endif /* __CEventSourceChangedEvent_h__ */


// ##### ENDFILE "CEventSourceChangedEvent.h"


// ##### BEGINFILE "CExtraDataChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CExtraDataChangedEvent_h__
#define __CExtraDataChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CExtraDataChangedEvent : public CInterface<IExtraDataChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IExtraDataChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CExtraDataChangedEvent() {}

    template<class OI, class OB> explicit CExtraDataChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CExtraDataChangedEvent(const CExtraDataChangedEvent & that) : Base(that) {}

    template<class OI> explicit CExtraDataChangedEvent(OI * aIface) { attach(aIface); }

    explicit CExtraDataChangedEvent(IExtraDataChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CExtraDataChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CExtraDataChangedEvent & operator=(const CExtraDataChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CExtraDataChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CExtraDataChangedEvent & operator=(IExtraDataChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetMachineId() const;
    QString GetKey() const;
    QString GetValue() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CExtraDataChangedEvent)

#endif /* __CExtraDataChangedEvent_h__ */


// ##### ENDFILE "CExtraDataChangedEvent.h"


// ##### BEGINFILE "CVetoEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CVetoEvent_h__
#define __CVetoEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CVetoEvent : public CInterface<IVetoEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IVetoEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CVetoEvent() {}

    template<class OI, class OB> explicit CVetoEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CVetoEvent(const CVetoEvent & that) : Base(that) {}

    template<class OI> explicit CVetoEvent(OI * aIface) { attach(aIface); }

    explicit CVetoEvent(IVetoEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CVetoEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CVetoEvent & operator=(const CVetoEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CVetoEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CVetoEvent & operator=(IVetoEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void AddVeto(const QString & aReason);
    BOOL IsVetoed();
    QVector<QString> GetVetos();

    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CVetoEvent)

#endif /* __CVetoEvent_h__ */


// ##### ENDFILE "CVetoEvent.h"


// ##### BEGINFILE "CExtraDataCanChangeEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CExtraDataCanChangeEvent_h__
#define __CExtraDataCanChangeEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CExtraDataCanChangeEvent : public CInterface<IExtraDataCanChangeEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IExtraDataCanChangeEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CExtraDataCanChangeEvent() {}

    template<class OI, class OB> explicit CExtraDataCanChangeEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CExtraDataCanChangeEvent(const CExtraDataCanChangeEvent & that) : Base(that) {}

    template<class OI> explicit CExtraDataCanChangeEvent(OI * aIface) { attach(aIface); }

    explicit CExtraDataCanChangeEvent(IExtraDataCanChangeEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CExtraDataCanChangeEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CExtraDataCanChangeEvent & operator=(const CExtraDataCanChangeEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CExtraDataCanChangeEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CExtraDataCanChangeEvent & operator=(IExtraDataCanChangeEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetMachineId() const;
    QString GetKey() const;
    QString GetValue() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void AddVeto(const QString & aReason);
    BOOL IsVetoed();
    QVector<QString> GetVetos();

    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CExtraDataCanChangeEvent)

#endif /* __CExtraDataCanChangeEvent_h__ */


// ##### ENDFILE "CExtraDataCanChangeEvent.h"


// ##### BEGINFILE "CCanShowWindowEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CCanShowWindowEvent_h__
#define __CCanShowWindowEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CCanShowWindowEvent : public CInterface<ICanShowWindowEvent, COMBaseWithEI>
{
public:

    typedef CInterface<ICanShowWindowEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CCanShowWindowEvent() {}

    template<class OI, class OB> explicit CCanShowWindowEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CCanShowWindowEvent(const CCanShowWindowEvent & that) : Base(that) {}

    template<class OI> explicit CCanShowWindowEvent(OI * aIface) { attach(aIface); }

    explicit CCanShowWindowEvent(ICanShowWindowEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CCanShowWindowEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CCanShowWindowEvent & operator=(const CCanShowWindowEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CCanShowWindowEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CCanShowWindowEvent & operator=(ICanShowWindowEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void AddVeto(const QString & aReason);
    BOOL IsVetoed();
    QVector<QString> GetVetos();

    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CCanShowWindowEvent)

#endif /* __CCanShowWindowEvent_h__ */


// ##### ENDFILE "CCanShowWindowEvent.h"


// ##### BEGINFILE "CShowWindowEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CShowWindowEvent_h__
#define __CShowWindowEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CShowWindowEvent : public CInterface<IShowWindowEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IShowWindowEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CShowWindowEvent() {}

    template<class OI, class OB> explicit CShowWindowEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CShowWindowEvent(const CShowWindowEvent & that) : Base(that) {}

    template<class OI> explicit CShowWindowEvent(OI * aIface) { attach(aIface); }

    explicit CShowWindowEvent(IShowWindowEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CShowWindowEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CShowWindowEvent & operator=(const CShowWindowEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CShowWindowEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CShowWindowEvent & operator=(IShowWindowEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    LONG64 GetWinId() const;
    void SetWinId(LONG64 aWinId);

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CShowWindowEvent)

#endif /* __CShowWindowEvent_h__ */


// ##### ENDFILE "CShowWindowEvent.h"


// ##### BEGINFILE "CNATRedirectEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CNATRedirectEvent_h__
#define __CNATRedirectEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CNATRedirectEvent : public CInterface<INATRedirectEvent, COMBaseWithEI>
{
public:

    typedef CInterface<INATRedirectEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CNATRedirectEvent() {}

    template<class OI, class OB> explicit CNATRedirectEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CNATRedirectEvent(const CNATRedirectEvent & that) : Base(that) {}

    template<class OI> explicit CNATRedirectEvent(OI * aIface) { attach(aIface); }

    explicit CNATRedirectEvent(INATRedirectEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CNATRedirectEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CNATRedirectEvent & operator=(const CNATRedirectEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CNATRedirectEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CNATRedirectEvent & operator=(INATRedirectEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    ULONG GetSlot() const;
    BOOL GetRemove() const;
    QString GetName() const;
    KNATProtocol GetProto() const;
    QString GetHostIP() const;
    LONG GetHostPort() const;
    QString GetGuestIP() const;
    LONG GetGuestPort() const;

    QString GetMachineId() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CNATRedirectEvent)

#endif /* __CNATRedirectEvent_h__ */


// ##### ENDFILE "CNATRedirectEvent.h"


// ##### BEGINFILE "CHostPCIDevicePlugEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CHostPCIDevicePlugEvent_h__
#define __CHostPCIDevicePlugEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CHostPCIDevicePlugEvent : public CInterface<IHostPCIDevicePlugEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IHostPCIDevicePlugEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CHostPCIDevicePlugEvent() {}

    template<class OI, class OB> explicit CHostPCIDevicePlugEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CHostPCIDevicePlugEvent(const CHostPCIDevicePlugEvent & that) : Base(that) {}

    template<class OI> explicit CHostPCIDevicePlugEvent(OI * aIface) { attach(aIface); }

    explicit CHostPCIDevicePlugEvent(IHostPCIDevicePlugEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CHostPCIDevicePlugEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CHostPCIDevicePlugEvent & operator=(const CHostPCIDevicePlugEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CHostPCIDevicePlugEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CHostPCIDevicePlugEvent & operator=(IHostPCIDevicePlugEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    BOOL GetPlugged() const;
    BOOL GetSuccess() const;
    CPCIDeviceAttachment GetAttachment() const;
    QString GetMessage() const;

    QString GetMachineId() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CHostPCIDevicePlugEvent)

#endif /* __CHostPCIDevicePlugEvent_h__ */


// ##### ENDFILE "CHostPCIDevicePlugEvent.h"


// ##### BEGINFILE "CVBoxSVCAvailabilityChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CVBoxSVCAvailabilityChangedEvent_h__
#define __CVBoxSVCAvailabilityChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CVBoxSVCAvailabilityChangedEvent : public CInterface<IVBoxSVCAvailabilityChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IVBoxSVCAvailabilityChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CVBoxSVCAvailabilityChangedEvent() {}

    template<class OI, class OB> explicit CVBoxSVCAvailabilityChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CVBoxSVCAvailabilityChangedEvent(const CVBoxSVCAvailabilityChangedEvent & that) : Base(that) {}

    template<class OI> explicit CVBoxSVCAvailabilityChangedEvent(OI * aIface) { attach(aIface); }

    explicit CVBoxSVCAvailabilityChangedEvent(IVBoxSVCAvailabilityChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CVBoxSVCAvailabilityChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CVBoxSVCAvailabilityChangedEvent & operator=(const CVBoxSVCAvailabilityChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CVBoxSVCAvailabilityChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CVBoxSVCAvailabilityChangedEvent & operator=(IVBoxSVCAvailabilityChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    BOOL GetAvailable() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CVBoxSVCAvailabilityChangedEvent)

#endif /* __CVBoxSVCAvailabilityChangedEvent_h__ */


// ##### ENDFILE "CVBoxSVCAvailabilityChangedEvent.h"


// ##### BEGINFILE "CBandwidthGroupChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CBandwidthGroupChangedEvent_h__
#define __CBandwidthGroupChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CBandwidthGroupChangedEvent : public CInterface<IBandwidthGroupChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IBandwidthGroupChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CBandwidthGroupChangedEvent() {}

    template<class OI, class OB> explicit CBandwidthGroupChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CBandwidthGroupChangedEvent(const CBandwidthGroupChangedEvent & that) : Base(that) {}

    template<class OI> explicit CBandwidthGroupChangedEvent(OI * aIface) { attach(aIface); }

    explicit CBandwidthGroupChangedEvent(IBandwidthGroupChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CBandwidthGroupChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CBandwidthGroupChangedEvent & operator=(const CBandwidthGroupChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CBandwidthGroupChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CBandwidthGroupChangedEvent & operator=(IBandwidthGroupChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    CBandwidthGroup GetBandwidthGroup() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CBandwidthGroupChangedEvent)

#endif /* __CBandwidthGroupChangedEvent_h__ */


// ##### ENDFILE "CBandwidthGroupChangedEvent.h"


// ##### BEGINFILE "CGuestMonitorChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestMonitorChangedEvent_h__
#define __CGuestMonitorChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestMonitorChangedEvent : public CInterface<IGuestMonitorChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestMonitorChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestMonitorChangedEvent() {}

    template<class OI, class OB> explicit CGuestMonitorChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestMonitorChangedEvent(const CGuestMonitorChangedEvent & that) : Base(that) {}

    template<class OI> explicit CGuestMonitorChangedEvent(OI * aIface) { attach(aIface); }

    explicit CGuestMonitorChangedEvent(IGuestMonitorChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestMonitorChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestMonitorChangedEvent & operator=(const CGuestMonitorChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestMonitorChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestMonitorChangedEvent & operator=(IGuestMonitorChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KGuestMonitorChangedEventType GetChangeType() const;
    ULONG GetScreenId() const;
    ULONG GetOriginX() const;
    ULONG GetOriginY() const;
    ULONG GetWidth() const;
    ULONG GetHeight() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestMonitorChangedEvent)

#endif /* __CGuestMonitorChangedEvent_h__ */


// ##### ENDFILE "CGuestMonitorChangedEvent.h"


// ##### BEGINFILE "CGuestUserStateChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CGuestUserStateChangedEvent_h__
#define __CGuestUserStateChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CGuestUserStateChangedEvent : public CInterface<IGuestUserStateChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IGuestUserStateChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CGuestUserStateChangedEvent() {}

    template<class OI, class OB> explicit CGuestUserStateChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CGuestUserStateChangedEvent(const CGuestUserStateChangedEvent & that) : Base(that) {}

    template<class OI> explicit CGuestUserStateChangedEvent(OI * aIface) { attach(aIface); }

    explicit CGuestUserStateChangedEvent(IGuestUserStateChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CGuestUserStateChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CGuestUserStateChangedEvent & operator=(const CGuestUserStateChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CGuestUserStateChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CGuestUserStateChangedEvent & operator=(IGuestUserStateChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetName() const;
    QString GetDomain() const;
    KGuestUserState GetState() const;
    QString GetStateDetails() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CGuestUserStateChangedEvent)

#endif /* __CGuestUserStateChangedEvent_h__ */


// ##### ENDFILE "CGuestUserStateChangedEvent.h"


// ##### BEGINFILE "CStorageDeviceChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CStorageDeviceChangedEvent_h__
#define __CStorageDeviceChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CStorageDeviceChangedEvent : public CInterface<IStorageDeviceChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IStorageDeviceChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CStorageDeviceChangedEvent() {}

    template<class OI, class OB> explicit CStorageDeviceChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CStorageDeviceChangedEvent(const CStorageDeviceChangedEvent & that) : Base(that) {}

    template<class OI> explicit CStorageDeviceChangedEvent(OI * aIface) { attach(aIface); }

    explicit CStorageDeviceChangedEvent(IStorageDeviceChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CStorageDeviceChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CStorageDeviceChangedEvent & operator=(const CStorageDeviceChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CStorageDeviceChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CStorageDeviceChangedEvent & operator=(IStorageDeviceChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    CMediumAttachment GetStorageDevice() const;
    BOOL GetRemoved() const;
    BOOL GetSilent() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CStorageDeviceChangedEvent)

#endif /* __CStorageDeviceChangedEvent_h__ */


// ##### ENDFILE "CStorageDeviceChangedEvent.h"


// ##### BEGINFILE "CNATNetworkChangedEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CNATNetworkChangedEvent_h__
#define __CNATNetworkChangedEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CNATNetworkChangedEvent : public CInterface<INATNetworkChangedEvent, COMBaseWithEI>
{
public:

    typedef CInterface<INATNetworkChangedEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CNATNetworkChangedEvent() {}

    template<class OI, class OB> explicit CNATNetworkChangedEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CNATNetworkChangedEvent(const CNATNetworkChangedEvent & that) : Base(that) {}

    template<class OI> explicit CNATNetworkChangedEvent(OI * aIface) { attach(aIface); }

    explicit CNATNetworkChangedEvent(INATNetworkChangedEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CNATNetworkChangedEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CNATNetworkChangedEvent & operator=(const CNATNetworkChangedEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CNATNetworkChangedEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CNATNetworkChangedEvent & operator=(INATNetworkChangedEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetNetworkName() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CNATNetworkChangedEvent)

#endif /* __CNATNetworkChangedEvent_h__ */


// ##### ENDFILE "CNATNetworkChangedEvent.h"


// ##### BEGINFILE "CNATNetworkStartStopEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CNATNetworkStartStopEvent_h__
#define __CNATNetworkStartStopEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CNATNetworkStartStopEvent : public CInterface<INATNetworkStartStopEvent, COMBaseWithEI>
{
public:

    typedef CInterface<INATNetworkStartStopEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CNATNetworkStartStopEvent() {}

    template<class OI, class OB> explicit CNATNetworkStartStopEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CNATNetworkStartStopEvent(const CNATNetworkStartStopEvent & that) : Base(that) {}

    template<class OI> explicit CNATNetworkStartStopEvent(OI * aIface) { attach(aIface); }

    explicit CNATNetworkStartStopEvent(INATNetworkStartStopEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CNATNetworkStartStopEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CNATNetworkStartStopEvent & operator=(const CNATNetworkStartStopEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CNATNetworkStartStopEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CNATNetworkStartStopEvent & operator=(INATNetworkStartStopEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    BOOL GetStartEvent() const;

    QString GetNetworkName() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CNATNetworkStartStopEvent)

#endif /* __CNATNetworkStartStopEvent_h__ */


// ##### ENDFILE "CNATNetworkStartStopEvent.h"


// ##### BEGINFILE "CNATNetworkAlterEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CNATNetworkAlterEvent_h__
#define __CNATNetworkAlterEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CNATNetworkAlterEvent : public CInterface<INATNetworkAlterEvent, COMBaseWithEI>
{
public:

    typedef CInterface<INATNetworkAlterEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CNATNetworkAlterEvent() {}

    template<class OI, class OB> explicit CNATNetworkAlterEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CNATNetworkAlterEvent(const CNATNetworkAlterEvent & that) : Base(that) {}

    template<class OI> explicit CNATNetworkAlterEvent(OI * aIface) { attach(aIface); }

    explicit CNATNetworkAlterEvent(INATNetworkAlterEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CNATNetworkAlterEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CNATNetworkAlterEvent & operator=(const CNATNetworkAlterEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CNATNetworkAlterEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CNATNetworkAlterEvent & operator=(INATNetworkAlterEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    QString GetNetworkName() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CNATNetworkAlterEvent)

#endif /* __CNATNetworkAlterEvent_h__ */


// ##### ENDFILE "CNATNetworkAlterEvent.h"


// ##### BEGINFILE "CNATNetworkCreationDeletionEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CNATNetworkCreationDeletionEvent_h__
#define __CNATNetworkCreationDeletionEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CNATNetworkCreationDeletionEvent : public CInterface<INATNetworkCreationDeletionEvent, COMBaseWithEI>
{
public:

    typedef CInterface<INATNetworkCreationDeletionEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CNATNetworkCreationDeletionEvent() {}

    template<class OI, class OB> explicit CNATNetworkCreationDeletionEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CNATNetworkCreationDeletionEvent(const CNATNetworkCreationDeletionEvent & that) : Base(that) {}

    template<class OI> explicit CNATNetworkCreationDeletionEvent(OI * aIface) { attach(aIface); }

    explicit CNATNetworkCreationDeletionEvent(INATNetworkCreationDeletionEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CNATNetworkCreationDeletionEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CNATNetworkCreationDeletionEvent & operator=(const CNATNetworkCreationDeletionEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CNATNetworkCreationDeletionEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CNATNetworkCreationDeletionEvent & operator=(INATNetworkCreationDeletionEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    BOOL GetCreationEvent() const;

    QString GetNetworkName() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CNATNetworkCreationDeletionEvent)

#endif /* __CNATNetworkCreationDeletionEvent_h__ */


// ##### ENDFILE "CNATNetworkCreationDeletionEvent.h"


// ##### BEGINFILE "CNATNetworkSettingEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CNATNetworkSettingEvent_h__
#define __CNATNetworkSettingEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CNATNetworkSettingEvent : public CInterface<INATNetworkSettingEvent, COMBaseWithEI>
{
public:

    typedef CInterface<INATNetworkSettingEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CNATNetworkSettingEvent() {}

    template<class OI, class OB> explicit CNATNetworkSettingEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CNATNetworkSettingEvent(const CNATNetworkSettingEvent & that) : Base(that) {}

    template<class OI> explicit CNATNetworkSettingEvent(OI * aIface) { attach(aIface); }

    explicit CNATNetworkSettingEvent(INATNetworkSettingEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CNATNetworkSettingEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CNATNetworkSettingEvent & operator=(const CNATNetworkSettingEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CNATNetworkSettingEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CNATNetworkSettingEvent & operator=(INATNetworkSettingEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    BOOL GetEnabled() const;
    QString GetNetwork() const;
    QString GetGateway() const;
    BOOL GetAdvertiseDefaultIPv6RouteEnabled() const;
    BOOL GetNeedDhcpServer() const;

    QString GetNetworkName() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CNATNetworkSettingEvent)

#endif /* __CNATNetworkSettingEvent_h__ */


// ##### ENDFILE "CNATNetworkSettingEvent.h"


// ##### BEGINFILE "CNATNetworkPortForwardEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CNATNetworkPortForwardEvent_h__
#define __CNATNetworkPortForwardEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CNATNetworkPortForwardEvent : public CInterface<INATNetworkPortForwardEvent, COMBaseWithEI>
{
public:

    typedef CInterface<INATNetworkPortForwardEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CNATNetworkPortForwardEvent() {}

    template<class OI, class OB> explicit CNATNetworkPortForwardEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CNATNetworkPortForwardEvent(const CNATNetworkPortForwardEvent & that) : Base(that) {}

    template<class OI> explicit CNATNetworkPortForwardEvent(OI * aIface) { attach(aIface); }

    explicit CNATNetworkPortForwardEvent(INATNetworkPortForwardEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CNATNetworkPortForwardEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CNATNetworkPortForwardEvent & operator=(const CNATNetworkPortForwardEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CNATNetworkPortForwardEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CNATNetworkPortForwardEvent & operator=(INATNetworkPortForwardEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    BOOL GetCreate() const;
    BOOL GetIpv6() const;
    QString GetName() const;
    KNATProtocol GetProto() const;
    QString GetHostIp() const;
    LONG GetHostPort() const;
    QString GetGuestIp() const;
    LONG GetGuestPort() const;

    QString GetNetworkName() const;

    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CNATNetworkPortForwardEvent)

#endif /* __CNATNetworkPortForwardEvent_h__ */


// ##### ENDFILE "CNATNetworkPortForwardEvent.h"


// ##### BEGINFILE "CHostNameResolutionConfigurationChangeEvent.h"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrapper declaration for VirtualBox Main API (COM) interface.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

#ifndef __CHostNameResolutionConfigurationChangeEvent_h__
#define __CHostNameResolutionConfigurationChangeEvent_h__

/* GUI includes: */
#include "COMDefs.h"

/* Forward declarations: */
class CVirtualBoxErrorInfo;
class CNATNetwork;
class CDHCPServer;
class CVirtualBox;
class CVFSExplorer;
class CAppliance;
class CVirtualSystemDescription;
class CBIOSSettings;
class CPCIAddress;
class CPCIDeviceAttachment;
class CMachine;
class CEmulatedUSB;
class CVRDEServerInfo;
class CConsole;
class CHostNetworkInterface;
class CHostVideoInputDevice;
class CHost;
class CSystemProperties;
class CGuestOSType;
class CAdditionsFacility;
class CGuestSession;
class CProcess;
class CGuestProcess;
class CDirectory;
class CGuestDirectory;
class CFile;
class CGuestFile;
class CFsObjInfo;
class CGuestFsObjInfo;
class CGuest;
class CProgress;
class CSnapshot;
class CMediumAttachment;
class CMedium;
class CMediumFormat;
class CToken;
class CKeyboard;
class CMouse;
class CFramebuffer;
class CFramebufferOverlay;
class CDisplay;
class CNetworkAdapter;
class CSerialPort;
class CParallelPort;
class CMachineDebugger;
class CUSBDeviceFilters;
class CUSBController;
class CUSBDevice;
class CUSBDeviceFilter;
class CHostUSBDevice;
class CHostUSBDeviceFilter;
class CAudioAdapter;
class CVRDEServer;
class CSharedFolder;
class CSession;
class CStorageController;
class CPerformanceMetric;
class CPerformanceCollector;
class CNATEngine;
class CExtPackPlugIn;
class CExtPackBase;
class CExtPack;
class CExtPackFile;
class CExtPackManager;
class CBandwidthGroup;
class CBandwidthControl;
class CVirtualBoxClient;
class CEventSource;
class CEventListener;
class CEvent;
class CReusableEvent;
class CMachineEvent;
class CMachineStateChangedEvent;
class CMachineDataChangedEvent;
class CMediumRegisteredEvent;
class CMachineRegisteredEvent;
class CSessionStateChangedEvent;
class CGuestPropertyChangedEvent;
class CSnapshotEvent;
class CSnapshotTakenEvent;
class CSnapshotDeletedEvent;
class CSnapshotChangedEvent;
class CMousePointerShapeChangedEvent;
class CMouseCapabilityChangedEvent;
class CKeyboardLedsChangedEvent;
class CStateChangedEvent;
class CAdditionsStateChangedEvent;
class CNetworkAdapterChangedEvent;
class CSerialPortChangedEvent;
class CParallelPortChangedEvent;
class CStorageControllerChangedEvent;
class CMediumChangedEvent;
class CClipboardModeChangedEvent;
class CDragAndDropModeChangedEvent;
class CCPUChangedEvent;
class CCPUExecutionCapChangedEvent;
class CGuestKeyboardEvent;
class CGuestMouseEvent;
class CGuestMultiTouchEvent;
class CGuestSessionEvent;
class CGuestSessionStateChangedEvent;
class CGuestSessionRegisteredEvent;
class CGuestProcessEvent;
class CGuestProcessRegisteredEvent;
class CGuestProcessStateChangedEvent;
class CGuestProcessIOEvent;
class CGuestProcessInputNotifyEvent;
class CGuestProcessOutputEvent;
class CGuestFileEvent;
class CGuestFileRegisteredEvent;
class CGuestFileStateChangedEvent;
class CGuestFileIOEvent;
class CGuestFileOffsetChangedEvent;
class CGuestFileReadEvent;
class CGuestFileWriteEvent;
class CVRDEServerChangedEvent;
class CVRDEServerInfoChangedEvent;
class CVideoCaptureChangedEvent;
class CUSBControllerChangedEvent;
class CUSBDeviceStateChangedEvent;
class CSharedFolderChangedEvent;
class CRuntimeErrorEvent;
class CEventSourceChangedEvent;
class CExtraDataChangedEvent;
class CVetoEvent;
class CExtraDataCanChangeEvent;
class CCanShowWindowEvent;
class CShowWindowEvent;
class CNATRedirectEvent;
class CHostPCIDevicePlugEvent;
class CVBoxSVCAvailabilityChangedEvent;
class CBandwidthGroupChangedEvent;
class CGuestMonitorChangedEvent;
class CGuestUserStateChangedEvent;
class CStorageDeviceChangedEvent;
class CNATNetworkChangedEvent;
class CNATNetworkStartStopEvent;
class CNATNetworkAlterEvent;
class CNATNetworkCreationDeletionEvent;
class CNATNetworkSettingEvent;
class CNATNetworkPortForwardEvent;
class CHostNameResolutionConfigurationChangeEvent;
class CVirtualBox;
class CVirtualBoxClient;
class CSession;

/* Interface declaration: */
class CHostNameResolutionConfigurationChangeEvent : public CInterface<IHostNameResolutionConfigurationChangeEvent, COMBaseWithEI>
{
public:

    typedef CInterface<IHostNameResolutionConfigurationChangeEvent, COMBaseWithEI> Base;

    /* Constructors and assignments taking CUnknown and raw iface pointer: */

    CHostNameResolutionConfigurationChangeEvent() {}

    template<class OI, class OB> explicit CHostNameResolutionConfigurationChangeEvent(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
    }

    CHostNameResolutionConfigurationChangeEvent(const CHostNameResolutionConfigurationChangeEvent & that) : Base(that) {}

    template<class OI> explicit CHostNameResolutionConfigurationChangeEvent(OI * aIface) { attach(aIface); }

    explicit CHostNameResolutionConfigurationChangeEvent(IHostNameResolutionConfigurationChangeEvent * aIface) : Base(aIface) {}

    template<class OI, class OB> CHostNameResolutionConfigurationChangeEvent & operator=(const CInterface<OI, OB> & that)
    {
        attach(that.raw());
        if (SUCCEEDED(mRC))
        {
            mRC = that.lastRC();
            setErrorInfo(that.errorInfo());
        }
        return *this;
    }

    CHostNameResolutionConfigurationChangeEvent & operator=(const CHostNameResolutionConfigurationChangeEvent & that)
    {
        Base::operator=(that);
        return *this;
    }

    template<class OI> CHostNameResolutionConfigurationChangeEvent & operator=(OI * aIface)
    {
        attach(aIface);
        return *this;
    }

    CHostNameResolutionConfigurationChangeEvent & operator=(IHostNameResolutionConfigurationChangeEvent * aIface)
    {
        Base::operator=(aIface);
        return *this;
    }

    /* Attributes (properties): */
    KVBoxEventType GetType() const;
    CEventSource GetSource() const;
    BOOL GetWaitable() const;

    /* Methods: */
    void SetProcessed();
    BOOL WaitProcessed(LONG aTimeout);

    /* Friend wrappers: */
    friend class CUnknown;
};

/* Let QMetaType know about generated interface: */
Q_DECLARE_METATYPE(CHostNameResolutionConfigurationChangeEvent)

#endif /* __CHostNameResolutionConfigurationChangeEvent_h__ */


// ##### ENDFILE "CHostNameResolutionConfigurationChangeEvent.h"


// ##### BEGINFILE "COMWrappers.cpp"
/*
 * DO NOT EDIT! This is a generated file.
 *
 * Qt-based wrappers definitions for VirtualBox Main API (COM) interfaces.
 * Generated from XIDL (XML interface definition).
 *
 * Source    : src/VBox/Main/idl/VirtualBox.xidl
 * Generator : src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl
 */

/* COM includes: */
#include "COMEnums.h"
#include "CVirtualBoxErrorInfo.h"
#include "CNATNetwork.h"
#include "CDHCPServer.h"
#include "CVirtualBox.h"
#include "CVFSExplorer.h"
#include "CAppliance.h"
#include "CVirtualSystemDescription.h"
#include "CBIOSSettings.h"
#include "CPCIAddress.h"
#include "CPCIDeviceAttachment.h"
#include "CMachine.h"
#include "CEmulatedUSB.h"
#include "CVRDEServerInfo.h"
#include "CConsole.h"
#include "CHostNetworkInterface.h"
#include "CHostVideoInputDevice.h"
#include "CHost.h"
#include "CSystemProperties.h"
#include "CGuestOSType.h"
#include "CAdditionsFacility.h"
#include "CGuestSession.h"
#include "CProcess.h"
#include "CGuestProcess.h"
#include "CDirectory.h"
#include "CGuestDirectory.h"
#include "CFile.h"
#include "CGuestFile.h"
#include "CFsObjInfo.h"
#include "CGuestFsObjInfo.h"
#include "CGuest.h"
#include "CProgress.h"
#include "CSnapshot.h"
#include "CMediumAttachment.h"
#include "CMedium.h"
#include "CMediumFormat.h"
#include "CToken.h"
#include "CKeyboard.h"
#include "CMouse.h"
#include "CFramebuffer.h"
#include "CFramebufferOverlay.h"
#include "CDisplay.h"
#include "CNetworkAdapter.h"
#include "CSerialPort.h"
#include "CParallelPort.h"
#include "CMachineDebugger.h"
#include "CUSBDeviceFilters.h"
#include "CUSBController.h"
#include "CUSBDevice.h"
#include "CUSBDeviceFilter.h"
#include "CHostUSBDevice.h"
#include "CHostUSBDeviceFilter.h"
#include "CAudioAdapter.h"
#include "CVRDEServer.h"
#include "CSharedFolder.h"
#include "CSession.h"
#include "CStorageController.h"
#include "CPerformanceMetric.h"
#include "CPerformanceCollector.h"
#include "CNATEngine.h"
#include "CExtPackPlugIn.h"
#include "CExtPackBase.h"
#include "CExtPack.h"
#include "CExtPackFile.h"
#include "CExtPackManager.h"
#include "CBandwidthGroup.h"
#include "CBandwidthControl.h"
#include "CVirtualBoxClient.h"
#include "CEventSource.h"
#include "CEventListener.h"
#include "CEvent.h"
#include "CReusableEvent.h"
#include "CMachineEvent.h"
#include "CMachineStateChangedEvent.h"
#include "CMachineDataChangedEvent.h"
#include "CMediumRegisteredEvent.h"
#include "CMachineRegisteredEvent.h"
#include "CSessionStateChangedEvent.h"
#include "CGuestPropertyChangedEvent.h"
#include "CSnapshotEvent.h"
#include "CSnapshotTakenEvent.h"
#include "CSnapshotDeletedEvent.h"
#include "CSnapshotChangedEvent.h"
#include "CMousePointerShapeChangedEvent.h"
#include "CMouseCapabilityChangedEvent.h"
#include "CKeyboardLedsChangedEvent.h"
#include "CStateChangedEvent.h"
#include "CAdditionsStateChangedEvent.h"
#include "CNetworkAdapterChangedEvent.h"
#include "CSerialPortChangedEvent.h"
#include "CParallelPortChangedEvent.h"
#include "CStorageControllerChangedEvent.h"
#include "CMediumChangedEvent.h"
#include "CClipboardModeChangedEvent.h"
#include "CDragAndDropModeChangedEvent.h"
#include "CCPUChangedEvent.h"
#include "CCPUExecutionCapChangedEvent.h"
#include "CGuestKeyboardEvent.h"
#include "CGuestMouseEvent.h"
#include "CGuestMultiTouchEvent.h"
#include "CGuestSessionEvent.h"
#include "CGuestSessionStateChangedEvent.h"
#include "CGuestSessionRegisteredEvent.h"
#include "CGuestProcessEvent.h"
#include "CGuestProcessRegisteredEvent.h"
#include "CGuestProcessStateChangedEvent.h"
#include "CGuestProcessIOEvent.h"
#include "CGuestProcessInputNotifyEvent.h"
#include "CGuestProcessOutputEvent.h"
#include "CGuestFileEvent.h"
#include "CGuestFileRegisteredEvent.h"
#include "CGuestFileStateChangedEvent.h"
#include "CGuestFileIOEvent.h"
#include "CGuestFileOffsetChangedEvent.h"
#include "CGuestFileReadEvent.h"
#include "CGuestFileWriteEvent.h"
#include "CVRDEServerChangedEvent.h"
#include "CVRDEServerInfoChangedEvent.h"
#include "CVideoCaptureChangedEvent.h"
#include "CUSBControllerChangedEvent.h"
#include "CUSBDeviceStateChangedEvent.h"
#include "CSharedFolderChangedEvent.h"
#include "CRuntimeErrorEvent.h"
#include "CEventSourceChangedEvent.h"
#include "CExtraDataChangedEvent.h"
#include "CVetoEvent.h"
#include "CExtraDataCanChangeEvent.h"
#include "CCanShowWindowEvent.h"
#include "CShowWindowEvent.h"
#include "CNATRedirectEvent.h"
#include "CHostPCIDevicePlugEvent.h"
#include "CVBoxSVCAvailabilityChangedEvent.h"
#include "CBandwidthGroupChangedEvent.h"
#include "CGuestMonitorChangedEvent.h"
#include "CGuestUserStateChangedEvent.h"
#include "CStorageDeviceChangedEvent.h"
#include "CNATNetworkChangedEvent.h"
#include "CNATNetworkStartStopEvent.h"
#include "CNATNetworkAlterEvent.h"
#include "CNATNetworkCreationDeletionEvent.h"
#include "CNATNetworkSettingEvent.h"
#include "CNATNetworkPortForwardEvent.h"
#include "CHostNameResolutionConfigurationChangeEvent.h"

// IVirtualBoxErrorInfo wrapper

LONG CVirtualBoxErrorInfo::GetResultCode() const
{
    LONG aResultCode = 0;
    AssertReturn(ptr(), aResultCode);
    mRC = ptr()->COMGETTER(ResultCode)(&aResultCode);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    return aResultCode;
}

LONG CVirtualBoxErrorInfo::GetResultDetail() const
{
    LONG aResultDetail = 0;
    AssertReturn(ptr(), aResultDetail);
    mRC = ptr()->COMGETTER(ResultDetail)(&aResultDetail);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    return aResultDetail;
}

QString CVirtualBoxErrorInfo::GetInterfaceID() const
{
    QString aInterfaceID;
    AssertReturn(ptr(), aInterfaceID);
    mRC = ptr()->COMGETTER(InterfaceID)(BSTROut(aInterfaceID));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    return aInterfaceID;
}

QString CVirtualBoxErrorInfo::GetComponent() const
{
    QString aComponent;
    AssertReturn(ptr(), aComponent);
    mRC = ptr()->COMGETTER(Component)(BSTROut(aComponent));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    return aComponent;
}

QString CVirtualBoxErrorInfo::GetText() const
{
    QString aText;
    AssertReturn(ptr(), aText);
    mRC = ptr()->COMGETTER(Text)(BSTROut(aText));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    return aText;
}

CVirtualBoxErrorInfo CVirtualBoxErrorInfo::GetNext() const
{
    CVirtualBoxErrorInfo aNext;
    AssertReturn(ptr(), aNext);
    IVirtualBoxErrorInfo* nextPtr = NULL;
    mRC = ptr()->COMGETTER(Next)(&nextPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aNext.setPtr(nextPtr);
    return aNext;
}

// INATNetwork wrapper

QString CNATNetwork::GetNetworkName() const
{
    QString aNetworkName;
    AssertReturn(ptr(), aNetworkName);
    mRC = ptr()->COMGETTER(NetworkName)(BSTROut(aNetworkName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNetworkName;
}
void CNATNetwork::SetNetworkName(const QString & aNetworkName)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(NetworkName)(BSTRIn(aNetworkName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CNATNetwork::GetEnabled() const
{
    BOOL aEnabled = FALSE;
    AssertReturn(ptr(), aEnabled);
    mRC = ptr()->COMGETTER(Enabled)(&aEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEnabled;
}
void CNATNetwork::SetEnabled(BOOL aEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Enabled)(aEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CNATNetwork::GetNetwork() const
{
    QString aNetwork;
    AssertReturn(ptr(), aNetwork);
    mRC = ptr()->COMGETTER(Network)(BSTROut(aNetwork));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNetwork;
}
void CNATNetwork::SetNetwork(const QString & aNetwork)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Network)(BSTRIn(aNetwork));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CNATNetwork::GetGateway() const
{
    QString aGateway;
    AssertReturn(ptr(), aGateway);
    mRC = ptr()->COMGETTER(Gateway)(BSTROut(aGateway));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGateway;
}

BOOL CNATNetwork::GetIPv6Enabled() const
{
    BOOL aIPv6Enabled = FALSE;
    AssertReturn(ptr(), aIPv6Enabled);
    mRC = ptr()->COMGETTER(IPv6Enabled)(&aIPv6Enabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aIPv6Enabled;
}
void CNATNetwork::SetIPv6Enabled(BOOL aIPv6Enabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(IPv6Enabled)(aIPv6Enabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CNATNetwork::GetIPv6Prefix() const
{
    QString aIPv6Prefix;
    AssertReturn(ptr(), aIPv6Prefix);
    mRC = ptr()->COMGETTER(IPv6Prefix)(BSTROut(aIPv6Prefix));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aIPv6Prefix;
}
void CNATNetwork::SetIPv6Prefix(const QString & aIPv6Prefix)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(IPv6Prefix)(BSTRIn(aIPv6Prefix));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CNATNetwork::GetAdvertiseDefaultIPv6RouteEnabled() const
{
    BOOL aAdvertiseDefaultIPv6RouteEnabled = FALSE;
    AssertReturn(ptr(), aAdvertiseDefaultIPv6RouteEnabled);
    mRC = ptr()->COMGETTER(AdvertiseDefaultIPv6RouteEnabled)(&aAdvertiseDefaultIPv6RouteEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAdvertiseDefaultIPv6RouteEnabled;
}
void CNATNetwork::SetAdvertiseDefaultIPv6RouteEnabled(BOOL aAdvertiseDefaultIPv6RouteEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(AdvertiseDefaultIPv6RouteEnabled)(aAdvertiseDefaultIPv6RouteEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CNATNetwork::GetNeedDhcpServer() const
{
    BOOL aNeedDhcpServer = FALSE;
    AssertReturn(ptr(), aNeedDhcpServer);
    mRC = ptr()->COMGETTER(NeedDhcpServer)(&aNeedDhcpServer);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNeedDhcpServer;
}
void CNATNetwork::SetNeedDhcpServer(BOOL aNeedDhcpServer)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(NeedDhcpServer)(aNeedDhcpServer);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CEventSource CNATNetwork::GetEventSource() const
{
    CEventSource aEventSource;
    AssertReturn(ptr(), aEventSource);
    IEventSource* eventSourcePtr = NULL;
    mRC = ptr()->COMGETTER(EventSource)(&eventSourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aEventSource.setPtr(eventSourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEventSource;
}

QVector<QString> CNATNetwork::GetPortForwardRules4() const
{
    QVector<QString> aPortForwardRules4;
    AssertReturn(ptr(), aPortForwardRules4);
    com::SafeArray <BSTR> portForwardRules4;
    mRC = ptr()->COMGETTER(PortForwardRules4)(ComSafeArrayAsOutParam(portForwardRules4));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(portForwardRules4, aPortForwardRules4);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPortForwardRules4;
}

QVector<QString> CNATNetwork::GetLocalMappings() const
{
    QVector<QString> aLocalMappings;
    AssertReturn(ptr(), aLocalMappings);
    com::SafeArray <BSTR> localMappings;
    mRC = ptr()->COMGETTER(LocalMappings)(ComSafeArrayAsOutParam(localMappings));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(localMappings, aLocalMappings);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLocalMappings;
}

LONG CNATNetwork::GetLoopbackIp6() const
{
    LONG aLoopbackIp6 = 0;
    AssertReturn(ptr(), aLoopbackIp6);
    mRC = ptr()->COMGETTER(LoopbackIp6)(&aLoopbackIp6);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLoopbackIp6;
}
void CNATNetwork::SetLoopbackIp6(LONG aLoopbackIp6)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(LoopbackIp6)(aLoopbackIp6);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QVector<QString> CNATNetwork::GetPortForwardRules6() const
{
    QVector<QString> aPortForwardRules6;
    AssertReturn(ptr(), aPortForwardRules6);
    com::SafeArray <BSTR> portForwardRules6;
    mRC = ptr()->COMGETTER(PortForwardRules6)(ComSafeArrayAsOutParam(portForwardRules6));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(portForwardRules6, aPortForwardRules6);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPortForwardRules6;
}

void CNATNetwork::AddLocalMapping(const QString & aHostid, LONG aOffset)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->AddLocalMapping(BSTRIn(aHostid), aOffset);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CNATNetwork::AddPortForwardRule(BOOL aIsIpv6, const QString & aRuleName, const KNATProtocol & aProto, const QString & aHostIP, USHORT aHostPort, const QString & aGuestIP, USHORT aGuestPort)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->AddPortForwardRule(aIsIpv6, BSTRIn(aRuleName), (NATProtocol_T) aProto, BSTRIn(aHostIP), aHostPort, BSTRIn(aGuestIP), aGuestPort);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CNATNetwork::RemovePortForwardRule(BOOL aISipv6, const QString & aRuleName)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->RemovePortForwardRule(aISipv6, BSTRIn(aRuleName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CNATNetwork::Start(const QString & aTrunkType)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Start(BSTRIn(aTrunkType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CNATNetwork::Stop()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Stop();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IDHCPServer wrapper

CEventSource CDHCPServer::GetEventSource() const
{
    CEventSource aEventSource;
    AssertReturn(ptr(), aEventSource);
    IEventSource* eventSourcePtr = NULL;
    mRC = ptr()->COMGETTER(EventSource)(&eventSourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aEventSource.setPtr(eventSourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEventSource;
}

BOOL CDHCPServer::GetEnabled() const
{
    BOOL aEnabled = FALSE;
    AssertReturn(ptr(), aEnabled);
    mRC = ptr()->COMGETTER(Enabled)(&aEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEnabled;
}
void CDHCPServer::SetEnabled(BOOL aEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Enabled)(aEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CDHCPServer::GetIPAddress() const
{
    QString aIPAddress;
    AssertReturn(ptr(), aIPAddress);
    mRC = ptr()->COMGETTER(IPAddress)(BSTROut(aIPAddress));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aIPAddress;
}

QString CDHCPServer::GetNetworkMask() const
{
    QString aNetworkMask;
    AssertReturn(ptr(), aNetworkMask);
    mRC = ptr()->COMGETTER(NetworkMask)(BSTROut(aNetworkMask));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNetworkMask;
}

QString CDHCPServer::GetNetworkName() const
{
    QString aNetworkName;
    AssertReturn(ptr(), aNetworkName);
    mRC = ptr()->COMGETTER(NetworkName)(BSTROut(aNetworkName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNetworkName;
}

QString CDHCPServer::GetLowerIP() const
{
    QString aLowerIP;
    AssertReturn(ptr(), aLowerIP);
    mRC = ptr()->COMGETTER(LowerIP)(BSTROut(aLowerIP));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLowerIP;
}

QString CDHCPServer::GetUpperIP() const
{
    QString aUpperIP;
    AssertReturn(ptr(), aUpperIP);
    mRC = ptr()->COMGETTER(UpperIP)(BSTROut(aUpperIP));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUpperIP;
}

QVector<QString> CDHCPServer::GetGlobalOptions() const
{
    QVector<QString> aGlobalOptions;
    AssertReturn(ptr(), aGlobalOptions);
    com::SafeArray <BSTR> globalOptions;
    mRC = ptr()->COMGETTER(GlobalOptions)(ComSafeArrayAsOutParam(globalOptions));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(globalOptions, aGlobalOptions);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGlobalOptions;
}

QVector<QString> CDHCPServer::GetVmConfigs() const
{
    QVector<QString> aVmConfigs;
    AssertReturn(ptr(), aVmConfigs);
    com::SafeArray <BSTR> vmConfigs;
    mRC = ptr()->COMGETTER(VmConfigs)(ComSafeArrayAsOutParam(vmConfigs));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(vmConfigs, aVmConfigs);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVmConfigs;
}

void CDHCPServer::AddGlobalOption(const KDhcpOpt & aOption, const QString & aValue)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->AddGlobalOption((DhcpOpt_T) aOption, BSTRIn(aValue));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CDHCPServer::AddVmSlotOption(const QString & aVmname, LONG aSlot, const KDhcpOpt & aOption, const QString & aValue)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->AddVmSlotOption(BSTRIn(aVmname), aSlot, (DhcpOpt_T) aOption, BSTRIn(aValue));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CDHCPServer::RemoveVmSlotOptions(const QString & aVmname, LONG aSlot)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->RemoveVmSlotOptions(BSTRIn(aVmname), aSlot);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QVector<QString> CDHCPServer::GetVmSlotOptions(const QString & aVmname, LONG aSlot)
{
    QVector<QString> aOption;
    AssertReturn(ptr(), aOption);
    com::SafeArray <BSTR> option;
    mRC = ptr()->GetVmSlotOptions(BSTRIn(aVmname), aSlot, ComSafeArrayAsOutParam(option));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(option, aOption);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOption;
}

QVector<QString> CDHCPServer::GetMacOptions(const QString & aMac)
{
    QVector<QString> aOption;
    AssertReturn(ptr(), aOption);
    com::SafeArray <BSTR> option;
    mRC = ptr()->GetMacOptions(BSTRIn(aMac), ComSafeArrayAsOutParam(option));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(option, aOption);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOption;
}

void CDHCPServer::SetConfiguration(const QString & aIPAddress, const QString & aNetworkMask, const QString & aFromIPAddress, const QString & aToIPAddress)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetConfiguration(BSTRIn(aIPAddress), BSTRIn(aNetworkMask), BSTRIn(aFromIPAddress), BSTRIn(aToIPAddress));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CDHCPServer::Start(const QString & aNetworkName, const QString & aTrunkName, const QString & aTrunkType)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Start(BSTRIn(aNetworkName), BSTRIn(aTrunkName), BSTRIn(aTrunkType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CDHCPServer::Stop()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Stop();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IVirtualBox wrapper

QString CVirtualBox::GetVersion() const
{
    QString aVersion;
    AssertReturn(ptr(), aVersion);
    mRC = ptr()->COMGETTER(Version)(BSTROut(aVersion));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVersion;
}

QString CVirtualBox::GetVersionNormalized() const
{
    QString aVersionNormalized;
    AssertReturn(ptr(), aVersionNormalized);
    mRC = ptr()->COMGETTER(VersionNormalized)(BSTROut(aVersionNormalized));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVersionNormalized;
}

ULONG CVirtualBox::GetRevision() const
{
    ULONG aRevision = 0;
    AssertReturn(ptr(), aRevision);
    mRC = ptr()->COMGETTER(Revision)(&aRevision);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRevision;
}

QString CVirtualBox::GetPackageType() const
{
    QString aPackageType;
    AssertReturn(ptr(), aPackageType);
    mRC = ptr()->COMGETTER(PackageType)(BSTROut(aPackageType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPackageType;
}

QString CVirtualBox::GetAPIVersion() const
{
    QString aAPIVersion;
    AssertReturn(ptr(), aAPIVersion);
    mRC = ptr()->COMGETTER(APIVersion)(BSTROut(aAPIVersion));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAPIVersion;
}

QString CVirtualBox::GetHomeFolder() const
{
    QString aHomeFolder;
    AssertReturn(ptr(), aHomeFolder);
    mRC = ptr()->COMGETTER(HomeFolder)(BSTROut(aHomeFolder));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHomeFolder;
}

QString CVirtualBox::GetSettingsFilePath() const
{
    QString aSettingsFilePath;
    AssertReturn(ptr(), aSettingsFilePath);
    mRC = ptr()->COMGETTER(SettingsFilePath)(BSTROut(aSettingsFilePath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSettingsFilePath;
}

CHost CVirtualBox::GetHost() const
{
    CHost aHost;
    AssertReturn(ptr(), aHost);
    IHost* hostPtr = NULL;
    mRC = ptr()->COMGETTER(Host)(&hostPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aHost.setPtr(hostPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHost;
}

CSystemProperties CVirtualBox::GetSystemProperties() const
{
    CSystemProperties aSystemProperties;
    AssertReturn(ptr(), aSystemProperties);
    ISystemProperties* systemPropertiesPtr = NULL;
    mRC = ptr()->COMGETTER(SystemProperties)(&systemPropertiesPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSystemProperties.setPtr(systemPropertiesPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSystemProperties;
}

QVector<CMachine> CVirtualBox::GetMachines() const
{
    QVector<CMachine> aMachines;
    AssertReturn(ptr(), aMachines);
    com::SafeIfaceArray <IMachine> machines;
    mRC = ptr()->COMGETTER(Machines)(ComSafeArrayAsOutParam(machines));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(machines, aMachines);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachines;
}

QVector<QString> CVirtualBox::GetMachineGroups() const
{
    QVector<QString> aMachineGroups;
    AssertReturn(ptr(), aMachineGroups);
    com::SafeArray <BSTR> machineGroups;
    mRC = ptr()->COMGETTER(MachineGroups)(ComSafeArrayAsOutParam(machineGroups));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(machineGroups, aMachineGroups);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachineGroups;
}

QVector<CMedium> CVirtualBox::GetHardDisks() const
{
    QVector<CMedium> aHardDisks;
    AssertReturn(ptr(), aHardDisks);
    com::SafeIfaceArray <IMedium> hardDisks;
    mRC = ptr()->COMGETTER(HardDisks)(ComSafeArrayAsOutParam(hardDisks));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(hardDisks, aHardDisks);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHardDisks;
}

QVector<CMedium> CVirtualBox::GetDVDImages() const
{
    QVector<CMedium> aDVDImages;
    AssertReturn(ptr(), aDVDImages);
    com::SafeIfaceArray <IMedium> DVDImages;
    mRC = ptr()->COMGETTER(DVDImages)(ComSafeArrayAsOutParam(DVDImages));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(DVDImages, aDVDImages);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDVDImages;
}

QVector<CMedium> CVirtualBox::GetFloppyImages() const
{
    QVector<CMedium> aFloppyImages;
    AssertReturn(ptr(), aFloppyImages);
    com::SafeIfaceArray <IMedium> floppyImages;
    mRC = ptr()->COMGETTER(FloppyImages)(ComSafeArrayAsOutParam(floppyImages));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(floppyImages, aFloppyImages);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFloppyImages;
}

QVector<CProgress> CVirtualBox::GetProgressOperations() const
{
    QVector<CProgress> aProgressOperations;
    AssertReturn(ptr(), aProgressOperations);
    com::SafeIfaceArray <IProgress> progressOperations;
    mRC = ptr()->COMGETTER(ProgressOperations)(ComSafeArrayAsOutParam(progressOperations));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(progressOperations, aProgressOperations);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgressOperations;
}

QVector<CGuestOSType> CVirtualBox::GetGuestOSTypes() const
{
    QVector<CGuestOSType> aGuestOSTypes;
    AssertReturn(ptr(), aGuestOSTypes);
    com::SafeIfaceArray <IGuestOSType> guestOSTypes;
    mRC = ptr()->COMGETTER(GuestOSTypes)(ComSafeArrayAsOutParam(guestOSTypes));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(guestOSTypes, aGuestOSTypes);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGuestOSTypes;
}

QVector<CSharedFolder> CVirtualBox::GetSharedFolders() const
{
    QVector<CSharedFolder> aSharedFolders;
    AssertReturn(ptr(), aSharedFolders);
    com::SafeIfaceArray <ISharedFolder> sharedFolders;
    mRC = ptr()->COMGETTER(SharedFolders)(ComSafeArrayAsOutParam(sharedFolders));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(sharedFolders, aSharedFolders);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSharedFolders;
}

CPerformanceCollector CVirtualBox::GetPerformanceCollector() const
{
    CPerformanceCollector aPerformanceCollector;
    AssertReturn(ptr(), aPerformanceCollector);
    IPerformanceCollector* performanceCollectorPtr = NULL;
    mRC = ptr()->COMGETTER(PerformanceCollector)(&performanceCollectorPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aPerformanceCollector.setPtr(performanceCollectorPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPerformanceCollector;
}

QVector<CDHCPServer> CVirtualBox::GetDHCPServers() const
{
    QVector<CDHCPServer> aDHCPServers;
    AssertReturn(ptr(), aDHCPServers);
    com::SafeIfaceArray <IDHCPServer> DHCPServers;
    mRC = ptr()->COMGETTER(DHCPServers)(ComSafeArrayAsOutParam(DHCPServers));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(DHCPServers, aDHCPServers);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDHCPServers;
}

QVector<CNATNetwork> CVirtualBox::GetNATNetworks() const
{
    QVector<CNATNetwork> aNATNetworks;
    AssertReturn(ptr(), aNATNetworks);
    com::SafeIfaceArray <INATNetwork> NATNetworks;
    mRC = ptr()->COMGETTER(NATNetworks)(ComSafeArrayAsOutParam(NATNetworks));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(NATNetworks, aNATNetworks);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNATNetworks;
}

CEventSource CVirtualBox::GetEventSource() const
{
    CEventSource aEventSource;
    AssertReturn(ptr(), aEventSource);
    IEventSource* eventSourcePtr = NULL;
    mRC = ptr()->COMGETTER(EventSource)(&eventSourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aEventSource.setPtr(eventSourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEventSource;
}

CExtPackManager CVirtualBox::GetExtensionPackManager() const
{
    CExtPackManager aExtensionPackManager;
    AssertReturn(ptr(), aExtensionPackManager);
    IExtPackManager* extensionPackManagerPtr = NULL;
    mRC = ptr()->COMGETTER(ExtensionPackManager)(&extensionPackManagerPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aExtensionPackManager.setPtr(extensionPackManagerPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aExtensionPackManager;
}

QVector<QString> CVirtualBox::GetInternalNetworks() const
{
    QVector<QString> aInternalNetworks;
    AssertReturn(ptr(), aInternalNetworks);
    com::SafeArray <BSTR> internalNetworks;
    mRC = ptr()->COMGETTER(InternalNetworks)(ComSafeArrayAsOutParam(internalNetworks));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(internalNetworks, aInternalNetworks);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aInternalNetworks;
}

QVector<QString> CVirtualBox::GetGenericNetworkDrivers() const
{
    QVector<QString> aGenericNetworkDrivers;
    AssertReturn(ptr(), aGenericNetworkDrivers);
    com::SafeArray <BSTR> genericNetworkDrivers;
    mRC = ptr()->COMGETTER(GenericNetworkDrivers)(ComSafeArrayAsOutParam(genericNetworkDrivers));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(genericNetworkDrivers, aGenericNetworkDrivers);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGenericNetworkDrivers;
}

QString CVirtualBox::ComposeMachineFilename(const QString & aName, const QString & aGroup, const QString & aCreateFlags, const QString & aBaseFolder)
{
    QString aFile;
    AssertReturn(ptr(), aFile);
    mRC = ptr()->ComposeMachineFilename(BSTRIn(aName), BSTRIn(aGroup), BSTRIn(aCreateFlags), BSTRIn(aBaseFolder), BSTROut(aFile));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFile;
}

CMachine CVirtualBox::CreateMachine(const QString & aSettingsFile, const QString & aName, const QVector<QString> & aGroups, const QString & aOsTypeId, const QString & aFlags)
{
    CMachine aMachine;
    AssertReturn(ptr(), aMachine);
    com::SafeArray <BSTR> groups;
    ToSafeArray(aGroups, groups);
    IMachine* machinePtr = NULL;
    mRC = ptr()->CreateMachine(BSTRIn(aSettingsFile), BSTRIn(aName), ComSafeArrayAsInParam(groups), BSTRIn(aOsTypeId), BSTRIn(aFlags), &machinePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aMachine.setPtr(machinePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachine;
}

CMachine CVirtualBox::OpenMachine(const QString & aSettingsFile)
{
    CMachine aMachine;
    AssertReturn(ptr(), aMachine);
    IMachine* machinePtr = NULL;
    mRC = ptr()->OpenMachine(BSTRIn(aSettingsFile), &machinePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aMachine.setPtr(machinePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachine;
}

void CVirtualBox::RegisterMachine(const CMachine & aMachine)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->RegisterMachine(aMachine.ptr());
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CMachine CVirtualBox::FindMachine(const QString & aNameOrId)
{
    CMachine aMachine;
    AssertReturn(ptr(), aMachine);
    IMachine* machinePtr = NULL;
    mRC = ptr()->FindMachine(BSTRIn(aNameOrId), &machinePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aMachine.setPtr(machinePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachine;
}

QVector<CMachine> CVirtualBox::GetMachinesByGroups(const QVector<QString> & aGroups)
{
    QVector<CMachine> aMachines;
    AssertReturn(ptr(), aMachines);
    com::SafeArray <BSTR> groups;
    ToSafeArray(aGroups, groups);
    com::SafeIfaceArray <IMachine> machines;
    mRC = ptr()->GetMachinesByGroups(ComSafeArrayAsInParam(groups), ComSafeArrayAsOutParam(machines));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(machines, aMachines);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachines;
}

QVector<KMachineState> CVirtualBox::GetMachineStates(const QVector<CMachine> & aMachines)
{
    QVector<KMachineState> aStates;
    AssertReturn(ptr(), aStates);
    com::SafeIfaceArray <IMachine> machines;
    ToSafeIfaceArray(aMachines, machines);
    com::SafeArray <MachineState_T> states;
    mRC = ptr()->GetMachineStates(ComSafeArrayAsInParam(machines), ComSafeArrayAsOutParam(states));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(states, aStates);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStates;
}

CAppliance CVirtualBox::CreateAppliance()
{
    CAppliance aAppliance;
    AssertReturn(ptr(), aAppliance);
    IAppliance* appliancePtr = NULL;
    mRC = ptr()->CreateAppliance(&appliancePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aAppliance.setPtr(appliancePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAppliance;
}

CMedium CVirtualBox::CreateHardDisk(const QString & aFormat, const QString & aLocation)
{
    CMedium aMedium;
    AssertReturn(ptr(), aMedium);
    IMedium* mediumPtr = NULL;
    mRC = ptr()->CreateHardDisk(BSTRIn(aFormat), BSTRIn(aLocation), &mediumPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aMedium.setPtr(mediumPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMedium;
}

CMedium CVirtualBox::OpenMedium(const QString & aLocation, const KDeviceType & aDeviceType, const KAccessMode & aAccessMode, BOOL aForceNewUuid)
{
    CMedium aMedium;
    AssertReturn(ptr(), aMedium);
    IMedium* mediumPtr = NULL;
    mRC = ptr()->OpenMedium(BSTRIn(aLocation), (DeviceType_T) aDeviceType, (AccessMode_T) aAccessMode, aForceNewUuid, &mediumPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aMedium.setPtr(mediumPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMedium;
}

CGuestOSType CVirtualBox::GetGuestOSType(QString aId)
{
    CGuestOSType aType;
    AssertReturn(ptr(), aType);
    IGuestOSType* typePtr = NULL;
    mRC = ptr()->GetGuestOSType(BSTRIn(aId), &typePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aType.setPtr(typePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

void CVirtualBox::CreateSharedFolder(const QString & aName, const QString & aHostPath, BOOL aWritable, BOOL aAutomount)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->CreateSharedFolder(BSTRIn(aName), BSTRIn(aHostPath), aWritable, aAutomount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CVirtualBox::RemoveSharedFolder(const QString & aName)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->RemoveSharedFolder(BSTRIn(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QVector<QString> CVirtualBox::GetExtraDataKeys()
{
    QVector<QString> aKeys;
    AssertReturn(ptr(), aKeys);
    com::SafeArray <BSTR> keys;
    mRC = ptr()->GetExtraDataKeys(ComSafeArrayAsOutParam(keys));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(keys, aKeys);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aKeys;
}

QString CVirtualBox::GetExtraData(const QString & aKey)
{
    QString aValue;
    AssertReturn(ptr(), aValue);
    mRC = ptr()->GetExtraData(BSTRIn(aKey), BSTROut(aValue));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aValue;
}

void CVirtualBox::SetExtraData(const QString & aKey, const QString & aValue)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetExtraData(BSTRIn(aKey), BSTRIn(aValue));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CVirtualBox::SetSettingsSecret(const QString & aPassword)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetSettingsSecret(BSTRIn(aPassword));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CDHCPServer CVirtualBox::CreateDHCPServer(const QString & aName)
{
    CDHCPServer aServer;
    AssertReturn(ptr(), aServer);
    IDHCPServer* serverPtr = NULL;
    mRC = ptr()->CreateDHCPServer(BSTRIn(aName), &serverPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aServer.setPtr(serverPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aServer;
}

CDHCPServer CVirtualBox::FindDHCPServerByNetworkName(const QString & aName)
{
    CDHCPServer aServer;
    AssertReturn(ptr(), aServer);
    IDHCPServer* serverPtr = NULL;
    mRC = ptr()->FindDHCPServerByNetworkName(BSTRIn(aName), &serverPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aServer.setPtr(serverPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aServer;
}

void CVirtualBox::RemoveDHCPServer(const CDHCPServer & aServer)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->RemoveDHCPServer(aServer.ptr());
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CNATNetwork CVirtualBox::CreateNATNetwork(const QString & aNetworkName)
{
    CNATNetwork aNetwork;
    AssertReturn(ptr(), aNetwork);
    INATNetwork* networkPtr = NULL;
    mRC = ptr()->CreateNATNetwork(BSTRIn(aNetworkName), &networkPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aNetwork.setPtr(networkPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNetwork;
}

CNATNetwork CVirtualBox::FindNATNetworkByName(const QString & aNetworkName)
{
    CNATNetwork aNetwork;
    AssertReturn(ptr(), aNetwork);
    INATNetwork* networkPtr = NULL;
    mRC = ptr()->FindNATNetworkByName(BSTRIn(aNetworkName), &networkPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aNetwork.setPtr(networkPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNetwork;
}

void CVirtualBox::RemoveNATNetwork(const CNATNetwork & aNetwork)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->RemoveNATNetwork(aNetwork.ptr());
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CVirtualBox::CheckFirmwarePresent(const KFirmwareType & aFirmwareType, const QString & aVersion, QString & aUrl, QString & aFile)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->CheckFirmwarePresent((FirmwareType_T) aFirmwareType, BSTRIn(aVersion), BSTROut(aUrl), BSTROut(aFile), &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

/* ExtraData helpers: */
void CVirtualBox::SetExtraDataBool(const QString &strKey, bool fValue)
{
    SetExtraData(strKey, fValue == true ? "true" : "false");
}

bool CVirtualBox::GetExtraDataBool(const QString &strKey, bool fDef /* = true */)
{
    bool fResult = fDef;
    QString value = GetExtraData(strKey);
    if (   value == "true"
        || value == "on"
        || value == "yes")
        fResult = true;
    else if (   value == "false"
             || value == "off"
             || value == "no")
             fResult = false;
    return fResult;
}

void CVirtualBox::SetExtraDataInt(const QString &strKey, int value)
{
    SetExtraData(strKey, QString::number(value));
}

int CVirtualBox::GetExtraDataInt(const QString &strKey, int def /* = 0 */)
{
    QString value = GetExtraData(strKey);
    bool fOk;
    int result = value.toInt(&fOk);
    if (fOk)
        return result;
    return def;
}

void CVirtualBox::SetExtraDataRect(const QString &strKey, const QRect &value)
{
    SetExtraData(strKey, QString("%1,%2,%3,%4")
                         .arg(value.x())
                         .arg(value.y())
                         .arg(value.width())
                         .arg(value.height()));
}

QRect CVirtualBox::GetExtraDataRect(const QString &strKey, const QRect &def /* = QRect() */)
{
    QRect result = def;
    QList<int> intList = GetExtraDataIntList(strKey);
    if (intList.size() == 4)
    {
        result.setRect(intList.at(0),
                       intList.at(1),
                       intList.at(2),
                       intList.at(3));
    }
    return result;
}

void CVirtualBox::SetExtraDataStringList(const QString &strKey, const QStringList &value)
{
    SetExtraData(strKey, value.join(","));
}

QStringList CVirtualBox::GetExtraDataStringList(const QString &strKey, QStringList def /* = QStringList() */)
{
    QString strValue = GetExtraData(strKey);
    if (strValue.isEmpty())
        return def;
    else
        return strValue.split(",");
}

void CVirtualBox::SetExtraDataIntList(const QString &strKey, const QList<int> &value)
{
    QStringList strList;
    for (int i=0; i < value.size(); ++i)
        strList << QString::number(value.at(i));
    SetExtraDataStringList(strKey, strList);
}

QList<int> CVirtualBox::GetExtraDataIntList(const QString &strKey, QList<int> def /* = QList<int>() */)
{
    QStringList strList = GetExtraDataStringList(strKey);
    if (strList.size() > 0)
    {
        QList<int> intList;
        bool fOk;
        for (int i=0; i < strList.size(); ++i)
        {
            intList << strList.at(i).toInt(&fOk);
            if (!fOk)
                return def;
        }
        return intList;
    }
    return def;
}

// IVFSExplorer wrapper

QString CVFSExplorer::GetPath() const
{
    QString aPath;
    AssertReturn(ptr(), aPath);
    mRC = ptr()->COMGETTER(Path)(BSTROut(aPath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPath;
}

KVFSType CVFSExplorer::GetType() const
{
    KVFSType aType = (KVFSType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVFSType, VFSType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CProgress CVFSExplorer::Update()
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->Update(&progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CProgress CVFSExplorer::Cd(const QString & aDir)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->Cd(BSTRIn(aDir), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CProgress CVFSExplorer::CdUp()
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->CdUp(&progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

void CVFSExplorer::EntryList(QVector<QString> & aNames, QVector<ULONG> & aTypes, QVector<LONG64> & aSizes, QVector<ULONG> & aModes)
{
    AssertReturnVoid(ptr());
    com::SafeArray <BSTR> names;
    com::SafeArray <ULONG> types;
    com::SafeArray <LONG64> sizes;
    com::SafeArray <ULONG> modes;
    mRC = ptr()->EntryList(ComSafeArrayAsOutParam(names), ComSafeArrayAsOutParam(types), ComSafeArrayAsOutParam(sizes), ComSafeArrayAsOutParam(modes));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(names, aNames);
    FromSafeArray(types, aTypes);
    FromSafeArray(sizes, aSizes);
    FromSafeArray(modes, aModes);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QVector<QString> CVFSExplorer::Exists(const QVector<QString> & aNames)
{
    QVector<QString> aExists;
    AssertReturn(ptr(), aExists);
    com::SafeArray <BSTR> names;
    ToSafeArray(aNames, names);
    com::SafeArray <BSTR> exists;
    mRC = ptr()->Exists(ComSafeArrayAsInParam(names), ComSafeArrayAsOutParam(exists));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(exists, aExists);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aExists;
}

CProgress CVFSExplorer::Remove(const QVector<QString> & aNames)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    com::SafeArray <BSTR> names;
    ToSafeArray(aNames, names);
    IProgress* progressPtr = NULL;
    mRC = ptr()->Remove(ComSafeArrayAsInParam(names), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

// IAppliance wrapper

QString CAppliance::GetPath() const
{
    QString aPath;
    AssertReturn(ptr(), aPath);
    mRC = ptr()->COMGETTER(Path)(BSTROut(aPath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPath;
}

QVector<QString> CAppliance::GetDisks() const
{
    QVector<QString> aDisks;
    AssertReturn(ptr(), aDisks);
    com::SafeArray <BSTR> disks;
    mRC = ptr()->COMGETTER(Disks)(ComSafeArrayAsOutParam(disks));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(disks, aDisks);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDisks;
}

QVector<CVirtualSystemDescription> CAppliance::GetVirtualSystemDescriptions() const
{
    QVector<CVirtualSystemDescription> aVirtualSystemDescriptions;
    AssertReturn(ptr(), aVirtualSystemDescriptions);
    com::SafeIfaceArray <IVirtualSystemDescription> virtualSystemDescriptions;
    mRC = ptr()->COMGETTER(VirtualSystemDescriptions)(ComSafeArrayAsOutParam(virtualSystemDescriptions));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(virtualSystemDescriptions, aVirtualSystemDescriptions);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVirtualSystemDescriptions;
}

QVector<QString> CAppliance::GetMachines() const
{
    QVector<QString> aMachines;
    AssertReturn(ptr(), aMachines);
    com::SafeArray <BSTR> machines;
    mRC = ptr()->COMGETTER(Machines)(ComSafeArrayAsOutParam(machines));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(machines, aMachines);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachines;
}

CProgress CAppliance::Read(const QString & aFile)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->Read(BSTRIn(aFile), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

void CAppliance::Interpret()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Interpret();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CProgress CAppliance::ImportMachines(const QVector<KImportOptions> & aOptions)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    com::SafeArray <ImportOptions_T> options;
    ToSafeArray(aOptions, options);
    IProgress* progressPtr = NULL;
    mRC = ptr()->ImportMachines(ComSafeArrayAsInParam(options), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CVFSExplorer CAppliance::CreateVFSExplorer(const QString & aURI)
{
    CVFSExplorer aExplorer;
    AssertReturn(ptr(), aExplorer);
    IVFSExplorer* explorerPtr = NULL;
    mRC = ptr()->CreateVFSExplorer(BSTRIn(aURI), &explorerPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aExplorer.setPtr(explorerPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aExplorer;
}

CProgress CAppliance::Write(const QString & aFormat, const QVector<KExportOptions> & aOptions, const QString & aPath)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    com::SafeArray <ExportOptions_T> options;
    ToSafeArray(aOptions, options);
    IProgress* progressPtr = NULL;
    mRC = ptr()->Write(BSTRIn(aFormat), ComSafeArrayAsInParam(options), BSTRIn(aPath), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

QVector<QString> CAppliance::GetWarnings()
{
    QVector<QString> aWarnings;
    AssertReturn(ptr(), aWarnings);
    com::SafeArray <BSTR> warnings;
    mRC = ptr()->GetWarnings(ComSafeArrayAsOutParam(warnings));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(warnings, aWarnings);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWarnings;
}

// IVirtualSystemDescription wrapper

ULONG CVirtualSystemDescription::GetCount() const
{
    ULONG aCount = 0;
    AssertReturn(ptr(), aCount);
    mRC = ptr()->COMGETTER(Count)(&aCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCount;
}

void CVirtualSystemDescription::GetDescription(QVector<KVirtualSystemDescriptionType> & aTypes, QVector<QString> & aRefs, QVector<QString> & aOVFValues, QVector<QString> & aVBoxValues, QVector<QString> & aExtraConfigValues)
{
    AssertReturnVoid(ptr());
    com::SafeArray <VirtualSystemDescriptionType_T> types;
    com::SafeArray <BSTR> refs;
    com::SafeArray <BSTR> OVFValues;
    com::SafeArray <BSTR> VBoxValues;
    com::SafeArray <BSTR> extraConfigValues;
    mRC = ptr()->GetDescription(ComSafeArrayAsOutParam(types), ComSafeArrayAsOutParam(refs), ComSafeArrayAsOutParam(OVFValues), ComSafeArrayAsOutParam(VBoxValues), ComSafeArrayAsOutParam(extraConfigValues));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(types, aTypes);
    FromSafeArray(refs, aRefs);
    FromSafeArray(OVFValues, aOVFValues);
    FromSafeArray(VBoxValues, aVBoxValues);
    FromSafeArray(extraConfigValues, aExtraConfigValues);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CVirtualSystemDescription::GetDescriptionByType(const KVirtualSystemDescriptionType & aType, QVector<KVirtualSystemDescriptionType> & aTypes, QVector<QString> & aRefs, QVector<QString> & aOVFValues, QVector<QString> & aVBoxValues, QVector<QString> & aExtraConfigValues)
{
    AssertReturnVoid(ptr());
    com::SafeArray <VirtualSystemDescriptionType_T> types;
    com::SafeArray <BSTR> refs;
    com::SafeArray <BSTR> OVFValues;
    com::SafeArray <BSTR> VBoxValues;
    com::SafeArray <BSTR> extraConfigValues;
    mRC = ptr()->GetDescriptionByType((VirtualSystemDescriptionType_T) aType, ComSafeArrayAsOutParam(types), ComSafeArrayAsOutParam(refs), ComSafeArrayAsOutParam(OVFValues), ComSafeArrayAsOutParam(VBoxValues), ComSafeArrayAsOutParam(extraConfigValues));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(types, aTypes);
    FromSafeArray(refs, aRefs);
    FromSafeArray(OVFValues, aOVFValues);
    FromSafeArray(VBoxValues, aVBoxValues);
    FromSafeArray(extraConfigValues, aExtraConfigValues);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QVector<QString> CVirtualSystemDescription::GetValuesByType(const KVirtualSystemDescriptionType & aType, const KVirtualSystemDescriptionValueType & aWhich)
{
    QVector<QString> aValues;
    AssertReturn(ptr(), aValues);
    com::SafeArray <BSTR> values;
    mRC = ptr()->GetValuesByType((VirtualSystemDescriptionType_T) aType, (VirtualSystemDescriptionValueType_T) aWhich, ComSafeArrayAsOutParam(values));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(values, aValues);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aValues;
}

void CVirtualSystemDescription::SetFinalValues(const QVector<BOOL> & aEnabled, const QVector<QString> & aVBoxValues, const QVector<QString> & aExtraConfigValues)
{
    AssertReturnVoid(ptr());
    com::SafeArray <BOOL> enabled;
    ToSafeArray(aEnabled, enabled);
    com::SafeArray <BSTR> VBoxValues;
    ToSafeArray(aVBoxValues, VBoxValues);
    com::SafeArray <BSTR> extraConfigValues;
    ToSafeArray(aExtraConfigValues, extraConfigValues);
    mRC = ptr()->SetFinalValues(ComSafeArrayAsInParam(enabled), ComSafeArrayAsInParam(VBoxValues), ComSafeArrayAsInParam(extraConfigValues));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CVirtualSystemDescription::AddDescription(const KVirtualSystemDescriptionType & aType, const QString & aVBoxValue, const QString & aExtraConfigValue)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->AddDescription((VirtualSystemDescriptionType_T) aType, BSTRIn(aVBoxValue), BSTRIn(aExtraConfigValue));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IBIOSSettings wrapper

BOOL CBIOSSettings::GetLogoFadeIn() const
{
    BOOL aLogoFadeIn = FALSE;
    AssertReturn(ptr(), aLogoFadeIn);
    mRC = ptr()->COMGETTER(LogoFadeIn)(&aLogoFadeIn);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLogoFadeIn;
}
void CBIOSSettings::SetLogoFadeIn(BOOL aLogoFadeIn)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(LogoFadeIn)(aLogoFadeIn);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CBIOSSettings::GetLogoFadeOut() const
{
    BOOL aLogoFadeOut = FALSE;
    AssertReturn(ptr(), aLogoFadeOut);
    mRC = ptr()->COMGETTER(LogoFadeOut)(&aLogoFadeOut);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLogoFadeOut;
}
void CBIOSSettings::SetLogoFadeOut(BOOL aLogoFadeOut)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(LogoFadeOut)(aLogoFadeOut);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CBIOSSettings::GetLogoDisplayTime() const
{
    ULONG aLogoDisplayTime = 0;
    AssertReturn(ptr(), aLogoDisplayTime);
    mRC = ptr()->COMGETTER(LogoDisplayTime)(&aLogoDisplayTime);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLogoDisplayTime;
}
void CBIOSSettings::SetLogoDisplayTime(ULONG aLogoDisplayTime)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(LogoDisplayTime)(aLogoDisplayTime);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CBIOSSettings::GetLogoImagePath() const
{
    QString aLogoImagePath;
    AssertReturn(ptr(), aLogoImagePath);
    mRC = ptr()->COMGETTER(LogoImagePath)(BSTROut(aLogoImagePath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLogoImagePath;
}
void CBIOSSettings::SetLogoImagePath(const QString & aLogoImagePath)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(LogoImagePath)(BSTRIn(aLogoImagePath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KBIOSBootMenuMode CBIOSSettings::GetBootMenuMode() const
{
    KBIOSBootMenuMode aBootMenuMode = (KBIOSBootMenuMode) 0;
    AssertReturn(ptr(), aBootMenuMode);
    mRC = ptr()->COMGETTER(BootMenuMode)(ENUMOut<KBIOSBootMenuMode, BIOSBootMenuMode_T>(aBootMenuMode));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBootMenuMode;
}
void CBIOSSettings::SetBootMenuMode(const KBIOSBootMenuMode & aBootMenuMode)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(BootMenuMode)((BIOSBootMenuMode_T) aBootMenuMode);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CBIOSSettings::GetACPIEnabled() const
{
    BOOL aACPIEnabled = FALSE;
    AssertReturn(ptr(), aACPIEnabled);
    mRC = ptr()->COMGETTER(ACPIEnabled)(&aACPIEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aACPIEnabled;
}
void CBIOSSettings::SetACPIEnabled(BOOL aACPIEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(ACPIEnabled)(aACPIEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CBIOSSettings::GetIOAPICEnabled() const
{
    BOOL aIOAPICEnabled = FALSE;
    AssertReturn(ptr(), aIOAPICEnabled);
    mRC = ptr()->COMGETTER(IOAPICEnabled)(&aIOAPICEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aIOAPICEnabled;
}
void CBIOSSettings::SetIOAPICEnabled(BOOL aIOAPICEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(IOAPICEnabled)(aIOAPICEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

LONG64 CBIOSSettings::GetTimeOffset() const
{
    LONG64 aTimeOffset = 0;
    AssertReturn(ptr(), aTimeOffset);
    mRC = ptr()->COMGETTER(TimeOffset)(&aTimeOffset);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aTimeOffset;
}
void CBIOSSettings::SetTimeOffset(LONG64 aTimeOffset)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(TimeOffset)(aTimeOffset);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CBIOSSettings::GetPXEDebugEnabled() const
{
    BOOL aPXEDebugEnabled = FALSE;
    AssertReturn(ptr(), aPXEDebugEnabled);
    mRC = ptr()->COMGETTER(PXEDebugEnabled)(&aPXEDebugEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPXEDebugEnabled;
}
void CBIOSSettings::SetPXEDebugEnabled(BOOL aPXEDebugEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(PXEDebugEnabled)(aPXEDebugEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CBIOSSettings::GetNonVolatileStorageFile() const
{
    QString aNonVolatileStorageFile;
    AssertReturn(ptr(), aNonVolatileStorageFile);
    mRC = ptr()->COMGETTER(NonVolatileStorageFile)(BSTROut(aNonVolatileStorageFile));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNonVolatileStorageFile;
}

// IPCIAddress wrapper

SHORT CPCIAddress::GetBus() const
{
    SHORT aBus = 0;
    AssertReturn(ptr(), aBus);
    mRC = ptr()->COMGETTER(Bus)(&aBus);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBus;
}
void CPCIAddress::SetBus(SHORT aBus)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Bus)(aBus);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

SHORT CPCIAddress::GetDevice() const
{
    SHORT aDevice = 0;
    AssertReturn(ptr(), aDevice);
    mRC = ptr()->COMGETTER(Device)(&aDevice);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDevice;
}
void CPCIAddress::SetDevice(SHORT aDevice)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Device)(aDevice);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

SHORT CPCIAddress::GetDevFunction() const
{
    SHORT aDevFunction = 0;
    AssertReturn(ptr(), aDevFunction);
    mRC = ptr()->COMGETTER(DevFunction)(&aDevFunction);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDevFunction;
}
void CPCIAddress::SetDevFunction(SHORT aDevFunction)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(DevFunction)(aDevFunction);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

LONG CPCIAddress::AsLong()
{
    LONG aResult = 0;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->AsLong(&aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

void CPCIAddress::FromLong(LONG aNumber)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->FromLong(aNumber);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IPCIDeviceAttachment wrapper

QString CPCIDeviceAttachment::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

BOOL CPCIDeviceAttachment::GetIsPhysicalDevice() const
{
    BOOL aIsPhysicalDevice = FALSE;
    AssertReturn(ptr(), aIsPhysicalDevice);
    mRC = ptr()->COMGETTER(IsPhysicalDevice)(&aIsPhysicalDevice);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aIsPhysicalDevice;
}

LONG CPCIDeviceAttachment::GetHostAddress() const
{
    LONG aHostAddress = 0;
    AssertReturn(ptr(), aHostAddress);
    mRC = ptr()->COMGETTER(HostAddress)(&aHostAddress);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHostAddress;
}

LONG CPCIDeviceAttachment::GetGuestAddress() const
{
    LONG aGuestAddress = 0;
    AssertReturn(ptr(), aGuestAddress);
    mRC = ptr()->COMGETTER(GuestAddress)(&aGuestAddress);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGuestAddress;
}

// IMachine wrapper

CVirtualBox CMachine::GetParent() const
{
    CVirtualBox aParent;
    AssertReturn(ptr(), aParent);
    IVirtualBox* parentPtr = NULL;
    mRC = ptr()->COMGETTER(Parent)(&parentPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aParent.setPtr(parentPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aParent;
}

QVector<BYTE> CMachine::GetIcon() const
{
    QVector<BYTE> aIcon;
    AssertReturn(ptr(), aIcon);
    com::SafeArray <BYTE> icon;
    mRC = ptr()->COMGETTER(Icon)(ComSafeArrayAsOutParam(icon));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(icon, aIcon);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aIcon;
}
void CMachine::SetIcon(const QVector<BYTE> & aIcon)
{
    AssertReturnVoid(ptr());
    com::SafeArray <BYTE> icon;
    ToSafeArray(aIcon, icon);
    mRC = ptr()->COMSETTER(Icon)(ComSafeArrayAsInParam(icon));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachine::GetAccessible() const
{
    BOOL aAccessible = FALSE;
    AssertReturn(ptr(), aAccessible);
    mRC = ptr()->COMGETTER(Accessible)(&aAccessible);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAccessible;
}

CVirtualBoxErrorInfo CMachine::GetAccessError() const
{
    CVirtualBoxErrorInfo aAccessError;
    AssertReturn(ptr(), aAccessError);
    IVirtualBoxErrorInfo* accessErrorPtr = NULL;
    mRC = ptr()->COMGETTER(AccessError)(&accessErrorPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aAccessError.setPtr(accessErrorPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAccessError;
}

QString CMachine::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}
void CMachine::SetName(const QString & aName)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Name)(BSTRIn(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CMachine::GetDescription() const
{
    QString aDescription;
    AssertReturn(ptr(), aDescription);
    mRC = ptr()->COMGETTER(Description)(BSTROut(aDescription));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDescription;
}
void CMachine::SetDescription(const QString & aDescription)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Description)(BSTRIn(aDescription));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CMachine::GetId() const
{
    QString aId;
    AssertReturn(ptr(), aId);
    mRC = ptr()->COMGETTER(Id)(BSTROut(aId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aId;
}

QVector<QString> CMachine::GetGroups() const
{
    QVector<QString> aGroups;
    AssertReturn(ptr(), aGroups);
    com::SafeArray <BSTR> groups;
    mRC = ptr()->COMGETTER(Groups)(ComSafeArrayAsOutParam(groups));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(groups, aGroups);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGroups;
}
void CMachine::SetGroups(const QVector<QString> & aGroups)
{
    AssertReturnVoid(ptr());
    com::SafeArray <BSTR> groups;
    ToSafeArray(aGroups, groups);
    mRC = ptr()->COMSETTER(Groups)(ComSafeArrayAsInParam(groups));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CMachine::GetOSTypeId() const
{
    QString aOSTypeId;
    AssertReturn(ptr(), aOSTypeId);
    mRC = ptr()->COMGETTER(OSTypeId)(BSTROut(aOSTypeId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOSTypeId;
}
void CMachine::SetOSTypeId(const QString & aOSTypeId)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(OSTypeId)(BSTRIn(aOSTypeId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CMachine::GetHardwareVersion() const
{
    QString aHardwareVersion;
    AssertReturn(ptr(), aHardwareVersion);
    mRC = ptr()->COMGETTER(HardwareVersion)(BSTROut(aHardwareVersion));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHardwareVersion;
}
void CMachine::SetHardwareVersion(const QString & aHardwareVersion)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(HardwareVersion)(BSTRIn(aHardwareVersion));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CMachine::GetHardwareUUID() const
{
    QString aHardwareUUID;
    AssertReturn(ptr(), aHardwareUUID);
    mRC = ptr()->COMGETTER(HardwareUUID)(BSTROut(aHardwareUUID));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHardwareUUID;
}
void CMachine::SetHardwareUUID(QString aHardwareUUID)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(HardwareUUID)(BSTRIn(aHardwareUUID));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CMachine::GetCPUCount() const
{
    ULONG aCPUCount = 0;
    AssertReturn(ptr(), aCPUCount);
    mRC = ptr()->COMGETTER(CPUCount)(&aCPUCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCPUCount;
}
void CMachine::SetCPUCount(ULONG aCPUCount)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(CPUCount)(aCPUCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachine::GetCPUHotPlugEnabled() const
{
    BOOL aCPUHotPlugEnabled = FALSE;
    AssertReturn(ptr(), aCPUHotPlugEnabled);
    mRC = ptr()->COMGETTER(CPUHotPlugEnabled)(&aCPUHotPlugEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCPUHotPlugEnabled;
}
void CMachine::SetCPUHotPlugEnabled(BOOL aCPUHotPlugEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(CPUHotPlugEnabled)(aCPUHotPlugEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CMachine::GetCPUExecutionCap() const
{
    ULONG aCPUExecutionCap = 0;
    AssertReturn(ptr(), aCPUExecutionCap);
    mRC = ptr()->COMGETTER(CPUExecutionCap)(&aCPUExecutionCap);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCPUExecutionCap;
}
void CMachine::SetCPUExecutionCap(ULONG aCPUExecutionCap)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(CPUExecutionCap)(aCPUExecutionCap);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CMachine::GetMemorySize() const
{
    ULONG aMemorySize = 0;
    AssertReturn(ptr(), aMemorySize);
    mRC = ptr()->COMGETTER(MemorySize)(&aMemorySize);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMemorySize;
}
void CMachine::SetMemorySize(ULONG aMemorySize)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(MemorySize)(aMemorySize);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CMachine::GetMemoryBalloonSize() const
{
    ULONG aMemoryBalloonSize = 0;
    AssertReturn(ptr(), aMemoryBalloonSize);
    mRC = ptr()->COMGETTER(MemoryBalloonSize)(&aMemoryBalloonSize);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMemoryBalloonSize;
}
void CMachine::SetMemoryBalloonSize(ULONG aMemoryBalloonSize)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(MemoryBalloonSize)(aMemoryBalloonSize);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachine::GetPageFusionEnabled() const
{
    BOOL aPageFusionEnabled = FALSE;
    AssertReturn(ptr(), aPageFusionEnabled);
    mRC = ptr()->COMGETTER(PageFusionEnabled)(&aPageFusionEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPageFusionEnabled;
}
void CMachine::SetPageFusionEnabled(BOOL aPageFusionEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(PageFusionEnabled)(aPageFusionEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KGraphicsControllerType CMachine::GetGraphicsControllerType() const
{
    KGraphicsControllerType aGraphicsControllerType = (KGraphicsControllerType) 0;
    AssertReturn(ptr(), aGraphicsControllerType);
    mRC = ptr()->COMGETTER(GraphicsControllerType)(ENUMOut<KGraphicsControllerType, GraphicsControllerType_T>(aGraphicsControllerType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGraphicsControllerType;
}
void CMachine::SetGraphicsControllerType(const KGraphicsControllerType & aGraphicsControllerType)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(GraphicsControllerType)((GraphicsControllerType_T) aGraphicsControllerType);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CMachine::GetVRAMSize() const
{
    ULONG aVRAMSize = 0;
    AssertReturn(ptr(), aVRAMSize);
    mRC = ptr()->COMGETTER(VRAMSize)(&aVRAMSize);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVRAMSize;
}
void CMachine::SetVRAMSize(ULONG aVRAMSize)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(VRAMSize)(aVRAMSize);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachine::GetAccelerate3DEnabled() const
{
    BOOL aAccelerate3DEnabled = FALSE;
    AssertReturn(ptr(), aAccelerate3DEnabled);
    mRC = ptr()->COMGETTER(Accelerate3DEnabled)(&aAccelerate3DEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAccelerate3DEnabled;
}
void CMachine::SetAccelerate3DEnabled(BOOL aAccelerate3DEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Accelerate3DEnabled)(aAccelerate3DEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachine::GetAccelerate2DVideoEnabled() const
{
    BOOL aAccelerate2DVideoEnabled = FALSE;
    AssertReturn(ptr(), aAccelerate2DVideoEnabled);
    mRC = ptr()->COMGETTER(Accelerate2DVideoEnabled)(&aAccelerate2DVideoEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAccelerate2DVideoEnabled;
}
void CMachine::SetAccelerate2DVideoEnabled(BOOL aAccelerate2DVideoEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Accelerate2DVideoEnabled)(aAccelerate2DVideoEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CMachine::GetMonitorCount() const
{
    ULONG aMonitorCount = 0;
    AssertReturn(ptr(), aMonitorCount);
    mRC = ptr()->COMGETTER(MonitorCount)(&aMonitorCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMonitorCount;
}
void CMachine::SetMonitorCount(ULONG aMonitorCount)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(MonitorCount)(aMonitorCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachine::GetVideoCaptureEnabled() const
{
    BOOL aVideoCaptureEnabled = FALSE;
    AssertReturn(ptr(), aVideoCaptureEnabled);
    mRC = ptr()->COMGETTER(VideoCaptureEnabled)(&aVideoCaptureEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVideoCaptureEnabled;
}
void CMachine::SetVideoCaptureEnabled(BOOL aVideoCaptureEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(VideoCaptureEnabled)(aVideoCaptureEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QVector<BOOL> CMachine::GetVideoCaptureScreens() const
{
    QVector<BOOL> aVideoCaptureScreens;
    AssertReturn(ptr(), aVideoCaptureScreens);
    com::SafeArray <BOOL> videoCaptureScreens;
    mRC = ptr()->COMGETTER(VideoCaptureScreens)(ComSafeArrayAsOutParam(videoCaptureScreens));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(videoCaptureScreens, aVideoCaptureScreens);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVideoCaptureScreens;
}
void CMachine::SetVideoCaptureScreens(const QVector<BOOL> & aVideoCaptureScreens)
{
    AssertReturnVoid(ptr());
    com::SafeArray <BOOL> videoCaptureScreens;
    ToSafeArray(aVideoCaptureScreens, videoCaptureScreens);
    mRC = ptr()->COMSETTER(VideoCaptureScreens)(ComSafeArrayAsInParam(videoCaptureScreens));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CMachine::GetVideoCaptureFile() const
{
    QString aVideoCaptureFile;
    AssertReturn(ptr(), aVideoCaptureFile);
    mRC = ptr()->COMGETTER(VideoCaptureFile)(BSTROut(aVideoCaptureFile));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVideoCaptureFile;
}
void CMachine::SetVideoCaptureFile(const QString & aVideoCaptureFile)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(VideoCaptureFile)(BSTRIn(aVideoCaptureFile));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CMachine::GetVideoCaptureWidth() const
{
    ULONG aVideoCaptureWidth = 0;
    AssertReturn(ptr(), aVideoCaptureWidth);
    mRC = ptr()->COMGETTER(VideoCaptureWidth)(&aVideoCaptureWidth);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVideoCaptureWidth;
}
void CMachine::SetVideoCaptureWidth(ULONG aVideoCaptureWidth)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(VideoCaptureWidth)(aVideoCaptureWidth);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CMachine::GetVideoCaptureHeight() const
{
    ULONG aVideoCaptureHeight = 0;
    AssertReturn(ptr(), aVideoCaptureHeight);
    mRC = ptr()->COMGETTER(VideoCaptureHeight)(&aVideoCaptureHeight);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVideoCaptureHeight;
}
void CMachine::SetVideoCaptureHeight(ULONG aVideoCaptureHeight)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(VideoCaptureHeight)(aVideoCaptureHeight);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CMachine::GetVideoCaptureRate() const
{
    ULONG aVideoCaptureRate = 0;
    AssertReturn(ptr(), aVideoCaptureRate);
    mRC = ptr()->COMGETTER(VideoCaptureRate)(&aVideoCaptureRate);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVideoCaptureRate;
}
void CMachine::SetVideoCaptureRate(ULONG aVideoCaptureRate)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(VideoCaptureRate)(aVideoCaptureRate);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CMachine::GetVideoCaptureFPS() const
{
    ULONG aVideoCaptureFPS = 0;
    AssertReturn(ptr(), aVideoCaptureFPS);
    mRC = ptr()->COMGETTER(VideoCaptureFPS)(&aVideoCaptureFPS);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVideoCaptureFPS;
}
void CMachine::SetVideoCaptureFPS(ULONG aVideoCaptureFPS)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(VideoCaptureFPS)(aVideoCaptureFPS);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CBIOSSettings CMachine::GetBIOSSettings() const
{
    CBIOSSettings aBIOSSettings;
    AssertReturn(ptr(), aBIOSSettings);
    IBIOSSettings* BIOSSettingsPtr = NULL;
    mRC = ptr()->COMGETTER(BIOSSettings)(&BIOSSettingsPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aBIOSSettings.setPtr(BIOSSettingsPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBIOSSettings;
}

KFirmwareType CMachine::GetFirmwareType() const
{
    KFirmwareType aFirmwareType = (KFirmwareType) 0;
    AssertReturn(ptr(), aFirmwareType);
    mRC = ptr()->COMGETTER(FirmwareType)(ENUMOut<KFirmwareType, FirmwareType_T>(aFirmwareType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFirmwareType;
}
void CMachine::SetFirmwareType(const KFirmwareType & aFirmwareType)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(FirmwareType)((FirmwareType_T) aFirmwareType);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KPointingHIDType CMachine::GetPointingHIDType() const
{
    KPointingHIDType aPointingHIDType = (KPointingHIDType) 0;
    AssertReturn(ptr(), aPointingHIDType);
    mRC = ptr()->COMGETTER(PointingHIDType)(ENUMOut<KPointingHIDType, PointingHIDType_T>(aPointingHIDType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPointingHIDType;
}
void CMachine::SetPointingHIDType(const KPointingHIDType & aPointingHIDType)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(PointingHIDType)((PointingHIDType_T) aPointingHIDType);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KKeyboardHIDType CMachine::GetKeyboardHIDType() const
{
    KKeyboardHIDType aKeyboardHIDType = (KKeyboardHIDType) 0;
    AssertReturn(ptr(), aKeyboardHIDType);
    mRC = ptr()->COMGETTER(KeyboardHIDType)(ENUMOut<KKeyboardHIDType, KeyboardHIDType_T>(aKeyboardHIDType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aKeyboardHIDType;
}
void CMachine::SetKeyboardHIDType(const KKeyboardHIDType & aKeyboardHIDType)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(KeyboardHIDType)((KeyboardHIDType_T) aKeyboardHIDType);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachine::GetHPETEnabled() const
{
    BOOL aHPETEnabled = FALSE;
    AssertReturn(ptr(), aHPETEnabled);
    mRC = ptr()->COMGETTER(HPETEnabled)(&aHPETEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHPETEnabled;
}
void CMachine::SetHPETEnabled(BOOL aHPETEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(HPETEnabled)(aHPETEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KChipsetType CMachine::GetChipsetType() const
{
    KChipsetType aChipsetType = (KChipsetType) 0;
    AssertReturn(ptr(), aChipsetType);
    mRC = ptr()->COMGETTER(ChipsetType)(ENUMOut<KChipsetType, ChipsetType_T>(aChipsetType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aChipsetType;
}
void CMachine::SetChipsetType(const KChipsetType & aChipsetType)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(ChipsetType)((ChipsetType_T) aChipsetType);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CMachine::GetSnapshotFolder() const
{
    QString aSnapshotFolder;
    AssertReturn(ptr(), aSnapshotFolder);
    mRC = ptr()->COMGETTER(SnapshotFolder)(BSTROut(aSnapshotFolder));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSnapshotFolder;
}
void CMachine::SetSnapshotFolder(const QString & aSnapshotFolder)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(SnapshotFolder)(BSTRIn(aSnapshotFolder));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CVRDEServer CMachine::GetVRDEServer() const
{
    CVRDEServer aVRDEServer;
    AssertReturn(ptr(), aVRDEServer);
    IVRDEServer* VRDEServerPtr = NULL;
    mRC = ptr()->COMGETTER(VRDEServer)(&VRDEServerPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aVRDEServer.setPtr(VRDEServerPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVRDEServer;
}

BOOL CMachine::GetEmulatedUSBCardReaderEnabled() const
{
    BOOL aEmulatedUSBCardReaderEnabled = FALSE;
    AssertReturn(ptr(), aEmulatedUSBCardReaderEnabled);
    mRC = ptr()->COMGETTER(EmulatedUSBCardReaderEnabled)(&aEmulatedUSBCardReaderEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEmulatedUSBCardReaderEnabled;
}
void CMachine::SetEmulatedUSBCardReaderEnabled(BOOL aEmulatedUSBCardReaderEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(EmulatedUSBCardReaderEnabled)(aEmulatedUSBCardReaderEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QVector<CMediumAttachment> CMachine::GetMediumAttachments() const
{
    QVector<CMediumAttachment> aMediumAttachments;
    AssertReturn(ptr(), aMediumAttachments);
    com::SafeIfaceArray <IMediumAttachment> mediumAttachments;
    mRC = ptr()->COMGETTER(MediumAttachments)(ComSafeArrayAsOutParam(mediumAttachments));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(mediumAttachments, aMediumAttachments);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMediumAttachments;
}

QVector<CUSBController> CMachine::GetUSBControllers() const
{
    QVector<CUSBController> aUSBControllers;
    AssertReturn(ptr(), aUSBControllers);
    com::SafeIfaceArray <IUSBController> USBControllers;
    mRC = ptr()->COMGETTER(USBControllers)(ComSafeArrayAsOutParam(USBControllers));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(USBControllers, aUSBControllers);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUSBControllers;
}

CUSBDeviceFilters CMachine::GetUSBDeviceFilters() const
{
    CUSBDeviceFilters aUSBDeviceFilters;
    AssertReturn(ptr(), aUSBDeviceFilters);
    IUSBDeviceFilters* USBDeviceFiltersPtr = NULL;
    mRC = ptr()->COMGETTER(USBDeviceFilters)(&USBDeviceFiltersPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aUSBDeviceFilters.setPtr(USBDeviceFiltersPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUSBDeviceFilters;
}

CAudioAdapter CMachine::GetAudioAdapter() const
{
    CAudioAdapter aAudioAdapter;
    AssertReturn(ptr(), aAudioAdapter);
    IAudioAdapter* audioAdapterPtr = NULL;
    mRC = ptr()->COMGETTER(AudioAdapter)(&audioAdapterPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aAudioAdapter.setPtr(audioAdapterPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAudioAdapter;
}

QVector<CStorageController> CMachine::GetStorageControllers() const
{
    QVector<CStorageController> aStorageControllers;
    AssertReturn(ptr(), aStorageControllers);
    com::SafeIfaceArray <IStorageController> storageControllers;
    mRC = ptr()->COMGETTER(StorageControllers)(ComSafeArrayAsOutParam(storageControllers));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(storageControllers, aStorageControllers);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStorageControllers;
}

QString CMachine::GetSettingsFilePath() const
{
    QString aSettingsFilePath;
    AssertReturn(ptr(), aSettingsFilePath);
    mRC = ptr()->COMGETTER(SettingsFilePath)(BSTROut(aSettingsFilePath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSettingsFilePath;
}

BOOL CMachine::GetSettingsModified() const
{
    BOOL aSettingsModified = FALSE;
    AssertReturn(ptr(), aSettingsModified);
    mRC = ptr()->COMGETTER(SettingsModified)(&aSettingsModified);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSettingsModified;
}

KSessionState CMachine::GetSessionState() const
{
    KSessionState aSessionState = (KSessionState) 0;
    AssertReturn(ptr(), aSessionState);
    mRC = ptr()->COMGETTER(SessionState)(ENUMOut<KSessionState, SessionState_T>(aSessionState));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSessionState;
}

QString CMachine::GetSessionType() const
{
    QString aSessionType;
    AssertReturn(ptr(), aSessionType);
    mRC = ptr()->COMGETTER(SessionType)(BSTROut(aSessionType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSessionType;
}

ULONG CMachine::GetSessionPID() const
{
    ULONG aSessionPID = 0;
    AssertReturn(ptr(), aSessionPID);
    mRC = ptr()->COMGETTER(SessionPID)(&aSessionPID);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSessionPID;
}

KMachineState CMachine::GetState() const
{
    KMachineState aState = (KMachineState) 0;
    AssertReturn(ptr(), aState);
    mRC = ptr()->COMGETTER(State)(ENUMOut<KMachineState, MachineState_T>(aState));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aState;
}

LONG64 CMachine::GetLastStateChange() const
{
    LONG64 aLastStateChange = 0;
    AssertReturn(ptr(), aLastStateChange);
    mRC = ptr()->COMGETTER(LastStateChange)(&aLastStateChange);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLastStateChange;
}

QString CMachine::GetStateFilePath() const
{
    QString aStateFilePath;
    AssertReturn(ptr(), aStateFilePath);
    mRC = ptr()->COMGETTER(StateFilePath)(BSTROut(aStateFilePath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStateFilePath;
}

QString CMachine::GetLogFolder() const
{
    QString aLogFolder;
    AssertReturn(ptr(), aLogFolder);
    mRC = ptr()->COMGETTER(LogFolder)(BSTROut(aLogFolder));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLogFolder;
}

CSnapshot CMachine::GetCurrentSnapshot() const
{
    CSnapshot aCurrentSnapshot;
    AssertReturn(ptr(), aCurrentSnapshot);
    ISnapshot* currentSnapshotPtr = NULL;
    mRC = ptr()->COMGETTER(CurrentSnapshot)(&currentSnapshotPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aCurrentSnapshot.setPtr(currentSnapshotPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCurrentSnapshot;
}

ULONG CMachine::GetSnapshotCount() const
{
    ULONG aSnapshotCount = 0;
    AssertReturn(ptr(), aSnapshotCount);
    mRC = ptr()->COMGETTER(SnapshotCount)(&aSnapshotCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSnapshotCount;
}

BOOL CMachine::GetCurrentStateModified() const
{
    BOOL aCurrentStateModified = FALSE;
    AssertReturn(ptr(), aCurrentStateModified);
    mRC = ptr()->COMGETTER(CurrentStateModified)(&aCurrentStateModified);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCurrentStateModified;
}

QVector<CSharedFolder> CMachine::GetSharedFolders() const
{
    QVector<CSharedFolder> aSharedFolders;
    AssertReturn(ptr(), aSharedFolders);
    com::SafeIfaceArray <ISharedFolder> sharedFolders;
    mRC = ptr()->COMGETTER(SharedFolders)(ComSafeArrayAsOutParam(sharedFolders));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(sharedFolders, aSharedFolders);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSharedFolders;
}

KClipboardMode CMachine::GetClipboardMode() const
{
    KClipboardMode aClipboardMode = (KClipboardMode) 0;
    AssertReturn(ptr(), aClipboardMode);
    mRC = ptr()->COMGETTER(ClipboardMode)(ENUMOut<KClipboardMode, ClipboardMode_T>(aClipboardMode));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aClipboardMode;
}
void CMachine::SetClipboardMode(const KClipboardMode & aClipboardMode)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(ClipboardMode)((ClipboardMode_T) aClipboardMode);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KDragAndDropMode CMachine::GetDragAndDropMode() const
{
    KDragAndDropMode aDragAndDropMode = (KDragAndDropMode) 0;
    AssertReturn(ptr(), aDragAndDropMode);
    mRC = ptr()->COMGETTER(DragAndDropMode)(ENUMOut<KDragAndDropMode, DragAndDropMode_T>(aDragAndDropMode));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDragAndDropMode;
}
void CMachine::SetDragAndDropMode(const KDragAndDropMode & aDragAndDropMode)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(DragAndDropMode)((DragAndDropMode_T) aDragAndDropMode);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CMachine::GetGuestPropertyNotificationPatterns() const
{
    QString aGuestPropertyNotificationPatterns;
    AssertReturn(ptr(), aGuestPropertyNotificationPatterns);
    mRC = ptr()->COMGETTER(GuestPropertyNotificationPatterns)(BSTROut(aGuestPropertyNotificationPatterns));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGuestPropertyNotificationPatterns;
}
void CMachine::SetGuestPropertyNotificationPatterns(const QString & aGuestPropertyNotificationPatterns)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(GuestPropertyNotificationPatterns)(BSTRIn(aGuestPropertyNotificationPatterns));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachine::GetTeleporterEnabled() const
{
    BOOL aTeleporterEnabled = FALSE;
    AssertReturn(ptr(), aTeleporterEnabled);
    mRC = ptr()->COMGETTER(TeleporterEnabled)(&aTeleporterEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aTeleporterEnabled;
}
void CMachine::SetTeleporterEnabled(BOOL aTeleporterEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(TeleporterEnabled)(aTeleporterEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CMachine::GetTeleporterPort() const
{
    ULONG aTeleporterPort = 0;
    AssertReturn(ptr(), aTeleporterPort);
    mRC = ptr()->COMGETTER(TeleporterPort)(&aTeleporterPort);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aTeleporterPort;
}
void CMachine::SetTeleporterPort(ULONG aTeleporterPort)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(TeleporterPort)(aTeleporterPort);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CMachine::GetTeleporterAddress() const
{
    QString aTeleporterAddress;
    AssertReturn(ptr(), aTeleporterAddress);
    mRC = ptr()->COMGETTER(TeleporterAddress)(BSTROut(aTeleporterAddress));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aTeleporterAddress;
}
void CMachine::SetTeleporterAddress(const QString & aTeleporterAddress)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(TeleporterAddress)(BSTRIn(aTeleporterAddress));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CMachine::GetTeleporterPassword() const
{
    QString aTeleporterPassword;
    AssertReturn(ptr(), aTeleporterPassword);
    mRC = ptr()->COMGETTER(TeleporterPassword)(BSTROut(aTeleporterPassword));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aTeleporterPassword;
}
void CMachine::SetTeleporterPassword(const QString & aTeleporterPassword)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(TeleporterPassword)(BSTRIn(aTeleporterPassword));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KFaultToleranceState CMachine::GetFaultToleranceState() const
{
    KFaultToleranceState aFaultToleranceState = (KFaultToleranceState) 0;
    AssertReturn(ptr(), aFaultToleranceState);
    mRC = ptr()->COMGETTER(FaultToleranceState)(ENUMOut<KFaultToleranceState, FaultToleranceState_T>(aFaultToleranceState));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFaultToleranceState;
}
void CMachine::SetFaultToleranceState(const KFaultToleranceState & aFaultToleranceState)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(FaultToleranceState)((FaultToleranceState_T) aFaultToleranceState);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CMachine::GetFaultTolerancePort() const
{
    ULONG aFaultTolerancePort = 0;
    AssertReturn(ptr(), aFaultTolerancePort);
    mRC = ptr()->COMGETTER(FaultTolerancePort)(&aFaultTolerancePort);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFaultTolerancePort;
}
void CMachine::SetFaultTolerancePort(ULONG aFaultTolerancePort)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(FaultTolerancePort)(aFaultTolerancePort);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CMachine::GetFaultToleranceAddress() const
{
    QString aFaultToleranceAddress;
    AssertReturn(ptr(), aFaultToleranceAddress);
    mRC = ptr()->COMGETTER(FaultToleranceAddress)(BSTROut(aFaultToleranceAddress));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFaultToleranceAddress;
}
void CMachine::SetFaultToleranceAddress(const QString & aFaultToleranceAddress)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(FaultToleranceAddress)(BSTRIn(aFaultToleranceAddress));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CMachine::GetFaultTolerancePassword() const
{
    QString aFaultTolerancePassword;
    AssertReturn(ptr(), aFaultTolerancePassword);
    mRC = ptr()->COMGETTER(FaultTolerancePassword)(BSTROut(aFaultTolerancePassword));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFaultTolerancePassword;
}
void CMachine::SetFaultTolerancePassword(const QString & aFaultTolerancePassword)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(FaultTolerancePassword)(BSTRIn(aFaultTolerancePassword));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CMachine::GetFaultToleranceSyncInterval() const
{
    ULONG aFaultToleranceSyncInterval = 0;
    AssertReturn(ptr(), aFaultToleranceSyncInterval);
    mRC = ptr()->COMGETTER(FaultToleranceSyncInterval)(&aFaultToleranceSyncInterval);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFaultToleranceSyncInterval;
}
void CMachine::SetFaultToleranceSyncInterval(ULONG aFaultToleranceSyncInterval)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(FaultToleranceSyncInterval)(aFaultToleranceSyncInterval);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachine::GetRTCUseUTC() const
{
    BOOL aRTCUseUTC = FALSE;
    AssertReturn(ptr(), aRTCUseUTC);
    mRC = ptr()->COMGETTER(RTCUseUTC)(&aRTCUseUTC);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRTCUseUTC;
}
void CMachine::SetRTCUseUTC(BOOL aRTCUseUTC)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(RTCUseUTC)(aRTCUseUTC);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachine::GetIOCacheEnabled() const
{
    BOOL aIOCacheEnabled = FALSE;
    AssertReturn(ptr(), aIOCacheEnabled);
    mRC = ptr()->COMGETTER(IOCacheEnabled)(&aIOCacheEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aIOCacheEnabled;
}
void CMachine::SetIOCacheEnabled(BOOL aIOCacheEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(IOCacheEnabled)(aIOCacheEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CMachine::GetIOCacheSize() const
{
    ULONG aIOCacheSize = 0;
    AssertReturn(ptr(), aIOCacheSize);
    mRC = ptr()->COMGETTER(IOCacheSize)(&aIOCacheSize);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aIOCacheSize;
}
void CMachine::SetIOCacheSize(ULONG aIOCacheSize)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(IOCacheSize)(aIOCacheSize);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QVector<CPCIDeviceAttachment> CMachine::GetPCIDeviceAssignments() const
{
    QVector<CPCIDeviceAttachment> aPCIDeviceAssignments;
    AssertReturn(ptr(), aPCIDeviceAssignments);
    com::SafeIfaceArray <IPCIDeviceAttachment> PCIDeviceAssignments;
    mRC = ptr()->COMGETTER(PCIDeviceAssignments)(ComSafeArrayAsOutParam(PCIDeviceAssignments));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(PCIDeviceAssignments, aPCIDeviceAssignments);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPCIDeviceAssignments;
}

CBandwidthControl CMachine::GetBandwidthControl() const
{
    CBandwidthControl aBandwidthControl;
    AssertReturn(ptr(), aBandwidthControl);
    IBandwidthControl* bandwidthControlPtr = NULL;
    mRC = ptr()->COMGETTER(BandwidthControl)(&bandwidthControlPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aBandwidthControl.setPtr(bandwidthControlPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBandwidthControl;
}

BOOL CMachine::GetTracingEnabled() const
{
    BOOL aTracingEnabled = FALSE;
    AssertReturn(ptr(), aTracingEnabled);
    mRC = ptr()->COMGETTER(TracingEnabled)(&aTracingEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aTracingEnabled;
}
void CMachine::SetTracingEnabled(BOOL aTracingEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(TracingEnabled)(aTracingEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CMachine::GetTracingConfig() const
{
    QString aTracingConfig;
    AssertReturn(ptr(), aTracingConfig);
    mRC = ptr()->COMGETTER(TracingConfig)(BSTROut(aTracingConfig));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aTracingConfig;
}
void CMachine::SetTracingConfig(const QString & aTracingConfig)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(TracingConfig)(BSTRIn(aTracingConfig));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachine::GetAllowTracingToAccessVM() const
{
    BOOL aAllowTracingToAccessVM = FALSE;
    AssertReturn(ptr(), aAllowTracingToAccessVM);
    mRC = ptr()->COMGETTER(AllowTracingToAccessVM)(&aAllowTracingToAccessVM);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAllowTracingToAccessVM;
}
void CMachine::SetAllowTracingToAccessVM(BOOL aAllowTracingToAccessVM)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(AllowTracingToAccessVM)(aAllowTracingToAccessVM);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachine::GetAutostartEnabled() const
{
    BOOL aAutostartEnabled = FALSE;
    AssertReturn(ptr(), aAutostartEnabled);
    mRC = ptr()->COMGETTER(AutostartEnabled)(&aAutostartEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAutostartEnabled;
}
void CMachine::SetAutostartEnabled(BOOL aAutostartEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(AutostartEnabled)(aAutostartEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CMachine::GetAutostartDelay() const
{
    ULONG aAutostartDelay = 0;
    AssertReturn(ptr(), aAutostartDelay);
    mRC = ptr()->COMGETTER(AutostartDelay)(&aAutostartDelay);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAutostartDelay;
}
void CMachine::SetAutostartDelay(ULONG aAutostartDelay)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(AutostartDelay)(aAutostartDelay);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KAutostopType CMachine::GetAutostopType() const
{
    KAutostopType aAutostopType = (KAutostopType) 0;
    AssertReturn(ptr(), aAutostopType);
    mRC = ptr()->COMGETTER(AutostopType)(ENUMOut<KAutostopType, AutostopType_T>(aAutostopType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAutostopType;
}
void CMachine::SetAutostopType(const KAutostopType & aAutostopType)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(AutostopType)((AutostopType_T) aAutostopType);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CMachine::GetDefaultFrontend() const
{
    QString aDefaultFrontend;
    AssertReturn(ptr(), aDefaultFrontend);
    mRC = ptr()->COMGETTER(DefaultFrontend)(BSTROut(aDefaultFrontend));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDefaultFrontend;
}
void CMachine::SetDefaultFrontend(const QString & aDefaultFrontend)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(DefaultFrontend)(BSTRIn(aDefaultFrontend));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachine::GetUSBProxyAvailable() const
{
    BOOL aUSBProxyAvailable = FALSE;
    AssertReturn(ptr(), aUSBProxyAvailable);
    mRC = ptr()->COMGETTER(USBProxyAvailable)(&aUSBProxyAvailable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUSBProxyAvailable;
}

void CMachine::LockMachine(const CSession & aSession, const KLockType & aLockType)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->LockMachine(aSession.ptr(), (LockType_T) aLockType);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CProgress CMachine::LaunchVMProcess(const CSession & aSession, const QString & aType, const QString & aEnvironment)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->LaunchVMProcess(aSession.ptr(), BSTRIn(aType), BSTRIn(aEnvironment), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

void CMachine::SetBootOrder(ULONG aPosition, const KDeviceType & aDevice)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetBootOrder(aPosition, (DeviceType_T) aDevice);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KDeviceType CMachine::GetBootOrder(ULONG aPosition) const
{
    KDeviceType aDevice = (KDeviceType) 0;
    AssertReturn(ptr(), aDevice);
    mRC = ptr()->GetBootOrder(aPosition, ENUMOut<KDeviceType, DeviceType_T>(aDevice));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDevice;
}

void CMachine::AttachDevice(const QString & aName, LONG aControllerPort, LONG aDevice, const KDeviceType & aType, const CMedium & aMedium)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->AttachDevice(BSTRIn(aName), aControllerPort, aDevice, (DeviceType_T) aType, aMedium.ptr());
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::AttachDeviceWithoutMedium(const QString & aName, LONG aControllerPort, LONG aDevice, const KDeviceType & aType)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->AttachDeviceWithoutMedium(BSTRIn(aName), aControllerPort, aDevice, (DeviceType_T) aType);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::DetachDevice(const QString & aName, LONG aControllerPort, LONG aDevice)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->DetachDevice(BSTRIn(aName), aControllerPort, aDevice);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::PassthroughDevice(const QString & aName, LONG aControllerPort, LONG aDevice, BOOL aPassthrough)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->PassthroughDevice(BSTRIn(aName), aControllerPort, aDevice, aPassthrough);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::TemporaryEjectDevice(const QString & aName, LONG aControllerPort, LONG aDevice, BOOL aTemporaryEject)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->TemporaryEjectDevice(BSTRIn(aName), aControllerPort, aDevice, aTemporaryEject);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::NonRotationalDevice(const QString & aName, LONG aControllerPort, LONG aDevice, BOOL aNonRotational)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->NonRotationalDevice(BSTRIn(aName), aControllerPort, aDevice, aNonRotational);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::SetAutoDiscardForDevice(const QString & aName, LONG aControllerPort, LONG aDevice, BOOL aDiscard)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetAutoDiscardForDevice(BSTRIn(aName), aControllerPort, aDevice, aDiscard);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::SetHotPluggableForDevice(const QString & aName, LONG aControllerPort, LONG aDevice, BOOL aHotPluggable)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetHotPluggableForDevice(BSTRIn(aName), aControllerPort, aDevice, aHotPluggable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::SetBandwidthGroupForDevice(const QString & aName, LONG aControllerPort, LONG aDevice, const CBandwidthGroup & aBandwidthGroup)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetBandwidthGroupForDevice(BSTRIn(aName), aControllerPort, aDevice, aBandwidthGroup.ptr());
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::SetNoBandwidthGroupForDevice(const QString & aName, LONG aControllerPort, LONG aDevice)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetNoBandwidthGroupForDevice(BSTRIn(aName), aControllerPort, aDevice);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::UnmountMedium(const QString & aName, LONG aControllerPort, LONG aDevice, BOOL aForce)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->UnmountMedium(BSTRIn(aName), aControllerPort, aDevice, aForce);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::MountMedium(const QString & aName, LONG aControllerPort, LONG aDevice, const CMedium & aMedium, BOOL aForce)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->MountMedium(BSTRIn(aName), aControllerPort, aDevice, aMedium.ptr(), aForce);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CMedium CMachine::GetMedium(const QString & aName, LONG aControllerPort, LONG aDevice) const
{
    CMedium aMedium;
    AssertReturn(ptr(), aMedium);
    IMedium* mediumPtr = NULL;
    mRC = ptr()->GetMedium(BSTRIn(aName), aControllerPort, aDevice, &mediumPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aMedium.setPtr(mediumPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMedium;
}

QVector<CMediumAttachment> CMachine::GetMediumAttachmentsOfController(const QString & aName) const
{
    QVector<CMediumAttachment> aMediumAttachments;
    AssertReturn(ptr(), aMediumAttachments);
    com::SafeIfaceArray <IMediumAttachment> mediumAttachments;
    mRC = ptr()->GetMediumAttachmentsOfController(BSTRIn(aName), ComSafeArrayAsOutParam(mediumAttachments));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(mediumAttachments, aMediumAttachments);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMediumAttachments;
}

CMediumAttachment CMachine::GetMediumAttachment(const QString & aName, LONG aControllerPort, LONG aDevice) const
{
    CMediumAttachment aAttachment;
    AssertReturn(ptr(), aAttachment);
    IMediumAttachment* attachmentPtr = NULL;
    mRC = ptr()->GetMediumAttachment(BSTRIn(aName), aControllerPort, aDevice, &attachmentPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aAttachment.setPtr(attachmentPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAttachment;
}

void CMachine::AttachHostPCIDevice(LONG aHostAddress, LONG aDesiredGuestAddress, BOOL aTryToUnbind)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->AttachHostPCIDevice(aHostAddress, aDesiredGuestAddress, aTryToUnbind);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::DetachHostPCIDevice(LONG aHostAddress)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->DetachHostPCIDevice(aHostAddress);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CNetworkAdapter CMachine::GetNetworkAdapter(ULONG aSlot) const
{
    CNetworkAdapter aAdapter;
    AssertReturn(ptr(), aAdapter);
    INetworkAdapter* adapterPtr = NULL;
    mRC = ptr()->GetNetworkAdapter(aSlot, &adapterPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aAdapter.setPtr(adapterPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAdapter;
}

CStorageController CMachine::AddStorageController(const QString & aName, const KStorageBus & aConnectionType)
{
    CStorageController aController;
    AssertReturn(ptr(), aController);
    IStorageController* controllerPtr = NULL;
    mRC = ptr()->AddStorageController(BSTRIn(aName), (StorageBus_T) aConnectionType, &controllerPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aController.setPtr(controllerPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aController;
}

CStorageController CMachine::GetStorageControllerByName(const QString & aName) const
{
    CStorageController aStorageController;
    AssertReturn(ptr(), aStorageController);
    IStorageController* storageControllerPtr = NULL;
    mRC = ptr()->GetStorageControllerByName(BSTRIn(aName), &storageControllerPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aStorageController.setPtr(storageControllerPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStorageController;
}

CStorageController CMachine::GetStorageControllerByInstance(ULONG aInstance) const
{
    CStorageController aStorageController;
    AssertReturn(ptr(), aStorageController);
    IStorageController* storageControllerPtr = NULL;
    mRC = ptr()->GetStorageControllerByInstance(aInstance, &storageControllerPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aStorageController.setPtr(storageControllerPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStorageController;
}

void CMachine::RemoveStorageController(const QString & aName)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->RemoveStorageController(BSTRIn(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::SetStorageControllerBootable(const QString & aName, BOOL aBootable)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetStorageControllerBootable(BSTRIn(aName), aBootable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CUSBController CMachine::AddUSBController(const QString & aName, const KUSBControllerType & aType)
{
    CUSBController aController;
    AssertReturn(ptr(), aController);
    IUSBController* controllerPtr = NULL;
    mRC = ptr()->AddUSBController(BSTRIn(aName), (USBControllerType_T) aType, &controllerPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aController.setPtr(controllerPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aController;
}

void CMachine::RemoveUSBController(const QString & aName)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->RemoveUSBController(BSTRIn(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CUSBController CMachine::GetUSBControllerByName(const QString & aName) const
{
    CUSBController aController;
    AssertReturn(ptr(), aController);
    IUSBController* controllerPtr = NULL;
    mRC = ptr()->GetUSBControllerByName(BSTRIn(aName), &controllerPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aController.setPtr(controllerPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aController;
}

ULONG CMachine::GetUSBControllerCountByType(const KUSBControllerType & aType) const
{
    ULONG aControllers = 0;
    AssertReturn(ptr(), aControllers);
    mRC = ptr()->GetUSBControllerCountByType((USBControllerType_T) aType, &aControllers);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aControllers;
}

CSerialPort CMachine::GetSerialPort(ULONG aSlot) const
{
    CSerialPort aPort;
    AssertReturn(ptr(), aPort);
    ISerialPort* portPtr = NULL;
    mRC = ptr()->GetSerialPort(aSlot, &portPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aPort.setPtr(portPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPort;
}

CParallelPort CMachine::GetParallelPort(ULONG aSlot) const
{
    CParallelPort aPort;
    AssertReturn(ptr(), aPort);
    IParallelPort* portPtr = NULL;
    mRC = ptr()->GetParallelPort(aSlot, &portPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aPort.setPtr(portPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPort;
}

QVector<QString> CMachine::GetExtraDataKeys()
{
    QVector<QString> aKeys;
    AssertReturn(ptr(), aKeys);
    com::SafeArray <BSTR> keys;
    mRC = ptr()->GetExtraDataKeys(ComSafeArrayAsOutParam(keys));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(keys, aKeys);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aKeys;
}

QString CMachine::GetExtraData(const QString & aKey)
{
    QString aValue;
    AssertReturn(ptr(), aValue);
    mRC = ptr()->GetExtraData(BSTRIn(aKey), BSTROut(aValue));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aValue;
}

void CMachine::SetExtraData(const QString & aKey, const QString & aValue)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetExtraData(BSTRIn(aKey), BSTRIn(aValue));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachine::GetCPUProperty(const KCPUPropertyType & aProperty) const
{
    BOOL aValue = FALSE;
    AssertReturn(ptr(), aValue);
    mRC = ptr()->GetCPUProperty((CPUPropertyType_T) aProperty, &aValue);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aValue;
}

void CMachine::SetCPUProperty(const KCPUPropertyType & aProperty, BOOL aValue)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetCPUProperty((CPUPropertyType_T) aProperty, aValue);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::GetCPUIDLeaf(ULONG aId, ULONG & aValEax, ULONG & aValEbx, ULONG & aValEcx, ULONG & aValEdx) const
{
    AssertReturnVoid(ptr());
    mRC = ptr()->GetCPUIDLeaf(aId, &aValEax, &aValEbx, &aValEcx, &aValEdx);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::SetCPUIDLeaf(ULONG aId, ULONG aValEax, ULONG aValEbx, ULONG aValEcx, ULONG aValEdx)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetCPUIDLeaf(aId, aValEax, aValEbx, aValEcx, aValEdx);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::RemoveCPUIDLeaf(ULONG aId)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->RemoveCPUIDLeaf(aId);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::RemoveAllCPUIDLeaves()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->RemoveAllCPUIDLeaves();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachine::GetHWVirtExProperty(const KHWVirtExPropertyType & aProperty) const
{
    BOOL aValue = FALSE;
    AssertReturn(ptr(), aValue);
    mRC = ptr()->GetHWVirtExProperty((HWVirtExPropertyType_T) aProperty, &aValue);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aValue;
}

void CMachine::SetHWVirtExProperty(const KHWVirtExPropertyType & aProperty, BOOL aValue)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetHWVirtExProperty((HWVirtExPropertyType_T) aProperty, aValue);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CProgress CMachine::SetSettingsFilePath(const QString & aSettingsFilePath)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->SetSettingsFilePath(BSTRIn(aSettingsFilePath), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

void CMachine::SaveSettings()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SaveSettings();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::DiscardSettings()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->DiscardSettings();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QVector<CMedium> CMachine::Unregister(const KCleanupMode & aCleanupMode)
{
    QVector<CMedium> aMedia;
    AssertReturn(ptr(), aMedia);
    com::SafeIfaceArray <IMedium> media;
    mRC = ptr()->Unregister((CleanupMode_T) aCleanupMode, ComSafeArrayAsOutParam(media));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(media, aMedia);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMedia;
}

CProgress CMachine::DeleteConfig(const QVector<CMedium> & aMedia)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    com::SafeIfaceArray <IMedium> media;
    ToSafeIfaceArray(aMedia, media);
    IProgress* progressPtr = NULL;
    mRC = ptr()->DeleteConfig(ComSafeArrayAsInParam(media), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CVirtualSystemDescription CMachine::ExportTo(const CAppliance & aAppliance, const QString & aLocation)
{
    CVirtualSystemDescription aDescription;
    AssertReturn(ptr(), aDescription);
    IVirtualSystemDescription* descriptionPtr = NULL;
    mRC = ptr()->ExportTo(aAppliance.ptr(), BSTRIn(aLocation), &descriptionPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aDescription.setPtr(descriptionPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDescription;
}

CSnapshot CMachine::FindSnapshot(const QString & aNameOrId)
{
    CSnapshot aSnapshot;
    AssertReturn(ptr(), aSnapshot);
    ISnapshot* snapshotPtr = NULL;
    mRC = ptr()->FindSnapshot(BSTRIn(aNameOrId), &snapshotPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSnapshot.setPtr(snapshotPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSnapshot;
}

void CMachine::CreateSharedFolder(const QString & aName, const QString & aHostPath, BOOL aWritable, BOOL aAutomount)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->CreateSharedFolder(BSTRIn(aName), BSTRIn(aHostPath), aWritable, aAutomount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::RemoveSharedFolder(const QString & aName)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->RemoveSharedFolder(BSTRIn(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachine::CanShowConsoleWindow()
{
    BOOL aCanShow = FALSE;
    AssertReturn(ptr(), aCanShow);
    mRC = ptr()->CanShowConsoleWindow(&aCanShow);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCanShow;
}

LONG64 CMachine::ShowConsoleWindow()
{
    LONG64 aWinId = 0;
    AssertReturn(ptr(), aWinId);
    mRC = ptr()->ShowConsoleWindow(&aWinId);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWinId;
}

void CMachine::GetGuestProperty(const QString & aName, QString & aValue, LONG64 & aTimestamp, QString & aFlags) const
{
    AssertReturnVoid(ptr());
    mRC = ptr()->GetGuestProperty(BSTRIn(aName), BSTROut(aValue), &aTimestamp, BSTROut(aFlags));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CMachine::GetGuestPropertyValue(const QString & aProperty) const
{
    QString aValue;
    AssertReturn(ptr(), aValue);
    mRC = ptr()->GetGuestPropertyValue(BSTRIn(aProperty), BSTROut(aValue));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aValue;
}

LONG64 CMachine::GetGuestPropertyTimestamp(const QString & aProperty) const
{
    LONG64 aValue = 0;
    AssertReturn(ptr(), aValue);
    mRC = ptr()->GetGuestPropertyTimestamp(BSTRIn(aProperty), &aValue);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aValue;
}

void CMachine::SetGuestProperty(const QString & aProperty, const QString & aValue, const QString & aFlags)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetGuestProperty(BSTRIn(aProperty), BSTRIn(aValue), BSTRIn(aFlags));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::SetGuestPropertyValue(const QString & aProperty, const QString & aValue)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetGuestPropertyValue(BSTRIn(aProperty), BSTRIn(aValue));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::DeleteGuestProperty(const QString & aName) const
{
    AssertReturnVoid(ptr());
    mRC = ptr()->DeleteGuestProperty(BSTRIn(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::EnumerateGuestProperties(const QString & aPatterns, QVector<QString> & aNames, QVector<QString> & aValues, QVector<LONG64> & aTimestamps, QVector<QString> & aFlags) const
{
    AssertReturnVoid(ptr());
    com::SafeArray <BSTR> names;
    com::SafeArray <BSTR> values;
    com::SafeArray <LONG64> timestamps;
    com::SafeArray <BSTR> flags;
    mRC = ptr()->EnumerateGuestProperties(BSTRIn(aPatterns), ComSafeArrayAsOutParam(names), ComSafeArrayAsOutParam(values), ComSafeArrayAsOutParam(timestamps), ComSafeArrayAsOutParam(flags));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(names, aNames);
    FromSafeArray(values, aValues);
    FromSafeArray(timestamps, aTimestamps);
    FromSafeArray(flags, aFlags);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::QuerySavedGuestScreenInfo(ULONG aScreenId, ULONG & aOriginX, ULONG & aOriginY, ULONG & aWidth, ULONG & aHeight, BOOL & aEnabled) const
{
    AssertReturnVoid(ptr());
    mRC = ptr()->QuerySavedGuestScreenInfo(aScreenId, &aOriginX, &aOriginY, &aWidth, &aHeight, &aEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::QuerySavedThumbnailSize(ULONG aScreenId, ULONG & aSize, ULONG & aWidth, ULONG & aHeight)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->QuerySavedThumbnailSize(aScreenId, &aSize, &aWidth, &aHeight);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QVector<BYTE> CMachine::ReadSavedThumbnailToArray(ULONG aScreenId, BOOL aBGR, ULONG & aWidth, ULONG & aHeight)
{
    QVector<BYTE> aData;
    AssertReturn(ptr(), aData);
    com::SafeArray <BYTE> data;
    mRC = ptr()->ReadSavedThumbnailToArray(aScreenId, aBGR, &aWidth, &aHeight, ComSafeArrayAsOutParam(data));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(data, aData);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aData;
}

QVector<BYTE> CMachine::ReadSavedThumbnailPNGToArray(ULONG aScreenId, ULONG & aWidth, ULONG & aHeight)
{
    QVector<BYTE> aData;
    AssertReturn(ptr(), aData);
    com::SafeArray <BYTE> data;
    mRC = ptr()->ReadSavedThumbnailPNGToArray(aScreenId, &aWidth, &aHeight, ComSafeArrayAsOutParam(data));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(data, aData);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aData;
}

void CMachine::QuerySavedScreenshotPNGSize(ULONG aScreenId, ULONG & aSize, ULONG & aWidth, ULONG & aHeight)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->QuerySavedScreenshotPNGSize(aScreenId, &aSize, &aWidth, &aHeight);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QVector<BYTE> CMachine::ReadSavedScreenshotPNGToArray(ULONG aScreenId, ULONG & aWidth, ULONG & aHeight)
{
    QVector<BYTE> aData;
    AssertReturn(ptr(), aData);
    com::SafeArray <BYTE> data;
    mRC = ptr()->ReadSavedScreenshotPNGToArray(aScreenId, &aWidth, &aHeight, ComSafeArrayAsOutParam(data));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(data, aData);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aData;
}

void CMachine::HotPlugCPU(ULONG aCpu)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->HotPlugCPU(aCpu);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachine::HotUnplugCPU(ULONG aCpu)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->HotUnplugCPU(aCpu);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachine::GetCPUStatus(ULONG aCpu)
{
    BOOL aAttached = FALSE;
    AssertReturn(ptr(), aAttached);
    mRC = ptr()->GetCPUStatus(aCpu, &aAttached);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAttached;
}

QString CMachine::QueryLogFilename(ULONG aIdx)
{
    QString aFilename;
    AssertReturn(ptr(), aFilename);
    mRC = ptr()->QueryLogFilename(aIdx, BSTROut(aFilename));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFilename;
}

QVector<BYTE> CMachine::ReadLog(ULONG aIdx, LONG64 aOffset, LONG64 aSize)
{
    QVector<BYTE> aData;
    AssertReturn(ptr(), aData);
    com::SafeArray <BYTE> data;
    mRC = ptr()->ReadLog(aIdx, aOffset, aSize, ComSafeArrayAsOutParam(data));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(data, aData);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aData;
}

CProgress CMachine::CloneTo(const CMachine & aTarget, const KCloneMode & aMode, const QVector<KCloneOptions> & aOptions)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    com::SafeArray <CloneOptions_T> options;
    ToSafeArray(aOptions, options);
    IProgress* progressPtr = NULL;
    mRC = ptr()->CloneTo(aTarget.ptr(), (CloneMode_T) aMode, ComSafeArrayAsInParam(options), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

/* ExtraData helpers: */
void CMachine::SetExtraDataBool(const QString &strKey, bool fValue)
{
    SetExtraData(strKey, fValue == true ? "true" : "false");
}

bool CMachine::GetExtraDataBool(const QString &strKey, bool fDef /* = true */)
{
    bool fResult = fDef;
    QString value = GetExtraData(strKey);
    if (   value == "true"
        || value == "on"
        || value == "yes")
        fResult = true;
    else if (   value == "false"
             || value == "off"
             || value == "no")
             fResult = false;
    return fResult;
}

void CMachine::SetExtraDataInt(const QString &strKey, int value)
{
    SetExtraData(strKey, QString::number(value));
}

int CMachine::GetExtraDataInt(const QString &strKey, int def /* = 0 */)
{
    QString value = GetExtraData(strKey);
    bool fOk;
    int result = value.toInt(&fOk);
    if (fOk)
        return result;
    return def;
}

void CMachine::SetExtraDataRect(const QString &strKey, const QRect &value)
{
    SetExtraData(strKey, QString("%1,%2,%3,%4")
                         .arg(value.x())
                         .arg(value.y())
                         .arg(value.width())
                         .arg(value.height()));
}

QRect CMachine::GetExtraDataRect(const QString &strKey, const QRect &def /* = QRect() */)
{
    QRect result = def;
    QList<int> intList = GetExtraDataIntList(strKey);
    if (intList.size() == 4)
    {
        result.setRect(intList.at(0),
                       intList.at(1),
                       intList.at(2),
                       intList.at(3));
    }
    return result;
}

void CMachine::SetExtraDataStringList(const QString &strKey, const QStringList &value)
{
    SetExtraData(strKey, value.join(","));
}

QStringList CMachine::GetExtraDataStringList(const QString &strKey, QStringList def /* = QStringList() */)
{
    QString strValue = GetExtraData(strKey);
    if (strValue.isEmpty())
        return def;
    else
        return strValue.split(",");
}

void CMachine::SetExtraDataIntList(const QString &strKey, const QList<int> &value)
{
    QStringList strList;
    for (int i=0; i < value.size(); ++i)
        strList << QString::number(value.at(i));
    SetExtraDataStringList(strKey, strList);
}

QList<int> CMachine::GetExtraDataIntList(const QString &strKey, QList<int> def /* = QList<int>() */)
{
    QStringList strList = GetExtraDataStringList(strKey);
    if (strList.size() > 0)
    {
        QList<int> intList;
        bool fOk;
        for (int i=0; i < strList.size(); ++i)
        {
            intList << strList.at(i).toInt(&fOk);
            if (!fOk)
                return def;
        }
        return intList;
    }
    return def;
}

// IEmulatedUSB wrapper

QVector<QString> CEmulatedUSB::GetWebcams() const
{
    QVector<QString> aWebcams;
    AssertReturn(ptr(), aWebcams);
    com::SafeArray <BSTR> webcams;
    mRC = ptr()->COMGETTER(Webcams)(ComSafeArrayAsOutParam(webcams));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(webcams, aWebcams);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWebcams;
}

void CEmulatedUSB::WebcamAttach(const QString & aPath, const QString & aSettings)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->WebcamAttach(BSTRIn(aPath), BSTRIn(aSettings));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CEmulatedUSB::WebcamDetach(const QString & aPath)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->WebcamDetach(BSTRIn(aPath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IVRDEServerInfo wrapper

BOOL CVRDEServerInfo::GetActive() const
{
    BOOL aActive = FALSE;
    AssertReturn(ptr(), aActive);
    mRC = ptr()->COMGETTER(Active)(&aActive);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aActive;
}

LONG CVRDEServerInfo::GetPort() const
{
    LONG aPort = 0;
    AssertReturn(ptr(), aPort);
    mRC = ptr()->COMGETTER(Port)(&aPort);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPort;
}

ULONG CVRDEServerInfo::GetNumberOfClients() const
{
    ULONG aNumberOfClients = 0;
    AssertReturn(ptr(), aNumberOfClients);
    mRC = ptr()->COMGETTER(NumberOfClients)(&aNumberOfClients);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNumberOfClients;
}

LONG64 CVRDEServerInfo::GetBeginTime() const
{
    LONG64 aBeginTime = 0;
    AssertReturn(ptr(), aBeginTime);
    mRC = ptr()->COMGETTER(BeginTime)(&aBeginTime);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBeginTime;
}

LONG64 CVRDEServerInfo::GetEndTime() const
{
    LONG64 aEndTime = 0;
    AssertReturn(ptr(), aEndTime);
    mRC = ptr()->COMGETTER(EndTime)(&aEndTime);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEndTime;
}

LONG64 CVRDEServerInfo::GetBytesSent() const
{
    LONG64 aBytesSent = 0;
    AssertReturn(ptr(), aBytesSent);
    mRC = ptr()->COMGETTER(BytesSent)(&aBytesSent);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBytesSent;
}

LONG64 CVRDEServerInfo::GetBytesSentTotal() const
{
    LONG64 aBytesSentTotal = 0;
    AssertReturn(ptr(), aBytesSentTotal);
    mRC = ptr()->COMGETTER(BytesSentTotal)(&aBytesSentTotal);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBytesSentTotal;
}

LONG64 CVRDEServerInfo::GetBytesReceived() const
{
    LONG64 aBytesReceived = 0;
    AssertReturn(ptr(), aBytesReceived);
    mRC = ptr()->COMGETTER(BytesReceived)(&aBytesReceived);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBytesReceived;
}

LONG64 CVRDEServerInfo::GetBytesReceivedTotal() const
{
    LONG64 aBytesReceivedTotal = 0;
    AssertReturn(ptr(), aBytesReceivedTotal);
    mRC = ptr()->COMGETTER(BytesReceivedTotal)(&aBytesReceivedTotal);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBytesReceivedTotal;
}

QString CVRDEServerInfo::GetUser() const
{
    QString aUser;
    AssertReturn(ptr(), aUser);
    mRC = ptr()->COMGETTER(User)(BSTROut(aUser));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUser;
}

QString CVRDEServerInfo::GetDomain() const
{
    QString aDomain;
    AssertReturn(ptr(), aDomain);
    mRC = ptr()->COMGETTER(Domain)(BSTROut(aDomain));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDomain;
}

QString CVRDEServerInfo::GetClientName() const
{
    QString aClientName;
    AssertReturn(ptr(), aClientName);
    mRC = ptr()->COMGETTER(ClientName)(BSTROut(aClientName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aClientName;
}

QString CVRDEServerInfo::GetClientIP() const
{
    QString aClientIP;
    AssertReturn(ptr(), aClientIP);
    mRC = ptr()->COMGETTER(ClientIP)(BSTROut(aClientIP));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aClientIP;
}

ULONG CVRDEServerInfo::GetClientVersion() const
{
    ULONG aClientVersion = 0;
    AssertReturn(ptr(), aClientVersion);
    mRC = ptr()->COMGETTER(ClientVersion)(&aClientVersion);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aClientVersion;
}

ULONG CVRDEServerInfo::GetEncryptionStyle() const
{
    ULONG aEncryptionStyle = 0;
    AssertReturn(ptr(), aEncryptionStyle);
    mRC = ptr()->COMGETTER(EncryptionStyle)(&aEncryptionStyle);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEncryptionStyle;
}

// IConsole wrapper

CMachine CConsole::GetMachine() const
{
    CMachine aMachine;
    AssertReturn(ptr(), aMachine);
    IMachine* machinePtr = NULL;
    mRC = ptr()->COMGETTER(Machine)(&machinePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aMachine.setPtr(machinePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachine;
}

KMachineState CConsole::GetState() const
{
    KMachineState aState = (KMachineState) 0;
    AssertReturn(ptr(), aState);
    mRC = ptr()->COMGETTER(State)(ENUMOut<KMachineState, MachineState_T>(aState));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aState;
}

CGuest CConsole::GetGuest() const
{
    CGuest aGuest;
    AssertReturn(ptr(), aGuest);
    IGuest* guestPtr = NULL;
    mRC = ptr()->COMGETTER(Guest)(&guestPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aGuest.setPtr(guestPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGuest;
}

CKeyboard CConsole::GetKeyboard() const
{
    CKeyboard aKeyboard;
    AssertReturn(ptr(), aKeyboard);
    IKeyboard* keyboardPtr = NULL;
    mRC = ptr()->COMGETTER(Keyboard)(&keyboardPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aKeyboard.setPtr(keyboardPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aKeyboard;
}

CMouse CConsole::GetMouse() const
{
    CMouse aMouse;
    AssertReturn(ptr(), aMouse);
    IMouse* mousePtr = NULL;
    mRC = ptr()->COMGETTER(Mouse)(&mousePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aMouse.setPtr(mousePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMouse;
}

CDisplay CConsole::GetDisplay() const
{
    CDisplay aDisplay;
    AssertReturn(ptr(), aDisplay);
    IDisplay* displayPtr = NULL;
    mRC = ptr()->COMGETTER(Display)(&displayPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aDisplay.setPtr(displayPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDisplay;
}

CMachineDebugger CConsole::GetDebugger() const
{
    CMachineDebugger aDebugger;
    AssertReturn(ptr(), aDebugger);
    IMachineDebugger* debuggerPtr = NULL;
    mRC = ptr()->COMGETTER(Debugger)(&debuggerPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aDebugger.setPtr(debuggerPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDebugger;
}

QVector<CUSBDevice> CConsole::GetUSBDevices() const
{
    QVector<CUSBDevice> aUSBDevices;
    AssertReturn(ptr(), aUSBDevices);
    com::SafeIfaceArray <IUSBDevice> USBDevices;
    mRC = ptr()->COMGETTER(USBDevices)(ComSafeArrayAsOutParam(USBDevices));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(USBDevices, aUSBDevices);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUSBDevices;
}

QVector<CHostUSBDevice> CConsole::GetRemoteUSBDevices() const
{
    QVector<CHostUSBDevice> aRemoteUSBDevices;
    AssertReturn(ptr(), aRemoteUSBDevices);
    com::SafeIfaceArray <IHostUSBDevice> remoteUSBDevices;
    mRC = ptr()->COMGETTER(RemoteUSBDevices)(ComSafeArrayAsOutParam(remoteUSBDevices));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(remoteUSBDevices, aRemoteUSBDevices);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRemoteUSBDevices;
}

QVector<CSharedFolder> CConsole::GetSharedFolders() const
{
    QVector<CSharedFolder> aSharedFolders;
    AssertReturn(ptr(), aSharedFolders);
    com::SafeIfaceArray <ISharedFolder> sharedFolders;
    mRC = ptr()->COMGETTER(SharedFolders)(ComSafeArrayAsOutParam(sharedFolders));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(sharedFolders, aSharedFolders);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSharedFolders;
}

CVRDEServerInfo CConsole::GetVRDEServerInfo() const
{
    CVRDEServerInfo aVRDEServerInfo;
    AssertReturn(ptr(), aVRDEServerInfo);
    IVRDEServerInfo* VRDEServerInfoPtr = NULL;
    mRC = ptr()->COMGETTER(VRDEServerInfo)(&VRDEServerInfoPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aVRDEServerInfo.setPtr(VRDEServerInfoPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVRDEServerInfo;
}

CEventSource CConsole::GetEventSource() const
{
    CEventSource aEventSource;
    AssertReturn(ptr(), aEventSource);
    IEventSource* eventSourcePtr = NULL;
    mRC = ptr()->COMGETTER(EventSource)(&eventSourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aEventSource.setPtr(eventSourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEventSource;
}

QVector<CPCIDeviceAttachment> CConsole::GetAttachedPCIDevices() const
{
    QVector<CPCIDeviceAttachment> aAttachedPCIDevices;
    AssertReturn(ptr(), aAttachedPCIDevices);
    com::SafeIfaceArray <IPCIDeviceAttachment> attachedPCIDevices;
    mRC = ptr()->COMGETTER(AttachedPCIDevices)(ComSafeArrayAsOutParam(attachedPCIDevices));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(attachedPCIDevices, aAttachedPCIDevices);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAttachedPCIDevices;
}

BOOL CConsole::GetUseHostClipboard() const
{
    BOOL aUseHostClipboard = FALSE;
    AssertReturn(ptr(), aUseHostClipboard);
    mRC = ptr()->COMGETTER(UseHostClipboard)(&aUseHostClipboard);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUseHostClipboard;
}
void CConsole::SetUseHostClipboard(BOOL aUseHostClipboard)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(UseHostClipboard)(aUseHostClipboard);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CEmulatedUSB CConsole::GetEmulatedUSB() const
{
    CEmulatedUSB aEmulatedUSB;
    AssertReturn(ptr(), aEmulatedUSB);
    IEmulatedUSB* emulatedUSBPtr = NULL;
    mRC = ptr()->COMGETTER(EmulatedUSB)(&emulatedUSBPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aEmulatedUSB.setPtr(emulatedUSBPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEmulatedUSB;
}

CProgress CConsole::PowerUp()
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->PowerUp(&progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CProgress CConsole::PowerUpPaused()
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->PowerUpPaused(&progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CProgress CConsole::PowerDown()
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->PowerDown(&progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

void CConsole::Reset()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Reset();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CConsole::Pause()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Pause();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CConsole::Resume()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Resume();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CConsole::PowerButton()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->PowerButton();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CConsole::SleepButton()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SleepButton();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CConsole::GetPowerButtonHandled()
{
    BOOL aHandled = FALSE;
    AssertReturn(ptr(), aHandled);
    mRC = ptr()->GetPowerButtonHandled(&aHandled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHandled;
}

BOOL CConsole::GetGuestEnteredACPIMode()
{
    BOOL aEntered = FALSE;
    AssertReturn(ptr(), aEntered);
    mRC = ptr()->GetGuestEnteredACPIMode(&aEntered);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEntered;
}

CProgress CConsole::SaveState()
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->SaveState(&progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

void CConsole::AdoptSavedState(const QString & aSavedStateFile)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->AdoptSavedState(BSTRIn(aSavedStateFile));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CConsole::DiscardSavedState(BOOL aFRemoveFile)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->DiscardSavedState(aFRemoveFile);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KDeviceActivity CConsole::GetDeviceActivity(const KDeviceType & aType)
{
    KDeviceActivity aActivity = (KDeviceActivity) 0;
    AssertReturn(ptr(), aActivity);
    mRC = ptr()->GetDeviceActivity((DeviceType_T) aType, ENUMOut<KDeviceActivity, DeviceActivity_T>(aActivity));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aActivity;
}

void CConsole::AttachUSBDevice(QString aId)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->AttachUSBDevice(BSTRIn(aId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CUSBDevice CConsole::DetachUSBDevice(QString aId)
{
    CUSBDevice aDevice;
    AssertReturn(ptr(), aDevice);
    IUSBDevice* devicePtr = NULL;
    mRC = ptr()->DetachUSBDevice(BSTRIn(aId), &devicePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aDevice.setPtr(devicePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDevice;
}

CUSBDevice CConsole::FindUSBDeviceByAddress(const QString & aName)
{
    CUSBDevice aDevice;
    AssertReturn(ptr(), aDevice);
    IUSBDevice* devicePtr = NULL;
    mRC = ptr()->FindUSBDeviceByAddress(BSTRIn(aName), &devicePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aDevice.setPtr(devicePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDevice;
}

CUSBDevice CConsole::FindUSBDeviceById(QString aId)
{
    CUSBDevice aDevice;
    AssertReturn(ptr(), aDevice);
    IUSBDevice* devicePtr = NULL;
    mRC = ptr()->FindUSBDeviceById(BSTRIn(aId), &devicePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aDevice.setPtr(devicePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDevice;
}

void CConsole::CreateSharedFolder(const QString & aName, const QString & aHostPath, BOOL aWritable, BOOL aAutomount)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->CreateSharedFolder(BSTRIn(aName), BSTRIn(aHostPath), aWritable, aAutomount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CConsole::RemoveSharedFolder(const QString & aName)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->RemoveSharedFolder(BSTRIn(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CProgress CConsole::TakeSnapshot(const QString & aName, const QString & aDescription)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->TakeSnapshot(BSTRIn(aName), BSTRIn(aDescription), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CProgress CConsole::DeleteSnapshot(QString aId)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->DeleteSnapshot(BSTRIn(aId), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CProgress CConsole::DeleteSnapshotAndAllChildren(QString aId)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->DeleteSnapshotAndAllChildren(BSTRIn(aId), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CProgress CConsole::DeleteSnapshotRange(QString aStartId, QString aEndId)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->DeleteSnapshotRange(BSTRIn(aStartId), BSTRIn(aEndId), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CProgress CConsole::RestoreSnapshot(const CSnapshot & aSnapshot)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->RestoreSnapshot(aSnapshot.ptr(), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CProgress CConsole::Teleport(const QString & aHostname, ULONG aTcpport, const QString & aPassword, ULONG aMaxDowntime)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->Teleport(BSTRIn(aHostname), aTcpport, BSTRIn(aPassword), aMaxDowntime, &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

// IHostNetworkInterface wrapper

QString CHostNetworkInterface::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

QString CHostNetworkInterface::GetShortName() const
{
    QString aShortName;
    AssertReturn(ptr(), aShortName);
    mRC = ptr()->COMGETTER(ShortName)(BSTROut(aShortName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aShortName;
}

QString CHostNetworkInterface::GetId() const
{
    QString aId;
    AssertReturn(ptr(), aId);
    mRC = ptr()->COMGETTER(Id)(BSTROut(aId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aId;
}

QString CHostNetworkInterface::GetNetworkName() const
{
    QString aNetworkName;
    AssertReturn(ptr(), aNetworkName);
    mRC = ptr()->COMGETTER(NetworkName)(BSTROut(aNetworkName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNetworkName;
}

BOOL CHostNetworkInterface::GetDHCPEnabled() const
{
    BOOL aDHCPEnabled = FALSE;
    AssertReturn(ptr(), aDHCPEnabled);
    mRC = ptr()->COMGETTER(DHCPEnabled)(&aDHCPEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDHCPEnabled;
}

QString CHostNetworkInterface::GetIPAddress() const
{
    QString aIPAddress;
    AssertReturn(ptr(), aIPAddress);
    mRC = ptr()->COMGETTER(IPAddress)(BSTROut(aIPAddress));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aIPAddress;
}

QString CHostNetworkInterface::GetNetworkMask() const
{
    QString aNetworkMask;
    AssertReturn(ptr(), aNetworkMask);
    mRC = ptr()->COMGETTER(NetworkMask)(BSTROut(aNetworkMask));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNetworkMask;
}

BOOL CHostNetworkInterface::GetIPV6Supported() const
{
    BOOL aIPV6Supported = FALSE;
    AssertReturn(ptr(), aIPV6Supported);
    mRC = ptr()->COMGETTER(IPV6Supported)(&aIPV6Supported);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aIPV6Supported;
}

QString CHostNetworkInterface::GetIPV6Address() const
{
    QString aIPV6Address;
    AssertReturn(ptr(), aIPV6Address);
    mRC = ptr()->COMGETTER(IPV6Address)(BSTROut(aIPV6Address));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aIPV6Address;
}

ULONG CHostNetworkInterface::GetIPV6NetworkMaskPrefixLength() const
{
    ULONG aIPV6NetworkMaskPrefixLength = 0;
    AssertReturn(ptr(), aIPV6NetworkMaskPrefixLength);
    mRC = ptr()->COMGETTER(IPV6NetworkMaskPrefixLength)(&aIPV6NetworkMaskPrefixLength);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aIPV6NetworkMaskPrefixLength;
}

QString CHostNetworkInterface::GetHardwareAddress() const
{
    QString aHardwareAddress;
    AssertReturn(ptr(), aHardwareAddress);
    mRC = ptr()->COMGETTER(HardwareAddress)(BSTROut(aHardwareAddress));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHardwareAddress;
}

KHostNetworkInterfaceMediumType CHostNetworkInterface::GetMediumType() const
{
    KHostNetworkInterfaceMediumType aMediumType = (KHostNetworkInterfaceMediumType) 0;
    AssertReturn(ptr(), aMediumType);
    mRC = ptr()->COMGETTER(MediumType)(ENUMOut<KHostNetworkInterfaceMediumType, HostNetworkInterfaceMediumType_T>(aMediumType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMediumType;
}

KHostNetworkInterfaceStatus CHostNetworkInterface::GetStatus() const
{
    KHostNetworkInterfaceStatus aStatus = (KHostNetworkInterfaceStatus) 0;
    AssertReturn(ptr(), aStatus);
    mRC = ptr()->COMGETTER(Status)(ENUMOut<KHostNetworkInterfaceStatus, HostNetworkInterfaceStatus_T>(aStatus));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStatus;
}

KHostNetworkInterfaceType CHostNetworkInterface::GetInterfaceType() const
{
    KHostNetworkInterfaceType aInterfaceType = (KHostNetworkInterfaceType) 0;
    AssertReturn(ptr(), aInterfaceType);
    mRC = ptr()->COMGETTER(InterfaceType)(ENUMOut<KHostNetworkInterfaceType, HostNetworkInterfaceType_T>(aInterfaceType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aInterfaceType;
}

void CHostNetworkInterface::EnableStaticIPConfig(const QString & aIPAddress, const QString & aNetworkMask)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->EnableStaticIPConfig(BSTRIn(aIPAddress), BSTRIn(aNetworkMask));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CHostNetworkInterface::EnableStaticIPConfigV6(const QString & aIPV6Address, ULONG aIPV6NetworkMaskPrefixLength)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->EnableStaticIPConfigV6(BSTRIn(aIPV6Address), aIPV6NetworkMaskPrefixLength);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CHostNetworkInterface::EnableDynamicIPConfig()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->EnableDynamicIPConfig();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CHostNetworkInterface::DHCPRediscover()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->DHCPRediscover();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IHostVideoInputDevice wrapper

QString CHostVideoInputDevice::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

QString CHostVideoInputDevice::GetPath() const
{
    QString aPath;
    AssertReturn(ptr(), aPath);
    mRC = ptr()->COMGETTER(Path)(BSTROut(aPath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPath;
}

QString CHostVideoInputDevice::GetAlias() const
{
    QString aAlias;
    AssertReturn(ptr(), aAlias);
    mRC = ptr()->COMGETTER(Alias)(BSTROut(aAlias));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAlias;
}

// IHost wrapper

QVector<CMedium> CHost::GetDVDDrives() const
{
    QVector<CMedium> aDVDDrives;
    AssertReturn(ptr(), aDVDDrives);
    com::SafeIfaceArray <IMedium> DVDDrives;
    mRC = ptr()->COMGETTER(DVDDrives)(ComSafeArrayAsOutParam(DVDDrives));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(DVDDrives, aDVDDrives);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDVDDrives;
}

QVector<CMedium> CHost::GetFloppyDrives() const
{
    QVector<CMedium> aFloppyDrives;
    AssertReturn(ptr(), aFloppyDrives);
    com::SafeIfaceArray <IMedium> floppyDrives;
    mRC = ptr()->COMGETTER(FloppyDrives)(ComSafeArrayAsOutParam(floppyDrives));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(floppyDrives, aFloppyDrives);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFloppyDrives;
}

QVector<CHostUSBDevice> CHost::GetUSBDevices() const
{
    QVector<CHostUSBDevice> aUSBDevices;
    AssertReturn(ptr(), aUSBDevices);
    com::SafeIfaceArray <IHostUSBDevice> USBDevices;
    mRC = ptr()->COMGETTER(USBDevices)(ComSafeArrayAsOutParam(USBDevices));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(USBDevices, aUSBDevices);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUSBDevices;
}

QVector<CHostUSBDeviceFilter> CHost::GetUSBDeviceFilters() const
{
    QVector<CHostUSBDeviceFilter> aUSBDeviceFilters;
    AssertReturn(ptr(), aUSBDeviceFilters);
    com::SafeIfaceArray <IHostUSBDeviceFilter> USBDeviceFilters;
    mRC = ptr()->COMGETTER(USBDeviceFilters)(ComSafeArrayAsOutParam(USBDeviceFilters));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(USBDeviceFilters, aUSBDeviceFilters);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUSBDeviceFilters;
}

QVector<CHostNetworkInterface> CHost::GetNetworkInterfaces() const
{
    QVector<CHostNetworkInterface> aNetworkInterfaces;
    AssertReturn(ptr(), aNetworkInterfaces);
    com::SafeIfaceArray <IHostNetworkInterface> networkInterfaces;
    mRC = ptr()->COMGETTER(NetworkInterfaces)(ComSafeArrayAsOutParam(networkInterfaces));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(networkInterfaces, aNetworkInterfaces);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNetworkInterfaces;
}

QVector<QString> CHost::GetNameServers() const
{
    QVector<QString> aNameServers;
    AssertReturn(ptr(), aNameServers);
    com::SafeArray <BSTR> nameServers;
    mRC = ptr()->COMGETTER(NameServers)(ComSafeArrayAsOutParam(nameServers));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(nameServers, aNameServers);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNameServers;
}

QString CHost::GetDomainName() const
{
    QString aDomainName;
    AssertReturn(ptr(), aDomainName);
    mRC = ptr()->COMGETTER(DomainName)(BSTROut(aDomainName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDomainName;
}

QVector<QString> CHost::GetSearchStrings() const
{
    QVector<QString> aSearchStrings;
    AssertReturn(ptr(), aSearchStrings);
    com::SafeArray <BSTR> searchStrings;
    mRC = ptr()->COMGETTER(SearchStrings)(ComSafeArrayAsOutParam(searchStrings));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(searchStrings, aSearchStrings);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSearchStrings;
}

ULONG CHost::GetProcessorCount() const
{
    ULONG aProcessorCount = 0;
    AssertReturn(ptr(), aProcessorCount);
    mRC = ptr()->COMGETTER(ProcessorCount)(&aProcessorCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProcessorCount;
}

ULONG CHost::GetProcessorOnlineCount() const
{
    ULONG aProcessorOnlineCount = 0;
    AssertReturn(ptr(), aProcessorOnlineCount);
    mRC = ptr()->COMGETTER(ProcessorOnlineCount)(&aProcessorOnlineCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProcessorOnlineCount;
}

ULONG CHost::GetProcessorCoreCount() const
{
    ULONG aProcessorCoreCount = 0;
    AssertReturn(ptr(), aProcessorCoreCount);
    mRC = ptr()->COMGETTER(ProcessorCoreCount)(&aProcessorCoreCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProcessorCoreCount;
}

ULONG CHost::GetProcessorOnlineCoreCount() const
{
    ULONG aProcessorOnlineCoreCount = 0;
    AssertReturn(ptr(), aProcessorOnlineCoreCount);
    mRC = ptr()->COMGETTER(ProcessorOnlineCoreCount)(&aProcessorOnlineCoreCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProcessorOnlineCoreCount;
}

ULONG CHost::GetMemorySize() const
{
    ULONG aMemorySize = 0;
    AssertReturn(ptr(), aMemorySize);
    mRC = ptr()->COMGETTER(MemorySize)(&aMemorySize);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMemorySize;
}

ULONG CHost::GetMemoryAvailable() const
{
    ULONG aMemoryAvailable = 0;
    AssertReturn(ptr(), aMemoryAvailable);
    mRC = ptr()->COMGETTER(MemoryAvailable)(&aMemoryAvailable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMemoryAvailable;
}

QString CHost::GetOperatingSystem() const
{
    QString aOperatingSystem;
    AssertReturn(ptr(), aOperatingSystem);
    mRC = ptr()->COMGETTER(OperatingSystem)(BSTROut(aOperatingSystem));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOperatingSystem;
}

QString CHost::GetOSVersion() const
{
    QString aOSVersion;
    AssertReturn(ptr(), aOSVersion);
    mRC = ptr()->COMGETTER(OSVersion)(BSTROut(aOSVersion));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOSVersion;
}

LONG64 CHost::GetUTCTime() const
{
    LONG64 aUTCTime = 0;
    AssertReturn(ptr(), aUTCTime);
    mRC = ptr()->COMGETTER(UTCTime)(&aUTCTime);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUTCTime;
}

BOOL CHost::GetAcceleration3DAvailable() const
{
    BOOL aAcceleration3DAvailable = FALSE;
    AssertReturn(ptr(), aAcceleration3DAvailable);
    mRC = ptr()->COMGETTER(Acceleration3DAvailable)(&aAcceleration3DAvailable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAcceleration3DAvailable;
}

QVector<CHostVideoInputDevice> CHost::GetVideoInputDevices() const
{
    QVector<CHostVideoInputDevice> aVideoInputDevices;
    AssertReturn(ptr(), aVideoInputDevices);
    com::SafeIfaceArray <IHostVideoInputDevice> videoInputDevices;
    mRC = ptr()->COMGETTER(VideoInputDevices)(ComSafeArrayAsOutParam(videoInputDevices));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(videoInputDevices, aVideoInputDevices);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVideoInputDevices;
}

ULONG CHost::GetProcessorSpeed(ULONG aCpuId)
{
    ULONG aSpeed = 0;
    AssertReturn(ptr(), aSpeed);
    mRC = ptr()->GetProcessorSpeed(aCpuId, &aSpeed);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSpeed;
}

BOOL CHost::GetProcessorFeature(const KProcessorFeature & aFeature)
{
    BOOL aSupported = FALSE;
    AssertReturn(ptr(), aSupported);
    mRC = ptr()->GetProcessorFeature((ProcessorFeature_T) aFeature, &aSupported);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSupported;
}

QString CHost::GetProcessorDescription(ULONG aCpuId)
{
    QString aDescription;
    AssertReturn(ptr(), aDescription);
    mRC = ptr()->GetProcessorDescription(aCpuId, BSTROut(aDescription));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDescription;
}

void CHost::GetProcessorCPUIDLeaf(ULONG aCpuId, ULONG aLeaf, ULONG aSubLeaf, ULONG & aValEax, ULONG & aValEbx, ULONG & aValEcx, ULONG & aValEdx)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->GetProcessorCPUIDLeaf(aCpuId, aLeaf, aSubLeaf, &aValEax, &aValEbx, &aValEcx, &aValEdx);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CProgress CHost::CreateHostOnlyNetworkInterface(CHostNetworkInterface & aHostInterface)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IHostNetworkInterface* hostInterfacePtr = NULL;
    IProgress* progressPtr = NULL;
    mRC = ptr()->CreateHostOnlyNetworkInterface(&hostInterfacePtr, &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aHostInterface.setPtr(hostInterfacePtr);
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CProgress CHost::RemoveHostOnlyNetworkInterface(QString aId)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->RemoveHostOnlyNetworkInterface(BSTRIn(aId), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CHostUSBDeviceFilter CHost::CreateUSBDeviceFilter(const QString & aName)
{
    CHostUSBDeviceFilter aFilter;
    AssertReturn(ptr(), aFilter);
    IHostUSBDeviceFilter* filterPtr = NULL;
    mRC = ptr()->CreateUSBDeviceFilter(BSTRIn(aName), &filterPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aFilter.setPtr(filterPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFilter;
}

void CHost::InsertUSBDeviceFilter(ULONG aPosition, const CHostUSBDeviceFilter & aFilter)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->InsertUSBDeviceFilter(aPosition, aFilter.ptr());
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CHost::RemoveUSBDeviceFilter(ULONG aPosition)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->RemoveUSBDeviceFilter(aPosition);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CMedium CHost::FindHostDVDDrive(const QString & aName)
{
    CMedium aDrive;
    AssertReturn(ptr(), aDrive);
    IMedium* drivePtr = NULL;
    mRC = ptr()->FindHostDVDDrive(BSTRIn(aName), &drivePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aDrive.setPtr(drivePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDrive;
}

CMedium CHost::FindHostFloppyDrive(const QString & aName)
{
    CMedium aDrive;
    AssertReturn(ptr(), aDrive);
    IMedium* drivePtr = NULL;
    mRC = ptr()->FindHostFloppyDrive(BSTRIn(aName), &drivePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aDrive.setPtr(drivePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDrive;
}

CHostNetworkInterface CHost::FindHostNetworkInterfaceByName(const QString & aName)
{
    CHostNetworkInterface aNetworkInterface;
    AssertReturn(ptr(), aNetworkInterface);
    IHostNetworkInterface* networkInterfacePtr = NULL;
    mRC = ptr()->FindHostNetworkInterfaceByName(BSTRIn(aName), &networkInterfacePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aNetworkInterface.setPtr(networkInterfacePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNetworkInterface;
}

CHostNetworkInterface CHost::FindHostNetworkInterfaceById(QString aId)
{
    CHostNetworkInterface aNetworkInterface;
    AssertReturn(ptr(), aNetworkInterface);
    IHostNetworkInterface* networkInterfacePtr = NULL;
    mRC = ptr()->FindHostNetworkInterfaceById(BSTRIn(aId), &networkInterfacePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aNetworkInterface.setPtr(networkInterfacePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNetworkInterface;
}

QVector<CHostNetworkInterface> CHost::FindHostNetworkInterfacesOfType(const KHostNetworkInterfaceType & aType)
{
    QVector<CHostNetworkInterface> aNetworkInterfaces;
    AssertReturn(ptr(), aNetworkInterfaces);
    com::SafeIfaceArray <IHostNetworkInterface> networkInterfaces;
    mRC = ptr()->FindHostNetworkInterfacesOfType((HostNetworkInterfaceType_T) aType, ComSafeArrayAsOutParam(networkInterfaces));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(networkInterfaces, aNetworkInterfaces);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNetworkInterfaces;
}

CHostUSBDevice CHost::FindUSBDeviceById(QString aId)
{
    CHostUSBDevice aDevice;
    AssertReturn(ptr(), aDevice);
    IHostUSBDevice* devicePtr = NULL;
    mRC = ptr()->FindUSBDeviceById(BSTRIn(aId), &devicePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aDevice.setPtr(devicePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDevice;
}

CHostUSBDevice CHost::FindUSBDeviceByAddress(const QString & aName)
{
    CHostUSBDevice aDevice;
    AssertReturn(ptr(), aDevice);
    IHostUSBDevice* devicePtr = NULL;
    mRC = ptr()->FindUSBDeviceByAddress(BSTRIn(aName), &devicePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aDevice.setPtr(devicePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDevice;
}

QString CHost::GenerateMACAddress()
{
    QString aAddress;
    AssertReturn(ptr(), aAddress);
    mRC = ptr()->GenerateMACAddress(BSTROut(aAddress));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAddress;
}

// ISystemProperties wrapper

ULONG CSystemProperties::GetMinGuestRAM() const
{
    ULONG aMinGuestRAM = 0;
    AssertReturn(ptr(), aMinGuestRAM);
    mRC = ptr()->COMGETTER(MinGuestRAM)(&aMinGuestRAM);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMinGuestRAM;
}

ULONG CSystemProperties::GetMaxGuestRAM() const
{
    ULONG aMaxGuestRAM = 0;
    AssertReturn(ptr(), aMaxGuestRAM);
    mRC = ptr()->COMGETTER(MaxGuestRAM)(&aMaxGuestRAM);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMaxGuestRAM;
}

ULONG CSystemProperties::GetMinGuestVRAM() const
{
    ULONG aMinGuestVRAM = 0;
    AssertReturn(ptr(), aMinGuestVRAM);
    mRC = ptr()->COMGETTER(MinGuestVRAM)(&aMinGuestVRAM);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMinGuestVRAM;
}

ULONG CSystemProperties::GetMaxGuestVRAM() const
{
    ULONG aMaxGuestVRAM = 0;
    AssertReturn(ptr(), aMaxGuestVRAM);
    mRC = ptr()->COMGETTER(MaxGuestVRAM)(&aMaxGuestVRAM);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMaxGuestVRAM;
}

ULONG CSystemProperties::GetMinGuestCPUCount() const
{
    ULONG aMinGuestCPUCount = 0;
    AssertReturn(ptr(), aMinGuestCPUCount);
    mRC = ptr()->COMGETTER(MinGuestCPUCount)(&aMinGuestCPUCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMinGuestCPUCount;
}

ULONG CSystemProperties::GetMaxGuestCPUCount() const
{
    ULONG aMaxGuestCPUCount = 0;
    AssertReturn(ptr(), aMaxGuestCPUCount);
    mRC = ptr()->COMGETTER(MaxGuestCPUCount)(&aMaxGuestCPUCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMaxGuestCPUCount;
}

ULONG CSystemProperties::GetMaxGuestMonitors() const
{
    ULONG aMaxGuestMonitors = 0;
    AssertReturn(ptr(), aMaxGuestMonitors);
    mRC = ptr()->COMGETTER(MaxGuestMonitors)(&aMaxGuestMonitors);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMaxGuestMonitors;
}

LONG64 CSystemProperties::GetInfoVDSize() const
{
    LONG64 aInfoVDSize = 0;
    AssertReturn(ptr(), aInfoVDSize);
    mRC = ptr()->COMGETTER(InfoVDSize)(&aInfoVDSize);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aInfoVDSize;
}

ULONG CSystemProperties::GetSerialPortCount() const
{
    ULONG aSerialPortCount = 0;
    AssertReturn(ptr(), aSerialPortCount);
    mRC = ptr()->COMGETTER(SerialPortCount)(&aSerialPortCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSerialPortCount;
}

ULONG CSystemProperties::GetParallelPortCount() const
{
    ULONG aParallelPortCount = 0;
    AssertReturn(ptr(), aParallelPortCount);
    mRC = ptr()->COMGETTER(ParallelPortCount)(&aParallelPortCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aParallelPortCount;
}

ULONG CSystemProperties::GetMaxBootPosition() const
{
    ULONG aMaxBootPosition = 0;
    AssertReturn(ptr(), aMaxBootPosition);
    mRC = ptr()->COMGETTER(MaxBootPosition)(&aMaxBootPosition);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMaxBootPosition;
}

BOOL CSystemProperties::GetExclusiveHwVirt() const
{
    BOOL aExclusiveHwVirt = FALSE;
    AssertReturn(ptr(), aExclusiveHwVirt);
    mRC = ptr()->COMGETTER(ExclusiveHwVirt)(&aExclusiveHwVirt);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aExclusiveHwVirt;
}
void CSystemProperties::SetExclusiveHwVirt(BOOL aExclusiveHwVirt)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(ExclusiveHwVirt)(aExclusiveHwVirt);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CSystemProperties::GetDefaultMachineFolder() const
{
    QString aDefaultMachineFolder;
    AssertReturn(ptr(), aDefaultMachineFolder);
    mRC = ptr()->COMGETTER(DefaultMachineFolder)(BSTROut(aDefaultMachineFolder));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDefaultMachineFolder;
}
void CSystemProperties::SetDefaultMachineFolder(const QString & aDefaultMachineFolder)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(DefaultMachineFolder)(BSTRIn(aDefaultMachineFolder));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CSystemProperties::GetLoggingLevel() const
{
    QString aLoggingLevel;
    AssertReturn(ptr(), aLoggingLevel);
    mRC = ptr()->COMGETTER(LoggingLevel)(BSTROut(aLoggingLevel));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLoggingLevel;
}
void CSystemProperties::SetLoggingLevel(const QString & aLoggingLevel)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(LoggingLevel)(BSTRIn(aLoggingLevel));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QVector<CMediumFormat> CSystemProperties::GetMediumFormats() const
{
    QVector<CMediumFormat> aMediumFormats;
    AssertReturn(ptr(), aMediumFormats);
    com::SafeIfaceArray <IMediumFormat> mediumFormats;
    mRC = ptr()->COMGETTER(MediumFormats)(ComSafeArrayAsOutParam(mediumFormats));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(mediumFormats, aMediumFormats);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMediumFormats;
}

QString CSystemProperties::GetDefaultHardDiskFormat() const
{
    QString aDefaultHardDiskFormat;
    AssertReturn(ptr(), aDefaultHardDiskFormat);
    mRC = ptr()->COMGETTER(DefaultHardDiskFormat)(BSTROut(aDefaultHardDiskFormat));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDefaultHardDiskFormat;
}
void CSystemProperties::SetDefaultHardDiskFormat(const QString & aDefaultHardDiskFormat)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(DefaultHardDiskFormat)(BSTRIn(aDefaultHardDiskFormat));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

LONG64 CSystemProperties::GetFreeDiskSpaceWarning() const
{
    LONG64 aFreeDiskSpaceWarning = 0;
    AssertReturn(ptr(), aFreeDiskSpaceWarning);
    mRC = ptr()->COMGETTER(FreeDiskSpaceWarning)(&aFreeDiskSpaceWarning);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFreeDiskSpaceWarning;
}
void CSystemProperties::SetFreeDiskSpaceWarning(LONG64 aFreeDiskSpaceWarning)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(FreeDiskSpaceWarning)(aFreeDiskSpaceWarning);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CSystemProperties::GetFreeDiskSpacePercentWarning() const
{
    ULONG aFreeDiskSpacePercentWarning = 0;
    AssertReturn(ptr(), aFreeDiskSpacePercentWarning);
    mRC = ptr()->COMGETTER(FreeDiskSpacePercentWarning)(&aFreeDiskSpacePercentWarning);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFreeDiskSpacePercentWarning;
}
void CSystemProperties::SetFreeDiskSpacePercentWarning(ULONG aFreeDiskSpacePercentWarning)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(FreeDiskSpacePercentWarning)(aFreeDiskSpacePercentWarning);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

LONG64 CSystemProperties::GetFreeDiskSpaceError() const
{
    LONG64 aFreeDiskSpaceError = 0;
    AssertReturn(ptr(), aFreeDiskSpaceError);
    mRC = ptr()->COMGETTER(FreeDiskSpaceError)(&aFreeDiskSpaceError);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFreeDiskSpaceError;
}
void CSystemProperties::SetFreeDiskSpaceError(LONG64 aFreeDiskSpaceError)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(FreeDiskSpaceError)(aFreeDiskSpaceError);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CSystemProperties::GetFreeDiskSpacePercentError() const
{
    ULONG aFreeDiskSpacePercentError = 0;
    AssertReturn(ptr(), aFreeDiskSpacePercentError);
    mRC = ptr()->COMGETTER(FreeDiskSpacePercentError)(&aFreeDiskSpacePercentError);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFreeDiskSpacePercentError;
}
void CSystemProperties::SetFreeDiskSpacePercentError(ULONG aFreeDiskSpacePercentError)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(FreeDiskSpacePercentError)(aFreeDiskSpacePercentError);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CSystemProperties::GetVRDEAuthLibrary() const
{
    QString aVRDEAuthLibrary;
    AssertReturn(ptr(), aVRDEAuthLibrary);
    mRC = ptr()->COMGETTER(VRDEAuthLibrary)(BSTROut(aVRDEAuthLibrary));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVRDEAuthLibrary;
}
void CSystemProperties::SetVRDEAuthLibrary(const QString & aVRDEAuthLibrary)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(VRDEAuthLibrary)(BSTRIn(aVRDEAuthLibrary));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CSystemProperties::GetWebServiceAuthLibrary() const
{
    QString aWebServiceAuthLibrary;
    AssertReturn(ptr(), aWebServiceAuthLibrary);
    mRC = ptr()->COMGETTER(WebServiceAuthLibrary)(BSTROut(aWebServiceAuthLibrary));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWebServiceAuthLibrary;
}
void CSystemProperties::SetWebServiceAuthLibrary(const QString & aWebServiceAuthLibrary)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(WebServiceAuthLibrary)(BSTRIn(aWebServiceAuthLibrary));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CSystemProperties::GetDefaultVRDEExtPack() const
{
    QString aDefaultVRDEExtPack;
    AssertReturn(ptr(), aDefaultVRDEExtPack);
    mRC = ptr()->COMGETTER(DefaultVRDEExtPack)(BSTROut(aDefaultVRDEExtPack));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDefaultVRDEExtPack;
}
void CSystemProperties::SetDefaultVRDEExtPack(const QString & aDefaultVRDEExtPack)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(DefaultVRDEExtPack)(BSTRIn(aDefaultVRDEExtPack));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CSystemProperties::GetLogHistoryCount() const
{
    ULONG aLogHistoryCount = 0;
    AssertReturn(ptr(), aLogHistoryCount);
    mRC = ptr()->COMGETTER(LogHistoryCount)(&aLogHistoryCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLogHistoryCount;
}
void CSystemProperties::SetLogHistoryCount(ULONG aLogHistoryCount)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(LogHistoryCount)(aLogHistoryCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KAudioDriverType CSystemProperties::GetDefaultAudioDriver() const
{
    KAudioDriverType aDefaultAudioDriver = (KAudioDriverType) 0;
    AssertReturn(ptr(), aDefaultAudioDriver);
    mRC = ptr()->COMGETTER(DefaultAudioDriver)(ENUMOut<KAudioDriverType, AudioDriverType_T>(aDefaultAudioDriver));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDefaultAudioDriver;
}

QString CSystemProperties::GetAutostartDatabasePath() const
{
    QString aAutostartDatabasePath;
    AssertReturn(ptr(), aAutostartDatabasePath);
    mRC = ptr()->COMGETTER(AutostartDatabasePath)(BSTROut(aAutostartDatabasePath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAutostartDatabasePath;
}
void CSystemProperties::SetAutostartDatabasePath(const QString & aAutostartDatabasePath)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(AutostartDatabasePath)(BSTRIn(aAutostartDatabasePath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CSystemProperties::GetDefaultAdditionsISO() const
{
    QString aDefaultAdditionsISO;
    AssertReturn(ptr(), aDefaultAdditionsISO);
    mRC = ptr()->COMGETTER(DefaultAdditionsISO)(BSTROut(aDefaultAdditionsISO));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDefaultAdditionsISO;
}
void CSystemProperties::SetDefaultAdditionsISO(const QString & aDefaultAdditionsISO)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(DefaultAdditionsISO)(BSTRIn(aDefaultAdditionsISO));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CSystemProperties::GetDefaultFrontend() const
{
    QString aDefaultFrontend;
    AssertReturn(ptr(), aDefaultFrontend);
    mRC = ptr()->COMGETTER(DefaultFrontend)(BSTROut(aDefaultFrontend));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDefaultFrontend;
}
void CSystemProperties::SetDefaultFrontend(const QString & aDefaultFrontend)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(DefaultFrontend)(BSTRIn(aDefaultFrontend));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CSystemProperties::GetMaxNetworkAdapters(const KChipsetType & aChipset)
{
    ULONG aMaxNetworkAdapters = 0;
    AssertReturn(ptr(), aMaxNetworkAdapters);
    mRC = ptr()->GetMaxNetworkAdapters((ChipsetType_T) aChipset, &aMaxNetworkAdapters);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMaxNetworkAdapters;
}

ULONG CSystemProperties::GetMaxNetworkAdaptersOfType(const KChipsetType & aChipset, const KNetworkAttachmentType & aType)
{
    ULONG aMaxNetworkAdapters = 0;
    AssertReturn(ptr(), aMaxNetworkAdapters);
    mRC = ptr()->GetMaxNetworkAdaptersOfType((ChipsetType_T) aChipset, (NetworkAttachmentType_T) aType, &aMaxNetworkAdapters);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMaxNetworkAdapters;
}

ULONG CSystemProperties::GetMaxDevicesPerPortForStorageBus(const KStorageBus & aBus)
{
    ULONG aMaxDevicesPerPort = 0;
    AssertReturn(ptr(), aMaxDevicesPerPort);
    mRC = ptr()->GetMaxDevicesPerPortForStorageBus((StorageBus_T) aBus, &aMaxDevicesPerPort);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMaxDevicesPerPort;
}

ULONG CSystemProperties::GetMinPortCountForStorageBus(const KStorageBus & aBus)
{
    ULONG aMinPortCount = 0;
    AssertReturn(ptr(), aMinPortCount);
    mRC = ptr()->GetMinPortCountForStorageBus((StorageBus_T) aBus, &aMinPortCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMinPortCount;
}

ULONG CSystemProperties::GetMaxPortCountForStorageBus(const KStorageBus & aBus)
{
    ULONG aMaxPortCount = 0;
    AssertReturn(ptr(), aMaxPortCount);
    mRC = ptr()->GetMaxPortCountForStorageBus((StorageBus_T) aBus, &aMaxPortCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMaxPortCount;
}

ULONG CSystemProperties::GetMaxInstancesOfStorageBus(const KChipsetType & aChipset, const KStorageBus & aBus)
{
    ULONG aMaxInstances = 0;
    AssertReturn(ptr(), aMaxInstances);
    mRC = ptr()->GetMaxInstancesOfStorageBus((ChipsetType_T) aChipset, (StorageBus_T) aBus, &aMaxInstances);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMaxInstances;
}

QVector<KDeviceType> CSystemProperties::GetDeviceTypesForStorageBus(const KStorageBus & aBus)
{
    QVector<KDeviceType> aDeviceTypes;
    AssertReturn(ptr(), aDeviceTypes);
    com::SafeArray <DeviceType_T> deviceTypes;
    mRC = ptr()->GetDeviceTypesForStorageBus((StorageBus_T) aBus, ComSafeArrayAsOutParam(deviceTypes));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(deviceTypes, aDeviceTypes);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDeviceTypes;
}

BOOL CSystemProperties::GetDefaultIoCacheSettingForStorageController(const KStorageControllerType & aControllerType)
{
    BOOL aEnabled = FALSE;
    AssertReturn(ptr(), aEnabled);
    mRC = ptr()->GetDefaultIoCacheSettingForStorageController((StorageControllerType_T) aControllerType, &aEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEnabled;
}

ULONG CSystemProperties::GetMaxInstancesOfUSBControllerType(const KChipsetType & aChipset, const KUSBControllerType & aType)
{
    ULONG aMaxInstances = 0;
    AssertReturn(ptr(), aMaxInstances);
    mRC = ptr()->GetMaxInstancesOfUSBControllerType((ChipsetType_T) aChipset, (USBControllerType_T) aType, &aMaxInstances);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMaxInstances;
}

// IGuestOSType wrapper

QString CGuestOSType::GetFamilyId() const
{
    QString aFamilyId;
    AssertReturn(ptr(), aFamilyId);
    mRC = ptr()->COMGETTER(FamilyId)(BSTROut(aFamilyId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFamilyId;
}

QString CGuestOSType::GetFamilyDescription() const
{
    QString aFamilyDescription;
    AssertReturn(ptr(), aFamilyDescription);
    mRC = ptr()->COMGETTER(FamilyDescription)(BSTROut(aFamilyDescription));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFamilyDescription;
}

QString CGuestOSType::GetId() const
{
    QString aId;
    AssertReturn(ptr(), aId);
    mRC = ptr()->COMGETTER(Id)(BSTROut(aId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aId;
}

QString CGuestOSType::GetDescription() const
{
    QString aDescription;
    AssertReturn(ptr(), aDescription);
    mRC = ptr()->COMGETTER(Description)(BSTROut(aDescription));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDescription;
}

BOOL CGuestOSType::GetIs64Bit() const
{
    BOOL aIs64Bit = FALSE;
    AssertReturn(ptr(), aIs64Bit);
    mRC = ptr()->COMGETTER(Is64Bit)(&aIs64Bit);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aIs64Bit;
}

BOOL CGuestOSType::GetRecommendedIOAPIC() const
{
    BOOL aRecommendedIOAPIC = FALSE;
    AssertReturn(ptr(), aRecommendedIOAPIC);
    mRC = ptr()->COMGETTER(RecommendedIOAPIC)(&aRecommendedIOAPIC);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecommendedIOAPIC;
}

BOOL CGuestOSType::GetRecommendedVirtEx() const
{
    BOOL aRecommendedVirtEx = FALSE;
    AssertReturn(ptr(), aRecommendedVirtEx);
    mRC = ptr()->COMGETTER(RecommendedVirtEx)(&aRecommendedVirtEx);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecommendedVirtEx;
}

ULONG CGuestOSType::GetRecommendedRAM() const
{
    ULONG aRecommendedRAM = 0;
    AssertReturn(ptr(), aRecommendedRAM);
    mRC = ptr()->COMGETTER(RecommendedRAM)(&aRecommendedRAM);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecommendedRAM;
}

ULONG CGuestOSType::GetRecommendedVRAM() const
{
    ULONG aRecommendedVRAM = 0;
    AssertReturn(ptr(), aRecommendedVRAM);
    mRC = ptr()->COMGETTER(RecommendedVRAM)(&aRecommendedVRAM);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecommendedVRAM;
}

BOOL CGuestOSType::GetRecommended2DVideoAcceleration() const
{
    BOOL aRecommended2DVideoAcceleration = FALSE;
    AssertReturn(ptr(), aRecommended2DVideoAcceleration);
    mRC = ptr()->COMGETTER(Recommended2DVideoAcceleration)(&aRecommended2DVideoAcceleration);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecommended2DVideoAcceleration;
}

BOOL CGuestOSType::GetRecommended3DAcceleration() const
{
    BOOL aRecommended3DAcceleration = FALSE;
    AssertReturn(ptr(), aRecommended3DAcceleration);
    mRC = ptr()->COMGETTER(Recommended3DAcceleration)(&aRecommended3DAcceleration);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecommended3DAcceleration;
}

LONG64 CGuestOSType::GetRecommendedHDD() const
{
    LONG64 aRecommendedHDD = 0;
    AssertReturn(ptr(), aRecommendedHDD);
    mRC = ptr()->COMGETTER(RecommendedHDD)(&aRecommendedHDD);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecommendedHDD;
}

KNetworkAdapterType CGuestOSType::GetAdapterType() const
{
    KNetworkAdapterType aAdapterType = (KNetworkAdapterType) 0;
    AssertReturn(ptr(), aAdapterType);
    mRC = ptr()->COMGETTER(AdapterType)(ENUMOut<KNetworkAdapterType, NetworkAdapterType_T>(aAdapterType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAdapterType;
}

BOOL CGuestOSType::GetRecommendedPAE() const
{
    BOOL aRecommendedPAE = FALSE;
    AssertReturn(ptr(), aRecommendedPAE);
    mRC = ptr()->COMGETTER(RecommendedPAE)(&aRecommendedPAE);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecommendedPAE;
}

KStorageControllerType CGuestOSType::GetRecommendedDVDStorageController() const
{
    KStorageControllerType aRecommendedDVDStorageController = (KStorageControllerType) 0;
    AssertReturn(ptr(), aRecommendedDVDStorageController);
    mRC = ptr()->COMGETTER(RecommendedDVDStorageController)(ENUMOut<KStorageControllerType, StorageControllerType_T>(aRecommendedDVDStorageController));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecommendedDVDStorageController;
}

KStorageBus CGuestOSType::GetRecommendedDVDStorageBus() const
{
    KStorageBus aRecommendedDVDStorageBus = (KStorageBus) 0;
    AssertReturn(ptr(), aRecommendedDVDStorageBus);
    mRC = ptr()->COMGETTER(RecommendedDVDStorageBus)(ENUMOut<KStorageBus, StorageBus_T>(aRecommendedDVDStorageBus));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecommendedDVDStorageBus;
}

KStorageControllerType CGuestOSType::GetRecommendedHDStorageController() const
{
    KStorageControllerType aRecommendedHDStorageController = (KStorageControllerType) 0;
    AssertReturn(ptr(), aRecommendedHDStorageController);
    mRC = ptr()->COMGETTER(RecommendedHDStorageController)(ENUMOut<KStorageControllerType, StorageControllerType_T>(aRecommendedHDStorageController));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecommendedHDStorageController;
}

KStorageBus CGuestOSType::GetRecommendedHDStorageBus() const
{
    KStorageBus aRecommendedHDStorageBus = (KStorageBus) 0;
    AssertReturn(ptr(), aRecommendedHDStorageBus);
    mRC = ptr()->COMGETTER(RecommendedHDStorageBus)(ENUMOut<KStorageBus, StorageBus_T>(aRecommendedHDStorageBus));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecommendedHDStorageBus;
}

KFirmwareType CGuestOSType::GetRecommendedFirmware() const
{
    KFirmwareType aRecommendedFirmware = (KFirmwareType) 0;
    AssertReturn(ptr(), aRecommendedFirmware);
    mRC = ptr()->COMGETTER(RecommendedFirmware)(ENUMOut<KFirmwareType, FirmwareType_T>(aRecommendedFirmware));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecommendedFirmware;
}

BOOL CGuestOSType::GetRecommendedUSBHID() const
{
    BOOL aRecommendedUSBHID = FALSE;
    AssertReturn(ptr(), aRecommendedUSBHID);
    mRC = ptr()->COMGETTER(RecommendedUSBHID)(&aRecommendedUSBHID);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecommendedUSBHID;
}

BOOL CGuestOSType::GetRecommendedHPET() const
{
    BOOL aRecommendedHPET = FALSE;
    AssertReturn(ptr(), aRecommendedHPET);
    mRC = ptr()->COMGETTER(RecommendedHPET)(&aRecommendedHPET);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecommendedHPET;
}

BOOL CGuestOSType::GetRecommendedUSBTablet() const
{
    BOOL aRecommendedUSBTablet = FALSE;
    AssertReturn(ptr(), aRecommendedUSBTablet);
    mRC = ptr()->COMGETTER(RecommendedUSBTablet)(&aRecommendedUSBTablet);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecommendedUSBTablet;
}

BOOL CGuestOSType::GetRecommendedRTCUseUTC() const
{
    BOOL aRecommendedRTCUseUTC = FALSE;
    AssertReturn(ptr(), aRecommendedRTCUseUTC);
    mRC = ptr()->COMGETTER(RecommendedRTCUseUTC)(&aRecommendedRTCUseUTC);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecommendedRTCUseUTC;
}

KChipsetType CGuestOSType::GetRecommendedChipset() const
{
    KChipsetType aRecommendedChipset = (KChipsetType) 0;
    AssertReturn(ptr(), aRecommendedChipset);
    mRC = ptr()->COMGETTER(RecommendedChipset)(ENUMOut<KChipsetType, ChipsetType_T>(aRecommendedChipset));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecommendedChipset;
}

KAudioControllerType CGuestOSType::GetRecommendedAudioController() const
{
    KAudioControllerType aRecommendedAudioController = (KAudioControllerType) 0;
    AssertReturn(ptr(), aRecommendedAudioController);
    mRC = ptr()->COMGETTER(RecommendedAudioController)(ENUMOut<KAudioControllerType, AudioControllerType_T>(aRecommendedAudioController));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecommendedAudioController;
}

BOOL CGuestOSType::GetRecommendedFloppy() const
{
    BOOL aRecommendedFloppy = FALSE;
    AssertReturn(ptr(), aRecommendedFloppy);
    mRC = ptr()->COMGETTER(RecommendedFloppy)(&aRecommendedFloppy);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecommendedFloppy;
}

BOOL CGuestOSType::GetRecommendedUSB() const
{
    BOOL aRecommendedUSB = FALSE;
    AssertReturn(ptr(), aRecommendedUSB);
    mRC = ptr()->COMGETTER(RecommendedUSB)(&aRecommendedUSB);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecommendedUSB;
}

// IAdditionsFacility wrapper

KAdditionsFacilityClass CAdditionsFacility::GetClassType() const
{
    KAdditionsFacilityClass aClassType = (KAdditionsFacilityClass) 0;
    AssertReturn(ptr(), aClassType);
    mRC = ptr()->COMGETTER(ClassType)(ENUMOut<KAdditionsFacilityClass, AdditionsFacilityClass_T>(aClassType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aClassType;
}

LONG64 CAdditionsFacility::GetLastUpdated() const
{
    LONG64 aLastUpdated = 0;
    AssertReturn(ptr(), aLastUpdated);
    mRC = ptr()->COMGETTER(LastUpdated)(&aLastUpdated);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLastUpdated;
}

QString CAdditionsFacility::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

KAdditionsFacilityStatus CAdditionsFacility::GetStatus() const
{
    KAdditionsFacilityStatus aStatus = (KAdditionsFacilityStatus) 0;
    AssertReturn(ptr(), aStatus);
    mRC = ptr()->COMGETTER(Status)(ENUMOut<KAdditionsFacilityStatus, AdditionsFacilityStatus_T>(aStatus));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStatus;
}

KAdditionsFacilityType CAdditionsFacility::GetType() const
{
    KAdditionsFacilityType aType = (KAdditionsFacilityType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KAdditionsFacilityType, AdditionsFacilityType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

// IGuestSession wrapper

QString CGuestSession::GetUser() const
{
    QString aUser;
    AssertReturn(ptr(), aUser);
    mRC = ptr()->COMGETTER(User)(BSTROut(aUser));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUser;
}

QString CGuestSession::GetDomain() const
{
    QString aDomain;
    AssertReturn(ptr(), aDomain);
    mRC = ptr()->COMGETTER(Domain)(BSTROut(aDomain));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDomain;
}

QString CGuestSession::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

ULONG CGuestSession::GetId() const
{
    ULONG aId = 0;
    AssertReturn(ptr(), aId);
    mRC = ptr()->COMGETTER(Id)(&aId);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aId;
}

ULONG CGuestSession::GetTimeout() const
{
    ULONG aTimeout = 0;
    AssertReturn(ptr(), aTimeout);
    mRC = ptr()->COMGETTER(Timeout)(&aTimeout);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aTimeout;
}
void CGuestSession::SetTimeout(ULONG aTimeout)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Timeout)(aTimeout);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CGuestSession::GetProtocolVersion() const
{
    ULONG aProtocolVersion = 0;
    AssertReturn(ptr(), aProtocolVersion);
    mRC = ptr()->COMGETTER(ProtocolVersion)(&aProtocolVersion);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProtocolVersion;
}

KGuestSessionStatus CGuestSession::GetStatus() const
{
    KGuestSessionStatus aStatus = (KGuestSessionStatus) 0;
    AssertReturn(ptr(), aStatus);
    mRC = ptr()->COMGETTER(Status)(ENUMOut<KGuestSessionStatus, GuestSessionStatus_T>(aStatus));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStatus;
}

QVector<QString> CGuestSession::GetEnvironment() const
{
    QVector<QString> aEnvironment;
    AssertReturn(ptr(), aEnvironment);
    com::SafeArray <BSTR> environment;
    mRC = ptr()->COMGETTER(Environment)(ComSafeArrayAsOutParam(environment));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(environment, aEnvironment);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEnvironment;
}
void CGuestSession::SetEnvironment(const QVector<QString> & aEnvironment)
{
    AssertReturnVoid(ptr());
    com::SafeArray <BSTR> environment;
    ToSafeArray(aEnvironment, environment);
    mRC = ptr()->COMSETTER(Environment)(ComSafeArrayAsInParam(environment));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QVector<CGuestProcess> CGuestSession::GetProcesses() const
{
    QVector<CGuestProcess> aProcesses;
    AssertReturn(ptr(), aProcesses);
    com::SafeIfaceArray <IGuestProcess> processes;
    mRC = ptr()->COMGETTER(Processes)(ComSafeArrayAsOutParam(processes));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(processes, aProcesses);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProcesses;
}

QVector<CGuestDirectory> CGuestSession::GetDirectories() const
{
    QVector<CGuestDirectory> aDirectories;
    AssertReturn(ptr(), aDirectories);
    com::SafeIfaceArray <IGuestDirectory> directories;
    mRC = ptr()->COMGETTER(Directories)(ComSafeArrayAsOutParam(directories));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(directories, aDirectories);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDirectories;
}

QVector<CGuestFile> CGuestSession::GetFiles() const
{
    QVector<CGuestFile> aFiles;
    AssertReturn(ptr(), aFiles);
    com::SafeIfaceArray <IGuestFile> files;
    mRC = ptr()->COMGETTER(Files)(ComSafeArrayAsOutParam(files));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(files, aFiles);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFiles;
}

CEventSource CGuestSession::GetEventSource() const
{
    CEventSource aEventSource;
    AssertReturn(ptr(), aEventSource);
    IEventSource* eventSourcePtr = NULL;
    mRC = ptr()->COMGETTER(EventSource)(&eventSourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aEventSource.setPtr(eventSourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEventSource;
}

void CGuestSession::Close()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Close();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CProgress CGuestSession::CopyFrom(const QString & aSource, const QString & aDest, const QVector<KCopyFileFlag> & aFlags)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    com::SafeArray <CopyFileFlag_T> flags;
    ToSafeArray(aFlags, flags);
    IProgress* progressPtr = NULL;
    mRC = ptr()->CopyFrom(BSTRIn(aSource), BSTRIn(aDest), ComSafeArrayAsInParam(flags), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CProgress CGuestSession::CopyTo(const QString & aSource, const QString & aDest, const QVector<KCopyFileFlag> & aFlags)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    com::SafeArray <CopyFileFlag_T> flags;
    ToSafeArray(aFlags, flags);
    IProgress* progressPtr = NULL;
    mRC = ptr()->CopyTo(BSTRIn(aSource), BSTRIn(aDest), ComSafeArrayAsInParam(flags), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

void CGuestSession::DirectoryCreate(const QString & aPath, ULONG aMode, const QVector<KDirectoryCreateFlag> & aFlags)
{
    AssertReturnVoid(ptr());
    com::SafeArray <DirectoryCreateFlag_T> flags;
    ToSafeArray(aFlags, flags);
    mRC = ptr()->DirectoryCreate(BSTRIn(aPath), aMode, ComSafeArrayAsInParam(flags));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CGuestSession::DirectoryCreateTemp(const QString & aTemplateName, ULONG aMode, const QString & aPath, BOOL aSecure)
{
    QString aDirectory;
    AssertReturn(ptr(), aDirectory);
    mRC = ptr()->DirectoryCreateTemp(BSTRIn(aTemplateName), aMode, BSTRIn(aPath), aSecure, BSTROut(aDirectory));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDirectory;
}

BOOL CGuestSession::DirectoryExists(const QString & aPath)
{
    BOOL aExists = FALSE;
    AssertReturn(ptr(), aExists);
    mRC = ptr()->DirectoryExists(BSTRIn(aPath), &aExists);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aExists;
}

CGuestDirectory CGuestSession::DirectoryOpen(const QString & aPath, const QString & aFilter, const QVector<KDirectoryOpenFlag> & aFlags)
{
    CGuestDirectory aDirectory;
    AssertReturn(ptr(), aDirectory);
    com::SafeArray <DirectoryOpenFlag_T> flags;
    ToSafeArray(aFlags, flags);
    IGuestDirectory* directoryPtr = NULL;
    mRC = ptr()->DirectoryOpen(BSTRIn(aPath), BSTRIn(aFilter), ComSafeArrayAsInParam(flags), &directoryPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aDirectory.setPtr(directoryPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDirectory;
}

CGuestFsObjInfo CGuestSession::DirectoryQueryInfo(const QString & aPath)
{
    CGuestFsObjInfo aInfo;
    AssertReturn(ptr(), aInfo);
    IGuestFsObjInfo* infoPtr = NULL;
    mRC = ptr()->DirectoryQueryInfo(BSTRIn(aPath), &infoPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aInfo.setPtr(infoPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aInfo;
}

void CGuestSession::DirectoryRemove(const QString & aPath)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->DirectoryRemove(BSTRIn(aPath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CProgress CGuestSession::DirectoryRemoveRecursive(const QString & aPath, const QVector<KDirectoryRemoveRecFlag> & aFlags)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    com::SafeArray <DirectoryRemoveRecFlag_T> flags;
    ToSafeArray(aFlags, flags);
    IProgress* progressPtr = NULL;
    mRC = ptr()->DirectoryRemoveRecursive(BSTRIn(aPath), ComSafeArrayAsInParam(flags), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

void CGuestSession::DirectoryRename(const QString & aSource, const QString & aDest, const QVector<KPathRenameFlag> & aFlags)
{
    AssertReturnVoid(ptr());
    com::SafeArray <PathRenameFlag_T> flags;
    ToSafeArray(aFlags, flags);
    mRC = ptr()->DirectoryRename(BSTRIn(aSource), BSTRIn(aDest), ComSafeArrayAsInParam(flags));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CGuestSession::DirectorySetACL(const QString & aPath, const QString & aAcl)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->DirectorySetACL(BSTRIn(aPath), BSTRIn(aAcl));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CGuestSession::EnvironmentClear()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->EnvironmentClear();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CGuestSession::EnvironmentGet(const QString & aName)
{
    QString aValue;
    AssertReturn(ptr(), aValue);
    mRC = ptr()->EnvironmentGet(BSTRIn(aName), BSTROut(aValue));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aValue;
}

void CGuestSession::EnvironmentSet(const QString & aName, const QString & aValue)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->EnvironmentSet(BSTRIn(aName), BSTRIn(aValue));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CGuestSession::EnvironmentUnset(const QString & aName)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->EnvironmentUnset(BSTRIn(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CGuestFile CGuestSession::FileCreateTemp(const QString & aTemplateName, ULONG aMode, const QString & aPath, BOOL aSecure)
{
    CGuestFile aFile;
    AssertReturn(ptr(), aFile);
    IGuestFile* filePtr = NULL;
    mRC = ptr()->FileCreateTemp(BSTRIn(aTemplateName), aMode, BSTRIn(aPath), aSecure, &filePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aFile.setPtr(filePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFile;
}

BOOL CGuestSession::FileExists(const QString & aPath)
{
    BOOL aExists = FALSE;
    AssertReturn(ptr(), aExists);
    mRC = ptr()->FileExists(BSTRIn(aPath), &aExists);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aExists;
}

void CGuestSession::FileRemove(const QString & aPath)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->FileRemove(BSTRIn(aPath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CGuestFile CGuestSession::FileOpen(const QString & aPath, const QString & aOpenMode, const QString & aDisposition, ULONG aCreationMode)
{
    CGuestFile aFile;
    AssertReturn(ptr(), aFile);
    IGuestFile* filePtr = NULL;
    mRC = ptr()->FileOpen(BSTRIn(aPath), BSTRIn(aOpenMode), BSTRIn(aDisposition), aCreationMode, &filePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aFile.setPtr(filePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFile;
}

CGuestFile CGuestSession::FileOpenEx(const QString & aPath, const QString & aOpenMode, const QString & aDisposition, const QString & aSharingMode, ULONG aCreationMode, LONG64 aOffset)
{
    CGuestFile aFile;
    AssertReturn(ptr(), aFile);
    IGuestFile* filePtr = NULL;
    mRC = ptr()->FileOpenEx(BSTRIn(aPath), BSTRIn(aOpenMode), BSTRIn(aDisposition), BSTRIn(aSharingMode), aCreationMode, aOffset, &filePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aFile.setPtr(filePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFile;
}

CGuestFsObjInfo CGuestSession::FileQueryInfo(const QString & aPath)
{
    CGuestFsObjInfo aInfo;
    AssertReturn(ptr(), aInfo);
    IGuestFsObjInfo* infoPtr = NULL;
    mRC = ptr()->FileQueryInfo(BSTRIn(aPath), &infoPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aInfo.setPtr(infoPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aInfo;
}

LONG64 CGuestSession::FileQuerySize(const QString & aPath)
{
    LONG64 aSize = 0;
    AssertReturn(ptr(), aSize);
    mRC = ptr()->FileQuerySize(BSTRIn(aPath), &aSize);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSize;
}

void CGuestSession::FileRename(const QString & aSource, const QString & aDest, const QVector<KPathRenameFlag> & aFlags)
{
    AssertReturnVoid(ptr());
    com::SafeArray <PathRenameFlag_T> flags;
    ToSafeArray(aFlags, flags);
    mRC = ptr()->FileRename(BSTRIn(aSource), BSTRIn(aDest), ComSafeArrayAsInParam(flags));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CGuestSession::FileSetACL(const QString & aFile, const QString & aAcl)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->FileSetACL(BSTRIn(aFile), BSTRIn(aAcl));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CGuestProcess CGuestSession::ProcessCreate(const QString & aCommand, const QVector<QString> & aArguments, const QVector<QString> & aEnvironment, const QVector<KProcessCreateFlag> & aFlags, ULONG aTimeoutMS)
{
    CGuestProcess aGuestProcess;
    AssertReturn(ptr(), aGuestProcess);
    com::SafeArray <BSTR> arguments;
    ToSafeArray(aArguments, arguments);
    com::SafeArray <BSTR> environment;
    ToSafeArray(aEnvironment, environment);
    com::SafeArray <ProcessCreateFlag_T> flags;
    ToSafeArray(aFlags, flags);
    IGuestProcess* guestProcessPtr = NULL;
    mRC = ptr()->ProcessCreate(BSTRIn(aCommand), ComSafeArrayAsInParam(arguments), ComSafeArrayAsInParam(environment), ComSafeArrayAsInParam(flags), aTimeoutMS, &guestProcessPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aGuestProcess.setPtr(guestProcessPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGuestProcess;
}

CGuestProcess CGuestSession::ProcessCreateEx(const QString & aCommand, const QVector<QString> & aArguments, const QVector<QString> & aEnvironment, const QVector<KProcessCreateFlag> & aFlags, ULONG aTimeoutMS, const KProcessPriority & aPriority, const QVector<LONG> & aAffinity)
{
    CGuestProcess aGuestProcess;
    AssertReturn(ptr(), aGuestProcess);
    com::SafeArray <BSTR> arguments;
    ToSafeArray(aArguments, arguments);
    com::SafeArray <BSTR> environment;
    ToSafeArray(aEnvironment, environment);
    com::SafeArray <ProcessCreateFlag_T> flags;
    ToSafeArray(aFlags, flags);
    com::SafeArray <LONG> affinity;
    ToSafeArray(aAffinity, affinity);
    IGuestProcess* guestProcessPtr = NULL;
    mRC = ptr()->ProcessCreateEx(BSTRIn(aCommand), ComSafeArrayAsInParam(arguments), ComSafeArrayAsInParam(environment), ComSafeArrayAsInParam(flags), aTimeoutMS, (ProcessPriority_T) aPriority, ComSafeArrayAsInParam(affinity), &guestProcessPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aGuestProcess.setPtr(guestProcessPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGuestProcess;
}

CGuestProcess CGuestSession::ProcessGet(ULONG aPid)
{
    CGuestProcess aGuestProcess;
    AssertReturn(ptr(), aGuestProcess);
    IGuestProcess* guestProcessPtr = NULL;
    mRC = ptr()->ProcessGet(aPid, &guestProcessPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aGuestProcess.setPtr(guestProcessPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGuestProcess;
}

void CGuestSession::SymlinkCreate(const QString & aSource, const QString & aTarget, const KSymlinkType & aType)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SymlinkCreate(BSTRIn(aSource), BSTRIn(aTarget), (SymlinkType_T) aType);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestSession::SymlinkExists(const QString & aSymlink)
{
    BOOL aExists = FALSE;
    AssertReturn(ptr(), aExists);
    mRC = ptr()->SymlinkExists(BSTRIn(aSymlink), &aExists);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aExists;
}

QString CGuestSession::SymlinkRead(const QString & aSymlink, const QVector<KSymlinkReadFlag> & aFlags)
{
    QString aTarget;
    AssertReturn(ptr(), aTarget);
    com::SafeArray <SymlinkReadFlag_T> flags;
    ToSafeArray(aFlags, flags);
    mRC = ptr()->SymlinkRead(BSTRIn(aSymlink), ComSafeArrayAsInParam(flags), BSTROut(aTarget));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aTarget;
}

void CGuestSession::SymlinkRemoveDirectory(const QString & aPath)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SymlinkRemoveDirectory(BSTRIn(aPath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CGuestSession::SymlinkRemoveFile(const QString & aFile)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SymlinkRemoveFile(BSTRIn(aFile));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KGuestSessionWaitResult CGuestSession::WaitFor(ULONG aWaitFor, ULONG aTimeoutMS)
{
    KGuestSessionWaitResult aReason = (KGuestSessionWaitResult) 0;
    AssertReturn(ptr(), aReason);
    mRC = ptr()->WaitFor(aWaitFor, aTimeoutMS, ENUMOut<KGuestSessionWaitResult, GuestSessionWaitResult_T>(aReason));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aReason;
}

KGuestSessionWaitResult CGuestSession::WaitForArray(const QVector<KGuestSessionWaitForFlag> & aWaitFor, ULONG aTimeoutMS)
{
    KGuestSessionWaitResult aReason = (KGuestSessionWaitResult) 0;
    AssertReturn(ptr(), aReason);
    com::SafeArray <GuestSessionWaitForFlag_T> waitFor;
    ToSafeArray(aWaitFor, waitFor);
    mRC = ptr()->WaitForArray(ComSafeArrayAsInParam(waitFor), aTimeoutMS, ENUMOut<KGuestSessionWaitResult, GuestSessionWaitResult_T>(aReason));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aReason;
}

// IProcess wrapper

QVector<QString> CProcess::GetArguments() const
{
    QVector<QString> aArguments;
    AssertReturn(ptr(), aArguments);
    com::SafeArray <BSTR> arguments;
    mRC = ptr()->COMGETTER(Arguments)(ComSafeArrayAsOutParam(arguments));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(arguments, aArguments);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aArguments;
}

QVector<QString> CProcess::GetEnvironment() const
{
    QVector<QString> aEnvironment;
    AssertReturn(ptr(), aEnvironment);
    com::SafeArray <BSTR> environment;
    mRC = ptr()->COMGETTER(Environment)(ComSafeArrayAsOutParam(environment));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(environment, aEnvironment);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEnvironment;
}

CEventSource CProcess::GetEventSource() const
{
    CEventSource aEventSource;
    AssertReturn(ptr(), aEventSource);
    IEventSource* eventSourcePtr = NULL;
    mRC = ptr()->COMGETTER(EventSource)(&eventSourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aEventSource.setPtr(eventSourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEventSource;
}

QString CProcess::GetExecutablePath() const
{
    QString aExecutablePath;
    AssertReturn(ptr(), aExecutablePath);
    mRC = ptr()->COMGETTER(ExecutablePath)(BSTROut(aExecutablePath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aExecutablePath;
}

LONG CProcess::GetExitCode() const
{
    LONG aExitCode = 0;
    AssertReturn(ptr(), aExitCode);
    mRC = ptr()->COMGETTER(ExitCode)(&aExitCode);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aExitCode;
}

QString CProcess::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

ULONG CProcess::GetPID() const
{
    ULONG aPID = 0;
    AssertReturn(ptr(), aPID);
    mRC = ptr()->COMGETTER(PID)(&aPID);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPID;
}

KProcessStatus CProcess::GetStatus() const
{
    KProcessStatus aStatus = (KProcessStatus) 0;
    AssertReturn(ptr(), aStatus);
    mRC = ptr()->COMGETTER(Status)(ENUMOut<KProcessStatus, ProcessStatus_T>(aStatus));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStatus;
}

KProcessWaitResult CProcess::WaitFor(ULONG aWaitFor, ULONG aTimeoutMS)
{
    KProcessWaitResult aReason = (KProcessWaitResult) 0;
    AssertReturn(ptr(), aReason);
    mRC = ptr()->WaitFor(aWaitFor, aTimeoutMS, ENUMOut<KProcessWaitResult, ProcessWaitResult_T>(aReason));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aReason;
}

KProcessWaitResult CProcess::WaitForArray(const QVector<KProcessWaitForFlag> & aWaitFor, ULONG aTimeoutMS)
{
    KProcessWaitResult aReason = (KProcessWaitResult) 0;
    AssertReturn(ptr(), aReason);
    com::SafeArray <ProcessWaitForFlag_T> waitFor;
    ToSafeArray(aWaitFor, waitFor);
    mRC = ptr()->WaitForArray(ComSafeArrayAsInParam(waitFor), aTimeoutMS, ENUMOut<KProcessWaitResult, ProcessWaitResult_T>(aReason));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aReason;
}

QVector<BYTE> CProcess::Read(ULONG aHandle, ULONG aToRead, ULONG aTimeoutMS)
{
    QVector<BYTE> aData;
    AssertReturn(ptr(), aData);
    com::SafeArray <BYTE> data;
    mRC = ptr()->Read(aHandle, aToRead, aTimeoutMS, ComSafeArrayAsOutParam(data));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(data, aData);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aData;
}

ULONG CProcess::Write(ULONG aHandle, ULONG aFlags, const QVector<BYTE> & aData, ULONG aTimeoutMS)
{
    ULONG aWritten = 0;
    AssertReturn(ptr(), aWritten);
    com::SafeArray <BYTE> data;
    ToSafeArray(aData, data);
    mRC = ptr()->Write(aHandle, aFlags, ComSafeArrayAsInParam(data), aTimeoutMS, &aWritten);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWritten;
}

ULONG CProcess::WriteArray(ULONG aHandle, const QVector<KProcessInputFlag> & aFlags, const QVector<BYTE> & aData, ULONG aTimeoutMS)
{
    ULONG aWritten = 0;
    AssertReturn(ptr(), aWritten);
    com::SafeArray <ProcessInputFlag_T> flags;
    ToSafeArray(aFlags, flags);
    com::SafeArray <BYTE> data;
    ToSafeArray(aData, data);
    mRC = ptr()->WriteArray(aHandle, ComSafeArrayAsInParam(flags), ComSafeArrayAsInParam(data), aTimeoutMS, &aWritten);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWritten;
}

void CProcess::Terminate()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Terminate();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IGuestProcess wrapper

QVector<QString> CGuestProcess::GetArguments() const
{
    QVector<QString> aArguments;
    AssertReturn(ptr(), aArguments);
    com::SafeArray <BSTR> arguments;
    mRC = ptr()->COMGETTER(Arguments)(ComSafeArrayAsOutParam(arguments));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(arguments, aArguments);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aArguments;
}

QVector<QString> CGuestProcess::GetEnvironment() const
{
    QVector<QString> aEnvironment;
    AssertReturn(ptr(), aEnvironment);
    com::SafeArray <BSTR> environment;
    mRC = ptr()->COMGETTER(Environment)(ComSafeArrayAsOutParam(environment));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(environment, aEnvironment);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEnvironment;
}

CEventSource CGuestProcess::GetEventSource() const
{
    CEventSource aEventSource;
    AssertReturn(ptr(), aEventSource);
    IEventSource* eventSourcePtr = NULL;
    mRC = ptr()->COMGETTER(EventSource)(&eventSourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aEventSource.setPtr(eventSourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEventSource;
}

QString CGuestProcess::GetExecutablePath() const
{
    QString aExecutablePath;
    AssertReturn(ptr(), aExecutablePath);
    mRC = ptr()->COMGETTER(ExecutablePath)(BSTROut(aExecutablePath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aExecutablePath;
}

LONG CGuestProcess::GetExitCode() const
{
    LONG aExitCode = 0;
    AssertReturn(ptr(), aExitCode);
    mRC = ptr()->COMGETTER(ExitCode)(&aExitCode);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aExitCode;
}

QString CGuestProcess::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

ULONG CGuestProcess::GetPID() const
{
    ULONG aPID = 0;
    AssertReturn(ptr(), aPID);
    mRC = ptr()->COMGETTER(PID)(&aPID);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPID;
}

KProcessStatus CGuestProcess::GetStatus() const
{
    KProcessStatus aStatus = (KProcessStatus) 0;
    AssertReturn(ptr(), aStatus);
    mRC = ptr()->COMGETTER(Status)(ENUMOut<KProcessStatus, ProcessStatus_T>(aStatus));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStatus;
}

KProcessWaitResult CGuestProcess::WaitFor(ULONG aWaitFor, ULONG aTimeoutMS)
{
    KProcessWaitResult aReason = (KProcessWaitResult) 0;
    AssertReturn(ptr(), aReason);
    mRC = ptr()->WaitFor(aWaitFor, aTimeoutMS, ENUMOut<KProcessWaitResult, ProcessWaitResult_T>(aReason));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aReason;
}

KProcessWaitResult CGuestProcess::WaitForArray(const QVector<KProcessWaitForFlag> & aWaitFor, ULONG aTimeoutMS)
{
    KProcessWaitResult aReason = (KProcessWaitResult) 0;
    AssertReturn(ptr(), aReason);
    com::SafeArray <ProcessWaitForFlag_T> waitFor;
    ToSafeArray(aWaitFor, waitFor);
    mRC = ptr()->WaitForArray(ComSafeArrayAsInParam(waitFor), aTimeoutMS, ENUMOut<KProcessWaitResult, ProcessWaitResult_T>(aReason));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aReason;
}

QVector<BYTE> CGuestProcess::Read(ULONG aHandle, ULONG aToRead, ULONG aTimeoutMS)
{
    QVector<BYTE> aData;
    AssertReturn(ptr(), aData);
    com::SafeArray <BYTE> data;
    mRC = ptr()->Read(aHandle, aToRead, aTimeoutMS, ComSafeArrayAsOutParam(data));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(data, aData);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aData;
}

ULONG CGuestProcess::Write(ULONG aHandle, ULONG aFlags, const QVector<BYTE> & aData, ULONG aTimeoutMS)
{
    ULONG aWritten = 0;
    AssertReturn(ptr(), aWritten);
    com::SafeArray <BYTE> data;
    ToSafeArray(aData, data);
    mRC = ptr()->Write(aHandle, aFlags, ComSafeArrayAsInParam(data), aTimeoutMS, &aWritten);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWritten;
}

ULONG CGuestProcess::WriteArray(ULONG aHandle, const QVector<KProcessInputFlag> & aFlags, const QVector<BYTE> & aData, ULONG aTimeoutMS)
{
    ULONG aWritten = 0;
    AssertReturn(ptr(), aWritten);
    com::SafeArray <ProcessInputFlag_T> flags;
    ToSafeArray(aFlags, flags);
    com::SafeArray <BYTE> data;
    ToSafeArray(aData, data);
    mRC = ptr()->WriteArray(aHandle, ComSafeArrayAsInParam(flags), ComSafeArrayAsInParam(data), aTimeoutMS, &aWritten);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWritten;
}

void CGuestProcess::Terminate()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Terminate();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IDirectory wrapper

QString CDirectory::GetDirectoryName() const
{
    QString aDirectoryName;
    AssertReturn(ptr(), aDirectoryName);
    mRC = ptr()->COMGETTER(DirectoryName)(BSTROut(aDirectoryName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDirectoryName;
}

QString CDirectory::GetFilter() const
{
    QString aFilter;
    AssertReturn(ptr(), aFilter);
    mRC = ptr()->COMGETTER(Filter)(BSTROut(aFilter));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFilter;
}

void CDirectory::Close()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Close();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CFsObjInfo CDirectory::Read()
{
    CFsObjInfo aObjInfo;
    AssertReturn(ptr(), aObjInfo);
    IFsObjInfo* objInfoPtr = NULL;
    mRC = ptr()->Read(&objInfoPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aObjInfo.setPtr(objInfoPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aObjInfo;
}

// IGuestDirectory wrapper

QString CGuestDirectory::GetDirectoryName() const
{
    QString aDirectoryName;
    AssertReturn(ptr(), aDirectoryName);
    mRC = ptr()->COMGETTER(DirectoryName)(BSTROut(aDirectoryName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDirectoryName;
}

QString CGuestDirectory::GetFilter() const
{
    QString aFilter;
    AssertReturn(ptr(), aFilter);
    mRC = ptr()->COMGETTER(Filter)(BSTROut(aFilter));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFilter;
}

void CGuestDirectory::Close()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Close();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CFsObjInfo CGuestDirectory::Read()
{
    CFsObjInfo aObjInfo;
    AssertReturn(ptr(), aObjInfo);
    IFsObjInfo* objInfoPtr = NULL;
    mRC = ptr()->Read(&objInfoPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aObjInfo.setPtr(objInfoPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aObjInfo;
}

// IFile wrapper

ULONG CFile::GetCreationMode() const
{
    ULONG aCreationMode = 0;
    AssertReturn(ptr(), aCreationMode);
    mRC = ptr()->COMGETTER(CreationMode)(&aCreationMode);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCreationMode;
}

QString CFile::GetDisposition() const
{
    QString aDisposition;
    AssertReturn(ptr(), aDisposition);
    mRC = ptr()->COMGETTER(Disposition)(BSTROut(aDisposition));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDisposition;
}

CEventSource CFile::GetEventSource() const
{
    CEventSource aEventSource;
    AssertReturn(ptr(), aEventSource);
    IEventSource* eventSourcePtr = NULL;
    mRC = ptr()->COMGETTER(EventSource)(&eventSourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aEventSource.setPtr(eventSourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEventSource;
}

QString CFile::GetFileName() const
{
    QString aFileName;
    AssertReturn(ptr(), aFileName);
    mRC = ptr()->COMGETTER(FileName)(BSTROut(aFileName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFileName;
}

ULONG CFile::GetId() const
{
    ULONG aId = 0;
    AssertReturn(ptr(), aId);
    mRC = ptr()->COMGETTER(Id)(&aId);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aId;
}

LONG64 CFile::GetInitialSize() const
{
    LONG64 aInitialSize = 0;
    AssertReturn(ptr(), aInitialSize);
    mRC = ptr()->COMGETTER(InitialSize)(&aInitialSize);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aInitialSize;
}

QString CFile::GetOpenMode() const
{
    QString aOpenMode;
    AssertReturn(ptr(), aOpenMode);
    mRC = ptr()->COMGETTER(OpenMode)(BSTROut(aOpenMode));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOpenMode;
}

LONG64 CFile::GetOffset() const
{
    LONG64 aOffset = 0;
    AssertReturn(ptr(), aOffset);
    mRC = ptr()->COMGETTER(Offset)(&aOffset);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOffset;
}

KFileStatus CFile::GetStatus() const
{
    KFileStatus aStatus = (KFileStatus) 0;
    AssertReturn(ptr(), aStatus);
    mRC = ptr()->COMGETTER(Status)(ENUMOut<KFileStatus, FileStatus_T>(aStatus));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStatus;
}

void CFile::Close()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Close();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CFsObjInfo CFile::QueryInfo()
{
    CFsObjInfo aObjInfo;
    AssertReturn(ptr(), aObjInfo);
    IFsObjInfo* objInfoPtr = NULL;
    mRC = ptr()->QueryInfo(&objInfoPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aObjInfo.setPtr(objInfoPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aObjInfo;
}

QVector<BYTE> CFile::Read(ULONG aToRead, ULONG aTimeoutMS)
{
    QVector<BYTE> aData;
    AssertReturn(ptr(), aData);
    com::SafeArray <BYTE> data;
    mRC = ptr()->Read(aToRead, aTimeoutMS, ComSafeArrayAsOutParam(data));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(data, aData);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aData;
}

QVector<BYTE> CFile::ReadAt(LONG64 aOffset, ULONG aToRead, ULONG aTimeoutMS)
{
    QVector<BYTE> aData;
    AssertReturn(ptr(), aData);
    com::SafeArray <BYTE> data;
    mRC = ptr()->ReadAt(aOffset, aToRead, aTimeoutMS, ComSafeArrayAsOutParam(data));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(data, aData);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aData;
}

void CFile::Seek(LONG64 aOffset, const KFileSeekType & aWhence)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Seek(aOffset, (FileSeekType_T) aWhence);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CFile::SetACL(const QString & aAcl)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetACL(BSTRIn(aAcl));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CFile::Write(const QVector<BYTE> & aData, ULONG aTimeoutMS)
{
    ULONG aWritten = 0;
    AssertReturn(ptr(), aWritten);
    com::SafeArray <BYTE> data;
    ToSafeArray(aData, data);
    mRC = ptr()->Write(ComSafeArrayAsInParam(data), aTimeoutMS, &aWritten);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWritten;
}

ULONG CFile::WriteAt(LONG64 aOffset, const QVector<BYTE> & aData, ULONG aTimeoutMS)
{
    ULONG aWritten = 0;
    AssertReturn(ptr(), aWritten);
    com::SafeArray <BYTE> data;
    ToSafeArray(aData, data);
    mRC = ptr()->WriteAt(aOffset, ComSafeArrayAsInParam(data), aTimeoutMS, &aWritten);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWritten;
}

// IGuestFile wrapper

ULONG CGuestFile::GetCreationMode() const
{
    ULONG aCreationMode = 0;
    AssertReturn(ptr(), aCreationMode);
    mRC = ptr()->COMGETTER(CreationMode)(&aCreationMode);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCreationMode;
}

QString CGuestFile::GetDisposition() const
{
    QString aDisposition;
    AssertReturn(ptr(), aDisposition);
    mRC = ptr()->COMGETTER(Disposition)(BSTROut(aDisposition));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDisposition;
}

CEventSource CGuestFile::GetEventSource() const
{
    CEventSource aEventSource;
    AssertReturn(ptr(), aEventSource);
    IEventSource* eventSourcePtr = NULL;
    mRC = ptr()->COMGETTER(EventSource)(&eventSourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aEventSource.setPtr(eventSourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEventSource;
}

QString CGuestFile::GetFileName() const
{
    QString aFileName;
    AssertReturn(ptr(), aFileName);
    mRC = ptr()->COMGETTER(FileName)(BSTROut(aFileName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFileName;
}

ULONG CGuestFile::GetId() const
{
    ULONG aId = 0;
    AssertReturn(ptr(), aId);
    mRC = ptr()->COMGETTER(Id)(&aId);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aId;
}

LONG64 CGuestFile::GetInitialSize() const
{
    LONG64 aInitialSize = 0;
    AssertReturn(ptr(), aInitialSize);
    mRC = ptr()->COMGETTER(InitialSize)(&aInitialSize);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aInitialSize;
}

QString CGuestFile::GetOpenMode() const
{
    QString aOpenMode;
    AssertReturn(ptr(), aOpenMode);
    mRC = ptr()->COMGETTER(OpenMode)(BSTROut(aOpenMode));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOpenMode;
}

LONG64 CGuestFile::GetOffset() const
{
    LONG64 aOffset = 0;
    AssertReturn(ptr(), aOffset);
    mRC = ptr()->COMGETTER(Offset)(&aOffset);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOffset;
}

KFileStatus CGuestFile::GetStatus() const
{
    KFileStatus aStatus = (KFileStatus) 0;
    AssertReturn(ptr(), aStatus);
    mRC = ptr()->COMGETTER(Status)(ENUMOut<KFileStatus, FileStatus_T>(aStatus));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStatus;
}

void CGuestFile::Close()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Close();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CFsObjInfo CGuestFile::QueryInfo()
{
    CFsObjInfo aObjInfo;
    AssertReturn(ptr(), aObjInfo);
    IFsObjInfo* objInfoPtr = NULL;
    mRC = ptr()->QueryInfo(&objInfoPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aObjInfo.setPtr(objInfoPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aObjInfo;
}

QVector<BYTE> CGuestFile::Read(ULONG aToRead, ULONG aTimeoutMS)
{
    QVector<BYTE> aData;
    AssertReturn(ptr(), aData);
    com::SafeArray <BYTE> data;
    mRC = ptr()->Read(aToRead, aTimeoutMS, ComSafeArrayAsOutParam(data));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(data, aData);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aData;
}

QVector<BYTE> CGuestFile::ReadAt(LONG64 aOffset, ULONG aToRead, ULONG aTimeoutMS)
{
    QVector<BYTE> aData;
    AssertReturn(ptr(), aData);
    com::SafeArray <BYTE> data;
    mRC = ptr()->ReadAt(aOffset, aToRead, aTimeoutMS, ComSafeArrayAsOutParam(data));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(data, aData);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aData;
}

void CGuestFile::Seek(LONG64 aOffset, const KFileSeekType & aWhence)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Seek(aOffset, (FileSeekType_T) aWhence);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CGuestFile::SetACL(const QString & aAcl)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetACL(BSTRIn(aAcl));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CGuestFile::Write(const QVector<BYTE> & aData, ULONG aTimeoutMS)
{
    ULONG aWritten = 0;
    AssertReturn(ptr(), aWritten);
    com::SafeArray <BYTE> data;
    ToSafeArray(aData, data);
    mRC = ptr()->Write(ComSafeArrayAsInParam(data), aTimeoutMS, &aWritten);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWritten;
}

ULONG CGuestFile::WriteAt(LONG64 aOffset, const QVector<BYTE> & aData, ULONG aTimeoutMS)
{
    ULONG aWritten = 0;
    AssertReturn(ptr(), aWritten);
    com::SafeArray <BYTE> data;
    ToSafeArray(aData, data);
    mRC = ptr()->WriteAt(aOffset, ComSafeArrayAsInParam(data), aTimeoutMS, &aWritten);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWritten;
}

// IFsObjInfo wrapper

LONG64 CFsObjInfo::GetAccessTime() const
{
    LONG64 aAccessTime = 0;
    AssertReturn(ptr(), aAccessTime);
    mRC = ptr()->COMGETTER(AccessTime)(&aAccessTime);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAccessTime;
}

LONG64 CFsObjInfo::GetAllocatedSize() const
{
    LONG64 aAllocatedSize = 0;
    AssertReturn(ptr(), aAllocatedSize);
    mRC = ptr()->COMGETTER(AllocatedSize)(&aAllocatedSize);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAllocatedSize;
}

LONG64 CFsObjInfo::GetBirthTime() const
{
    LONG64 aBirthTime = 0;
    AssertReturn(ptr(), aBirthTime);
    mRC = ptr()->COMGETTER(BirthTime)(&aBirthTime);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBirthTime;
}

LONG64 CFsObjInfo::GetChangeTime() const
{
    LONG64 aChangeTime = 0;
    AssertReturn(ptr(), aChangeTime);
    mRC = ptr()->COMGETTER(ChangeTime)(&aChangeTime);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aChangeTime;
}

ULONG CFsObjInfo::GetDeviceNumber() const
{
    ULONG aDeviceNumber = 0;
    AssertReturn(ptr(), aDeviceNumber);
    mRC = ptr()->COMGETTER(DeviceNumber)(&aDeviceNumber);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDeviceNumber;
}

QString CFsObjInfo::GetFileAttributes() const
{
    QString aFileAttributes;
    AssertReturn(ptr(), aFileAttributes);
    mRC = ptr()->COMGETTER(FileAttributes)(BSTROut(aFileAttributes));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFileAttributes;
}

ULONG CFsObjInfo::GetGenerationId() const
{
    ULONG aGenerationId = 0;
    AssertReturn(ptr(), aGenerationId);
    mRC = ptr()->COMGETTER(GenerationId)(&aGenerationId);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGenerationId;
}

ULONG CFsObjInfo::GetGID() const
{
    ULONG aGID = 0;
    AssertReturn(ptr(), aGID);
    mRC = ptr()->COMGETTER(GID)(&aGID);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGID;
}

QString CFsObjInfo::GetGroupName() const
{
    QString aGroupName;
    AssertReturn(ptr(), aGroupName);
    mRC = ptr()->COMGETTER(GroupName)(BSTROut(aGroupName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGroupName;
}

ULONG CFsObjInfo::GetHardLinks() const
{
    ULONG aHardLinks = 0;
    AssertReturn(ptr(), aHardLinks);
    mRC = ptr()->COMGETTER(HardLinks)(&aHardLinks);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHardLinks;
}

LONG64 CFsObjInfo::GetModificationTime() const
{
    LONG64 aModificationTime = 0;
    AssertReturn(ptr(), aModificationTime);
    mRC = ptr()->COMGETTER(ModificationTime)(&aModificationTime);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aModificationTime;
}

QString CFsObjInfo::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

LONG64 CFsObjInfo::GetNodeId() const
{
    LONG64 aNodeId = 0;
    AssertReturn(ptr(), aNodeId);
    mRC = ptr()->COMGETTER(NodeId)(&aNodeId);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNodeId;
}

ULONG CFsObjInfo::GetNodeIdDevice() const
{
    ULONG aNodeIdDevice = 0;
    AssertReturn(ptr(), aNodeIdDevice);
    mRC = ptr()->COMGETTER(NodeIdDevice)(&aNodeIdDevice);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNodeIdDevice;
}

LONG64 CFsObjInfo::GetObjectSize() const
{
    LONG64 aObjectSize = 0;
    AssertReturn(ptr(), aObjectSize);
    mRC = ptr()->COMGETTER(ObjectSize)(&aObjectSize);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aObjectSize;
}

KFsObjType CFsObjInfo::GetType() const
{
    KFsObjType aType = (KFsObjType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KFsObjType, FsObjType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

ULONG CFsObjInfo::GetUID() const
{
    ULONG aUID = 0;
    AssertReturn(ptr(), aUID);
    mRC = ptr()->COMGETTER(UID)(&aUID);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUID;
}

ULONG CFsObjInfo::GetUserFlags() const
{
    ULONG aUserFlags = 0;
    AssertReturn(ptr(), aUserFlags);
    mRC = ptr()->COMGETTER(UserFlags)(&aUserFlags);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUserFlags;
}

QString CFsObjInfo::GetUserName() const
{
    QString aUserName;
    AssertReturn(ptr(), aUserName);
    mRC = ptr()->COMGETTER(UserName)(BSTROut(aUserName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUserName;
}

// IGuestFsObjInfo wrapper

LONG64 CGuestFsObjInfo::GetAccessTime() const
{
    LONG64 aAccessTime = 0;
    AssertReturn(ptr(), aAccessTime);
    mRC = ptr()->COMGETTER(AccessTime)(&aAccessTime);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAccessTime;
}

LONG64 CGuestFsObjInfo::GetAllocatedSize() const
{
    LONG64 aAllocatedSize = 0;
    AssertReturn(ptr(), aAllocatedSize);
    mRC = ptr()->COMGETTER(AllocatedSize)(&aAllocatedSize);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAllocatedSize;
}

LONG64 CGuestFsObjInfo::GetBirthTime() const
{
    LONG64 aBirthTime = 0;
    AssertReturn(ptr(), aBirthTime);
    mRC = ptr()->COMGETTER(BirthTime)(&aBirthTime);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBirthTime;
}

LONG64 CGuestFsObjInfo::GetChangeTime() const
{
    LONG64 aChangeTime = 0;
    AssertReturn(ptr(), aChangeTime);
    mRC = ptr()->COMGETTER(ChangeTime)(&aChangeTime);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aChangeTime;
}

ULONG CGuestFsObjInfo::GetDeviceNumber() const
{
    ULONG aDeviceNumber = 0;
    AssertReturn(ptr(), aDeviceNumber);
    mRC = ptr()->COMGETTER(DeviceNumber)(&aDeviceNumber);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDeviceNumber;
}

QString CGuestFsObjInfo::GetFileAttributes() const
{
    QString aFileAttributes;
    AssertReturn(ptr(), aFileAttributes);
    mRC = ptr()->COMGETTER(FileAttributes)(BSTROut(aFileAttributes));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFileAttributes;
}

ULONG CGuestFsObjInfo::GetGenerationId() const
{
    ULONG aGenerationId = 0;
    AssertReturn(ptr(), aGenerationId);
    mRC = ptr()->COMGETTER(GenerationId)(&aGenerationId);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGenerationId;
}

ULONG CGuestFsObjInfo::GetGID() const
{
    ULONG aGID = 0;
    AssertReturn(ptr(), aGID);
    mRC = ptr()->COMGETTER(GID)(&aGID);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGID;
}

QString CGuestFsObjInfo::GetGroupName() const
{
    QString aGroupName;
    AssertReturn(ptr(), aGroupName);
    mRC = ptr()->COMGETTER(GroupName)(BSTROut(aGroupName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGroupName;
}

ULONG CGuestFsObjInfo::GetHardLinks() const
{
    ULONG aHardLinks = 0;
    AssertReturn(ptr(), aHardLinks);
    mRC = ptr()->COMGETTER(HardLinks)(&aHardLinks);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHardLinks;
}

LONG64 CGuestFsObjInfo::GetModificationTime() const
{
    LONG64 aModificationTime = 0;
    AssertReturn(ptr(), aModificationTime);
    mRC = ptr()->COMGETTER(ModificationTime)(&aModificationTime);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aModificationTime;
}

QString CGuestFsObjInfo::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

LONG64 CGuestFsObjInfo::GetNodeId() const
{
    LONG64 aNodeId = 0;
    AssertReturn(ptr(), aNodeId);
    mRC = ptr()->COMGETTER(NodeId)(&aNodeId);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNodeId;
}

ULONG CGuestFsObjInfo::GetNodeIdDevice() const
{
    ULONG aNodeIdDevice = 0;
    AssertReturn(ptr(), aNodeIdDevice);
    mRC = ptr()->COMGETTER(NodeIdDevice)(&aNodeIdDevice);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNodeIdDevice;
}

LONG64 CGuestFsObjInfo::GetObjectSize() const
{
    LONG64 aObjectSize = 0;
    AssertReturn(ptr(), aObjectSize);
    mRC = ptr()->COMGETTER(ObjectSize)(&aObjectSize);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aObjectSize;
}

KFsObjType CGuestFsObjInfo::GetType() const
{
    KFsObjType aType = (KFsObjType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KFsObjType, FsObjType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

ULONG CGuestFsObjInfo::GetUID() const
{
    ULONG aUID = 0;
    AssertReturn(ptr(), aUID);
    mRC = ptr()->COMGETTER(UID)(&aUID);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUID;
}

ULONG CGuestFsObjInfo::GetUserFlags() const
{
    ULONG aUserFlags = 0;
    AssertReturn(ptr(), aUserFlags);
    mRC = ptr()->COMGETTER(UserFlags)(&aUserFlags);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUserFlags;
}

QString CGuestFsObjInfo::GetUserName() const
{
    QString aUserName;
    AssertReturn(ptr(), aUserName);
    mRC = ptr()->COMGETTER(UserName)(BSTROut(aUserName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUserName;
}

// IGuest wrapper

QString CGuest::GetOSTypeId() const
{
    QString aOSTypeId;
    AssertReturn(ptr(), aOSTypeId);
    mRC = ptr()->COMGETTER(OSTypeId)(BSTROut(aOSTypeId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOSTypeId;
}

KAdditionsRunLevelType CGuest::GetAdditionsRunLevel() const
{
    KAdditionsRunLevelType aAdditionsRunLevel = (KAdditionsRunLevelType) 0;
    AssertReturn(ptr(), aAdditionsRunLevel);
    mRC = ptr()->COMGETTER(AdditionsRunLevel)(ENUMOut<KAdditionsRunLevelType, AdditionsRunLevelType_T>(aAdditionsRunLevel));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAdditionsRunLevel;
}

QString CGuest::GetAdditionsVersion() const
{
    QString aAdditionsVersion;
    AssertReturn(ptr(), aAdditionsVersion);
    mRC = ptr()->COMGETTER(AdditionsVersion)(BSTROut(aAdditionsVersion));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAdditionsVersion;
}

ULONG CGuest::GetAdditionsRevision() const
{
    ULONG aAdditionsRevision = 0;
    AssertReturn(ptr(), aAdditionsRevision);
    mRC = ptr()->COMGETTER(AdditionsRevision)(&aAdditionsRevision);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAdditionsRevision;
}

CEventSource CGuest::GetEventSource() const
{
    CEventSource aEventSource;
    AssertReturn(ptr(), aEventSource);
    IEventSource* eventSourcePtr = NULL;
    mRC = ptr()->COMGETTER(EventSource)(&eventSourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aEventSource.setPtr(eventSourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEventSource;
}

QVector<CAdditionsFacility> CGuest::GetFacilities() const
{
    QVector<CAdditionsFacility> aFacilities;
    AssertReturn(ptr(), aFacilities);
    com::SafeIfaceArray <IAdditionsFacility> facilities;
    mRC = ptr()->COMGETTER(Facilities)(ComSafeArrayAsOutParam(facilities));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(facilities, aFacilities);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFacilities;
}

QVector<CGuestSession> CGuest::GetSessions() const
{
    QVector<CGuestSession> aSessions;
    AssertReturn(ptr(), aSessions);
    com::SafeIfaceArray <IGuestSession> sessions;
    mRC = ptr()->COMGETTER(Sessions)(ComSafeArrayAsOutParam(sessions));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(sessions, aSessions);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSessions;
}

ULONG CGuest::GetMemoryBalloonSize() const
{
    ULONG aMemoryBalloonSize = 0;
    AssertReturn(ptr(), aMemoryBalloonSize);
    mRC = ptr()->COMGETTER(MemoryBalloonSize)(&aMemoryBalloonSize);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMemoryBalloonSize;
}
void CGuest::SetMemoryBalloonSize(ULONG aMemoryBalloonSize)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(MemoryBalloonSize)(aMemoryBalloonSize);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CGuest::GetStatisticsUpdateInterval() const
{
    ULONG aStatisticsUpdateInterval = 0;
    AssertReturn(ptr(), aStatisticsUpdateInterval);
    mRC = ptr()->COMGETTER(StatisticsUpdateInterval)(&aStatisticsUpdateInterval);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStatisticsUpdateInterval;
}
void CGuest::SetStatisticsUpdateInterval(ULONG aStatisticsUpdateInterval)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(StatisticsUpdateInterval)(aStatisticsUpdateInterval);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CGuest::InternalGetStatistics(ULONG & aCpuUser, ULONG & aCpuKernel, ULONG & aCpuIdle, ULONG & aMemTotal, ULONG & aMemFree, ULONG & aMemBalloon, ULONG & aMemShared, ULONG & aMemCache, ULONG & aPagedTotal, ULONG & aMemAllocTotal, ULONG & aMemFreeTotal, ULONG & aMemBalloonTotal, ULONG & aMemSharedTotal)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->InternalGetStatistics(&aCpuUser, &aCpuKernel, &aCpuIdle, &aMemTotal, &aMemFree, &aMemBalloon, &aMemShared, &aMemCache, &aPagedTotal, &aMemAllocTotal, &aMemFreeTotal, &aMemBalloonTotal, &aMemSharedTotal);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KAdditionsFacilityStatus CGuest::GetFacilityStatus(const KAdditionsFacilityType & aFacility, LONG64 & aTimestamp)
{
    KAdditionsFacilityStatus aStatus = (KAdditionsFacilityStatus) 0;
    AssertReturn(ptr(), aStatus);
    mRC = ptr()->GetFacilityStatus((AdditionsFacilityType_T) aFacility, &aTimestamp, ENUMOut<KAdditionsFacilityStatus, AdditionsFacilityStatus_T>(aStatus));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStatus;
}

BOOL CGuest::GetAdditionsStatus(const KAdditionsRunLevelType & aLevel)
{
    BOOL aActive = FALSE;
    AssertReturn(ptr(), aActive);
    mRC = ptr()->GetAdditionsStatus((AdditionsRunLevelType_T) aLevel, &aActive);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aActive;
}

void CGuest::SetCredentials(const QString & aUserName, const QString & aPassword, const QString & aDomain, BOOL aAllowInteractiveLogon)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetCredentials(BSTRIn(aUserName), BSTRIn(aPassword), BSTRIn(aDomain), aAllowInteractiveLogon);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KDragAndDropAction CGuest::DragHGEnter(ULONG aScreenId, ULONG aY, ULONG aX, const KDragAndDropAction & aDefaultAction, const QVector<KDragAndDropAction> & aAllowedActions, const QVector<QString> & aFormats)
{
    KDragAndDropAction aResultAction = (KDragAndDropAction) 0;
    AssertReturn(ptr(), aResultAction);
    com::SafeArray <DragAndDropAction_T> allowedActions;
    ToSafeArray(aAllowedActions, allowedActions);
    com::SafeArray <BSTR> formats;
    ToSafeArray(aFormats, formats);
    mRC = ptr()->DragHGEnter(aScreenId, aY, aX, (DragAndDropAction_T) aDefaultAction, ComSafeArrayAsInParam(allowedActions), ComSafeArrayAsInParam(formats), ENUMOut<KDragAndDropAction, DragAndDropAction_T>(aResultAction));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResultAction;
}

KDragAndDropAction CGuest::DragHGMove(ULONG aScreenId, ULONG aX, ULONG aY, const KDragAndDropAction & aDefaultAction, const QVector<KDragAndDropAction> & aAllowedActions, const QVector<QString> & aFormats)
{
    KDragAndDropAction aResultAction = (KDragAndDropAction) 0;
    AssertReturn(ptr(), aResultAction);
    com::SafeArray <DragAndDropAction_T> allowedActions;
    ToSafeArray(aAllowedActions, allowedActions);
    com::SafeArray <BSTR> formats;
    ToSafeArray(aFormats, formats);
    mRC = ptr()->DragHGMove(aScreenId, aX, aY, (DragAndDropAction_T) aDefaultAction, ComSafeArrayAsInParam(allowedActions), ComSafeArrayAsInParam(formats), ENUMOut<KDragAndDropAction, DragAndDropAction_T>(aResultAction));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResultAction;
}

void CGuest::DragHGLeave(ULONG aScreenId)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->DragHGLeave(aScreenId);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KDragAndDropAction CGuest::DragHGDrop(ULONG aScreenId, ULONG aX, ULONG aY, const KDragAndDropAction & aDefaultAction, const QVector<KDragAndDropAction> & aAllowedActions, const QVector<QString> & aFormats, QString & aFormat)
{
    KDragAndDropAction aResultAction = (KDragAndDropAction) 0;
    AssertReturn(ptr(), aResultAction);
    com::SafeArray <DragAndDropAction_T> allowedActions;
    ToSafeArray(aAllowedActions, allowedActions);
    com::SafeArray <BSTR> formats;
    ToSafeArray(aFormats, formats);
    mRC = ptr()->DragHGDrop(aScreenId, aX, aY, (DragAndDropAction_T) aDefaultAction, ComSafeArrayAsInParam(allowedActions), ComSafeArrayAsInParam(formats), BSTROut(aFormat), ENUMOut<KDragAndDropAction, DragAndDropAction_T>(aResultAction));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResultAction;
}

CProgress CGuest::DragHGPutData(ULONG aScreenId, const QString & aFormat, const QVector<BYTE> & aData)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    com::SafeArray <BYTE> data;
    ToSafeArray(aData, data);
    IProgress* progressPtr = NULL;
    mRC = ptr()->DragHGPutData(aScreenId, BSTRIn(aFormat), ComSafeArrayAsInParam(data), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

KDragAndDropAction CGuest::DragGHPending(ULONG aScreenId, QVector<QString> & aFormats, QVector<KDragAndDropAction> & aAllowedActions)
{
    KDragAndDropAction aDefaultAction = (KDragAndDropAction) 0;
    AssertReturn(ptr(), aDefaultAction);
    com::SafeArray <BSTR> formats;
    com::SafeArray <DragAndDropAction_T> allowedActions;
    mRC = ptr()->DragGHPending(aScreenId, ComSafeArrayAsOutParam(formats), ComSafeArrayAsOutParam(allowedActions), ENUMOut<KDragAndDropAction, DragAndDropAction_T>(aDefaultAction));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(formats, aFormats);
    FromSafeArray(allowedActions, aAllowedActions);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDefaultAction;
}

CProgress CGuest::DragGHDropped(const QString & aFormat, const KDragAndDropAction & aAction)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->DragGHDropped(BSTRIn(aFormat), (DragAndDropAction_T) aAction, &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

QVector<BYTE> CGuest::DragGHGetData()
{
    QVector<BYTE> aData;
    AssertReturn(ptr(), aData);
    com::SafeArray <BYTE> data;
    mRC = ptr()->DragGHGetData(ComSafeArrayAsOutParam(data));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(data, aData);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aData;
}

CGuestSession CGuest::CreateSession(const QString & aUser, const QString & aPassword, const QString & aDomain, const QString & aSessionName)
{
    CGuestSession aGuestSession;
    AssertReturn(ptr(), aGuestSession);
    IGuestSession* guestSessionPtr = NULL;
    mRC = ptr()->CreateSession(BSTRIn(aUser), BSTRIn(aPassword), BSTRIn(aDomain), BSTRIn(aSessionName), &guestSessionPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aGuestSession.setPtr(guestSessionPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGuestSession;
}

QVector<CGuestSession> CGuest::FindSession(const QString & aSessionName)
{
    QVector<CGuestSession> aSessions;
    AssertReturn(ptr(), aSessions);
    com::SafeIfaceArray <IGuestSession> sessions;
    mRC = ptr()->FindSession(BSTRIn(aSessionName), ComSafeArrayAsOutParam(sessions));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(sessions, aSessions);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSessions;
}

CProgress CGuest::UpdateGuestAdditions(const QString & aSource, const QVector<QString> & aArguments, const QVector<KAdditionsUpdateFlag> & aFlags)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    com::SafeArray <BSTR> arguments;
    ToSafeArray(aArguments, arguments);
    com::SafeArray <AdditionsUpdateFlag_T> flags;
    ToSafeArray(aFlags, flags);
    IProgress* progressPtr = NULL;
    mRC = ptr()->UpdateGuestAdditions(BSTRIn(aSource), ComSafeArrayAsInParam(arguments), ComSafeArrayAsInParam(flags), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

// IProgress wrapper

QString CProgress::GetId() const
{
    QString aId;
    AssertReturn(ptr(), aId);
    mRC = ptr()->COMGETTER(Id)(BSTROut(aId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aId;
}

QString CProgress::GetDescription() const
{
    QString aDescription;
    AssertReturn(ptr(), aDescription);
    mRC = ptr()->COMGETTER(Description)(BSTROut(aDescription));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDescription;
}

CUnknown CProgress::GetInitiator() const
{
    CUnknown aInitiator;
    AssertReturn(ptr(), aInitiator);
    IUnknown* initiatorPtr = NULL;
    mRC = ptr()->COMGETTER(Initiator)(&initiatorPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aInitiator.setPtr(initiatorPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aInitiator;
}

BOOL CProgress::GetCancelable() const
{
    BOOL aCancelable = FALSE;
    AssertReturn(ptr(), aCancelable);
    mRC = ptr()->COMGETTER(Cancelable)(&aCancelable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCancelable;
}

ULONG CProgress::GetPercent() const
{
    ULONG aPercent = 0;
    AssertReturn(ptr(), aPercent);
    mRC = ptr()->COMGETTER(Percent)(&aPercent);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPercent;
}

LONG CProgress::GetTimeRemaining() const
{
    LONG aTimeRemaining = 0;
    AssertReturn(ptr(), aTimeRemaining);
    mRC = ptr()->COMGETTER(TimeRemaining)(&aTimeRemaining);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aTimeRemaining;
}

BOOL CProgress::GetCompleted() const
{
    BOOL aCompleted = FALSE;
    AssertReturn(ptr(), aCompleted);
    mRC = ptr()->COMGETTER(Completed)(&aCompleted);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCompleted;
}

BOOL CProgress::GetCanceled() const
{
    BOOL aCanceled = FALSE;
    AssertReturn(ptr(), aCanceled);
    mRC = ptr()->COMGETTER(Canceled)(&aCanceled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCanceled;
}

LONG CProgress::GetResultCode() const
{
    LONG aResultCode = 0;
    AssertReturn(ptr(), aResultCode);
    mRC = ptr()->COMGETTER(ResultCode)(&aResultCode);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResultCode;
}

CVirtualBoxErrorInfo CProgress::GetErrorInfo() const
{
    CVirtualBoxErrorInfo aErrorInfo;
    AssertReturn(ptr(), aErrorInfo);
    IVirtualBoxErrorInfo* errorInfoPtr = NULL;
    mRC = ptr()->COMGETTER(ErrorInfo)(&errorInfoPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aErrorInfo.setPtr(errorInfoPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aErrorInfo;
}

ULONG CProgress::GetOperationCount() const
{
    ULONG aOperationCount = 0;
    AssertReturn(ptr(), aOperationCount);
    mRC = ptr()->COMGETTER(OperationCount)(&aOperationCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOperationCount;
}

ULONG CProgress::GetOperation() const
{
    ULONG aOperation = 0;
    AssertReturn(ptr(), aOperation);
    mRC = ptr()->COMGETTER(Operation)(&aOperation);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOperation;
}

QString CProgress::GetOperationDescription() const
{
    QString aOperationDescription;
    AssertReturn(ptr(), aOperationDescription);
    mRC = ptr()->COMGETTER(OperationDescription)(BSTROut(aOperationDescription));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOperationDescription;
}

ULONG CProgress::GetOperationPercent() const
{
    ULONG aOperationPercent = 0;
    AssertReturn(ptr(), aOperationPercent);
    mRC = ptr()->COMGETTER(OperationPercent)(&aOperationPercent);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOperationPercent;
}

ULONG CProgress::GetOperationWeight() const
{
    ULONG aOperationWeight = 0;
    AssertReturn(ptr(), aOperationWeight);
    mRC = ptr()->COMGETTER(OperationWeight)(&aOperationWeight);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOperationWeight;
}

ULONG CProgress::GetTimeout() const
{
    ULONG aTimeout = 0;
    AssertReturn(ptr(), aTimeout);
    mRC = ptr()->COMGETTER(Timeout)(&aTimeout);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aTimeout;
}
void CProgress::SetTimeout(ULONG aTimeout)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Timeout)(aTimeout);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CProgress::SetCurrentOperationProgress(ULONG aPercent)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetCurrentOperationProgress(aPercent);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CProgress::SetNextOperation(const QString & aNextOperationDescription, ULONG aNextOperationsWeight)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetNextOperation(BSTRIn(aNextOperationDescription), aNextOperationsWeight);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CProgress::WaitForCompletion(LONG aTimeout)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->WaitForCompletion(aTimeout);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CProgress::WaitForOperationCompletion(ULONG aOperation, LONG aTimeout)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->WaitForOperationCompletion(aOperation, aTimeout);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CProgress::WaitForAsyncProgressCompletion(const CProgress & aPProgressAsync)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->WaitForAsyncProgressCompletion(aPProgressAsync.ptr());
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CProgress::Cancel()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Cancel();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// ISnapshot wrapper

QString CSnapshot::GetId() const
{
    QString aId;
    AssertReturn(ptr(), aId);
    mRC = ptr()->COMGETTER(Id)(BSTROut(aId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aId;
}

QString CSnapshot::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}
void CSnapshot::SetName(const QString & aName)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Name)(BSTRIn(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CSnapshot::GetDescription() const
{
    QString aDescription;
    AssertReturn(ptr(), aDescription);
    mRC = ptr()->COMGETTER(Description)(BSTROut(aDescription));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDescription;
}
void CSnapshot::SetDescription(const QString & aDescription)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Description)(BSTRIn(aDescription));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

LONG64 CSnapshot::GetTimeStamp() const
{
    LONG64 aTimeStamp = 0;
    AssertReturn(ptr(), aTimeStamp);
    mRC = ptr()->COMGETTER(TimeStamp)(&aTimeStamp);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aTimeStamp;
}

BOOL CSnapshot::GetOnline() const
{
    BOOL aOnline = FALSE;
    AssertReturn(ptr(), aOnline);
    mRC = ptr()->COMGETTER(Online)(&aOnline);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOnline;
}

CMachine CSnapshot::GetMachine() const
{
    CMachine aMachine;
    AssertReturn(ptr(), aMachine);
    IMachine* machinePtr = NULL;
    mRC = ptr()->COMGETTER(Machine)(&machinePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aMachine.setPtr(machinePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachine;
}

CSnapshot CSnapshot::GetParent() const
{
    CSnapshot aParent;
    AssertReturn(ptr(), aParent);
    ISnapshot* parentPtr = NULL;
    mRC = ptr()->COMGETTER(Parent)(&parentPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aParent.setPtr(parentPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aParent;
}

QVector<CSnapshot> CSnapshot::GetChildren() const
{
    QVector<CSnapshot> aChildren;
    AssertReturn(ptr(), aChildren);
    com::SafeIfaceArray <ISnapshot> children;
    mRC = ptr()->COMGETTER(Children)(ComSafeArrayAsOutParam(children));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(children, aChildren);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aChildren;
}

ULONG CSnapshot::GetChildrenCount() const
{
    ULONG aChildrenCount = 0;
    AssertReturn(ptr(), aChildrenCount);
    mRC = ptr()->GetChildrenCount(&aChildrenCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aChildrenCount;
}

// IMediumAttachment wrapper

CMedium CMediumAttachment::GetMedium() const
{
    CMedium aMedium;
    AssertReturn(ptr(), aMedium);
    IMedium* mediumPtr = NULL;
    mRC = ptr()->COMGETTER(Medium)(&mediumPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aMedium.setPtr(mediumPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMedium;
}

QString CMediumAttachment::GetController() const
{
    QString aController;
    AssertReturn(ptr(), aController);
    mRC = ptr()->COMGETTER(Controller)(BSTROut(aController));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aController;
}

LONG CMediumAttachment::GetPort() const
{
    LONG aPort = 0;
    AssertReturn(ptr(), aPort);
    mRC = ptr()->COMGETTER(Port)(&aPort);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPort;
}

LONG CMediumAttachment::GetDevice() const
{
    LONG aDevice = 0;
    AssertReturn(ptr(), aDevice);
    mRC = ptr()->COMGETTER(Device)(&aDevice);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDevice;
}

KDeviceType CMediumAttachment::GetType() const
{
    KDeviceType aType = (KDeviceType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KDeviceType, DeviceType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

BOOL CMediumAttachment::GetPassthrough() const
{
    BOOL aPassthrough = FALSE;
    AssertReturn(ptr(), aPassthrough);
    mRC = ptr()->COMGETTER(Passthrough)(&aPassthrough);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPassthrough;
}

BOOL CMediumAttachment::GetTemporaryEject() const
{
    BOOL aTemporaryEject = FALSE;
    AssertReturn(ptr(), aTemporaryEject);
    mRC = ptr()->COMGETTER(TemporaryEject)(&aTemporaryEject);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aTemporaryEject;
}

BOOL CMediumAttachment::GetIsEjected() const
{
    BOOL aIsEjected = FALSE;
    AssertReturn(ptr(), aIsEjected);
    mRC = ptr()->COMGETTER(IsEjected)(&aIsEjected);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aIsEjected;
}

BOOL CMediumAttachment::GetNonRotational() const
{
    BOOL aNonRotational = FALSE;
    AssertReturn(ptr(), aNonRotational);
    mRC = ptr()->COMGETTER(NonRotational)(&aNonRotational);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNonRotational;
}

BOOL CMediumAttachment::GetDiscard() const
{
    BOOL aDiscard = FALSE;
    AssertReturn(ptr(), aDiscard);
    mRC = ptr()->COMGETTER(Discard)(&aDiscard);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDiscard;
}

BOOL CMediumAttachment::GetHotPluggable() const
{
    BOOL aHotPluggable = FALSE;
    AssertReturn(ptr(), aHotPluggable);
    mRC = ptr()->COMGETTER(HotPluggable)(&aHotPluggable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHotPluggable;
}

CBandwidthGroup CMediumAttachment::GetBandwidthGroup() const
{
    CBandwidthGroup aBandwidthGroup;
    AssertReturn(ptr(), aBandwidthGroup);
    IBandwidthGroup* bandwidthGroupPtr = NULL;
    mRC = ptr()->COMGETTER(BandwidthGroup)(&bandwidthGroupPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aBandwidthGroup.setPtr(bandwidthGroupPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBandwidthGroup;
}

// IMedium wrapper

QString CMedium::GetId() const
{
    QString aId;
    AssertReturn(ptr(), aId);
    mRC = ptr()->COMGETTER(Id)(BSTROut(aId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aId;
}

QString CMedium::GetDescription() const
{
    QString aDescription;
    AssertReturn(ptr(), aDescription);
    mRC = ptr()->COMGETTER(Description)(BSTROut(aDescription));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDescription;
}
void CMedium::SetDescription(const QString & aDescription)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Description)(BSTRIn(aDescription));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KMediumState CMedium::GetState() const
{
    KMediumState aState = (KMediumState) 0;
    AssertReturn(ptr(), aState);
    mRC = ptr()->COMGETTER(State)(ENUMOut<KMediumState, MediumState_T>(aState));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aState;
}

QVector<KMediumVariant> CMedium::GetVariant() const
{
    QVector<KMediumVariant> aVariant;
    AssertReturn(ptr(), aVariant);
    com::SafeArray <MediumVariant_T> variant;
    mRC = ptr()->COMGETTER(Variant)(ComSafeArrayAsOutParam(variant));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(variant, aVariant);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVariant;
}

QString CMedium::GetLocation() const
{
    QString aLocation;
    AssertReturn(ptr(), aLocation);
    mRC = ptr()->COMGETTER(Location)(BSTROut(aLocation));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLocation;
}

QString CMedium::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

KDeviceType CMedium::GetDeviceType() const
{
    KDeviceType aDeviceType = (KDeviceType) 0;
    AssertReturn(ptr(), aDeviceType);
    mRC = ptr()->COMGETTER(DeviceType)(ENUMOut<KDeviceType, DeviceType_T>(aDeviceType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDeviceType;
}

BOOL CMedium::GetHostDrive() const
{
    BOOL aHostDrive = FALSE;
    AssertReturn(ptr(), aHostDrive);
    mRC = ptr()->COMGETTER(HostDrive)(&aHostDrive);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHostDrive;
}

LONG64 CMedium::GetSize() const
{
    LONG64 aSize = 0;
    AssertReturn(ptr(), aSize);
    mRC = ptr()->COMGETTER(Size)(&aSize);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSize;
}

QString CMedium::GetFormat() const
{
    QString aFormat;
    AssertReturn(ptr(), aFormat);
    mRC = ptr()->COMGETTER(Format)(BSTROut(aFormat));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFormat;
}

CMediumFormat CMedium::GetMediumFormat() const
{
    CMediumFormat aMediumFormat;
    AssertReturn(ptr(), aMediumFormat);
    IMediumFormat* mediumFormatPtr = NULL;
    mRC = ptr()->COMGETTER(MediumFormat)(&mediumFormatPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aMediumFormat.setPtr(mediumFormatPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMediumFormat;
}

KMediumType CMedium::GetType() const
{
    KMediumType aType = (KMediumType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KMediumType, MediumType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}
void CMedium::SetType(const KMediumType & aType)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Type)((MediumType_T) aType);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QVector<KMediumType> CMedium::GetAllowedTypes() const
{
    QVector<KMediumType> aAllowedTypes;
    AssertReturn(ptr(), aAllowedTypes);
    com::SafeArray <MediumType_T> allowedTypes;
    mRC = ptr()->COMGETTER(AllowedTypes)(ComSafeArrayAsOutParam(allowedTypes));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(allowedTypes, aAllowedTypes);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAllowedTypes;
}

CMedium CMedium::GetParent() const
{
    CMedium aParent;
    AssertReturn(ptr(), aParent);
    IMedium* parentPtr = NULL;
    mRC = ptr()->COMGETTER(Parent)(&parentPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aParent.setPtr(parentPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aParent;
}

QVector<CMedium> CMedium::GetChildren() const
{
    QVector<CMedium> aChildren;
    AssertReturn(ptr(), aChildren);
    com::SafeIfaceArray <IMedium> children;
    mRC = ptr()->COMGETTER(Children)(ComSafeArrayAsOutParam(children));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(children, aChildren);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aChildren;
}

CMedium CMedium::GetBase() const
{
    CMedium aBase;
    AssertReturn(ptr(), aBase);
    IMedium* basePtr = NULL;
    mRC = ptr()->COMGETTER(Base)(&basePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aBase.setPtr(basePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBase;
}

BOOL CMedium::GetReadOnly() const
{
    BOOL aReadOnly = FALSE;
    AssertReturn(ptr(), aReadOnly);
    mRC = ptr()->COMGETTER(ReadOnly)(&aReadOnly);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aReadOnly;
}

LONG64 CMedium::GetLogicalSize() const
{
    LONG64 aLogicalSize = 0;
    AssertReturn(ptr(), aLogicalSize);
    mRC = ptr()->COMGETTER(LogicalSize)(&aLogicalSize);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLogicalSize;
}

BOOL CMedium::GetAutoReset() const
{
    BOOL aAutoReset = FALSE;
    AssertReturn(ptr(), aAutoReset);
    mRC = ptr()->COMGETTER(AutoReset)(&aAutoReset);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAutoReset;
}
void CMedium::SetAutoReset(BOOL aAutoReset)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(AutoReset)(aAutoReset);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CMedium::GetLastAccessError() const
{
    QString aLastAccessError;
    AssertReturn(ptr(), aLastAccessError);
    mRC = ptr()->COMGETTER(LastAccessError)(BSTROut(aLastAccessError));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLastAccessError;
}

QVector<QString> CMedium::GetMachineIds() const
{
    QVector<QString> aMachineIds;
    AssertReturn(ptr(), aMachineIds);
    com::SafeArray <BSTR> machineIds;
    mRC = ptr()->COMGETTER(MachineIds)(ComSafeArrayAsOutParam(machineIds));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(machineIds, aMachineIds);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachineIds;
}

void CMedium::SetIds(BOOL aSetImageId, QString aImageId, BOOL aSetParentId, QString aParentId)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetIds(aSetImageId, BSTRIn(aImageId), aSetParentId, BSTRIn(aParentId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KMediumState CMedium::RefreshState()
{
    KMediumState aState = (KMediumState) 0;
    AssertReturn(ptr(), aState);
    mRC = ptr()->RefreshState(ENUMOut<KMediumState, MediumState_T>(aState));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aState;
}

QVector<QString> CMedium::GetSnapshotIds(QString aMachineId)
{
    QVector<QString> aSnapshotIds;
    AssertReturn(ptr(), aSnapshotIds);
    com::SafeArray <BSTR> snapshotIds;
    mRC = ptr()->GetSnapshotIds(BSTRIn(aMachineId), ComSafeArrayAsOutParam(snapshotIds));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(snapshotIds, aSnapshotIds);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSnapshotIds;
}

CToken CMedium::LockRead()
{
    CToken aToken;
    AssertReturn(ptr(), aToken);
    IToken* tokenPtr = NULL;
    mRC = ptr()->LockRead(&tokenPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aToken.setPtr(tokenPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aToken;
}

CToken CMedium::LockWrite()
{
    CToken aToken;
    AssertReturn(ptr(), aToken);
    IToken* tokenPtr = NULL;
    mRC = ptr()->LockWrite(&tokenPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aToken.setPtr(tokenPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aToken;
}

void CMedium::Close()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Close();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CMedium::GetProperty(const QString & aName) const
{
    QString aValue;
    AssertReturn(ptr(), aValue);
    mRC = ptr()->GetProperty(BSTRIn(aName), BSTROut(aValue));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aValue;
}

void CMedium::SetProperty(const QString & aName, const QString & aValue)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProperty(BSTRIn(aName), BSTRIn(aValue));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QVector<QString> CMedium::GetProperties(const QString & aNames, QVector<QString> & aReturnNames) const
{
    QVector<QString> aReturnValues;
    AssertReturn(ptr(), aReturnValues);
    com::SafeArray <BSTR> returnNames;
    com::SafeArray <BSTR> returnValues;
    mRC = ptr()->GetProperties(BSTRIn(aNames), ComSafeArrayAsOutParam(returnNames), ComSafeArrayAsOutParam(returnValues));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(returnNames, aReturnNames);
    FromSafeArray(returnValues, aReturnValues);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aReturnValues;
}

void CMedium::SetProperties(const QVector<QString> & aNames, const QVector<QString> & aValues)
{
    AssertReturnVoid(ptr());
    com::SafeArray <BSTR> names;
    ToSafeArray(aNames, names);
    com::SafeArray <BSTR> values;
    ToSafeArray(aValues, values);
    mRC = ptr()->SetProperties(ComSafeArrayAsInParam(names), ComSafeArrayAsInParam(values));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CProgress CMedium::CreateBaseStorage(LONG64 aLogicalSize, const QVector<KMediumVariant> & aVariant)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    com::SafeArray <MediumVariant_T> variant;
    ToSafeArray(aVariant, variant);
    IProgress* progressPtr = NULL;
    mRC = ptr()->CreateBaseStorage(aLogicalSize, ComSafeArrayAsInParam(variant), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CProgress CMedium::DeleteStorage()
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->DeleteStorage(&progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CProgress CMedium::CreateDiffStorage(const CMedium & aTarget, const QVector<KMediumVariant> & aVariant)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    com::SafeArray <MediumVariant_T> variant;
    ToSafeArray(aVariant, variant);
    IProgress* progressPtr = NULL;
    mRC = ptr()->CreateDiffStorage(aTarget.ptr(), ComSafeArrayAsInParam(variant), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CProgress CMedium::MergeTo(const CMedium & aTarget)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->MergeTo(aTarget.ptr(), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CProgress CMedium::CloneTo(const CMedium & aTarget, const QVector<KMediumVariant> & aVariant, const CMedium & aParent)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    com::SafeArray <MediumVariant_T> variant;
    ToSafeArray(aVariant, variant);
    IProgress* progressPtr = NULL;
    mRC = ptr()->CloneTo(aTarget.ptr(), ComSafeArrayAsInParam(variant), aParent.ptr(), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CProgress CMedium::CloneToBase(const CMedium & aTarget, const QVector<KMediumVariant> & aVariant)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    com::SafeArray <MediumVariant_T> variant;
    ToSafeArray(aVariant, variant);
    IProgress* progressPtr = NULL;
    mRC = ptr()->CloneToBase(aTarget.ptr(), ComSafeArrayAsInParam(variant), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CProgress CMedium::SetLocation(const QString & aLocation)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->SetLocation(BSTRIn(aLocation), &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CProgress CMedium::Compact()
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->Compact(&progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CProgress CMedium::Resize(LONG64 aLogicalSize)
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->Resize(aLogicalSize, &progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

CProgress CMedium::Reset()
{
    CProgress aProgress;
    AssertReturn(ptr(), aProgress);
    IProgress* progressPtr = NULL;
    mRC = ptr()->Reset(&progressPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgress.setPtr(progressPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgress;
}

// IMediumFormat wrapper

QString CMediumFormat::GetId() const
{
    QString aId;
    AssertReturn(ptr(), aId);
    mRC = ptr()->COMGETTER(Id)(BSTROut(aId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aId;
}

QString CMediumFormat::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

QVector<KMediumFormatCapabilities> CMediumFormat::GetCapabilities() const
{
    QVector<KMediumFormatCapabilities> aCapabilities;
    AssertReturn(ptr(), aCapabilities);
    com::SafeArray <MediumFormatCapabilities_T> capabilities;
    mRC = ptr()->COMGETTER(Capabilities)(ComSafeArrayAsOutParam(capabilities));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(capabilities, aCapabilities);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCapabilities;
}

void CMediumFormat::DescribeFileExtensions(QVector<QString> & aExtensions, QVector<KDeviceType> & aTypes)
{
    AssertReturnVoid(ptr());
    com::SafeArray <BSTR> extensions;
    com::SafeArray <DeviceType_T> types;
    mRC = ptr()->DescribeFileExtensions(ComSafeArrayAsOutParam(extensions), ComSafeArrayAsOutParam(types));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(extensions, aExtensions);
    FromSafeArray(types, aTypes);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMediumFormat::DescribeProperties(QVector<QString> & aNames, QVector<QString> & aDescriptions, QVector<KDataType> & aTypes, QVector<ULONG> & aFlags, QVector<QString> & aDefaults) const
{
    AssertReturnVoid(ptr());
    com::SafeArray <BSTR> names;
    com::SafeArray <BSTR> descriptions;
    com::SafeArray <DataType_T> types;
    com::SafeArray <ULONG> flags;
    com::SafeArray <BSTR> defaults;
    mRC = ptr()->DescribeProperties(ComSafeArrayAsOutParam(names), ComSafeArrayAsOutParam(descriptions), ComSafeArrayAsOutParam(types), ComSafeArrayAsOutParam(flags), ComSafeArrayAsOutParam(defaults));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(names, aNames);
    FromSafeArray(descriptions, aDescriptions);
    FromSafeArray(types, aTypes);
    FromSafeArray(flags, aFlags);
    FromSafeArray(defaults, aDefaults);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IToken wrapper

void CToken::Abandon()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Abandon();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CToken::Dummy()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Dummy();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IKeyboard wrapper

CEventSource CKeyboard::GetEventSource() const
{
    CEventSource aEventSource;
    AssertReturn(ptr(), aEventSource);
    IEventSource* eventSourcePtr = NULL;
    mRC = ptr()->COMGETTER(EventSource)(&eventSourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aEventSource.setPtr(eventSourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEventSource;
}

void CKeyboard::PutScancode(LONG aScancode)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->PutScancode(aScancode);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CKeyboard::PutScancodes(const QVector<LONG> & aScancodes)
{
    ULONG aCodesStored = 0;
    AssertReturn(ptr(), aCodesStored);
    com::SafeArray <LONG> scancodes;
    ToSafeArray(aScancodes, scancodes);
    mRC = ptr()->PutScancodes(ComSafeArrayAsInParam(scancodes), &aCodesStored);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCodesStored;
}

void CKeyboard::PutCAD()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->PutCAD();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IMouse wrapper

BOOL CMouse::GetAbsoluteSupported() const
{
    BOOL aAbsoluteSupported = FALSE;
    AssertReturn(ptr(), aAbsoluteSupported);
    mRC = ptr()->COMGETTER(AbsoluteSupported)(&aAbsoluteSupported);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAbsoluteSupported;
}

BOOL CMouse::GetRelativeSupported() const
{
    BOOL aRelativeSupported = FALSE;
    AssertReturn(ptr(), aRelativeSupported);
    mRC = ptr()->COMGETTER(RelativeSupported)(&aRelativeSupported);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRelativeSupported;
}

BOOL CMouse::GetMultiTouchSupported() const
{
    BOOL aMultiTouchSupported = FALSE;
    AssertReturn(ptr(), aMultiTouchSupported);
    mRC = ptr()->COMGETTER(MultiTouchSupported)(&aMultiTouchSupported);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMultiTouchSupported;
}

BOOL CMouse::GetNeedsHostCursor() const
{
    BOOL aNeedsHostCursor = FALSE;
    AssertReturn(ptr(), aNeedsHostCursor);
    mRC = ptr()->COMGETTER(NeedsHostCursor)(&aNeedsHostCursor);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNeedsHostCursor;
}

CEventSource CMouse::GetEventSource() const
{
    CEventSource aEventSource;
    AssertReturn(ptr(), aEventSource);
    IEventSource* eventSourcePtr = NULL;
    mRC = ptr()->COMGETTER(EventSource)(&eventSourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aEventSource.setPtr(eventSourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEventSource;
}

void CMouse::PutMouseEvent(LONG aDx, LONG aDy, LONG aDz, LONG aDw, LONG aButtonState)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->PutMouseEvent(aDx, aDy, aDz, aDw, aButtonState);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMouse::PutMouseEventAbsolute(LONG aX, LONG aY, LONG aDz, LONG aDw, LONG aButtonState)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->PutMouseEventAbsolute(aX, aY, aDz, aDw, aButtonState);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMouse::PutEventMultiTouch(LONG aCount, const QVector<LONG64> & aContacts, ULONG aScanTime)
{
    AssertReturnVoid(ptr());
    com::SafeArray <LONG64> contacts;
    ToSafeArray(aContacts, contacts);
    mRC = ptr()->PutEventMultiTouch(aCount, ComSafeArrayAsInParam(contacts), aScanTime);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMouse::PutEventMultiTouchString(LONG aCount, const QString & aContacts, ULONG aScanTime)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->PutEventMultiTouchString(aCount, BSTRIn(aContacts), aScanTime);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IFramebuffer wrapper

BYTE * CFramebuffer::GetAddress() const
{
    BYTE * aAddress = NULL;
    AssertReturn(ptr(), aAddress);
    mRC = ptr()->COMGETTER(Address)(&aAddress);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAddress;
}

ULONG CFramebuffer::GetWidth() const
{
    ULONG aWidth = 0;
    AssertReturn(ptr(), aWidth);
    mRC = ptr()->COMGETTER(Width)(&aWidth);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWidth;
}

ULONG CFramebuffer::GetHeight() const
{
    ULONG aHeight = 0;
    AssertReturn(ptr(), aHeight);
    mRC = ptr()->COMGETTER(Height)(&aHeight);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHeight;
}

ULONG CFramebuffer::GetBitsPerPixel() const
{
    ULONG aBitsPerPixel = 0;
    AssertReturn(ptr(), aBitsPerPixel);
    mRC = ptr()->COMGETTER(BitsPerPixel)(&aBitsPerPixel);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBitsPerPixel;
}

ULONG CFramebuffer::GetBytesPerLine() const
{
    ULONG aBytesPerLine = 0;
    AssertReturn(ptr(), aBytesPerLine);
    mRC = ptr()->COMGETTER(BytesPerLine)(&aBytesPerLine);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBytesPerLine;
}

ULONG CFramebuffer::GetPixelFormat() const
{
    ULONG aPixelFormat = 0;
    AssertReturn(ptr(), aPixelFormat);
    mRC = ptr()->COMGETTER(PixelFormat)(&aPixelFormat);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPixelFormat;
}

BOOL CFramebuffer::GetUsesGuestVRAM() const
{
    BOOL aUsesGuestVRAM = FALSE;
    AssertReturn(ptr(), aUsesGuestVRAM);
    mRC = ptr()->COMGETTER(UsesGuestVRAM)(&aUsesGuestVRAM);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUsesGuestVRAM;
}

ULONG CFramebuffer::GetHeightReduction() const
{
    ULONG aHeightReduction = 0;
    AssertReturn(ptr(), aHeightReduction);
    mRC = ptr()->COMGETTER(HeightReduction)(&aHeightReduction);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHeightReduction;
}

CFramebufferOverlay CFramebuffer::GetOverlay() const
{
    CFramebufferOverlay aOverlay;
    AssertReturn(ptr(), aOverlay);
    IFramebufferOverlay* overlayPtr = NULL;
    mRC = ptr()->COMGETTER(Overlay)(&overlayPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aOverlay.setPtr(overlayPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOverlay;
}

LONG64 CFramebuffer::GetWinId() const
{
    LONG64 aWinId = 0;
    AssertReturn(ptr(), aWinId);
    mRC = ptr()->COMGETTER(WinId)(&aWinId);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWinId;
}

void CFramebuffer::Lock()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Lock();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CFramebuffer::Unlock()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Unlock();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CFramebuffer::NotifyUpdate(ULONG aX, ULONG aY, ULONG aWidth, ULONG aHeight)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->NotifyUpdate(aX, aY, aWidth, aHeight);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CFramebuffer::RequestResize(ULONG aScreenId, ULONG aPixelFormat, BYTE * aVRAM, ULONG aBitsPerPixel, ULONG aBytesPerLine, ULONG aWidth, ULONG aHeight)
{
    BOOL aFinished = FALSE;
    AssertReturn(ptr(), aFinished);
    mRC = ptr()->RequestResize(aScreenId, aPixelFormat, aVRAM, aBitsPerPixel, aBytesPerLine, aWidth, aHeight, &aFinished);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFinished;
}

BOOL CFramebuffer::VideoModeSupported(ULONG aWidth, ULONG aHeight, ULONG aBpp)
{
    BOOL aSupported = FALSE;
    AssertReturn(ptr(), aSupported);
    mRC = ptr()->VideoModeSupported(aWidth, aHeight, aBpp, &aSupported);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSupported;
}

ULONG CFramebuffer::GetVisibleRegion(BYTE * aRectangles, ULONG aCount)
{
    ULONG aCountCopied = 0;
    AssertReturn(ptr(), aCountCopied);
    mRC = ptr()->GetVisibleRegion(aRectangles, aCount, &aCountCopied);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCountCopied;
}

void CFramebuffer::SetVisibleRegion(BYTE * aRectangles, ULONG aCount)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetVisibleRegion(aRectangles, aCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CFramebuffer::ProcessVHWACommand(BYTE * aCommand)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->ProcessVHWACommand(aCommand);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CFramebuffer::Notify3DEvent(ULONG aType, BYTE * aData)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Notify3DEvent(aType, aData);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IFramebufferOverlay wrapper

ULONG CFramebufferOverlay::GetX() const
{
    ULONG aX = 0;
    AssertReturn(ptr(), aX);
    mRC = ptr()->COMGETTER(X)(&aX);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aX;
}

ULONG CFramebufferOverlay::GetY() const
{
    ULONG aY = 0;
    AssertReturn(ptr(), aY);
    mRC = ptr()->COMGETTER(Y)(&aY);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aY;
}

BOOL CFramebufferOverlay::GetVisible() const
{
    BOOL aVisible = FALSE;
    AssertReturn(ptr(), aVisible);
    mRC = ptr()->COMGETTER(Visible)(&aVisible);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVisible;
}
void CFramebufferOverlay::SetVisible(BOOL aVisible)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Visible)(aVisible);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CFramebufferOverlay::GetAlpha() const
{
    ULONG aAlpha = 0;
    AssertReturn(ptr(), aAlpha);
    mRC = ptr()->COMGETTER(Alpha)(&aAlpha);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAlpha;
}
void CFramebufferOverlay::SetAlpha(ULONG aAlpha)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Alpha)(aAlpha);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BYTE * CFramebufferOverlay::GetAddress() const
{
    BYTE * aAddress = NULL;
    AssertReturn(ptr(), aAddress);
    mRC = ptr()->COMGETTER(Address)(&aAddress);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAddress;
}

ULONG CFramebufferOverlay::GetWidth() const
{
    ULONG aWidth = 0;
    AssertReturn(ptr(), aWidth);
    mRC = ptr()->COMGETTER(Width)(&aWidth);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWidth;
}

ULONG CFramebufferOverlay::GetHeight() const
{
    ULONG aHeight = 0;
    AssertReturn(ptr(), aHeight);
    mRC = ptr()->COMGETTER(Height)(&aHeight);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHeight;
}

ULONG CFramebufferOverlay::GetBitsPerPixel() const
{
    ULONG aBitsPerPixel = 0;
    AssertReturn(ptr(), aBitsPerPixel);
    mRC = ptr()->COMGETTER(BitsPerPixel)(&aBitsPerPixel);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBitsPerPixel;
}

ULONG CFramebufferOverlay::GetBytesPerLine() const
{
    ULONG aBytesPerLine = 0;
    AssertReturn(ptr(), aBytesPerLine);
    mRC = ptr()->COMGETTER(BytesPerLine)(&aBytesPerLine);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBytesPerLine;
}

ULONG CFramebufferOverlay::GetPixelFormat() const
{
    ULONG aPixelFormat = 0;
    AssertReturn(ptr(), aPixelFormat);
    mRC = ptr()->COMGETTER(PixelFormat)(&aPixelFormat);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPixelFormat;
}

BOOL CFramebufferOverlay::GetUsesGuestVRAM() const
{
    BOOL aUsesGuestVRAM = FALSE;
    AssertReturn(ptr(), aUsesGuestVRAM);
    mRC = ptr()->COMGETTER(UsesGuestVRAM)(&aUsesGuestVRAM);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUsesGuestVRAM;
}

ULONG CFramebufferOverlay::GetHeightReduction() const
{
    ULONG aHeightReduction = 0;
    AssertReturn(ptr(), aHeightReduction);
    mRC = ptr()->COMGETTER(HeightReduction)(&aHeightReduction);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHeightReduction;
}

CFramebufferOverlay CFramebufferOverlay::GetOverlay() const
{
    CFramebufferOverlay aOverlay;
    AssertReturn(ptr(), aOverlay);
    IFramebufferOverlay* overlayPtr = NULL;
    mRC = ptr()->COMGETTER(Overlay)(&overlayPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aOverlay.setPtr(overlayPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOverlay;
}

LONG64 CFramebufferOverlay::GetWinId() const
{
    LONG64 aWinId = 0;
    AssertReturn(ptr(), aWinId);
    mRC = ptr()->COMGETTER(WinId)(&aWinId);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWinId;
}

void CFramebufferOverlay::Move(ULONG aX, ULONG aY)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Move(aX, aY);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CFramebufferOverlay::Lock()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Lock();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CFramebufferOverlay::Unlock()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Unlock();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CFramebufferOverlay::NotifyUpdate(ULONG aX, ULONG aY, ULONG aWidth, ULONG aHeight)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->NotifyUpdate(aX, aY, aWidth, aHeight);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CFramebufferOverlay::RequestResize(ULONG aScreenId, ULONG aPixelFormat, BYTE * aVRAM, ULONG aBitsPerPixel, ULONG aBytesPerLine, ULONG aWidth, ULONG aHeight)
{
    BOOL aFinished = FALSE;
    AssertReturn(ptr(), aFinished);
    mRC = ptr()->RequestResize(aScreenId, aPixelFormat, aVRAM, aBitsPerPixel, aBytesPerLine, aWidth, aHeight, &aFinished);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFinished;
}

BOOL CFramebufferOverlay::VideoModeSupported(ULONG aWidth, ULONG aHeight, ULONG aBpp)
{
    BOOL aSupported = FALSE;
    AssertReturn(ptr(), aSupported);
    mRC = ptr()->VideoModeSupported(aWidth, aHeight, aBpp, &aSupported);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSupported;
}

ULONG CFramebufferOverlay::GetVisibleRegion(BYTE * aRectangles, ULONG aCount)
{
    ULONG aCountCopied = 0;
    AssertReturn(ptr(), aCountCopied);
    mRC = ptr()->GetVisibleRegion(aRectangles, aCount, &aCountCopied);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCountCopied;
}

void CFramebufferOverlay::SetVisibleRegion(BYTE * aRectangles, ULONG aCount)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetVisibleRegion(aRectangles, aCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CFramebufferOverlay::ProcessVHWACommand(BYTE * aCommand)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->ProcessVHWACommand(aCommand);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CFramebufferOverlay::Notify3DEvent(ULONG aType, BYTE * aData)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Notify3DEvent(aType, aData);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IDisplay wrapper

void CDisplay::GetScreenResolution(ULONG aScreenId, ULONG & aWidth, ULONG & aHeight, ULONG & aBitsPerPixel, LONG & aXOrigin, LONG & aYOrigin)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->GetScreenResolution(aScreenId, &aWidth, &aHeight, &aBitsPerPixel, &aXOrigin, &aYOrigin);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CDisplay::SetFramebuffer(ULONG aScreenId, const CFramebuffer & aFramebuffer)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetFramebuffer(aScreenId, aFramebuffer.ptr());
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CDisplay::GetFramebuffer(ULONG aScreenId, CFramebuffer & aFramebuffer, LONG & aXOrigin, LONG & aYOrigin)
{
    AssertReturnVoid(ptr());
    IFramebuffer* framebufferPtr = NULL;
    mRC = ptr()->GetFramebuffer(aScreenId, &framebufferPtr, &aXOrigin, &aYOrigin);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aFramebuffer.setPtr(framebufferPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CDisplay::SetVideoModeHint(ULONG aDisplay, BOOL aEnabled, BOOL aChangeOrigin, LONG aOriginX, LONG aOriginY, ULONG aWidth, ULONG aHeight, ULONG aBitsPerPixel)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetVideoModeHint(aDisplay, aEnabled, aChangeOrigin, aOriginX, aOriginY, aWidth, aHeight, aBitsPerPixel);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CDisplay::SetSeamlessMode(BOOL aEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetSeamlessMode(aEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CDisplay::TakeScreenShot(ULONG aScreenId, BYTE * aAddress, ULONG aWidth, ULONG aHeight)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->TakeScreenShot(aScreenId, aAddress, aWidth, aHeight);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QVector<BYTE> CDisplay::TakeScreenShotToArray(ULONG aScreenId, ULONG aWidth, ULONG aHeight)
{
    QVector<BYTE> aScreenData;
    AssertReturn(ptr(), aScreenData);
    com::SafeArray <BYTE> screenData;
    mRC = ptr()->TakeScreenShotToArray(aScreenId, aWidth, aHeight, ComSafeArrayAsOutParam(screenData));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(screenData, aScreenData);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aScreenData;
}

QVector<BYTE> CDisplay::TakeScreenShotPNGToArray(ULONG aScreenId, ULONG aWidth, ULONG aHeight)
{
    QVector<BYTE> aScreenData;
    AssertReturn(ptr(), aScreenData);
    com::SafeArray <BYTE> screenData;
    mRC = ptr()->TakeScreenShotPNGToArray(aScreenId, aWidth, aHeight, ComSafeArrayAsOutParam(screenData));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(screenData, aScreenData);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aScreenData;
}

void CDisplay::DrawToScreen(ULONG aScreenId, BYTE * aAddress, ULONG aX, ULONG aY, ULONG aWidth, ULONG aHeight)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->DrawToScreen(aScreenId, aAddress, aX, aY, aWidth, aHeight);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CDisplay::InvalidateAndUpdate()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->InvalidateAndUpdate();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CDisplay::ResizeCompleted(ULONG aScreenId)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->ResizeCompleted(aScreenId);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CDisplay::CompleteVHWACommand(BYTE * aCommand)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->CompleteVHWACommand(aCommand);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CDisplay::ViewportChanged(ULONG aScreenId, ULONG aX, ULONG aY, ULONG aWidth, ULONG aHeight)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->ViewportChanged(aScreenId, aX, aY, aWidth, aHeight);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// INetworkAdapter wrapper

KNetworkAdapterType CNetworkAdapter::GetAdapterType() const
{
    KNetworkAdapterType aAdapterType = (KNetworkAdapterType) 0;
    AssertReturn(ptr(), aAdapterType);
    mRC = ptr()->COMGETTER(AdapterType)(ENUMOut<KNetworkAdapterType, NetworkAdapterType_T>(aAdapterType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAdapterType;
}
void CNetworkAdapter::SetAdapterType(const KNetworkAdapterType & aAdapterType)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(AdapterType)((NetworkAdapterType_T) aAdapterType);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CNetworkAdapter::GetSlot() const
{
    ULONG aSlot = 0;
    AssertReturn(ptr(), aSlot);
    mRC = ptr()->COMGETTER(Slot)(&aSlot);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSlot;
}

BOOL CNetworkAdapter::GetEnabled() const
{
    BOOL aEnabled = FALSE;
    AssertReturn(ptr(), aEnabled);
    mRC = ptr()->COMGETTER(Enabled)(&aEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEnabled;
}
void CNetworkAdapter::SetEnabled(BOOL aEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Enabled)(aEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CNetworkAdapter::GetMACAddress() const
{
    QString aMACAddress;
    AssertReturn(ptr(), aMACAddress);
    mRC = ptr()->COMGETTER(MACAddress)(BSTROut(aMACAddress));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMACAddress;
}
void CNetworkAdapter::SetMACAddress(const QString & aMACAddress)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(MACAddress)(BSTRIn(aMACAddress));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KNetworkAttachmentType CNetworkAdapter::GetAttachmentType() const
{
    KNetworkAttachmentType aAttachmentType = (KNetworkAttachmentType) 0;
    AssertReturn(ptr(), aAttachmentType);
    mRC = ptr()->COMGETTER(AttachmentType)(ENUMOut<KNetworkAttachmentType, NetworkAttachmentType_T>(aAttachmentType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAttachmentType;
}
void CNetworkAdapter::SetAttachmentType(const KNetworkAttachmentType & aAttachmentType)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(AttachmentType)((NetworkAttachmentType_T) aAttachmentType);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CNetworkAdapter::GetBridgedInterface() const
{
    QString aBridgedInterface;
    AssertReturn(ptr(), aBridgedInterface);
    mRC = ptr()->COMGETTER(BridgedInterface)(BSTROut(aBridgedInterface));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBridgedInterface;
}
void CNetworkAdapter::SetBridgedInterface(const QString & aBridgedInterface)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(BridgedInterface)(BSTRIn(aBridgedInterface));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CNetworkAdapter::GetHostOnlyInterface() const
{
    QString aHostOnlyInterface;
    AssertReturn(ptr(), aHostOnlyInterface);
    mRC = ptr()->COMGETTER(HostOnlyInterface)(BSTROut(aHostOnlyInterface));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHostOnlyInterface;
}
void CNetworkAdapter::SetHostOnlyInterface(const QString & aHostOnlyInterface)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(HostOnlyInterface)(BSTRIn(aHostOnlyInterface));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CNetworkAdapter::GetInternalNetwork() const
{
    QString aInternalNetwork;
    AssertReturn(ptr(), aInternalNetwork);
    mRC = ptr()->COMGETTER(InternalNetwork)(BSTROut(aInternalNetwork));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aInternalNetwork;
}
void CNetworkAdapter::SetInternalNetwork(const QString & aInternalNetwork)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(InternalNetwork)(BSTRIn(aInternalNetwork));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CNetworkAdapter::GetNATNetwork() const
{
    QString aNATNetwork;
    AssertReturn(ptr(), aNATNetwork);
    mRC = ptr()->COMGETTER(NATNetwork)(BSTROut(aNATNetwork));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNATNetwork;
}
void CNetworkAdapter::SetNATNetwork(const QString & aNATNetwork)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(NATNetwork)(BSTRIn(aNATNetwork));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CNetworkAdapter::GetGenericDriver() const
{
    QString aGenericDriver;
    AssertReturn(ptr(), aGenericDriver);
    mRC = ptr()->COMGETTER(GenericDriver)(BSTROut(aGenericDriver));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGenericDriver;
}
void CNetworkAdapter::SetGenericDriver(const QString & aGenericDriver)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(GenericDriver)(BSTRIn(aGenericDriver));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CNetworkAdapter::GetCableConnected() const
{
    BOOL aCableConnected = FALSE;
    AssertReturn(ptr(), aCableConnected);
    mRC = ptr()->COMGETTER(CableConnected)(&aCableConnected);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCableConnected;
}
void CNetworkAdapter::SetCableConnected(BOOL aCableConnected)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(CableConnected)(aCableConnected);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CNetworkAdapter::GetLineSpeed() const
{
    ULONG aLineSpeed = 0;
    AssertReturn(ptr(), aLineSpeed);
    mRC = ptr()->COMGETTER(LineSpeed)(&aLineSpeed);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLineSpeed;
}
void CNetworkAdapter::SetLineSpeed(ULONG aLineSpeed)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(LineSpeed)(aLineSpeed);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KNetworkAdapterPromiscModePolicy CNetworkAdapter::GetPromiscModePolicy() const
{
    KNetworkAdapterPromiscModePolicy aPromiscModePolicy = (KNetworkAdapterPromiscModePolicy) 0;
    AssertReturn(ptr(), aPromiscModePolicy);
    mRC = ptr()->COMGETTER(PromiscModePolicy)(ENUMOut<KNetworkAdapterPromiscModePolicy, NetworkAdapterPromiscModePolicy_T>(aPromiscModePolicy));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPromiscModePolicy;
}
void CNetworkAdapter::SetPromiscModePolicy(const KNetworkAdapterPromiscModePolicy & aPromiscModePolicy)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(PromiscModePolicy)((NetworkAdapterPromiscModePolicy_T) aPromiscModePolicy);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CNetworkAdapter::GetTraceEnabled() const
{
    BOOL aTraceEnabled = FALSE;
    AssertReturn(ptr(), aTraceEnabled);
    mRC = ptr()->COMGETTER(TraceEnabled)(&aTraceEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aTraceEnabled;
}
void CNetworkAdapter::SetTraceEnabled(BOOL aTraceEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(TraceEnabled)(aTraceEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CNetworkAdapter::GetTraceFile() const
{
    QString aTraceFile;
    AssertReturn(ptr(), aTraceFile);
    mRC = ptr()->COMGETTER(TraceFile)(BSTROut(aTraceFile));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aTraceFile;
}
void CNetworkAdapter::SetTraceFile(const QString & aTraceFile)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(TraceFile)(BSTRIn(aTraceFile));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CNATEngine CNetworkAdapter::GetNATEngine() const
{
    CNATEngine aNATEngine;
    AssertReturn(ptr(), aNATEngine);
    INATEngine* NATEnginePtr = NULL;
    mRC = ptr()->COMGETTER(NATEngine)(&NATEnginePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aNATEngine.setPtr(NATEnginePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNATEngine;
}

ULONG CNetworkAdapter::GetBootPriority() const
{
    ULONG aBootPriority = 0;
    AssertReturn(ptr(), aBootPriority);
    mRC = ptr()->COMGETTER(BootPriority)(&aBootPriority);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBootPriority;
}
void CNetworkAdapter::SetBootPriority(ULONG aBootPriority)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(BootPriority)(aBootPriority);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CBandwidthGroup CNetworkAdapter::GetBandwidthGroup() const
{
    CBandwidthGroup aBandwidthGroup;
    AssertReturn(ptr(), aBandwidthGroup);
    IBandwidthGroup* bandwidthGroupPtr = NULL;
    mRC = ptr()->COMGETTER(BandwidthGroup)(&bandwidthGroupPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aBandwidthGroup.setPtr(bandwidthGroupPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBandwidthGroup;
}
void CNetworkAdapter::SetBandwidthGroup(const CBandwidthGroup & aBandwidthGroup)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(BandwidthGroup)(aBandwidthGroup.ptr());
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CNetworkAdapter::GetProperty(const QString & aKey) const
{
    QString aValue;
    AssertReturn(ptr(), aValue);
    mRC = ptr()->GetProperty(BSTRIn(aKey), BSTROut(aValue));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aValue;
}

void CNetworkAdapter::SetProperty(const QString & aKey, const QString & aValue)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProperty(BSTRIn(aKey), BSTRIn(aValue));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QVector<QString> CNetworkAdapter::GetProperties(const QString & aNames, QVector<QString> & aReturnNames) const
{
    QVector<QString> aReturnValues;
    AssertReturn(ptr(), aReturnValues);
    com::SafeArray <BSTR> returnNames;
    com::SafeArray <BSTR> returnValues;
    mRC = ptr()->GetProperties(BSTRIn(aNames), ComSafeArrayAsOutParam(returnNames), ComSafeArrayAsOutParam(returnValues));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(returnNames, aReturnNames);
    FromSafeArray(returnValues, aReturnValues);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aReturnValues;
}

// ISerialPort wrapper

ULONG CSerialPort::GetSlot() const
{
    ULONG aSlot = 0;
    AssertReturn(ptr(), aSlot);
    mRC = ptr()->COMGETTER(Slot)(&aSlot);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSlot;
}

BOOL CSerialPort::GetEnabled() const
{
    BOOL aEnabled = FALSE;
    AssertReturn(ptr(), aEnabled);
    mRC = ptr()->COMGETTER(Enabled)(&aEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEnabled;
}
void CSerialPort::SetEnabled(BOOL aEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Enabled)(aEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CSerialPort::GetIOBase() const
{
    ULONG aIOBase = 0;
    AssertReturn(ptr(), aIOBase);
    mRC = ptr()->COMGETTER(IOBase)(&aIOBase);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aIOBase;
}
void CSerialPort::SetIOBase(ULONG aIOBase)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(IOBase)(aIOBase);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CSerialPort::GetIRQ() const
{
    ULONG aIRQ = 0;
    AssertReturn(ptr(), aIRQ);
    mRC = ptr()->COMGETTER(IRQ)(&aIRQ);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aIRQ;
}
void CSerialPort::SetIRQ(ULONG aIRQ)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(IRQ)(aIRQ);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KPortMode CSerialPort::GetHostMode() const
{
    KPortMode aHostMode = (KPortMode) 0;
    AssertReturn(ptr(), aHostMode);
    mRC = ptr()->COMGETTER(HostMode)(ENUMOut<KPortMode, PortMode_T>(aHostMode));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHostMode;
}
void CSerialPort::SetHostMode(const KPortMode & aHostMode)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(HostMode)((PortMode_T) aHostMode);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CSerialPort::GetServer() const
{
    BOOL aServer = FALSE;
    AssertReturn(ptr(), aServer);
    mRC = ptr()->COMGETTER(Server)(&aServer);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aServer;
}
void CSerialPort::SetServer(BOOL aServer)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Server)(aServer);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CSerialPort::GetPath() const
{
    QString aPath;
    AssertReturn(ptr(), aPath);
    mRC = ptr()->COMGETTER(Path)(BSTROut(aPath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPath;
}
void CSerialPort::SetPath(const QString & aPath)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Path)(BSTRIn(aPath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IParallelPort wrapper

ULONG CParallelPort::GetSlot() const
{
    ULONG aSlot = 0;
    AssertReturn(ptr(), aSlot);
    mRC = ptr()->COMGETTER(Slot)(&aSlot);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSlot;
}

BOOL CParallelPort::GetEnabled() const
{
    BOOL aEnabled = FALSE;
    AssertReturn(ptr(), aEnabled);
    mRC = ptr()->COMGETTER(Enabled)(&aEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEnabled;
}
void CParallelPort::SetEnabled(BOOL aEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Enabled)(aEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CParallelPort::GetIOBase() const
{
    ULONG aIOBase = 0;
    AssertReturn(ptr(), aIOBase);
    mRC = ptr()->COMGETTER(IOBase)(&aIOBase);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aIOBase;
}
void CParallelPort::SetIOBase(ULONG aIOBase)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(IOBase)(aIOBase);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CParallelPort::GetIRQ() const
{
    ULONG aIRQ = 0;
    AssertReturn(ptr(), aIRQ);
    mRC = ptr()->COMGETTER(IRQ)(&aIRQ);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aIRQ;
}
void CParallelPort::SetIRQ(ULONG aIRQ)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(IRQ)(aIRQ);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CParallelPort::GetPath() const
{
    QString aPath;
    AssertReturn(ptr(), aPath);
    mRC = ptr()->COMGETTER(Path)(BSTROut(aPath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPath;
}
void CParallelPort::SetPath(const QString & aPath)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Path)(BSTRIn(aPath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IMachineDebugger wrapper

BOOL CMachineDebugger::GetSingleStep() const
{
    BOOL aSingleStep = FALSE;
    AssertReturn(ptr(), aSingleStep);
    mRC = ptr()->COMGETTER(SingleStep)(&aSingleStep);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSingleStep;
}
void CMachineDebugger::SetSingleStep(BOOL aSingleStep)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(SingleStep)(aSingleStep);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachineDebugger::GetRecompileUser() const
{
    BOOL aRecompileUser = FALSE;
    AssertReturn(ptr(), aRecompileUser);
    mRC = ptr()->COMGETTER(RecompileUser)(&aRecompileUser);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecompileUser;
}
void CMachineDebugger::SetRecompileUser(BOOL aRecompileUser)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(RecompileUser)(aRecompileUser);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachineDebugger::GetRecompileSupervisor() const
{
    BOOL aRecompileSupervisor = FALSE;
    AssertReturn(ptr(), aRecompileSupervisor);
    mRC = ptr()->COMGETTER(RecompileSupervisor)(&aRecompileSupervisor);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRecompileSupervisor;
}
void CMachineDebugger::SetRecompileSupervisor(BOOL aRecompileSupervisor)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(RecompileSupervisor)(aRecompileSupervisor);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachineDebugger::GetExecuteAllInIEM() const
{
    BOOL aExecuteAllInIEM = FALSE;
    AssertReturn(ptr(), aExecuteAllInIEM);
    mRC = ptr()->COMGETTER(ExecuteAllInIEM)(&aExecuteAllInIEM);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aExecuteAllInIEM;
}
void CMachineDebugger::SetExecuteAllInIEM(BOOL aExecuteAllInIEM)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(ExecuteAllInIEM)(aExecuteAllInIEM);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachineDebugger::GetPATMEnabled() const
{
    BOOL aPATMEnabled = FALSE;
    AssertReturn(ptr(), aPATMEnabled);
    mRC = ptr()->COMGETTER(PATMEnabled)(&aPATMEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPATMEnabled;
}
void CMachineDebugger::SetPATMEnabled(BOOL aPATMEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(PATMEnabled)(aPATMEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachineDebugger::GetCSAMEnabled() const
{
    BOOL aCSAMEnabled = FALSE;
    AssertReturn(ptr(), aCSAMEnabled);
    mRC = ptr()->COMGETTER(CSAMEnabled)(&aCSAMEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCSAMEnabled;
}
void CMachineDebugger::SetCSAMEnabled(BOOL aCSAMEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(CSAMEnabled)(aCSAMEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachineDebugger::GetLogEnabled() const
{
    BOOL aLogEnabled = FALSE;
    AssertReturn(ptr(), aLogEnabled);
    mRC = ptr()->COMGETTER(LogEnabled)(&aLogEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLogEnabled;
}
void CMachineDebugger::SetLogEnabled(BOOL aLogEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(LogEnabled)(aLogEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CMachineDebugger::GetLogDbgFlags() const
{
    QString aLogDbgFlags;
    AssertReturn(ptr(), aLogDbgFlags);
    mRC = ptr()->COMGETTER(LogDbgFlags)(BSTROut(aLogDbgFlags));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLogDbgFlags;
}

QString CMachineDebugger::GetLogDbgGroups() const
{
    QString aLogDbgGroups;
    AssertReturn(ptr(), aLogDbgGroups);
    mRC = ptr()->COMGETTER(LogDbgGroups)(BSTROut(aLogDbgGroups));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLogDbgGroups;
}

QString CMachineDebugger::GetLogDbgDestinations() const
{
    QString aLogDbgDestinations;
    AssertReturn(ptr(), aLogDbgDestinations);
    mRC = ptr()->COMGETTER(LogDbgDestinations)(BSTROut(aLogDbgDestinations));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLogDbgDestinations;
}

QString CMachineDebugger::GetLogRelFlags() const
{
    QString aLogRelFlags;
    AssertReturn(ptr(), aLogRelFlags);
    mRC = ptr()->COMGETTER(LogRelFlags)(BSTROut(aLogRelFlags));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLogRelFlags;
}

QString CMachineDebugger::GetLogRelGroups() const
{
    QString aLogRelGroups;
    AssertReturn(ptr(), aLogRelGroups);
    mRC = ptr()->COMGETTER(LogRelGroups)(BSTROut(aLogRelGroups));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLogRelGroups;
}

QString CMachineDebugger::GetLogRelDestinations() const
{
    QString aLogRelDestinations;
    AssertReturn(ptr(), aLogRelDestinations);
    mRC = ptr()->COMGETTER(LogRelDestinations)(BSTROut(aLogRelDestinations));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLogRelDestinations;
}

BOOL CMachineDebugger::GetHWVirtExEnabled() const
{
    BOOL aHWVirtExEnabled = FALSE;
    AssertReturn(ptr(), aHWVirtExEnabled);
    mRC = ptr()->COMGETTER(HWVirtExEnabled)(&aHWVirtExEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHWVirtExEnabled;
}

BOOL CMachineDebugger::GetHWVirtExNestedPagingEnabled() const
{
    BOOL aHWVirtExNestedPagingEnabled = FALSE;
    AssertReturn(ptr(), aHWVirtExNestedPagingEnabled);
    mRC = ptr()->COMGETTER(HWVirtExNestedPagingEnabled)(&aHWVirtExNestedPagingEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHWVirtExNestedPagingEnabled;
}

BOOL CMachineDebugger::GetHWVirtExVPIDEnabled() const
{
    BOOL aHWVirtExVPIDEnabled = FALSE;
    AssertReturn(ptr(), aHWVirtExVPIDEnabled);
    mRC = ptr()->COMGETTER(HWVirtExVPIDEnabled)(&aHWVirtExVPIDEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHWVirtExVPIDEnabled;
}

BOOL CMachineDebugger::GetHWVirtExUXEnabled() const
{
    BOOL aHWVirtExUXEnabled = FALSE;
    AssertReturn(ptr(), aHWVirtExUXEnabled);
    mRC = ptr()->COMGETTER(HWVirtExUXEnabled)(&aHWVirtExUXEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHWVirtExUXEnabled;
}

QString CMachineDebugger::GetOSName() const
{
    QString aOSName;
    AssertReturn(ptr(), aOSName);
    mRC = ptr()->COMGETTER(OSName)(BSTROut(aOSName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOSName;
}

QString CMachineDebugger::GetOSVersion() const
{
    QString aOSVersion;
    AssertReturn(ptr(), aOSVersion);
    mRC = ptr()->COMGETTER(OSVersion)(BSTROut(aOSVersion));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOSVersion;
}

BOOL CMachineDebugger::GetPAEEnabled() const
{
    BOOL aPAEEnabled = FALSE;
    AssertReturn(ptr(), aPAEEnabled);
    mRC = ptr()->COMGETTER(PAEEnabled)(&aPAEEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPAEEnabled;
}

ULONG CMachineDebugger::GetVirtualTimeRate() const
{
    ULONG aVirtualTimeRate = 0;
    AssertReturn(ptr(), aVirtualTimeRate);
    mRC = ptr()->COMGETTER(VirtualTimeRate)(&aVirtualTimeRate);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVirtualTimeRate;
}
void CMachineDebugger::SetVirtualTimeRate(ULONG aVirtualTimeRate)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(VirtualTimeRate)(aVirtualTimeRate);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

LONG64 CMachineDebugger::GetVM() const
{
    LONG64 aVM = 0;
    AssertReturn(ptr(), aVM);
    mRC = ptr()->COMGETTER(VM)(&aVM);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVM;
}

void CMachineDebugger::DumpGuestCore(const QString & aFilename, const QString & aCompression)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->DumpGuestCore(BSTRIn(aFilename), BSTRIn(aCompression));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachineDebugger::DumpHostProcessCore(const QString & aFilename, const QString & aCompression)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->DumpHostProcessCore(BSTRIn(aFilename), BSTRIn(aCompression));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CMachineDebugger::Info(const QString & aName, const QString & aArgs)
{
    QString aInfo;
    AssertReturn(ptr(), aInfo);
    mRC = ptr()->Info(BSTRIn(aName), BSTRIn(aArgs), BSTROut(aInfo));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aInfo;
}

void CMachineDebugger::InjectNMI()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->InjectNMI();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachineDebugger::ModifyLogGroups(const QString & aSettings)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->ModifyLogGroups(BSTRIn(aSettings));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachineDebugger::ModifyLogFlags(const QString & aSettings)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->ModifyLogFlags(BSTRIn(aSettings));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachineDebugger::ModifyLogDestinations(const QString & aSettings)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->ModifyLogDestinations(BSTRIn(aSettings));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QVector<BYTE> CMachineDebugger::ReadPhysicalMemory(LONG64 aAddress, ULONG aSize)
{
    QVector<BYTE> aBytes;
    AssertReturn(ptr(), aBytes);
    com::SafeArray <BYTE> bytes;
    mRC = ptr()->ReadPhysicalMemory(aAddress, aSize, ComSafeArrayAsOutParam(bytes));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(bytes, aBytes);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBytes;
}

void CMachineDebugger::WritePhysicalMemory(LONG64 aAddress, ULONG aSize, const QVector<BYTE> & aBytes)
{
    AssertReturnVoid(ptr());
    com::SafeArray <BYTE> bytes;
    ToSafeArray(aBytes, bytes);
    mRC = ptr()->WritePhysicalMemory(aAddress, aSize, ComSafeArrayAsInParam(bytes));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QVector<BYTE> CMachineDebugger::ReadVirtualMemory(ULONG aCpuId, LONG64 aAddress, ULONG aSize)
{
    QVector<BYTE> aBytes;
    AssertReturn(ptr(), aBytes);
    com::SafeArray <BYTE> bytes;
    mRC = ptr()->ReadVirtualMemory(aCpuId, aAddress, aSize, ComSafeArrayAsOutParam(bytes));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(bytes, aBytes);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBytes;
}

void CMachineDebugger::WriteVirtualMemory(ULONG aCpuId, LONG64 aAddress, ULONG aSize, const QVector<BYTE> & aBytes)
{
    AssertReturnVoid(ptr());
    com::SafeArray <BYTE> bytes;
    ToSafeArray(aBytes, bytes);
    mRC = ptr()->WriteVirtualMemory(aCpuId, aAddress, aSize, ComSafeArrayAsInParam(bytes));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CMachineDebugger::DetectOS()
{
    QString aOs;
    AssertReturn(ptr(), aOs);
    mRC = ptr()->DetectOS(BSTROut(aOs));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOs;
}

QString CMachineDebugger::GetRegister(ULONG aCpuId, const QString & aName)
{
    QString aValue;
    AssertReturn(ptr(), aValue);
    mRC = ptr()->GetRegister(aCpuId, BSTRIn(aName), BSTROut(aValue));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aValue;
}

void CMachineDebugger::GetRegisters(ULONG aCpuId, QVector<QString> & aNames, QVector<QString> & aValues)
{
    AssertReturnVoid(ptr());
    com::SafeArray <BSTR> names;
    com::SafeArray <BSTR> values;
    mRC = ptr()->GetRegisters(aCpuId, ComSafeArrayAsOutParam(names), ComSafeArrayAsOutParam(values));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(names, aNames);
    FromSafeArray(values, aValues);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachineDebugger::SetRegister(ULONG aCpuId, const QString & aName, const QString & aValue)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetRegister(aCpuId, BSTRIn(aName), BSTRIn(aValue));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachineDebugger::SetRegisters(ULONG aCpuId, const QVector<QString> & aNames, const QVector<QString> & aValues)
{
    AssertReturnVoid(ptr());
    com::SafeArray <BSTR> names;
    ToSafeArray(aNames, names);
    com::SafeArray <BSTR> values;
    ToSafeArray(aValues, values);
    mRC = ptr()->SetRegisters(aCpuId, ComSafeArrayAsInParam(names), ComSafeArrayAsInParam(values));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CMachineDebugger::DumpGuestStack(ULONG aCpuId)
{
    QString aStack;
    AssertReturn(ptr(), aStack);
    mRC = ptr()->DumpGuestStack(aCpuId, BSTROut(aStack));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStack;
}

void CMachineDebugger::ResetStats(const QString & aPattern)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->ResetStats(BSTRIn(aPattern));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CMachineDebugger::DumpStats(const QString & aPattern)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->DumpStats(BSTRIn(aPattern));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CMachineDebugger::GetStats(const QString & aPattern, BOOL aWithDescriptions)
{
    QString aStats;
    AssertReturn(ptr(), aStats);
    mRC = ptr()->GetStats(BSTRIn(aPattern), aWithDescriptions, BSTROut(aStats));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStats;
}

// IUSBDeviceFilters wrapper

QVector<CUSBDeviceFilter> CUSBDeviceFilters::GetDeviceFilters() const
{
    QVector<CUSBDeviceFilter> aDeviceFilters;
    AssertReturn(ptr(), aDeviceFilters);
    com::SafeIfaceArray <IUSBDeviceFilter> deviceFilters;
    mRC = ptr()->COMGETTER(DeviceFilters)(ComSafeArrayAsOutParam(deviceFilters));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(deviceFilters, aDeviceFilters);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDeviceFilters;
}

CUSBDeviceFilter CUSBDeviceFilters::CreateDeviceFilter(const QString & aName)
{
    CUSBDeviceFilter aFilter;
    AssertReturn(ptr(), aFilter);
    IUSBDeviceFilter* filterPtr = NULL;
    mRC = ptr()->CreateDeviceFilter(BSTRIn(aName), &filterPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aFilter.setPtr(filterPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFilter;
}

void CUSBDeviceFilters::InsertDeviceFilter(ULONG aPosition, const CUSBDeviceFilter & aFilter)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->InsertDeviceFilter(aPosition, aFilter.ptr());
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CUSBDeviceFilter CUSBDeviceFilters::RemoveDeviceFilter(ULONG aPosition)
{
    CUSBDeviceFilter aFilter;
    AssertReturn(ptr(), aFilter);
    IUSBDeviceFilter* filterPtr = NULL;
    mRC = ptr()->RemoveDeviceFilter(aPosition, &filterPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aFilter.setPtr(filterPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFilter;
}

// IUSBController wrapper

QString CUSBController::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

KUSBControllerType CUSBController::GetType() const
{
    KUSBControllerType aType = (KUSBControllerType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KUSBControllerType, USBControllerType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

USHORT CUSBController::GetUSBStandard() const
{
    USHORT aUSBStandard = 0;
    AssertReturn(ptr(), aUSBStandard);
    mRC = ptr()->COMGETTER(USBStandard)(&aUSBStandard);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUSBStandard;
}

// IUSBDevice wrapper

QString CUSBDevice::GetId() const
{
    QString aId;
    AssertReturn(ptr(), aId);
    mRC = ptr()->COMGETTER(Id)(BSTROut(aId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aId;
}

USHORT CUSBDevice::GetVendorId() const
{
    USHORT aVendorId = 0;
    AssertReturn(ptr(), aVendorId);
    mRC = ptr()->COMGETTER(VendorId)(&aVendorId);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVendorId;
}

USHORT CUSBDevice::GetProductId() const
{
    USHORT aProductId = 0;
    AssertReturn(ptr(), aProductId);
    mRC = ptr()->COMGETTER(ProductId)(&aProductId);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProductId;
}

USHORT CUSBDevice::GetRevision() const
{
    USHORT aRevision = 0;
    AssertReturn(ptr(), aRevision);
    mRC = ptr()->COMGETTER(Revision)(&aRevision);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRevision;
}

QString CUSBDevice::GetManufacturer() const
{
    QString aManufacturer;
    AssertReturn(ptr(), aManufacturer);
    mRC = ptr()->COMGETTER(Manufacturer)(BSTROut(aManufacturer));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aManufacturer;
}

QString CUSBDevice::GetProduct() const
{
    QString aProduct;
    AssertReturn(ptr(), aProduct);
    mRC = ptr()->COMGETTER(Product)(BSTROut(aProduct));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProduct;
}

QString CUSBDevice::GetSerialNumber() const
{
    QString aSerialNumber;
    AssertReturn(ptr(), aSerialNumber);
    mRC = ptr()->COMGETTER(SerialNumber)(BSTROut(aSerialNumber));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSerialNumber;
}

QString CUSBDevice::GetAddress() const
{
    QString aAddress;
    AssertReturn(ptr(), aAddress);
    mRC = ptr()->COMGETTER(Address)(BSTROut(aAddress));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAddress;
}

USHORT CUSBDevice::GetPort() const
{
    USHORT aPort = 0;
    AssertReturn(ptr(), aPort);
    mRC = ptr()->COMGETTER(Port)(&aPort);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPort;
}

USHORT CUSBDevice::GetVersion() const
{
    USHORT aVersion = 0;
    AssertReturn(ptr(), aVersion);
    mRC = ptr()->COMGETTER(Version)(&aVersion);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVersion;
}

USHORT CUSBDevice::GetPortVersion() const
{
    USHORT aPortVersion = 0;
    AssertReturn(ptr(), aPortVersion);
    mRC = ptr()->COMGETTER(PortVersion)(&aPortVersion);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPortVersion;
}

BOOL CUSBDevice::GetRemote() const
{
    BOOL aRemote = FALSE;
    AssertReturn(ptr(), aRemote);
    mRC = ptr()->COMGETTER(Remote)(&aRemote);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRemote;
}

// IUSBDeviceFilter wrapper

QString CUSBDeviceFilter::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}
void CUSBDeviceFilter::SetName(const QString & aName)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Name)(BSTRIn(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CUSBDeviceFilter::GetActive() const
{
    BOOL aActive = FALSE;
    AssertReturn(ptr(), aActive);
    mRC = ptr()->COMGETTER(Active)(&aActive);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aActive;
}
void CUSBDeviceFilter::SetActive(BOOL aActive)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Active)(aActive);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CUSBDeviceFilter::GetVendorId() const
{
    QString aVendorId;
    AssertReturn(ptr(), aVendorId);
    mRC = ptr()->COMGETTER(VendorId)(BSTROut(aVendorId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVendorId;
}
void CUSBDeviceFilter::SetVendorId(const QString & aVendorId)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(VendorId)(BSTRIn(aVendorId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CUSBDeviceFilter::GetProductId() const
{
    QString aProductId;
    AssertReturn(ptr(), aProductId);
    mRC = ptr()->COMGETTER(ProductId)(BSTROut(aProductId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProductId;
}
void CUSBDeviceFilter::SetProductId(const QString & aProductId)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(ProductId)(BSTRIn(aProductId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CUSBDeviceFilter::GetRevision() const
{
    QString aRevision;
    AssertReturn(ptr(), aRevision);
    mRC = ptr()->COMGETTER(Revision)(BSTROut(aRevision));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRevision;
}
void CUSBDeviceFilter::SetRevision(const QString & aRevision)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Revision)(BSTRIn(aRevision));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CUSBDeviceFilter::GetManufacturer() const
{
    QString aManufacturer;
    AssertReturn(ptr(), aManufacturer);
    mRC = ptr()->COMGETTER(Manufacturer)(BSTROut(aManufacturer));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aManufacturer;
}
void CUSBDeviceFilter::SetManufacturer(const QString & aManufacturer)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Manufacturer)(BSTRIn(aManufacturer));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CUSBDeviceFilter::GetProduct() const
{
    QString aProduct;
    AssertReturn(ptr(), aProduct);
    mRC = ptr()->COMGETTER(Product)(BSTROut(aProduct));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProduct;
}
void CUSBDeviceFilter::SetProduct(const QString & aProduct)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Product)(BSTRIn(aProduct));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CUSBDeviceFilter::GetSerialNumber() const
{
    QString aSerialNumber;
    AssertReturn(ptr(), aSerialNumber);
    mRC = ptr()->COMGETTER(SerialNumber)(BSTROut(aSerialNumber));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSerialNumber;
}
void CUSBDeviceFilter::SetSerialNumber(const QString & aSerialNumber)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(SerialNumber)(BSTRIn(aSerialNumber));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CUSBDeviceFilter::GetPort() const
{
    QString aPort;
    AssertReturn(ptr(), aPort);
    mRC = ptr()->COMGETTER(Port)(BSTROut(aPort));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPort;
}
void CUSBDeviceFilter::SetPort(const QString & aPort)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Port)(BSTRIn(aPort));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CUSBDeviceFilter::GetRemote() const
{
    QString aRemote;
    AssertReturn(ptr(), aRemote);
    mRC = ptr()->COMGETTER(Remote)(BSTROut(aRemote));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRemote;
}
void CUSBDeviceFilter::SetRemote(const QString & aRemote)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Remote)(BSTRIn(aRemote));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CUSBDeviceFilter::GetMaskedInterfaces() const
{
    ULONG aMaskedInterfaces = 0;
    AssertReturn(ptr(), aMaskedInterfaces);
    mRC = ptr()->COMGETTER(MaskedInterfaces)(&aMaskedInterfaces);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMaskedInterfaces;
}
void CUSBDeviceFilter::SetMaskedInterfaces(ULONG aMaskedInterfaces)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(MaskedInterfaces)(aMaskedInterfaces);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IHostUSBDevice wrapper

KUSBDeviceState CHostUSBDevice::GetState() const
{
    KUSBDeviceState aState = (KUSBDeviceState) 0;
    AssertReturn(ptr(), aState);
    mRC = ptr()->COMGETTER(State)(ENUMOut<KUSBDeviceState, USBDeviceState_T>(aState));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aState;
}

QString CHostUSBDevice::GetId() const
{
    QString aId;
    AssertReturn(ptr(), aId);
    mRC = ptr()->COMGETTER(Id)(BSTROut(aId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aId;
}

USHORT CHostUSBDevice::GetVendorId() const
{
    USHORT aVendorId = 0;
    AssertReturn(ptr(), aVendorId);
    mRC = ptr()->COMGETTER(VendorId)(&aVendorId);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVendorId;
}

USHORT CHostUSBDevice::GetProductId() const
{
    USHORT aProductId = 0;
    AssertReturn(ptr(), aProductId);
    mRC = ptr()->COMGETTER(ProductId)(&aProductId);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProductId;
}

USHORT CHostUSBDevice::GetRevision() const
{
    USHORT aRevision = 0;
    AssertReturn(ptr(), aRevision);
    mRC = ptr()->COMGETTER(Revision)(&aRevision);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRevision;
}

QString CHostUSBDevice::GetManufacturer() const
{
    QString aManufacturer;
    AssertReturn(ptr(), aManufacturer);
    mRC = ptr()->COMGETTER(Manufacturer)(BSTROut(aManufacturer));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aManufacturer;
}

QString CHostUSBDevice::GetProduct() const
{
    QString aProduct;
    AssertReturn(ptr(), aProduct);
    mRC = ptr()->COMGETTER(Product)(BSTROut(aProduct));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProduct;
}

QString CHostUSBDevice::GetSerialNumber() const
{
    QString aSerialNumber;
    AssertReturn(ptr(), aSerialNumber);
    mRC = ptr()->COMGETTER(SerialNumber)(BSTROut(aSerialNumber));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSerialNumber;
}

QString CHostUSBDevice::GetAddress() const
{
    QString aAddress;
    AssertReturn(ptr(), aAddress);
    mRC = ptr()->COMGETTER(Address)(BSTROut(aAddress));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAddress;
}

USHORT CHostUSBDevice::GetPort() const
{
    USHORT aPort = 0;
    AssertReturn(ptr(), aPort);
    mRC = ptr()->COMGETTER(Port)(&aPort);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPort;
}

USHORT CHostUSBDevice::GetVersion() const
{
    USHORT aVersion = 0;
    AssertReturn(ptr(), aVersion);
    mRC = ptr()->COMGETTER(Version)(&aVersion);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVersion;
}

USHORT CHostUSBDevice::GetPortVersion() const
{
    USHORT aPortVersion = 0;
    AssertReturn(ptr(), aPortVersion);
    mRC = ptr()->COMGETTER(PortVersion)(&aPortVersion);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPortVersion;
}

BOOL CHostUSBDevice::GetRemote() const
{
    BOOL aRemote = FALSE;
    AssertReturn(ptr(), aRemote);
    mRC = ptr()->COMGETTER(Remote)(&aRemote);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRemote;
}

// IHostUSBDeviceFilter wrapper

KUSBDeviceFilterAction CHostUSBDeviceFilter::GetAction() const
{
    KUSBDeviceFilterAction aAction = (KUSBDeviceFilterAction) 0;
    AssertReturn(ptr(), aAction);
    mRC = ptr()->COMGETTER(Action)(ENUMOut<KUSBDeviceFilterAction, USBDeviceFilterAction_T>(aAction));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAction;
}
void CHostUSBDeviceFilter::SetAction(const KUSBDeviceFilterAction & aAction)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Action)((USBDeviceFilterAction_T) aAction);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CHostUSBDeviceFilter::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}
void CHostUSBDeviceFilter::SetName(const QString & aName)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Name)(BSTRIn(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CHostUSBDeviceFilter::GetActive() const
{
    BOOL aActive = FALSE;
    AssertReturn(ptr(), aActive);
    mRC = ptr()->COMGETTER(Active)(&aActive);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aActive;
}
void CHostUSBDeviceFilter::SetActive(BOOL aActive)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Active)(aActive);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CHostUSBDeviceFilter::GetVendorId() const
{
    QString aVendorId;
    AssertReturn(ptr(), aVendorId);
    mRC = ptr()->COMGETTER(VendorId)(BSTROut(aVendorId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVendorId;
}
void CHostUSBDeviceFilter::SetVendorId(const QString & aVendorId)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(VendorId)(BSTRIn(aVendorId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CHostUSBDeviceFilter::GetProductId() const
{
    QString aProductId;
    AssertReturn(ptr(), aProductId);
    mRC = ptr()->COMGETTER(ProductId)(BSTROut(aProductId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProductId;
}
void CHostUSBDeviceFilter::SetProductId(const QString & aProductId)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(ProductId)(BSTRIn(aProductId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CHostUSBDeviceFilter::GetRevision() const
{
    QString aRevision;
    AssertReturn(ptr(), aRevision);
    mRC = ptr()->COMGETTER(Revision)(BSTROut(aRevision));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRevision;
}
void CHostUSBDeviceFilter::SetRevision(const QString & aRevision)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Revision)(BSTRIn(aRevision));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CHostUSBDeviceFilter::GetManufacturer() const
{
    QString aManufacturer;
    AssertReturn(ptr(), aManufacturer);
    mRC = ptr()->COMGETTER(Manufacturer)(BSTROut(aManufacturer));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aManufacturer;
}
void CHostUSBDeviceFilter::SetManufacturer(const QString & aManufacturer)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Manufacturer)(BSTRIn(aManufacturer));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CHostUSBDeviceFilter::GetProduct() const
{
    QString aProduct;
    AssertReturn(ptr(), aProduct);
    mRC = ptr()->COMGETTER(Product)(BSTROut(aProduct));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProduct;
}
void CHostUSBDeviceFilter::SetProduct(const QString & aProduct)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Product)(BSTRIn(aProduct));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CHostUSBDeviceFilter::GetSerialNumber() const
{
    QString aSerialNumber;
    AssertReturn(ptr(), aSerialNumber);
    mRC = ptr()->COMGETTER(SerialNumber)(BSTROut(aSerialNumber));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSerialNumber;
}
void CHostUSBDeviceFilter::SetSerialNumber(const QString & aSerialNumber)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(SerialNumber)(BSTRIn(aSerialNumber));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CHostUSBDeviceFilter::GetPort() const
{
    QString aPort;
    AssertReturn(ptr(), aPort);
    mRC = ptr()->COMGETTER(Port)(BSTROut(aPort));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPort;
}
void CHostUSBDeviceFilter::SetPort(const QString & aPort)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Port)(BSTRIn(aPort));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CHostUSBDeviceFilter::GetRemote() const
{
    QString aRemote;
    AssertReturn(ptr(), aRemote);
    mRC = ptr()->COMGETTER(Remote)(BSTROut(aRemote));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRemote;
}
void CHostUSBDeviceFilter::SetRemote(const QString & aRemote)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Remote)(BSTRIn(aRemote));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CHostUSBDeviceFilter::GetMaskedInterfaces() const
{
    ULONG aMaskedInterfaces = 0;
    AssertReturn(ptr(), aMaskedInterfaces);
    mRC = ptr()->COMGETTER(MaskedInterfaces)(&aMaskedInterfaces);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMaskedInterfaces;
}
void CHostUSBDeviceFilter::SetMaskedInterfaces(ULONG aMaskedInterfaces)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(MaskedInterfaces)(aMaskedInterfaces);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IAudioAdapter wrapper

BOOL CAudioAdapter::GetEnabled() const
{
    BOOL aEnabled = FALSE;
    AssertReturn(ptr(), aEnabled);
    mRC = ptr()->COMGETTER(Enabled)(&aEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEnabled;
}
void CAudioAdapter::SetEnabled(BOOL aEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Enabled)(aEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KAudioControllerType CAudioAdapter::GetAudioController() const
{
    KAudioControllerType aAudioController = (KAudioControllerType) 0;
    AssertReturn(ptr(), aAudioController);
    mRC = ptr()->COMGETTER(AudioController)(ENUMOut<KAudioControllerType, AudioControllerType_T>(aAudioController));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAudioController;
}
void CAudioAdapter::SetAudioController(const KAudioControllerType & aAudioController)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(AudioController)((AudioControllerType_T) aAudioController);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KAudioDriverType CAudioAdapter::GetAudioDriver() const
{
    KAudioDriverType aAudioDriver = (KAudioDriverType) 0;
    AssertReturn(ptr(), aAudioDriver);
    mRC = ptr()->COMGETTER(AudioDriver)(ENUMOut<KAudioDriverType, AudioDriverType_T>(aAudioDriver));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAudioDriver;
}
void CAudioAdapter::SetAudioDriver(const KAudioDriverType & aAudioDriver)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(AudioDriver)((AudioDriverType_T) aAudioDriver);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IVRDEServer wrapper

BOOL CVRDEServer::GetEnabled() const
{
    BOOL aEnabled = FALSE;
    AssertReturn(ptr(), aEnabled);
    mRC = ptr()->COMGETTER(Enabled)(&aEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEnabled;
}
void CVRDEServer::SetEnabled(BOOL aEnabled)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Enabled)(aEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KAuthType CVRDEServer::GetAuthType() const
{
    KAuthType aAuthType = (KAuthType) 0;
    AssertReturn(ptr(), aAuthType);
    mRC = ptr()->COMGETTER(AuthType)(ENUMOut<KAuthType, AuthType_T>(aAuthType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAuthType;
}
void CVRDEServer::SetAuthType(const KAuthType & aAuthType)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(AuthType)((AuthType_T) aAuthType);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CVRDEServer::GetAuthTimeout() const
{
    ULONG aAuthTimeout = 0;
    AssertReturn(ptr(), aAuthTimeout);
    mRC = ptr()->COMGETTER(AuthTimeout)(&aAuthTimeout);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAuthTimeout;
}
void CVRDEServer::SetAuthTimeout(ULONG aAuthTimeout)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(AuthTimeout)(aAuthTimeout);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CVRDEServer::GetAllowMultiConnection() const
{
    BOOL aAllowMultiConnection = FALSE;
    AssertReturn(ptr(), aAllowMultiConnection);
    mRC = ptr()->COMGETTER(AllowMultiConnection)(&aAllowMultiConnection);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAllowMultiConnection;
}
void CVRDEServer::SetAllowMultiConnection(BOOL aAllowMultiConnection)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(AllowMultiConnection)(aAllowMultiConnection);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CVRDEServer::GetReuseSingleConnection() const
{
    BOOL aReuseSingleConnection = FALSE;
    AssertReturn(ptr(), aReuseSingleConnection);
    mRC = ptr()->COMGETTER(ReuseSingleConnection)(&aReuseSingleConnection);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aReuseSingleConnection;
}
void CVRDEServer::SetReuseSingleConnection(BOOL aReuseSingleConnection)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(ReuseSingleConnection)(aReuseSingleConnection);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CVRDEServer::GetVRDEExtPack() const
{
    QString aVRDEExtPack;
    AssertReturn(ptr(), aVRDEExtPack);
    mRC = ptr()->COMGETTER(VRDEExtPack)(BSTROut(aVRDEExtPack));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVRDEExtPack;
}
void CVRDEServer::SetVRDEExtPack(const QString & aVRDEExtPack)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(VRDEExtPack)(BSTRIn(aVRDEExtPack));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CVRDEServer::GetAuthLibrary() const
{
    QString aAuthLibrary;
    AssertReturn(ptr(), aAuthLibrary);
    mRC = ptr()->COMGETTER(AuthLibrary)(BSTROut(aAuthLibrary));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAuthLibrary;
}
void CVRDEServer::SetAuthLibrary(const QString & aAuthLibrary)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(AuthLibrary)(BSTRIn(aAuthLibrary));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QVector<QString> CVRDEServer::GetVRDEProperties() const
{
    QVector<QString> aVRDEProperties;
    AssertReturn(ptr(), aVRDEProperties);
    com::SafeArray <BSTR> VRDEProperties;
    mRC = ptr()->COMGETTER(VRDEProperties)(ComSafeArrayAsOutParam(VRDEProperties));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(VRDEProperties, aVRDEProperties);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVRDEProperties;
}

void CVRDEServer::SetVRDEProperty(const QString & aKey, const QString & aValue)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetVRDEProperty(BSTRIn(aKey), BSTRIn(aValue));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CVRDEServer::GetVRDEProperty(const QString & aKey) const
{
    QString aValue;
    AssertReturn(ptr(), aValue);
    mRC = ptr()->GetVRDEProperty(BSTRIn(aKey), BSTROut(aValue));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aValue;
}

// ISharedFolder wrapper

QString CSharedFolder::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

QString CSharedFolder::GetHostPath() const
{
    QString aHostPath;
    AssertReturn(ptr(), aHostPath);
    mRC = ptr()->COMGETTER(HostPath)(BSTROut(aHostPath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHostPath;
}

BOOL CSharedFolder::GetAccessible() const
{
    BOOL aAccessible = FALSE;
    AssertReturn(ptr(), aAccessible);
    mRC = ptr()->COMGETTER(Accessible)(&aAccessible);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAccessible;
}

BOOL CSharedFolder::GetWritable() const
{
    BOOL aWritable = FALSE;
    AssertReturn(ptr(), aWritable);
    mRC = ptr()->COMGETTER(Writable)(&aWritable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWritable;
}

BOOL CSharedFolder::GetAutoMount() const
{
    BOOL aAutoMount = FALSE;
    AssertReturn(ptr(), aAutoMount);
    mRC = ptr()->COMGETTER(AutoMount)(&aAutoMount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAutoMount;
}

QString CSharedFolder::GetLastAccessError() const
{
    QString aLastAccessError;
    AssertReturn(ptr(), aLastAccessError);
    mRC = ptr()->COMGETTER(LastAccessError)(BSTROut(aLastAccessError));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLastAccessError;
}

// ISession wrapper

KSessionState CSession::GetState() const
{
    KSessionState aState = (KSessionState) 0;
    AssertReturn(ptr(), aState);
    mRC = ptr()->COMGETTER(State)(ENUMOut<KSessionState, SessionState_T>(aState));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aState;
}

KSessionType CSession::GetType() const
{
    KSessionType aType = (KSessionType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KSessionType, SessionType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CMachine CSession::GetMachine() const
{
    CMachine aMachine;
    AssertReturn(ptr(), aMachine);
    IMachine* machinePtr = NULL;
    mRC = ptr()->COMGETTER(Machine)(&machinePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aMachine.setPtr(machinePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachine;
}

CConsole CSession::GetConsole() const
{
    CConsole aConsole;
    AssertReturn(ptr(), aConsole);
    IConsole* consolePtr = NULL;
    mRC = ptr()->COMGETTER(Console)(&consolePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aConsole.setPtr(consolePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aConsole;
}

void CSession::UnlockMachine()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->UnlockMachine();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IStorageController wrapper

QString CStorageController::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

ULONG CStorageController::GetMaxDevicesPerPortCount() const
{
    ULONG aMaxDevicesPerPortCount = 0;
    AssertReturn(ptr(), aMaxDevicesPerPortCount);
    mRC = ptr()->COMGETTER(MaxDevicesPerPortCount)(&aMaxDevicesPerPortCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMaxDevicesPerPortCount;
}

ULONG CStorageController::GetMinPortCount() const
{
    ULONG aMinPortCount = 0;
    AssertReturn(ptr(), aMinPortCount);
    mRC = ptr()->COMGETTER(MinPortCount)(&aMinPortCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMinPortCount;
}

ULONG CStorageController::GetMaxPortCount() const
{
    ULONG aMaxPortCount = 0;
    AssertReturn(ptr(), aMaxPortCount);
    mRC = ptr()->COMGETTER(MaxPortCount)(&aMaxPortCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMaxPortCount;
}

ULONG CStorageController::GetInstance() const
{
    ULONG aInstance = 0;
    AssertReturn(ptr(), aInstance);
    mRC = ptr()->COMGETTER(Instance)(&aInstance);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aInstance;
}
void CStorageController::SetInstance(ULONG aInstance)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Instance)(aInstance);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CStorageController::GetPortCount() const
{
    ULONG aPortCount = 0;
    AssertReturn(ptr(), aPortCount);
    mRC = ptr()->COMGETTER(PortCount)(&aPortCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPortCount;
}
void CStorageController::SetPortCount(ULONG aPortCount)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(PortCount)(aPortCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KStorageBus CStorageController::GetBus() const
{
    KStorageBus aBus = (KStorageBus) 0;
    AssertReturn(ptr(), aBus);
    mRC = ptr()->COMGETTER(Bus)(ENUMOut<KStorageBus, StorageBus_T>(aBus));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBus;
}

KStorageControllerType CStorageController::GetControllerType() const
{
    KStorageControllerType aControllerType = (KStorageControllerType) 0;
    AssertReturn(ptr(), aControllerType);
    mRC = ptr()->COMGETTER(ControllerType)(ENUMOut<KStorageControllerType, StorageControllerType_T>(aControllerType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aControllerType;
}
void CStorageController::SetControllerType(const KStorageControllerType & aControllerType)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(ControllerType)((StorageControllerType_T) aControllerType);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CStorageController::GetUseHostIOCache() const
{
    BOOL aUseHostIOCache = FALSE;
    AssertReturn(ptr(), aUseHostIOCache);
    mRC = ptr()->COMGETTER(UseHostIOCache)(&aUseHostIOCache);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUseHostIOCache;
}
void CStorageController::SetUseHostIOCache(BOOL aUseHostIOCache)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(UseHostIOCache)(aUseHostIOCache);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CStorageController::GetBootable() const
{
    BOOL aBootable = FALSE;
    AssertReturn(ptr(), aBootable);
    mRC = ptr()->COMGETTER(Bootable)(&aBootable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBootable;
}

// IPerformanceMetric wrapper

QString CPerformanceMetric::GetMetricName() const
{
    QString aMetricName;
    AssertReturn(ptr(), aMetricName);
    mRC = ptr()->COMGETTER(MetricName)(BSTROut(aMetricName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMetricName;
}

CUnknown CPerformanceMetric::GetObject() const
{
    CUnknown aObject;
    AssertReturn(ptr(), aObject);
    IUnknown* objectPtr = NULL;
    mRC = ptr()->COMGETTER(Object)(&objectPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aObject.setPtr(objectPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aObject;
}

QString CPerformanceMetric::GetDescription() const
{
    QString aDescription;
    AssertReturn(ptr(), aDescription);
    mRC = ptr()->COMGETTER(Description)(BSTROut(aDescription));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDescription;
}

ULONG CPerformanceMetric::GetPeriod() const
{
    ULONG aPeriod = 0;
    AssertReturn(ptr(), aPeriod);
    mRC = ptr()->COMGETTER(Period)(&aPeriod);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPeriod;
}

ULONG CPerformanceMetric::GetCount() const
{
    ULONG aCount = 0;
    AssertReturn(ptr(), aCount);
    mRC = ptr()->COMGETTER(Count)(&aCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCount;
}

QString CPerformanceMetric::GetUnit() const
{
    QString aUnit;
    AssertReturn(ptr(), aUnit);
    mRC = ptr()->COMGETTER(Unit)(BSTROut(aUnit));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUnit;
}

LONG CPerformanceMetric::GetMinimumValue() const
{
    LONG aMinimumValue = 0;
    AssertReturn(ptr(), aMinimumValue);
    mRC = ptr()->COMGETTER(MinimumValue)(&aMinimumValue);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMinimumValue;
}

LONG CPerformanceMetric::GetMaximumValue() const
{
    LONG aMaximumValue = 0;
    AssertReturn(ptr(), aMaximumValue);
    mRC = ptr()->COMGETTER(MaximumValue)(&aMaximumValue);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMaximumValue;
}

// IPerformanceCollector wrapper

QVector<QString> CPerformanceCollector::GetMetricNames() const
{
    QVector<QString> aMetricNames;
    AssertReturn(ptr(), aMetricNames);
    com::SafeArray <BSTR> metricNames;
    mRC = ptr()->COMGETTER(MetricNames)(ComSafeArrayAsOutParam(metricNames));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(metricNames, aMetricNames);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMetricNames;
}

QVector<CPerformanceMetric> CPerformanceCollector::GetMetrics(const QVector<QString> & aMetricNames, const QVector<CUnknown> & aObjects)
{
    QVector<CPerformanceMetric> aMetrics;
    AssertReturn(ptr(), aMetrics);
    com::SafeArray <BSTR> metricNames;
    ToSafeArray(aMetricNames, metricNames);
    com::SafeIfaceArray <IUnknown> objects;
    ToSafeIfaceArray(aObjects, objects);
    com::SafeIfaceArray <IPerformanceMetric> metrics;
    mRC = ptr()->GetMetrics(ComSafeArrayAsInParam(metricNames), ComSafeArrayAsInParam(objects), ComSafeArrayAsOutParam(metrics));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(metrics, aMetrics);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMetrics;
}

QVector<CPerformanceMetric> CPerformanceCollector::SetupMetrics(const QVector<QString> & aMetricNames, const QVector<CUnknown> & aObjects, ULONG aPeriod, ULONG aCount)
{
    QVector<CPerformanceMetric> aAffectedMetrics;
    AssertReturn(ptr(), aAffectedMetrics);
    com::SafeArray <BSTR> metricNames;
    ToSafeArray(aMetricNames, metricNames);
    com::SafeIfaceArray <IUnknown> objects;
    ToSafeIfaceArray(aObjects, objects);
    com::SafeIfaceArray <IPerformanceMetric> affectedMetrics;
    mRC = ptr()->SetupMetrics(ComSafeArrayAsInParam(metricNames), ComSafeArrayAsInParam(objects), aPeriod, aCount, ComSafeArrayAsOutParam(affectedMetrics));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(affectedMetrics, aAffectedMetrics);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAffectedMetrics;
}

QVector<CPerformanceMetric> CPerformanceCollector::EnableMetrics(const QVector<QString> & aMetricNames, const QVector<CUnknown> & aObjects)
{
    QVector<CPerformanceMetric> aAffectedMetrics;
    AssertReturn(ptr(), aAffectedMetrics);
    com::SafeArray <BSTR> metricNames;
    ToSafeArray(aMetricNames, metricNames);
    com::SafeIfaceArray <IUnknown> objects;
    ToSafeIfaceArray(aObjects, objects);
    com::SafeIfaceArray <IPerformanceMetric> affectedMetrics;
    mRC = ptr()->EnableMetrics(ComSafeArrayAsInParam(metricNames), ComSafeArrayAsInParam(objects), ComSafeArrayAsOutParam(affectedMetrics));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(affectedMetrics, aAffectedMetrics);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAffectedMetrics;
}

QVector<CPerformanceMetric> CPerformanceCollector::DisableMetrics(const QVector<QString> & aMetricNames, const QVector<CUnknown> & aObjects)
{
    QVector<CPerformanceMetric> aAffectedMetrics;
    AssertReturn(ptr(), aAffectedMetrics);
    com::SafeArray <BSTR> metricNames;
    ToSafeArray(aMetricNames, metricNames);
    com::SafeIfaceArray <IUnknown> objects;
    ToSafeIfaceArray(aObjects, objects);
    com::SafeIfaceArray <IPerformanceMetric> affectedMetrics;
    mRC = ptr()->DisableMetrics(ComSafeArrayAsInParam(metricNames), ComSafeArrayAsInParam(objects), ComSafeArrayAsOutParam(affectedMetrics));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(affectedMetrics, aAffectedMetrics);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAffectedMetrics;
}

QVector<LONG> CPerformanceCollector::QueryMetricsData(const QVector<QString> & aMetricNames, const QVector<CUnknown> & aObjects, QVector<QString> & aReturnMetricNames, QVector<CUnknown> & aReturnObjects, QVector<QString> & aReturnUnits, QVector<ULONG> & aReturnScales, QVector<ULONG> & aReturnSequenceNumbers, QVector<ULONG> & aReturnDataIndices, QVector<ULONG> & aReturnDataLengths)
{
    QVector<LONG> aReturnData;
    AssertReturn(ptr(), aReturnData);
    com::SafeArray <BSTR> metricNames;
    ToSafeArray(aMetricNames, metricNames);
    com::SafeIfaceArray <IUnknown> objects;
    ToSafeIfaceArray(aObjects, objects);
    com::SafeArray <BSTR> returnMetricNames;
    com::SafeIfaceArray <IUnknown> returnObjects;
    com::SafeArray <BSTR> returnUnits;
    com::SafeArray <ULONG> returnScales;
    com::SafeArray <ULONG> returnSequenceNumbers;
    com::SafeArray <ULONG> returnDataIndices;
    com::SafeArray <ULONG> returnDataLengths;
    com::SafeArray <LONG> returnData;
    mRC = ptr()->QueryMetricsData(ComSafeArrayAsInParam(metricNames), ComSafeArrayAsInParam(objects), ComSafeArrayAsOutParam(returnMetricNames), ComSafeArrayAsOutParam(returnObjects), ComSafeArrayAsOutParam(returnUnits), ComSafeArrayAsOutParam(returnScales), ComSafeArrayAsOutParam(returnSequenceNumbers), ComSafeArrayAsOutParam(returnDataIndices), ComSafeArrayAsOutParam(returnDataLengths), ComSafeArrayAsOutParam(returnData));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(returnMetricNames, aReturnMetricNames);
    FromSafeIfaceArray(returnObjects, aReturnObjects);
    FromSafeArray(returnUnits, aReturnUnits);
    FromSafeArray(returnScales, aReturnScales);
    FromSafeArray(returnSequenceNumbers, aReturnSequenceNumbers);
    FromSafeArray(returnDataIndices, aReturnDataIndices);
    FromSafeArray(returnDataLengths, aReturnDataLengths);
    FromSafeArray(returnData, aReturnData);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aReturnData;
}

// INATEngine wrapper

QString CNATEngine::GetNetwork() const
{
    QString aNetwork;
    AssertReturn(ptr(), aNetwork);
    mRC = ptr()->COMGETTER(Network)(BSTROut(aNetwork));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNetwork;
}
void CNATEngine::SetNetwork(const QString & aNetwork)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(Network)(BSTRIn(aNetwork));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CNATEngine::GetHostIP() const
{
    QString aHostIP;
    AssertReturn(ptr(), aHostIP);
    mRC = ptr()->COMGETTER(HostIP)(BSTROut(aHostIP));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHostIP;
}
void CNATEngine::SetHostIP(const QString & aHostIP)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(HostIP)(BSTRIn(aHostIP));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CNATEngine::GetTFTPPrefix() const
{
    QString aTFTPPrefix;
    AssertReturn(ptr(), aTFTPPrefix);
    mRC = ptr()->COMGETTER(TFTPPrefix)(BSTROut(aTFTPPrefix));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aTFTPPrefix;
}
void CNATEngine::SetTFTPPrefix(const QString & aTFTPPrefix)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(TFTPPrefix)(BSTRIn(aTFTPPrefix));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CNATEngine::GetTFTPBootFile() const
{
    QString aTFTPBootFile;
    AssertReturn(ptr(), aTFTPBootFile);
    mRC = ptr()->COMGETTER(TFTPBootFile)(BSTROut(aTFTPBootFile));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aTFTPBootFile;
}
void CNATEngine::SetTFTPBootFile(const QString & aTFTPBootFile)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(TFTPBootFile)(BSTRIn(aTFTPBootFile));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QString CNATEngine::GetTFTPNextServer() const
{
    QString aTFTPNextServer;
    AssertReturn(ptr(), aTFTPNextServer);
    mRC = ptr()->COMGETTER(TFTPNextServer)(BSTROut(aTFTPNextServer));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aTFTPNextServer;
}
void CNATEngine::SetTFTPNextServer(const QString & aTFTPNextServer)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(TFTPNextServer)(BSTRIn(aTFTPNextServer));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

ULONG CNATEngine::GetAliasMode() const
{
    ULONG aAliasMode = 0;
    AssertReturn(ptr(), aAliasMode);
    mRC = ptr()->COMGETTER(AliasMode)(&aAliasMode);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAliasMode;
}
void CNATEngine::SetAliasMode(ULONG aAliasMode)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(AliasMode)(aAliasMode);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CNATEngine::GetDNSPassDomain() const
{
    BOOL aDNSPassDomain = FALSE;
    AssertReturn(ptr(), aDNSPassDomain);
    mRC = ptr()->COMGETTER(DNSPassDomain)(&aDNSPassDomain);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDNSPassDomain;
}
void CNATEngine::SetDNSPassDomain(BOOL aDNSPassDomain)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(DNSPassDomain)(aDNSPassDomain);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CNATEngine::GetDNSProxy() const
{
    BOOL aDNSProxy = FALSE;
    AssertReturn(ptr(), aDNSProxy);
    mRC = ptr()->COMGETTER(DNSProxy)(&aDNSProxy);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDNSProxy;
}
void CNATEngine::SetDNSProxy(BOOL aDNSProxy)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(DNSProxy)(aDNSProxy);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CNATEngine::GetDNSUseHostResolver() const
{
    BOOL aDNSUseHostResolver = FALSE;
    AssertReturn(ptr(), aDNSUseHostResolver);
    mRC = ptr()->COMGETTER(DNSUseHostResolver)(&aDNSUseHostResolver);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDNSUseHostResolver;
}
void CNATEngine::SetDNSUseHostResolver(BOOL aDNSUseHostResolver)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(DNSUseHostResolver)(aDNSUseHostResolver);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QVector<QString> CNATEngine::GetRedirects() const
{
    QVector<QString> aRedirects;
    AssertReturn(ptr(), aRedirects);
    com::SafeArray <BSTR> redirects;
    mRC = ptr()->COMGETTER(Redirects)(ComSafeArrayAsOutParam(redirects));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(redirects, aRedirects);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRedirects;
}

void CNATEngine::SetNetworkSettings(ULONG aMtu, ULONG aSockSnd, ULONG aSockRcv, ULONG aTcpWndSnd, ULONG aTcpWndRcv)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetNetworkSettings(aMtu, aSockSnd, aSockRcv, aTcpWndSnd, aTcpWndRcv);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CNATEngine::GetNetworkSettings(ULONG & aMtu, ULONG & aSockSnd, ULONG & aSockRcv, ULONG & aTcpWndSnd, ULONG & aTcpWndRcv)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->GetNetworkSettings(&aMtu, &aSockSnd, &aSockRcv, &aTcpWndSnd, &aTcpWndRcv);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CNATEngine::AddRedirect(const QString & aName, const KNATProtocol & aProto, const QString & aHostIP, USHORT aHostPort, const QString & aGuestIP, USHORT aGuestPort)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->AddRedirect(BSTRIn(aName), (NATProtocol_T) aProto, BSTRIn(aHostIP), aHostPort, BSTRIn(aGuestIP), aGuestPort);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CNATEngine::RemoveRedirect(const QString & aName)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->RemoveRedirect(BSTRIn(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IExtPackPlugIn wrapper

QString CExtPackPlugIn::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

QString CExtPackPlugIn::GetDescription() const
{
    QString aDescription;
    AssertReturn(ptr(), aDescription);
    mRC = ptr()->COMGETTER(Description)(BSTROut(aDescription));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDescription;
}

QString CExtPackPlugIn::GetFrontend() const
{
    QString aFrontend;
    AssertReturn(ptr(), aFrontend);
    mRC = ptr()->COMGETTER(Frontend)(BSTROut(aFrontend));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFrontend;
}

QString CExtPackPlugIn::GetModulePath() const
{
    QString aModulePath;
    AssertReturn(ptr(), aModulePath);
    mRC = ptr()->COMGETTER(ModulePath)(BSTROut(aModulePath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aModulePath;
}

// IExtPackBase wrapper

QString CExtPackBase::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

QString CExtPackBase::GetDescription() const
{
    QString aDescription;
    AssertReturn(ptr(), aDescription);
    mRC = ptr()->COMGETTER(Description)(BSTROut(aDescription));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDescription;
}

QString CExtPackBase::GetVersion() const
{
    QString aVersion;
    AssertReturn(ptr(), aVersion);
    mRC = ptr()->COMGETTER(Version)(BSTROut(aVersion));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVersion;
}

ULONG CExtPackBase::GetRevision() const
{
    ULONG aRevision = 0;
    AssertReturn(ptr(), aRevision);
    mRC = ptr()->COMGETTER(Revision)(&aRevision);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRevision;
}

QString CExtPackBase::GetEdition() const
{
    QString aEdition;
    AssertReturn(ptr(), aEdition);
    mRC = ptr()->COMGETTER(Edition)(BSTROut(aEdition));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEdition;
}

QString CExtPackBase::GetVRDEModule() const
{
    QString aVRDEModule;
    AssertReturn(ptr(), aVRDEModule);
    mRC = ptr()->COMGETTER(VRDEModule)(BSTROut(aVRDEModule));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVRDEModule;
}

QVector<CExtPackPlugIn> CExtPackBase::GetPlugIns() const
{
    QVector<CExtPackPlugIn> aPlugIns;
    AssertReturn(ptr(), aPlugIns);
    com::SafeIfaceArray <IExtPackPlugIn> plugIns;
    mRC = ptr()->COMGETTER(PlugIns)(ComSafeArrayAsOutParam(plugIns));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(plugIns, aPlugIns);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPlugIns;
}

BOOL CExtPackBase::GetUsable() const
{
    BOOL aUsable = FALSE;
    AssertReturn(ptr(), aUsable);
    mRC = ptr()->COMGETTER(Usable)(&aUsable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUsable;
}

QString CExtPackBase::GetWhyUnusable() const
{
    QString aWhyUnusable;
    AssertReturn(ptr(), aWhyUnusable);
    mRC = ptr()->COMGETTER(WhyUnusable)(BSTROut(aWhyUnusable));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWhyUnusable;
}

BOOL CExtPackBase::GetShowLicense() const
{
    BOOL aShowLicense = FALSE;
    AssertReturn(ptr(), aShowLicense);
    mRC = ptr()->COMGETTER(ShowLicense)(&aShowLicense);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aShowLicense;
}

QString CExtPackBase::GetLicense() const
{
    QString aLicense;
    AssertReturn(ptr(), aLicense);
    mRC = ptr()->COMGETTER(License)(BSTROut(aLicense));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLicense;
}

QString CExtPackBase::QueryLicense(const QString & aPreferredLocale, const QString & aPreferredLanguage, const QString & aFormat)
{
    QString aLicenseText;
    AssertReturn(ptr(), aLicenseText);
    mRC = ptr()->QueryLicense(BSTRIn(aPreferredLocale), BSTRIn(aPreferredLanguage), BSTRIn(aFormat), BSTROut(aLicenseText));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLicenseText;
}

// IExtPack wrapper

QString CExtPack::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

QString CExtPack::GetDescription() const
{
    QString aDescription;
    AssertReturn(ptr(), aDescription);
    mRC = ptr()->COMGETTER(Description)(BSTROut(aDescription));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDescription;
}

QString CExtPack::GetVersion() const
{
    QString aVersion;
    AssertReturn(ptr(), aVersion);
    mRC = ptr()->COMGETTER(Version)(BSTROut(aVersion));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVersion;
}

ULONG CExtPack::GetRevision() const
{
    ULONG aRevision = 0;
    AssertReturn(ptr(), aRevision);
    mRC = ptr()->COMGETTER(Revision)(&aRevision);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRevision;
}

QString CExtPack::GetEdition() const
{
    QString aEdition;
    AssertReturn(ptr(), aEdition);
    mRC = ptr()->COMGETTER(Edition)(BSTROut(aEdition));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEdition;
}

QString CExtPack::GetVRDEModule() const
{
    QString aVRDEModule;
    AssertReturn(ptr(), aVRDEModule);
    mRC = ptr()->COMGETTER(VRDEModule)(BSTROut(aVRDEModule));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVRDEModule;
}

QVector<CExtPackPlugIn> CExtPack::GetPlugIns() const
{
    QVector<CExtPackPlugIn> aPlugIns;
    AssertReturn(ptr(), aPlugIns);
    com::SafeIfaceArray <IExtPackPlugIn> plugIns;
    mRC = ptr()->COMGETTER(PlugIns)(ComSafeArrayAsOutParam(plugIns));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(plugIns, aPlugIns);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPlugIns;
}

BOOL CExtPack::GetUsable() const
{
    BOOL aUsable = FALSE;
    AssertReturn(ptr(), aUsable);
    mRC = ptr()->COMGETTER(Usable)(&aUsable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUsable;
}

QString CExtPack::GetWhyUnusable() const
{
    QString aWhyUnusable;
    AssertReturn(ptr(), aWhyUnusable);
    mRC = ptr()->COMGETTER(WhyUnusable)(BSTROut(aWhyUnusable));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWhyUnusable;
}

BOOL CExtPack::GetShowLicense() const
{
    BOOL aShowLicense = FALSE;
    AssertReturn(ptr(), aShowLicense);
    mRC = ptr()->COMGETTER(ShowLicense)(&aShowLicense);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aShowLicense;
}

QString CExtPack::GetLicense() const
{
    QString aLicense;
    AssertReturn(ptr(), aLicense);
    mRC = ptr()->COMGETTER(License)(BSTROut(aLicense));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLicense;
}

CUnknown CExtPack::QueryObject(const QString & aObjUuid)
{
    CUnknown aReturnInterface;
    AssertReturn(ptr(), aReturnInterface);
    IUnknown* returnInterfacePtr = NULL;
    mRC = ptr()->QueryObject(BSTRIn(aObjUuid), &returnInterfacePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aReturnInterface.setPtr(returnInterfacePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aReturnInterface;
}

QString CExtPack::QueryLicense(const QString & aPreferredLocale, const QString & aPreferredLanguage, const QString & aFormat)
{
    QString aLicenseText;
    AssertReturn(ptr(), aLicenseText);
    mRC = ptr()->QueryLicense(BSTRIn(aPreferredLocale), BSTRIn(aPreferredLanguage), BSTRIn(aFormat), BSTROut(aLicenseText));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLicenseText;
}

// IExtPackFile wrapper

QString CExtPackFile::GetFilePath() const
{
    QString aFilePath;
    AssertReturn(ptr(), aFilePath);
    mRC = ptr()->COMGETTER(FilePath)(BSTROut(aFilePath));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFilePath;
}

QString CExtPackFile::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

QString CExtPackFile::GetDescription() const
{
    QString aDescription;
    AssertReturn(ptr(), aDescription);
    mRC = ptr()->COMGETTER(Description)(BSTROut(aDescription));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDescription;
}

QString CExtPackFile::GetVersion() const
{
    QString aVersion;
    AssertReturn(ptr(), aVersion);
    mRC = ptr()->COMGETTER(Version)(BSTROut(aVersion));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVersion;
}

ULONG CExtPackFile::GetRevision() const
{
    ULONG aRevision = 0;
    AssertReturn(ptr(), aRevision);
    mRC = ptr()->COMGETTER(Revision)(&aRevision);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRevision;
}

QString CExtPackFile::GetEdition() const
{
    QString aEdition;
    AssertReturn(ptr(), aEdition);
    mRC = ptr()->COMGETTER(Edition)(BSTROut(aEdition));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEdition;
}

QString CExtPackFile::GetVRDEModule() const
{
    QString aVRDEModule;
    AssertReturn(ptr(), aVRDEModule);
    mRC = ptr()->COMGETTER(VRDEModule)(BSTROut(aVRDEModule));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVRDEModule;
}

QVector<CExtPackPlugIn> CExtPackFile::GetPlugIns() const
{
    QVector<CExtPackPlugIn> aPlugIns;
    AssertReturn(ptr(), aPlugIns);
    com::SafeIfaceArray <IExtPackPlugIn> plugIns;
    mRC = ptr()->COMGETTER(PlugIns)(ComSafeArrayAsOutParam(plugIns));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(plugIns, aPlugIns);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPlugIns;
}

BOOL CExtPackFile::GetUsable() const
{
    BOOL aUsable = FALSE;
    AssertReturn(ptr(), aUsable);
    mRC = ptr()->COMGETTER(Usable)(&aUsable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUsable;
}

QString CExtPackFile::GetWhyUnusable() const
{
    QString aWhyUnusable;
    AssertReturn(ptr(), aWhyUnusable);
    mRC = ptr()->COMGETTER(WhyUnusable)(BSTROut(aWhyUnusable));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWhyUnusable;
}

BOOL CExtPackFile::GetShowLicense() const
{
    BOOL aShowLicense = FALSE;
    AssertReturn(ptr(), aShowLicense);
    mRC = ptr()->COMGETTER(ShowLicense)(&aShowLicense);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aShowLicense;
}

QString CExtPackFile::GetLicense() const
{
    QString aLicense;
    AssertReturn(ptr(), aLicense);
    mRC = ptr()->COMGETTER(License)(BSTROut(aLicense));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLicense;
}

CProgress CExtPackFile::Install(BOOL aReplace, const QString & aDisplayInfo)
{
    CProgress aProgess;
    AssertReturn(ptr(), aProgess);
    IProgress* progessPtr = NULL;
    mRC = ptr()->Install(aReplace, BSTRIn(aDisplayInfo), &progessPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgess.setPtr(progessPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgess;
}

QString CExtPackFile::QueryLicense(const QString & aPreferredLocale, const QString & aPreferredLanguage, const QString & aFormat)
{
    QString aLicenseText;
    AssertReturn(ptr(), aLicenseText);
    mRC = ptr()->QueryLicense(BSTRIn(aPreferredLocale), BSTRIn(aPreferredLanguage), BSTRIn(aFormat), BSTROut(aLicenseText));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aLicenseText;
}

// IExtPackManager wrapper

QVector<CExtPack> CExtPackManager::GetInstalledExtPacks() const
{
    QVector<CExtPack> aInstalledExtPacks;
    AssertReturn(ptr(), aInstalledExtPacks);
    com::SafeIfaceArray <IExtPack> installedExtPacks;
    mRC = ptr()->COMGETTER(InstalledExtPacks)(ComSafeArrayAsOutParam(installedExtPacks));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(installedExtPacks, aInstalledExtPacks);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aInstalledExtPacks;
}

CExtPack CExtPackManager::Find(const QString & aName)
{
    CExtPack aReturnData;
    AssertReturn(ptr(), aReturnData);
    IExtPack* returnDataPtr = NULL;
    mRC = ptr()->Find(BSTRIn(aName), &returnDataPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aReturnData.setPtr(returnDataPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aReturnData;
}

CExtPackFile CExtPackManager::OpenExtPackFile(const QString & aPath)
{
    CExtPackFile aFile;
    AssertReturn(ptr(), aFile);
    IExtPackFile* filePtr = NULL;
    mRC = ptr()->OpenExtPackFile(BSTRIn(aPath), &filePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aFile.setPtr(filePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFile;
}

CProgress CExtPackManager::Uninstall(const QString & aName, BOOL aForcedRemoval, const QString & aDisplayInfo)
{
    CProgress aProgess;
    AssertReturn(ptr(), aProgess);
    IProgress* progessPtr = NULL;
    mRC = ptr()->Uninstall(BSTRIn(aName), aForcedRemoval, BSTRIn(aDisplayInfo), &progessPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProgess.setPtr(progessPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProgess;
}

void CExtPackManager::Cleanup()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Cleanup();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

QVector<QString> CExtPackManager::QueryAllPlugInsForFrontend(const QString & aFrontendName)
{
    QVector<QString> aPlugInModules;
    AssertReturn(ptr(), aPlugInModules);
    com::SafeArray <BSTR> plugInModules;
    mRC = ptr()->QueryAllPlugInsForFrontend(BSTRIn(aFrontendName), ComSafeArrayAsOutParam(plugInModules));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(plugInModules, aPlugInModules);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPlugInModules;
}

BOOL CExtPackManager::IsExtPackUsable(const QString & aName)
{
    BOOL aUsable = FALSE;
    AssertReturn(ptr(), aUsable);
    mRC = ptr()->IsExtPackUsable(BSTRIn(aName), &aUsable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aUsable;
}

// IBandwidthGroup wrapper

QString CBandwidthGroup::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

KBandwidthGroupType CBandwidthGroup::GetType() const
{
    KBandwidthGroupType aType = (KBandwidthGroupType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KBandwidthGroupType, BandwidthGroupType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

ULONG CBandwidthGroup::GetReference() const
{
    ULONG aReference = 0;
    AssertReturn(ptr(), aReference);
    mRC = ptr()->COMGETTER(Reference)(&aReference);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aReference;
}

LONG64 CBandwidthGroup::GetMaxBytesPerSec() const
{
    LONG64 aMaxBytesPerSec = 0;
    AssertReturn(ptr(), aMaxBytesPerSec);
    mRC = ptr()->COMGETTER(MaxBytesPerSec)(&aMaxBytesPerSec);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMaxBytesPerSec;
}
void CBandwidthGroup::SetMaxBytesPerSec(LONG64 aMaxBytesPerSec)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(MaxBytesPerSec)(aMaxBytesPerSec);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IBandwidthControl wrapper

ULONG CBandwidthControl::GetNumGroups() const
{
    ULONG aNumGroups = 0;
    AssertReturn(ptr(), aNumGroups);
    mRC = ptr()->COMGETTER(NumGroups)(&aNumGroups);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNumGroups;
}

void CBandwidthControl::CreateBandwidthGroup(const QString & aName, const KBandwidthGroupType & aType, LONG64 aMaxBytesPerSec)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->CreateBandwidthGroup(BSTRIn(aName), (BandwidthGroupType_T) aType, aMaxBytesPerSec);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CBandwidthControl::DeleteBandwidthGroup(const QString & aName)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->DeleteBandwidthGroup(BSTRIn(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

CBandwidthGroup CBandwidthControl::GetBandwidthGroup(const QString & aName) const
{
    CBandwidthGroup aBandwidthGroup;
    AssertReturn(ptr(), aBandwidthGroup);
    IBandwidthGroup* bandwidthGroupPtr = NULL;
    mRC = ptr()->GetBandwidthGroup(BSTRIn(aName), &bandwidthGroupPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aBandwidthGroup.setPtr(bandwidthGroupPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBandwidthGroup;
}

QVector<CBandwidthGroup> CBandwidthControl::GetAllBandwidthGroups() const
{
    QVector<CBandwidthGroup> aBandwidthGroups;
    AssertReturn(ptr(), aBandwidthGroups);
    com::SafeIfaceArray <IBandwidthGroup> bandwidthGroups;
    mRC = ptr()->GetAllBandwidthGroups(ComSafeArrayAsOutParam(bandwidthGroups));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeIfaceArray(bandwidthGroups, aBandwidthGroups);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBandwidthGroups;
}

// IVirtualBoxClient wrapper

CVirtualBox CVirtualBoxClient::GetVirtualBox() const
{
    CVirtualBox aVirtualBox;
    AssertReturn(ptr(), aVirtualBox);
    IVirtualBox* virtualBoxPtr = NULL;
    mRC = ptr()->COMGETTER(VirtualBox)(&virtualBoxPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aVirtualBox.setPtr(virtualBoxPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVirtualBox;
}

CSession CVirtualBoxClient::GetSession() const
{
    CSession aSession;
    AssertReturn(ptr(), aSession);
    ISession* sessionPtr = NULL;
    mRC = ptr()->COMGETTER(Session)(&sessionPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSession.setPtr(sessionPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSession;
}

CEventSource CVirtualBoxClient::GetEventSource() const
{
    CEventSource aEventSource;
    AssertReturn(ptr(), aEventSource);
    IEventSource* eventSourcePtr = NULL;
    mRC = ptr()->COMGETTER(EventSource)(&eventSourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aEventSource.setPtr(eventSourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEventSource;
}

void CVirtualBoxClient::CheckMachineError(const CMachine & aMachine)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->CheckMachineError(aMachine.ptr());
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IEventSource wrapper

CEventListener CEventSource::CreateListener()
{
    CEventListener aListener;
    AssertReturn(ptr(), aListener);
    IEventListener* listenerPtr = NULL;
    mRC = ptr()->CreateListener(&listenerPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aListener.setPtr(listenerPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aListener;
}

CEventSource CEventSource::CreateAggregator(const QVector<CEventSource> & aSubordinates)
{
    CEventSource aResult;
    AssertReturn(ptr(), aResult);
    com::SafeIfaceArray <IEventSource> subordinates;
    ToSafeIfaceArray(aSubordinates, subordinates);
    IEventSource* resultPtr = NULL;
    mRC = ptr()->CreateAggregator(ComSafeArrayAsInParam(subordinates), &resultPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aResult.setPtr(resultPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

void CEventSource::RegisterListener(const CEventListener & aListener, const QVector<KVBoxEventType> & aInteresting, BOOL aActive)
{
    AssertReturnVoid(ptr());
    com::SafeArray <VBoxEventType_T> interesting;
    ToSafeArray(aInteresting, interesting);
    mRC = ptr()->RegisterListener(aListener.ptr(), ComSafeArrayAsInParam(interesting), aActive);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CEventSource::UnregisterListener(const CEventListener & aListener)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->UnregisterListener(aListener.ptr());
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CEventSource::FireEvent(const CEvent & aEvent, LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->FireEvent(aEvent.ptr(), aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

CEvent CEventSource::GetEvent(const CEventListener & aListener, LONG aTimeout)
{
    CEvent aEvent;
    AssertReturn(ptr(), aEvent);
    IEvent* eventPtr = NULL;
    mRC = ptr()->GetEvent(aListener.ptr(), aTimeout, &eventPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aEvent.setPtr(eventPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEvent;
}

void CEventSource::EventProcessed(const CEventListener & aListener, const CEvent & aEvent)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->EventProcessed(aListener.ptr(), aEvent.ptr());
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IEventListener wrapper

void CEventListener::HandleEvent(const CEvent & aEvent)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->HandleEvent(aEvent.ptr());
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

// IEvent wrapper

KVBoxEventType CEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IReusableEvent wrapper

ULONG CReusableEvent::GetGeneration() const
{
    ULONG aGeneration = 0;
    AssertReturn(ptr(), aGeneration);
    mRC = ptr()->COMGETTER(Generation)(&aGeneration);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGeneration;
}

KVBoxEventType CReusableEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CReusableEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CReusableEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CReusableEvent::Reuse()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Reuse();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CReusableEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CReusableEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IMachineEvent wrapper

QString CMachineEvent::GetMachineId() const
{
    QString aMachineId;
    AssertReturn(ptr(), aMachineId);
    mRC = ptr()->COMGETTER(MachineId)(BSTROut(aMachineId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachineId;
}

KVBoxEventType CMachineEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CMachineEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CMachineEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CMachineEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachineEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IMachineStateChangedEvent wrapper

KMachineState CMachineStateChangedEvent::GetState() const
{
    KMachineState aState = (KMachineState) 0;
    AssertReturn(ptr(), aState);
    mRC = ptr()->COMGETTER(State)(ENUMOut<KMachineState, MachineState_T>(aState));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aState;
}

QString CMachineStateChangedEvent::GetMachineId() const
{
    QString aMachineId;
    AssertReturn(ptr(), aMachineId);
    mRC = ptr()->COMGETTER(MachineId)(BSTROut(aMachineId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachineId;
}

KVBoxEventType CMachineStateChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CMachineStateChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CMachineStateChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CMachineStateChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachineStateChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IMachineDataChangedEvent wrapper

BOOL CMachineDataChangedEvent::GetTemporary() const
{
    BOOL aTemporary = FALSE;
    AssertReturn(ptr(), aTemporary);
    mRC = ptr()->COMGETTER(Temporary)(&aTemporary);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aTemporary;
}

QString CMachineDataChangedEvent::GetMachineId() const
{
    QString aMachineId;
    AssertReturn(ptr(), aMachineId);
    mRC = ptr()->COMGETTER(MachineId)(BSTROut(aMachineId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachineId;
}

KVBoxEventType CMachineDataChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CMachineDataChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CMachineDataChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CMachineDataChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachineDataChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IMediumRegisteredEvent wrapper

QString CMediumRegisteredEvent::GetMediumId() const
{
    QString aMediumId;
    AssertReturn(ptr(), aMediumId);
    mRC = ptr()->COMGETTER(MediumId)(BSTROut(aMediumId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMediumId;
}

KDeviceType CMediumRegisteredEvent::GetMediumType() const
{
    KDeviceType aMediumType = (KDeviceType) 0;
    AssertReturn(ptr(), aMediumType);
    mRC = ptr()->COMGETTER(MediumType)(ENUMOut<KDeviceType, DeviceType_T>(aMediumType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMediumType;
}

BOOL CMediumRegisteredEvent::GetRegistered() const
{
    BOOL aRegistered = FALSE;
    AssertReturn(ptr(), aRegistered);
    mRC = ptr()->COMGETTER(Registered)(&aRegistered);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRegistered;
}

KVBoxEventType CMediumRegisteredEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CMediumRegisteredEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CMediumRegisteredEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CMediumRegisteredEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMediumRegisteredEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IMachineRegisteredEvent wrapper

BOOL CMachineRegisteredEvent::GetRegistered() const
{
    BOOL aRegistered = FALSE;
    AssertReturn(ptr(), aRegistered);
    mRC = ptr()->COMGETTER(Registered)(&aRegistered);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRegistered;
}

QString CMachineRegisteredEvent::GetMachineId() const
{
    QString aMachineId;
    AssertReturn(ptr(), aMachineId);
    mRC = ptr()->COMGETTER(MachineId)(BSTROut(aMachineId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachineId;
}

KVBoxEventType CMachineRegisteredEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CMachineRegisteredEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CMachineRegisteredEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CMachineRegisteredEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMachineRegisteredEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// ISessionStateChangedEvent wrapper

KSessionState CSessionStateChangedEvent::GetState() const
{
    KSessionState aState = (KSessionState) 0;
    AssertReturn(ptr(), aState);
    mRC = ptr()->COMGETTER(State)(ENUMOut<KSessionState, SessionState_T>(aState));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aState;
}

QString CSessionStateChangedEvent::GetMachineId() const
{
    QString aMachineId;
    AssertReturn(ptr(), aMachineId);
    mRC = ptr()->COMGETTER(MachineId)(BSTROut(aMachineId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachineId;
}

KVBoxEventType CSessionStateChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CSessionStateChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CSessionStateChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CSessionStateChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CSessionStateChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IGuestPropertyChangedEvent wrapper

QString CGuestPropertyChangedEvent::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

QString CGuestPropertyChangedEvent::GetValue() const
{
    QString aValue;
    AssertReturn(ptr(), aValue);
    mRC = ptr()->COMGETTER(Value)(BSTROut(aValue));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aValue;
}

QString CGuestPropertyChangedEvent::GetFlags() const
{
    QString aFlags;
    AssertReturn(ptr(), aFlags);
    mRC = ptr()->COMGETTER(Flags)(BSTROut(aFlags));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFlags;
}

QString CGuestPropertyChangedEvent::GetMachineId() const
{
    QString aMachineId;
    AssertReturn(ptr(), aMachineId);
    mRC = ptr()->COMGETTER(MachineId)(BSTROut(aMachineId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachineId;
}

KVBoxEventType CGuestPropertyChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CGuestPropertyChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CGuestPropertyChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CGuestPropertyChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestPropertyChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// ISnapshotEvent wrapper

QString CSnapshotEvent::GetSnapshotId() const
{
    QString aSnapshotId;
    AssertReturn(ptr(), aSnapshotId);
    mRC = ptr()->COMGETTER(SnapshotId)(BSTROut(aSnapshotId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSnapshotId;
}

QString CSnapshotEvent::GetMachineId() const
{
    QString aMachineId;
    AssertReturn(ptr(), aMachineId);
    mRC = ptr()->COMGETTER(MachineId)(BSTROut(aMachineId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachineId;
}

KVBoxEventType CSnapshotEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CSnapshotEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CSnapshotEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CSnapshotEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CSnapshotEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// ISnapshotTakenEvent wrapper

QString CSnapshotTakenEvent::GetSnapshotId() const
{
    QString aSnapshotId;
    AssertReturn(ptr(), aSnapshotId);
    mRC = ptr()->COMGETTER(SnapshotId)(BSTROut(aSnapshotId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSnapshotId;
}

QString CSnapshotTakenEvent::GetMachineId() const
{
    QString aMachineId;
    AssertReturn(ptr(), aMachineId);
    mRC = ptr()->COMGETTER(MachineId)(BSTROut(aMachineId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachineId;
}

KVBoxEventType CSnapshotTakenEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CSnapshotTakenEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CSnapshotTakenEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CSnapshotTakenEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CSnapshotTakenEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// ISnapshotDeletedEvent wrapper

QString CSnapshotDeletedEvent::GetSnapshotId() const
{
    QString aSnapshotId;
    AssertReturn(ptr(), aSnapshotId);
    mRC = ptr()->COMGETTER(SnapshotId)(BSTROut(aSnapshotId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSnapshotId;
}

QString CSnapshotDeletedEvent::GetMachineId() const
{
    QString aMachineId;
    AssertReturn(ptr(), aMachineId);
    mRC = ptr()->COMGETTER(MachineId)(BSTROut(aMachineId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachineId;
}

KVBoxEventType CSnapshotDeletedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CSnapshotDeletedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CSnapshotDeletedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CSnapshotDeletedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CSnapshotDeletedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// ISnapshotChangedEvent wrapper

QString CSnapshotChangedEvent::GetSnapshotId() const
{
    QString aSnapshotId;
    AssertReturn(ptr(), aSnapshotId);
    mRC = ptr()->COMGETTER(SnapshotId)(BSTROut(aSnapshotId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSnapshotId;
}

QString CSnapshotChangedEvent::GetMachineId() const
{
    QString aMachineId;
    AssertReturn(ptr(), aMachineId);
    mRC = ptr()->COMGETTER(MachineId)(BSTROut(aMachineId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachineId;
}

KVBoxEventType CSnapshotChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CSnapshotChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CSnapshotChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CSnapshotChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CSnapshotChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IMousePointerShapeChangedEvent wrapper

BOOL CMousePointerShapeChangedEvent::GetVisible() const
{
    BOOL aVisible = FALSE;
    AssertReturn(ptr(), aVisible);
    mRC = ptr()->COMGETTER(Visible)(&aVisible);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aVisible;
}

BOOL CMousePointerShapeChangedEvent::GetAlpha() const
{
    BOOL aAlpha = FALSE;
    AssertReturn(ptr(), aAlpha);
    mRC = ptr()->COMGETTER(Alpha)(&aAlpha);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAlpha;
}

ULONG CMousePointerShapeChangedEvent::GetXhot() const
{
    ULONG aXhot = 0;
    AssertReturn(ptr(), aXhot);
    mRC = ptr()->COMGETTER(Xhot)(&aXhot);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aXhot;
}

ULONG CMousePointerShapeChangedEvent::GetYhot() const
{
    ULONG aYhot = 0;
    AssertReturn(ptr(), aYhot);
    mRC = ptr()->COMGETTER(Yhot)(&aYhot);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aYhot;
}

ULONG CMousePointerShapeChangedEvent::GetWidth() const
{
    ULONG aWidth = 0;
    AssertReturn(ptr(), aWidth);
    mRC = ptr()->COMGETTER(Width)(&aWidth);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWidth;
}

ULONG CMousePointerShapeChangedEvent::GetHeight() const
{
    ULONG aHeight = 0;
    AssertReturn(ptr(), aHeight);
    mRC = ptr()->COMGETTER(Height)(&aHeight);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHeight;
}

QVector<BYTE> CMousePointerShapeChangedEvent::GetShape() const
{
    QVector<BYTE> aShape;
    AssertReturn(ptr(), aShape);
    com::SafeArray <BYTE> shape;
    mRC = ptr()->COMGETTER(Shape)(ComSafeArrayAsOutParam(shape));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(shape, aShape);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aShape;
}

KVBoxEventType CMousePointerShapeChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CMousePointerShapeChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CMousePointerShapeChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CMousePointerShapeChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMousePointerShapeChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IMouseCapabilityChangedEvent wrapper

BOOL CMouseCapabilityChangedEvent::GetSupportsAbsolute() const
{
    BOOL aSupportsAbsolute = FALSE;
    AssertReturn(ptr(), aSupportsAbsolute);
    mRC = ptr()->COMGETTER(SupportsAbsolute)(&aSupportsAbsolute);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSupportsAbsolute;
}

BOOL CMouseCapabilityChangedEvent::GetSupportsRelative() const
{
    BOOL aSupportsRelative = FALSE;
    AssertReturn(ptr(), aSupportsRelative);
    mRC = ptr()->COMGETTER(SupportsRelative)(&aSupportsRelative);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSupportsRelative;
}

BOOL CMouseCapabilityChangedEvent::GetSupportsMultiTouch() const
{
    BOOL aSupportsMultiTouch = FALSE;
    AssertReturn(ptr(), aSupportsMultiTouch);
    mRC = ptr()->COMGETTER(SupportsMultiTouch)(&aSupportsMultiTouch);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSupportsMultiTouch;
}

BOOL CMouseCapabilityChangedEvent::GetNeedsHostCursor() const
{
    BOOL aNeedsHostCursor = FALSE;
    AssertReturn(ptr(), aNeedsHostCursor);
    mRC = ptr()->COMGETTER(NeedsHostCursor)(&aNeedsHostCursor);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNeedsHostCursor;
}

KVBoxEventType CMouseCapabilityChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CMouseCapabilityChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CMouseCapabilityChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CMouseCapabilityChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMouseCapabilityChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IKeyboardLedsChangedEvent wrapper

BOOL CKeyboardLedsChangedEvent::GetNumLock() const
{
    BOOL aNumLock = FALSE;
    AssertReturn(ptr(), aNumLock);
    mRC = ptr()->COMGETTER(NumLock)(&aNumLock);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNumLock;
}

BOOL CKeyboardLedsChangedEvent::GetCapsLock() const
{
    BOOL aCapsLock = FALSE;
    AssertReturn(ptr(), aCapsLock);
    mRC = ptr()->COMGETTER(CapsLock)(&aCapsLock);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCapsLock;
}

BOOL CKeyboardLedsChangedEvent::GetScrollLock() const
{
    BOOL aScrollLock = FALSE;
    AssertReturn(ptr(), aScrollLock);
    mRC = ptr()->COMGETTER(ScrollLock)(&aScrollLock);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aScrollLock;
}

KVBoxEventType CKeyboardLedsChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CKeyboardLedsChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CKeyboardLedsChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CKeyboardLedsChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CKeyboardLedsChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IStateChangedEvent wrapper

KMachineState CStateChangedEvent::GetState() const
{
    KMachineState aState = (KMachineState) 0;
    AssertReturn(ptr(), aState);
    mRC = ptr()->COMGETTER(State)(ENUMOut<KMachineState, MachineState_T>(aState));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aState;
}

KVBoxEventType CStateChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CStateChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CStateChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CStateChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CStateChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IAdditionsStateChangedEvent wrapper

KVBoxEventType CAdditionsStateChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CAdditionsStateChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CAdditionsStateChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CAdditionsStateChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CAdditionsStateChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// INetworkAdapterChangedEvent wrapper

CNetworkAdapter CNetworkAdapterChangedEvent::GetNetworkAdapter() const
{
    CNetworkAdapter aNetworkAdapter;
    AssertReturn(ptr(), aNetworkAdapter);
    INetworkAdapter* networkAdapterPtr = NULL;
    mRC = ptr()->COMGETTER(NetworkAdapter)(&networkAdapterPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aNetworkAdapter.setPtr(networkAdapterPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNetworkAdapter;
}

KVBoxEventType CNetworkAdapterChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CNetworkAdapterChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CNetworkAdapterChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CNetworkAdapterChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CNetworkAdapterChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// ISerialPortChangedEvent wrapper

CSerialPort CSerialPortChangedEvent::GetSerialPort() const
{
    CSerialPort aSerialPort;
    AssertReturn(ptr(), aSerialPort);
    ISerialPort* serialPortPtr = NULL;
    mRC = ptr()->COMGETTER(SerialPort)(&serialPortPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSerialPort.setPtr(serialPortPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSerialPort;
}

KVBoxEventType CSerialPortChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CSerialPortChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CSerialPortChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CSerialPortChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CSerialPortChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IParallelPortChangedEvent wrapper

CParallelPort CParallelPortChangedEvent::GetParallelPort() const
{
    CParallelPort aParallelPort;
    AssertReturn(ptr(), aParallelPort);
    IParallelPort* parallelPortPtr = NULL;
    mRC = ptr()->COMGETTER(ParallelPort)(&parallelPortPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aParallelPort.setPtr(parallelPortPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aParallelPort;
}

KVBoxEventType CParallelPortChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CParallelPortChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CParallelPortChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CParallelPortChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CParallelPortChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IStorageControllerChangedEvent wrapper

KVBoxEventType CStorageControllerChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CStorageControllerChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CStorageControllerChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CStorageControllerChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CStorageControllerChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IMediumChangedEvent wrapper

CMediumAttachment CMediumChangedEvent::GetMediumAttachment() const
{
    CMediumAttachment aMediumAttachment;
    AssertReturn(ptr(), aMediumAttachment);
    IMediumAttachment* mediumAttachmentPtr = NULL;
    mRC = ptr()->COMGETTER(MediumAttachment)(&mediumAttachmentPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aMediumAttachment.setPtr(mediumAttachmentPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMediumAttachment;
}

KVBoxEventType CMediumChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CMediumChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CMediumChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CMediumChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CMediumChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IClipboardModeChangedEvent wrapper

KClipboardMode CClipboardModeChangedEvent::GetClipboardMode() const
{
    KClipboardMode aClipboardMode = (KClipboardMode) 0;
    AssertReturn(ptr(), aClipboardMode);
    mRC = ptr()->COMGETTER(ClipboardMode)(ENUMOut<KClipboardMode, ClipboardMode_T>(aClipboardMode));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aClipboardMode;
}

KVBoxEventType CClipboardModeChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CClipboardModeChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CClipboardModeChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CClipboardModeChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CClipboardModeChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IDragAndDropModeChangedEvent wrapper

KDragAndDropMode CDragAndDropModeChangedEvent::GetDragAndDropMode() const
{
    KDragAndDropMode aDragAndDropMode = (KDragAndDropMode) 0;
    AssertReturn(ptr(), aDragAndDropMode);
    mRC = ptr()->COMGETTER(DragAndDropMode)(ENUMOut<KDragAndDropMode, DragAndDropMode_T>(aDragAndDropMode));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDragAndDropMode;
}

KVBoxEventType CDragAndDropModeChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CDragAndDropModeChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CDragAndDropModeChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CDragAndDropModeChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CDragAndDropModeChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// ICPUChangedEvent wrapper

ULONG CCPUChangedEvent::GetCPU() const
{
    ULONG aCPU = 0;
    AssertReturn(ptr(), aCPU);
    mRC = ptr()->COMGETTER(CPU)(&aCPU);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCPU;
}

BOOL CCPUChangedEvent::GetAdd() const
{
    BOOL aAdd = FALSE;
    AssertReturn(ptr(), aAdd);
    mRC = ptr()->COMGETTER(Add)(&aAdd);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAdd;
}

KVBoxEventType CCPUChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CCPUChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CCPUChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CCPUChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CCPUChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// ICPUExecutionCapChangedEvent wrapper

ULONG CCPUExecutionCapChangedEvent::GetExecutionCap() const
{
    ULONG aExecutionCap = 0;
    AssertReturn(ptr(), aExecutionCap);
    mRC = ptr()->COMGETTER(ExecutionCap)(&aExecutionCap);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aExecutionCap;
}

KVBoxEventType CCPUExecutionCapChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CCPUExecutionCapChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CCPUExecutionCapChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CCPUExecutionCapChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CCPUExecutionCapChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IGuestKeyboardEvent wrapper

QVector<LONG> CGuestKeyboardEvent::GetScancodes() const
{
    QVector<LONG> aScancodes;
    AssertReturn(ptr(), aScancodes);
    com::SafeArray <LONG> scancodes;
    mRC = ptr()->COMGETTER(Scancodes)(ComSafeArrayAsOutParam(scancodes));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(scancodes, aScancodes);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aScancodes;
}

KVBoxEventType CGuestKeyboardEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CGuestKeyboardEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CGuestKeyboardEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CGuestKeyboardEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestKeyboardEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IGuestMouseEvent wrapper

KGuestMouseEventMode CGuestMouseEvent::GetMode() const
{
    KGuestMouseEventMode aMode = (KGuestMouseEventMode) 0;
    AssertReturn(ptr(), aMode);
    mRC = ptr()->COMGETTER(Mode)(ENUMOut<KGuestMouseEventMode, GuestMouseEventMode_T>(aMode));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMode;
}

LONG CGuestMouseEvent::GetX() const
{
    LONG aX = 0;
    AssertReturn(ptr(), aX);
    mRC = ptr()->COMGETTER(X)(&aX);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aX;
}

LONG CGuestMouseEvent::GetY() const
{
    LONG aY = 0;
    AssertReturn(ptr(), aY);
    mRC = ptr()->COMGETTER(Y)(&aY);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aY;
}

LONG CGuestMouseEvent::GetZ() const
{
    LONG aZ = 0;
    AssertReturn(ptr(), aZ);
    mRC = ptr()->COMGETTER(Z)(&aZ);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aZ;
}

LONG CGuestMouseEvent::GetW() const
{
    LONG aW = 0;
    AssertReturn(ptr(), aW);
    mRC = ptr()->COMGETTER(W)(&aW);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aW;
}

LONG CGuestMouseEvent::GetButtons() const
{
    LONG aButtons = 0;
    AssertReturn(ptr(), aButtons);
    mRC = ptr()->COMGETTER(Buttons)(&aButtons);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aButtons;
}

ULONG CGuestMouseEvent::GetGeneration() const
{
    ULONG aGeneration = 0;
    AssertReturn(ptr(), aGeneration);
    mRC = ptr()->COMGETTER(Generation)(&aGeneration);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGeneration;
}

KVBoxEventType CGuestMouseEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CGuestMouseEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CGuestMouseEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CGuestMouseEvent::Reuse()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->Reuse();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

void CGuestMouseEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestMouseEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IGuestMultiTouchEvent wrapper

LONG CGuestMultiTouchEvent::GetContactCount() const
{
    LONG aContactCount = 0;
    AssertReturn(ptr(), aContactCount);
    mRC = ptr()->COMGETTER(ContactCount)(&aContactCount);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aContactCount;
}

QVector<SHORT> CGuestMultiTouchEvent::GetXPositions() const
{
    QVector<SHORT> aXPositions;
    AssertReturn(ptr(), aXPositions);
    com::SafeArray <SHORT> xPositions;
    mRC = ptr()->COMGETTER(XPositions)(ComSafeArrayAsOutParam(xPositions));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(xPositions, aXPositions);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aXPositions;
}

QVector<SHORT> CGuestMultiTouchEvent::GetYPositions() const
{
    QVector<SHORT> aYPositions;
    AssertReturn(ptr(), aYPositions);
    com::SafeArray <SHORT> yPositions;
    mRC = ptr()->COMGETTER(YPositions)(ComSafeArrayAsOutParam(yPositions));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(yPositions, aYPositions);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aYPositions;
}

QVector<USHORT> CGuestMultiTouchEvent::GetContactIds() const
{
    QVector<USHORT> aContactIds;
    AssertReturn(ptr(), aContactIds);
    com::SafeArray <USHORT> contactIds;
    mRC = ptr()->COMGETTER(ContactIds)(ComSafeArrayAsOutParam(contactIds));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(contactIds, aContactIds);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aContactIds;
}

QVector<USHORT> CGuestMultiTouchEvent::GetContactFlags() const
{
    QVector<USHORT> aContactFlags;
    AssertReturn(ptr(), aContactFlags);
    com::SafeArray <USHORT> contactFlags;
    mRC = ptr()->COMGETTER(ContactFlags)(ComSafeArrayAsOutParam(contactFlags));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(contactFlags, aContactFlags);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aContactFlags;
}

ULONG CGuestMultiTouchEvent::GetScanTime() const
{
    ULONG aScanTime = 0;
    AssertReturn(ptr(), aScanTime);
    mRC = ptr()->COMGETTER(ScanTime)(&aScanTime);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aScanTime;
}

KVBoxEventType CGuestMultiTouchEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CGuestMultiTouchEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CGuestMultiTouchEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CGuestMultiTouchEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestMultiTouchEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IGuestSessionEvent wrapper

CGuestSession CGuestSessionEvent::GetSession() const
{
    CGuestSession aSession;
    AssertReturn(ptr(), aSession);
    IGuestSession* sessionPtr = NULL;
    mRC = ptr()->COMGETTER(Session)(&sessionPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSession.setPtr(sessionPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSession;
}

KVBoxEventType CGuestSessionEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CGuestSessionEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CGuestSessionEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CGuestSessionEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestSessionEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IGuestSessionStateChangedEvent wrapper

ULONG CGuestSessionStateChangedEvent::GetId() const
{
    ULONG aId = 0;
    AssertReturn(ptr(), aId);
    mRC = ptr()->COMGETTER(Id)(&aId);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aId;
}

KGuestSessionStatus CGuestSessionStateChangedEvent::GetStatus() const
{
    KGuestSessionStatus aStatus = (KGuestSessionStatus) 0;
    AssertReturn(ptr(), aStatus);
    mRC = ptr()->COMGETTER(Status)(ENUMOut<KGuestSessionStatus, GuestSessionStatus_T>(aStatus));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStatus;
}

CVirtualBoxErrorInfo CGuestSessionStateChangedEvent::GetError() const
{
    CVirtualBoxErrorInfo aError;
    AssertReturn(ptr(), aError);
    IVirtualBoxErrorInfo* errorPtr = NULL;
    mRC = ptr()->COMGETTER(Error)(&errorPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aError.setPtr(errorPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aError;
}

CGuestSession CGuestSessionStateChangedEvent::GetSession() const
{
    CGuestSession aSession;
    AssertReturn(ptr(), aSession);
    IGuestSession* sessionPtr = NULL;
    mRC = ptr()->COMGETTER(Session)(&sessionPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSession.setPtr(sessionPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSession;
}

KVBoxEventType CGuestSessionStateChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CGuestSessionStateChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CGuestSessionStateChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CGuestSessionStateChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestSessionStateChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IGuestSessionRegisteredEvent wrapper

BOOL CGuestSessionRegisteredEvent::GetRegistered() const
{
    BOOL aRegistered = FALSE;
    AssertReturn(ptr(), aRegistered);
    mRC = ptr()->COMGETTER(Registered)(&aRegistered);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRegistered;
}

CGuestSession CGuestSessionRegisteredEvent::GetSession() const
{
    CGuestSession aSession;
    AssertReturn(ptr(), aSession);
    IGuestSession* sessionPtr = NULL;
    mRC = ptr()->COMGETTER(Session)(&sessionPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSession.setPtr(sessionPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSession;
}

KVBoxEventType CGuestSessionRegisteredEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CGuestSessionRegisteredEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CGuestSessionRegisteredEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CGuestSessionRegisteredEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestSessionRegisteredEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IGuestProcessEvent wrapper

CGuestProcess CGuestProcessEvent::GetProcess() const
{
    CGuestProcess aProcess;
    AssertReturn(ptr(), aProcess);
    IGuestProcess* processPtr = NULL;
    mRC = ptr()->COMGETTER(Process)(&processPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProcess.setPtr(processPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProcess;
}

ULONG CGuestProcessEvent::GetPid() const
{
    ULONG aPid = 0;
    AssertReturn(ptr(), aPid);
    mRC = ptr()->COMGETTER(Pid)(&aPid);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPid;
}

CGuestSession CGuestProcessEvent::GetSession() const
{
    CGuestSession aSession;
    AssertReturn(ptr(), aSession);
    IGuestSession* sessionPtr = NULL;
    mRC = ptr()->COMGETTER(Session)(&sessionPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSession.setPtr(sessionPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSession;
}

KVBoxEventType CGuestProcessEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CGuestProcessEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CGuestProcessEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CGuestProcessEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestProcessEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IGuestProcessRegisteredEvent wrapper

BOOL CGuestProcessRegisteredEvent::GetRegistered() const
{
    BOOL aRegistered = FALSE;
    AssertReturn(ptr(), aRegistered);
    mRC = ptr()->COMGETTER(Registered)(&aRegistered);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRegistered;
}

CGuestProcess CGuestProcessRegisteredEvent::GetProcess() const
{
    CGuestProcess aProcess;
    AssertReturn(ptr(), aProcess);
    IGuestProcess* processPtr = NULL;
    mRC = ptr()->COMGETTER(Process)(&processPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProcess.setPtr(processPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProcess;
}

ULONG CGuestProcessRegisteredEvent::GetPid() const
{
    ULONG aPid = 0;
    AssertReturn(ptr(), aPid);
    mRC = ptr()->COMGETTER(Pid)(&aPid);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPid;
}

CGuestSession CGuestProcessRegisteredEvent::GetSession() const
{
    CGuestSession aSession;
    AssertReturn(ptr(), aSession);
    IGuestSession* sessionPtr = NULL;
    mRC = ptr()->COMGETTER(Session)(&sessionPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSession.setPtr(sessionPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSession;
}

KVBoxEventType CGuestProcessRegisteredEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CGuestProcessRegisteredEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CGuestProcessRegisteredEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CGuestProcessRegisteredEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestProcessRegisteredEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IGuestProcessStateChangedEvent wrapper

KProcessStatus CGuestProcessStateChangedEvent::GetStatus() const
{
    KProcessStatus aStatus = (KProcessStatus) 0;
    AssertReturn(ptr(), aStatus);
    mRC = ptr()->COMGETTER(Status)(ENUMOut<KProcessStatus, ProcessStatus_T>(aStatus));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStatus;
}

CVirtualBoxErrorInfo CGuestProcessStateChangedEvent::GetError() const
{
    CVirtualBoxErrorInfo aError;
    AssertReturn(ptr(), aError);
    IVirtualBoxErrorInfo* errorPtr = NULL;
    mRC = ptr()->COMGETTER(Error)(&errorPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aError.setPtr(errorPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aError;
}

CGuestProcess CGuestProcessStateChangedEvent::GetProcess() const
{
    CGuestProcess aProcess;
    AssertReturn(ptr(), aProcess);
    IGuestProcess* processPtr = NULL;
    mRC = ptr()->COMGETTER(Process)(&processPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProcess.setPtr(processPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProcess;
}

ULONG CGuestProcessStateChangedEvent::GetPid() const
{
    ULONG aPid = 0;
    AssertReturn(ptr(), aPid);
    mRC = ptr()->COMGETTER(Pid)(&aPid);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPid;
}

CGuestSession CGuestProcessStateChangedEvent::GetSession() const
{
    CGuestSession aSession;
    AssertReturn(ptr(), aSession);
    IGuestSession* sessionPtr = NULL;
    mRC = ptr()->COMGETTER(Session)(&sessionPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSession.setPtr(sessionPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSession;
}

KVBoxEventType CGuestProcessStateChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CGuestProcessStateChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CGuestProcessStateChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CGuestProcessStateChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestProcessStateChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IGuestProcessIOEvent wrapper

ULONG CGuestProcessIOEvent::GetHandle() const
{
    ULONG aHandle = 0;
    AssertReturn(ptr(), aHandle);
    mRC = ptr()->COMGETTER(Handle)(&aHandle);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHandle;
}

ULONG CGuestProcessIOEvent::GetProcessed() const
{
    ULONG aProcessed = 0;
    AssertReturn(ptr(), aProcessed);
    mRC = ptr()->COMGETTER(Processed)(&aProcessed);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProcessed;
}

CGuestProcess CGuestProcessIOEvent::GetProcess() const
{
    CGuestProcess aProcess;
    AssertReturn(ptr(), aProcess);
    IGuestProcess* processPtr = NULL;
    mRC = ptr()->COMGETTER(Process)(&processPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProcess.setPtr(processPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProcess;
}

ULONG CGuestProcessIOEvent::GetPid() const
{
    ULONG aPid = 0;
    AssertReturn(ptr(), aPid);
    mRC = ptr()->COMGETTER(Pid)(&aPid);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPid;
}

CGuestSession CGuestProcessIOEvent::GetSession() const
{
    CGuestSession aSession;
    AssertReturn(ptr(), aSession);
    IGuestSession* sessionPtr = NULL;
    mRC = ptr()->COMGETTER(Session)(&sessionPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSession.setPtr(sessionPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSession;
}

KVBoxEventType CGuestProcessIOEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CGuestProcessIOEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CGuestProcessIOEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CGuestProcessIOEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestProcessIOEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IGuestProcessInputNotifyEvent wrapper

KProcessInputStatus CGuestProcessInputNotifyEvent::GetStatus() const
{
    KProcessInputStatus aStatus = (KProcessInputStatus) 0;
    AssertReturn(ptr(), aStatus);
    mRC = ptr()->COMGETTER(Status)(ENUMOut<KProcessInputStatus, ProcessInputStatus_T>(aStatus));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStatus;
}

ULONG CGuestProcessInputNotifyEvent::GetHandle() const
{
    ULONG aHandle = 0;
    AssertReturn(ptr(), aHandle);
    mRC = ptr()->COMGETTER(Handle)(&aHandle);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHandle;
}

ULONG CGuestProcessInputNotifyEvent::GetProcessed() const
{
    ULONG aProcessed = 0;
    AssertReturn(ptr(), aProcessed);
    mRC = ptr()->COMGETTER(Processed)(&aProcessed);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProcessed;
}

CGuestProcess CGuestProcessInputNotifyEvent::GetProcess() const
{
    CGuestProcess aProcess;
    AssertReturn(ptr(), aProcess);
    IGuestProcess* processPtr = NULL;
    mRC = ptr()->COMGETTER(Process)(&processPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProcess.setPtr(processPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProcess;
}

ULONG CGuestProcessInputNotifyEvent::GetPid() const
{
    ULONG aPid = 0;
    AssertReturn(ptr(), aPid);
    mRC = ptr()->COMGETTER(Pid)(&aPid);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPid;
}

CGuestSession CGuestProcessInputNotifyEvent::GetSession() const
{
    CGuestSession aSession;
    AssertReturn(ptr(), aSession);
    IGuestSession* sessionPtr = NULL;
    mRC = ptr()->COMGETTER(Session)(&sessionPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSession.setPtr(sessionPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSession;
}

KVBoxEventType CGuestProcessInputNotifyEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CGuestProcessInputNotifyEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CGuestProcessInputNotifyEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CGuestProcessInputNotifyEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestProcessInputNotifyEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IGuestProcessOutputEvent wrapper

QVector<BYTE> CGuestProcessOutputEvent::GetData() const
{
    QVector<BYTE> aData;
    AssertReturn(ptr(), aData);
    com::SafeArray <BYTE> data;
    mRC = ptr()->COMGETTER(Data)(ComSafeArrayAsOutParam(data));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(data, aData);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aData;
}

ULONG CGuestProcessOutputEvent::GetHandle() const
{
    ULONG aHandle = 0;
    AssertReturn(ptr(), aHandle);
    mRC = ptr()->COMGETTER(Handle)(&aHandle);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHandle;
}

ULONG CGuestProcessOutputEvent::GetProcessed() const
{
    ULONG aProcessed = 0;
    AssertReturn(ptr(), aProcessed);
    mRC = ptr()->COMGETTER(Processed)(&aProcessed);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProcessed;
}

CGuestProcess CGuestProcessOutputEvent::GetProcess() const
{
    CGuestProcess aProcess;
    AssertReturn(ptr(), aProcess);
    IGuestProcess* processPtr = NULL;
    mRC = ptr()->COMGETTER(Process)(&processPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aProcess.setPtr(processPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProcess;
}

ULONG CGuestProcessOutputEvent::GetPid() const
{
    ULONG aPid = 0;
    AssertReturn(ptr(), aPid);
    mRC = ptr()->COMGETTER(Pid)(&aPid);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPid;
}

CGuestSession CGuestProcessOutputEvent::GetSession() const
{
    CGuestSession aSession;
    AssertReturn(ptr(), aSession);
    IGuestSession* sessionPtr = NULL;
    mRC = ptr()->COMGETTER(Session)(&sessionPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSession.setPtr(sessionPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSession;
}

KVBoxEventType CGuestProcessOutputEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CGuestProcessOutputEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CGuestProcessOutputEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CGuestProcessOutputEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestProcessOutputEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IGuestFileEvent wrapper

CGuestFile CGuestFileEvent::GetFile() const
{
    CGuestFile aFile;
    AssertReturn(ptr(), aFile);
    IGuestFile* filePtr = NULL;
    mRC = ptr()->COMGETTER(File)(&filePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aFile.setPtr(filePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFile;
}

CGuestSession CGuestFileEvent::GetSession() const
{
    CGuestSession aSession;
    AssertReturn(ptr(), aSession);
    IGuestSession* sessionPtr = NULL;
    mRC = ptr()->COMGETTER(Session)(&sessionPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSession.setPtr(sessionPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSession;
}

KVBoxEventType CGuestFileEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CGuestFileEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CGuestFileEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CGuestFileEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestFileEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IGuestFileRegisteredEvent wrapper

BOOL CGuestFileRegisteredEvent::GetRegistered() const
{
    BOOL aRegistered = FALSE;
    AssertReturn(ptr(), aRegistered);
    mRC = ptr()->COMGETTER(Registered)(&aRegistered);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRegistered;
}

CGuestFile CGuestFileRegisteredEvent::GetFile() const
{
    CGuestFile aFile;
    AssertReturn(ptr(), aFile);
    IGuestFile* filePtr = NULL;
    mRC = ptr()->COMGETTER(File)(&filePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aFile.setPtr(filePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFile;
}

CGuestSession CGuestFileRegisteredEvent::GetSession() const
{
    CGuestSession aSession;
    AssertReturn(ptr(), aSession);
    IGuestSession* sessionPtr = NULL;
    mRC = ptr()->COMGETTER(Session)(&sessionPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSession.setPtr(sessionPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSession;
}

KVBoxEventType CGuestFileRegisteredEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CGuestFileRegisteredEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CGuestFileRegisteredEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CGuestFileRegisteredEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestFileRegisteredEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IGuestFileStateChangedEvent wrapper

KFileStatus CGuestFileStateChangedEvent::GetStatus() const
{
    KFileStatus aStatus = (KFileStatus) 0;
    AssertReturn(ptr(), aStatus);
    mRC = ptr()->COMGETTER(Status)(ENUMOut<KFileStatus, FileStatus_T>(aStatus));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStatus;
}

CVirtualBoxErrorInfo CGuestFileStateChangedEvent::GetError() const
{
    CVirtualBoxErrorInfo aError;
    AssertReturn(ptr(), aError);
    IVirtualBoxErrorInfo* errorPtr = NULL;
    mRC = ptr()->COMGETTER(Error)(&errorPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aError.setPtr(errorPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aError;
}

CGuestFile CGuestFileStateChangedEvent::GetFile() const
{
    CGuestFile aFile;
    AssertReturn(ptr(), aFile);
    IGuestFile* filePtr = NULL;
    mRC = ptr()->COMGETTER(File)(&filePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aFile.setPtr(filePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFile;
}

CGuestSession CGuestFileStateChangedEvent::GetSession() const
{
    CGuestSession aSession;
    AssertReturn(ptr(), aSession);
    IGuestSession* sessionPtr = NULL;
    mRC = ptr()->COMGETTER(Session)(&sessionPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSession.setPtr(sessionPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSession;
}

KVBoxEventType CGuestFileStateChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CGuestFileStateChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CGuestFileStateChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CGuestFileStateChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestFileStateChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IGuestFileIOEvent wrapper

LONG64 CGuestFileIOEvent::GetOffset() const
{
    LONG64 aOffset = 0;
    AssertReturn(ptr(), aOffset);
    mRC = ptr()->COMGETTER(Offset)(&aOffset);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOffset;
}

ULONG CGuestFileIOEvent::GetProcessed() const
{
    ULONG aProcessed = 0;
    AssertReturn(ptr(), aProcessed);
    mRC = ptr()->COMGETTER(Processed)(&aProcessed);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProcessed;
}

CGuestFile CGuestFileIOEvent::GetFile() const
{
    CGuestFile aFile;
    AssertReturn(ptr(), aFile);
    IGuestFile* filePtr = NULL;
    mRC = ptr()->COMGETTER(File)(&filePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aFile.setPtr(filePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFile;
}

CGuestSession CGuestFileIOEvent::GetSession() const
{
    CGuestSession aSession;
    AssertReturn(ptr(), aSession);
    IGuestSession* sessionPtr = NULL;
    mRC = ptr()->COMGETTER(Session)(&sessionPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSession.setPtr(sessionPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSession;
}

KVBoxEventType CGuestFileIOEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CGuestFileIOEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CGuestFileIOEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CGuestFileIOEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestFileIOEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IGuestFileOffsetChangedEvent wrapper

LONG64 CGuestFileOffsetChangedEvent::GetOffset() const
{
    LONG64 aOffset = 0;
    AssertReturn(ptr(), aOffset);
    mRC = ptr()->COMGETTER(Offset)(&aOffset);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOffset;
}

ULONG CGuestFileOffsetChangedEvent::GetProcessed() const
{
    ULONG aProcessed = 0;
    AssertReturn(ptr(), aProcessed);
    mRC = ptr()->COMGETTER(Processed)(&aProcessed);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProcessed;
}

CGuestFile CGuestFileOffsetChangedEvent::GetFile() const
{
    CGuestFile aFile;
    AssertReturn(ptr(), aFile);
    IGuestFile* filePtr = NULL;
    mRC = ptr()->COMGETTER(File)(&filePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aFile.setPtr(filePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFile;
}

CGuestSession CGuestFileOffsetChangedEvent::GetSession() const
{
    CGuestSession aSession;
    AssertReturn(ptr(), aSession);
    IGuestSession* sessionPtr = NULL;
    mRC = ptr()->COMGETTER(Session)(&sessionPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSession.setPtr(sessionPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSession;
}

KVBoxEventType CGuestFileOffsetChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CGuestFileOffsetChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CGuestFileOffsetChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CGuestFileOffsetChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestFileOffsetChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IGuestFileReadEvent wrapper

QVector<BYTE> CGuestFileReadEvent::GetData() const
{
    QVector<BYTE> aData;
    AssertReturn(ptr(), aData);
    com::SafeArray <BYTE> data;
    mRC = ptr()->COMGETTER(Data)(ComSafeArrayAsOutParam(data));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(data, aData);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aData;
}

LONG64 CGuestFileReadEvent::GetOffset() const
{
    LONG64 aOffset = 0;
    AssertReturn(ptr(), aOffset);
    mRC = ptr()->COMGETTER(Offset)(&aOffset);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOffset;
}

ULONG CGuestFileReadEvent::GetProcessed() const
{
    ULONG aProcessed = 0;
    AssertReturn(ptr(), aProcessed);
    mRC = ptr()->COMGETTER(Processed)(&aProcessed);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProcessed;
}

CGuestFile CGuestFileReadEvent::GetFile() const
{
    CGuestFile aFile;
    AssertReturn(ptr(), aFile);
    IGuestFile* filePtr = NULL;
    mRC = ptr()->COMGETTER(File)(&filePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aFile.setPtr(filePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFile;
}

CGuestSession CGuestFileReadEvent::GetSession() const
{
    CGuestSession aSession;
    AssertReturn(ptr(), aSession);
    IGuestSession* sessionPtr = NULL;
    mRC = ptr()->COMGETTER(Session)(&sessionPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSession.setPtr(sessionPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSession;
}

KVBoxEventType CGuestFileReadEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CGuestFileReadEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CGuestFileReadEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CGuestFileReadEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestFileReadEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IGuestFileWriteEvent wrapper

LONG64 CGuestFileWriteEvent::GetOffset() const
{
    LONG64 aOffset = 0;
    AssertReturn(ptr(), aOffset);
    mRC = ptr()->COMGETTER(Offset)(&aOffset);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOffset;
}

ULONG CGuestFileWriteEvent::GetProcessed() const
{
    ULONG aProcessed = 0;
    AssertReturn(ptr(), aProcessed);
    mRC = ptr()->COMGETTER(Processed)(&aProcessed);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProcessed;
}

CGuestFile CGuestFileWriteEvent::GetFile() const
{
    CGuestFile aFile;
    AssertReturn(ptr(), aFile);
    IGuestFile* filePtr = NULL;
    mRC = ptr()->COMGETTER(File)(&filePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aFile.setPtr(filePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFile;
}

CGuestSession CGuestFileWriteEvent::GetSession() const
{
    CGuestSession aSession;
    AssertReturn(ptr(), aSession);
    IGuestSession* sessionPtr = NULL;
    mRC = ptr()->COMGETTER(Session)(&sessionPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSession.setPtr(sessionPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSession;
}

KVBoxEventType CGuestFileWriteEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CGuestFileWriteEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CGuestFileWriteEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CGuestFileWriteEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestFileWriteEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IVRDEServerChangedEvent wrapper

KVBoxEventType CVRDEServerChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CVRDEServerChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CVRDEServerChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CVRDEServerChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CVRDEServerChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IVRDEServerInfoChangedEvent wrapper

KVBoxEventType CVRDEServerInfoChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CVRDEServerInfoChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CVRDEServerInfoChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CVRDEServerInfoChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CVRDEServerInfoChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IVideoCaptureChangedEvent wrapper

KVBoxEventType CVideoCaptureChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CVideoCaptureChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CVideoCaptureChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CVideoCaptureChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CVideoCaptureChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IUSBControllerChangedEvent wrapper

KVBoxEventType CUSBControllerChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CUSBControllerChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CUSBControllerChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CUSBControllerChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CUSBControllerChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IUSBDeviceStateChangedEvent wrapper

CUSBDevice CUSBDeviceStateChangedEvent::GetDevice() const
{
    CUSBDevice aDevice;
    AssertReturn(ptr(), aDevice);
    IUSBDevice* devicePtr = NULL;
    mRC = ptr()->COMGETTER(Device)(&devicePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aDevice.setPtr(devicePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDevice;
}

BOOL CUSBDeviceStateChangedEvent::GetAttached() const
{
    BOOL aAttached = FALSE;
    AssertReturn(ptr(), aAttached);
    mRC = ptr()->COMGETTER(Attached)(&aAttached);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAttached;
}

CVirtualBoxErrorInfo CUSBDeviceStateChangedEvent::GetError() const
{
    CVirtualBoxErrorInfo aError;
    AssertReturn(ptr(), aError);
    IVirtualBoxErrorInfo* errorPtr = NULL;
    mRC = ptr()->COMGETTER(Error)(&errorPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aError.setPtr(errorPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aError;
}

KVBoxEventType CUSBDeviceStateChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CUSBDeviceStateChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CUSBDeviceStateChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CUSBDeviceStateChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CUSBDeviceStateChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// ISharedFolderChangedEvent wrapper

KScope CSharedFolderChangedEvent::GetScope() const
{
    KScope aScope = (KScope) 0;
    AssertReturn(ptr(), aScope);
    mRC = ptr()->COMGETTER(Scope)(ENUMOut<KScope, Scope_T>(aScope));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aScope;
}

KVBoxEventType CSharedFolderChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CSharedFolderChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CSharedFolderChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CSharedFolderChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CSharedFolderChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IRuntimeErrorEvent wrapper

BOOL CRuntimeErrorEvent::GetFatal() const
{
    BOOL aFatal = FALSE;
    AssertReturn(ptr(), aFatal);
    mRC = ptr()->COMGETTER(Fatal)(&aFatal);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aFatal;
}

QString CRuntimeErrorEvent::GetId() const
{
    QString aId;
    AssertReturn(ptr(), aId);
    mRC = ptr()->COMGETTER(Id)(BSTROut(aId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aId;
}

QString CRuntimeErrorEvent::GetMessage() const
{
    QString aMessage;
    AssertReturn(ptr(), aMessage);
    mRC = ptr()->COMGETTER(Message)(BSTROut(aMessage));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMessage;
}

KVBoxEventType CRuntimeErrorEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CRuntimeErrorEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CRuntimeErrorEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CRuntimeErrorEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CRuntimeErrorEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IEventSourceChangedEvent wrapper

CEventListener CEventSourceChangedEvent::GetListener() const
{
    CEventListener aListener;
    AssertReturn(ptr(), aListener);
    IEventListener* listenerPtr = NULL;
    mRC = ptr()->COMGETTER(Listener)(&listenerPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aListener.setPtr(listenerPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aListener;
}

BOOL CEventSourceChangedEvent::GetAdd() const
{
    BOOL aAdd = FALSE;
    AssertReturn(ptr(), aAdd);
    mRC = ptr()->COMGETTER(Add)(&aAdd);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAdd;
}

KVBoxEventType CEventSourceChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CEventSourceChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CEventSourceChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CEventSourceChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CEventSourceChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IExtraDataChangedEvent wrapper

QString CExtraDataChangedEvent::GetMachineId() const
{
    QString aMachineId;
    AssertReturn(ptr(), aMachineId);
    mRC = ptr()->COMGETTER(MachineId)(BSTROut(aMachineId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachineId;
}

QString CExtraDataChangedEvent::GetKey() const
{
    QString aKey;
    AssertReturn(ptr(), aKey);
    mRC = ptr()->COMGETTER(Key)(BSTROut(aKey));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aKey;
}

QString CExtraDataChangedEvent::GetValue() const
{
    QString aValue;
    AssertReturn(ptr(), aValue);
    mRC = ptr()->COMGETTER(Value)(BSTROut(aValue));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aValue;
}

KVBoxEventType CExtraDataChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CExtraDataChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CExtraDataChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CExtraDataChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CExtraDataChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IVetoEvent wrapper

KVBoxEventType CVetoEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CVetoEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CVetoEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CVetoEvent::AddVeto(const QString & aReason)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->AddVeto(BSTRIn(aReason));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CVetoEvent::IsVetoed()
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->IsVetoed(&aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

QVector<QString> CVetoEvent::GetVetos()
{
    QVector<QString> aResult;
    AssertReturn(ptr(), aResult);
    com::SafeArray <BSTR> result;
    mRC = ptr()->GetVetos(ComSafeArrayAsOutParam(result));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(result, aResult);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

void CVetoEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CVetoEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IExtraDataCanChangeEvent wrapper

QString CExtraDataCanChangeEvent::GetMachineId() const
{
    QString aMachineId;
    AssertReturn(ptr(), aMachineId);
    mRC = ptr()->COMGETTER(MachineId)(BSTROut(aMachineId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachineId;
}

QString CExtraDataCanChangeEvent::GetKey() const
{
    QString aKey;
    AssertReturn(ptr(), aKey);
    mRC = ptr()->COMGETTER(Key)(BSTROut(aKey));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aKey;
}

QString CExtraDataCanChangeEvent::GetValue() const
{
    QString aValue;
    AssertReturn(ptr(), aValue);
    mRC = ptr()->COMGETTER(Value)(BSTROut(aValue));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aValue;
}

KVBoxEventType CExtraDataCanChangeEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CExtraDataCanChangeEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CExtraDataCanChangeEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CExtraDataCanChangeEvent::AddVeto(const QString & aReason)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->AddVeto(BSTRIn(aReason));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CExtraDataCanChangeEvent::IsVetoed()
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->IsVetoed(&aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

QVector<QString> CExtraDataCanChangeEvent::GetVetos()
{
    QVector<QString> aResult;
    AssertReturn(ptr(), aResult);
    com::SafeArray <BSTR> result;
    mRC = ptr()->GetVetos(ComSafeArrayAsOutParam(result));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(result, aResult);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

void CExtraDataCanChangeEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CExtraDataCanChangeEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// ICanShowWindowEvent wrapper

KVBoxEventType CCanShowWindowEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CCanShowWindowEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CCanShowWindowEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CCanShowWindowEvent::AddVeto(const QString & aReason)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->AddVeto(BSTRIn(aReason));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CCanShowWindowEvent::IsVetoed()
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->IsVetoed(&aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

QVector<QString> CCanShowWindowEvent::GetVetos()
{
    QVector<QString> aResult;
    AssertReturn(ptr(), aResult);
    com::SafeArray <BSTR> result;
    mRC = ptr()->GetVetos(ComSafeArrayAsOutParam(result));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    FromSafeArray(result, aResult);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

void CCanShowWindowEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CCanShowWindowEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IShowWindowEvent wrapper

LONG64 CShowWindowEvent::GetWinId() const
{
    LONG64 aWinId = 0;
    AssertReturn(ptr(), aWinId);
    mRC = ptr()->COMGETTER(WinId)(&aWinId);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWinId;
}
void CShowWindowEvent::SetWinId(LONG64 aWinId)
{
    AssertReturnVoid(ptr());
    mRC = ptr()->COMSETTER(WinId)(aWinId);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

KVBoxEventType CShowWindowEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CShowWindowEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CShowWindowEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CShowWindowEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CShowWindowEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// INATRedirectEvent wrapper

ULONG CNATRedirectEvent::GetSlot() const
{
    ULONG aSlot = 0;
    AssertReturn(ptr(), aSlot);
    mRC = ptr()->COMGETTER(Slot)(&aSlot);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSlot;
}

BOOL CNATRedirectEvent::GetRemove() const
{
    BOOL aRemove = FALSE;
    AssertReturn(ptr(), aRemove);
    mRC = ptr()->COMGETTER(Remove)(&aRemove);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRemove;
}

QString CNATRedirectEvent::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

KNATProtocol CNATRedirectEvent::GetProto() const
{
    KNATProtocol aProto = (KNATProtocol) 0;
    AssertReturn(ptr(), aProto);
    mRC = ptr()->COMGETTER(Proto)(ENUMOut<KNATProtocol, NATProtocol_T>(aProto));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProto;
}

QString CNATRedirectEvent::GetHostIP() const
{
    QString aHostIP;
    AssertReturn(ptr(), aHostIP);
    mRC = ptr()->COMGETTER(HostIP)(BSTROut(aHostIP));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHostIP;
}

LONG CNATRedirectEvent::GetHostPort() const
{
    LONG aHostPort = 0;
    AssertReturn(ptr(), aHostPort);
    mRC = ptr()->COMGETTER(HostPort)(&aHostPort);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHostPort;
}

QString CNATRedirectEvent::GetGuestIP() const
{
    QString aGuestIP;
    AssertReturn(ptr(), aGuestIP);
    mRC = ptr()->COMGETTER(GuestIP)(BSTROut(aGuestIP));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGuestIP;
}

LONG CNATRedirectEvent::GetGuestPort() const
{
    LONG aGuestPort = 0;
    AssertReturn(ptr(), aGuestPort);
    mRC = ptr()->COMGETTER(GuestPort)(&aGuestPort);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGuestPort;
}

QString CNATRedirectEvent::GetMachineId() const
{
    QString aMachineId;
    AssertReturn(ptr(), aMachineId);
    mRC = ptr()->COMGETTER(MachineId)(BSTROut(aMachineId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachineId;
}

KVBoxEventType CNATRedirectEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CNATRedirectEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CNATRedirectEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CNATRedirectEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CNATRedirectEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IHostPCIDevicePlugEvent wrapper

BOOL CHostPCIDevicePlugEvent::GetPlugged() const
{
    BOOL aPlugged = FALSE;
    AssertReturn(ptr(), aPlugged);
    mRC = ptr()->COMGETTER(Plugged)(&aPlugged);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aPlugged;
}

BOOL CHostPCIDevicePlugEvent::GetSuccess() const
{
    BOOL aSuccess = FALSE;
    AssertReturn(ptr(), aSuccess);
    mRC = ptr()->COMGETTER(Success)(&aSuccess);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSuccess;
}

CPCIDeviceAttachment CHostPCIDevicePlugEvent::GetAttachment() const
{
    CPCIDeviceAttachment aAttachment;
    AssertReturn(ptr(), aAttachment);
    IPCIDeviceAttachment* attachmentPtr = NULL;
    mRC = ptr()->COMGETTER(Attachment)(&attachmentPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aAttachment.setPtr(attachmentPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAttachment;
}

QString CHostPCIDevicePlugEvent::GetMessage() const
{
    QString aMessage;
    AssertReturn(ptr(), aMessage);
    mRC = ptr()->COMGETTER(Message)(BSTROut(aMessage));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMessage;
}

QString CHostPCIDevicePlugEvent::GetMachineId() const
{
    QString aMachineId;
    AssertReturn(ptr(), aMachineId);
    mRC = ptr()->COMGETTER(MachineId)(BSTROut(aMachineId));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aMachineId;
}

KVBoxEventType CHostPCIDevicePlugEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CHostPCIDevicePlugEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CHostPCIDevicePlugEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CHostPCIDevicePlugEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CHostPCIDevicePlugEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IVBoxSVCAvailabilityChangedEvent wrapper

BOOL CVBoxSVCAvailabilityChangedEvent::GetAvailable() const
{
    BOOL aAvailable = FALSE;
    AssertReturn(ptr(), aAvailable);
    mRC = ptr()->COMGETTER(Available)(&aAvailable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAvailable;
}

KVBoxEventType CVBoxSVCAvailabilityChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CVBoxSVCAvailabilityChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CVBoxSVCAvailabilityChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CVBoxSVCAvailabilityChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CVBoxSVCAvailabilityChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IBandwidthGroupChangedEvent wrapper

CBandwidthGroup CBandwidthGroupChangedEvent::GetBandwidthGroup() const
{
    CBandwidthGroup aBandwidthGroup;
    AssertReturn(ptr(), aBandwidthGroup);
    IBandwidthGroup* bandwidthGroupPtr = NULL;
    mRC = ptr()->COMGETTER(BandwidthGroup)(&bandwidthGroupPtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aBandwidthGroup.setPtr(bandwidthGroupPtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aBandwidthGroup;
}

KVBoxEventType CBandwidthGroupChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CBandwidthGroupChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CBandwidthGroupChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CBandwidthGroupChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CBandwidthGroupChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IGuestMonitorChangedEvent wrapper

KGuestMonitorChangedEventType CGuestMonitorChangedEvent::GetChangeType() const
{
    KGuestMonitorChangedEventType aChangeType = (KGuestMonitorChangedEventType) 0;
    AssertReturn(ptr(), aChangeType);
    mRC = ptr()->COMGETTER(ChangeType)(ENUMOut<KGuestMonitorChangedEventType, GuestMonitorChangedEventType_T>(aChangeType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aChangeType;
}

ULONG CGuestMonitorChangedEvent::GetScreenId() const
{
    ULONG aScreenId = 0;
    AssertReturn(ptr(), aScreenId);
    mRC = ptr()->COMGETTER(ScreenId)(&aScreenId);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aScreenId;
}

ULONG CGuestMonitorChangedEvent::GetOriginX() const
{
    ULONG aOriginX = 0;
    AssertReturn(ptr(), aOriginX);
    mRC = ptr()->COMGETTER(OriginX)(&aOriginX);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOriginX;
}

ULONG CGuestMonitorChangedEvent::GetOriginY() const
{
    ULONG aOriginY = 0;
    AssertReturn(ptr(), aOriginY);
    mRC = ptr()->COMGETTER(OriginY)(&aOriginY);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aOriginY;
}

ULONG CGuestMonitorChangedEvent::GetWidth() const
{
    ULONG aWidth = 0;
    AssertReturn(ptr(), aWidth);
    mRC = ptr()->COMGETTER(Width)(&aWidth);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWidth;
}

ULONG CGuestMonitorChangedEvent::GetHeight() const
{
    ULONG aHeight = 0;
    AssertReturn(ptr(), aHeight);
    mRC = ptr()->COMGETTER(Height)(&aHeight);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHeight;
}

KVBoxEventType CGuestMonitorChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CGuestMonitorChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CGuestMonitorChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CGuestMonitorChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestMonitorChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IGuestUserStateChangedEvent wrapper

QString CGuestUserStateChangedEvent::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

QString CGuestUserStateChangedEvent::GetDomain() const
{
    QString aDomain;
    AssertReturn(ptr(), aDomain);
    mRC = ptr()->COMGETTER(Domain)(BSTROut(aDomain));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aDomain;
}

KGuestUserState CGuestUserStateChangedEvent::GetState() const
{
    KGuestUserState aState = (KGuestUserState) 0;
    AssertReturn(ptr(), aState);
    mRC = ptr()->COMGETTER(State)(ENUMOut<KGuestUserState, GuestUserState_T>(aState));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aState;
}

QString CGuestUserStateChangedEvent::GetStateDetails() const
{
    QString aStateDetails;
    AssertReturn(ptr(), aStateDetails);
    mRC = ptr()->COMGETTER(StateDetails)(BSTROut(aStateDetails));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStateDetails;
}

KVBoxEventType CGuestUserStateChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CGuestUserStateChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CGuestUserStateChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CGuestUserStateChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CGuestUserStateChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IStorageDeviceChangedEvent wrapper

CMediumAttachment CStorageDeviceChangedEvent::GetStorageDevice() const
{
    CMediumAttachment aStorageDevice;
    AssertReturn(ptr(), aStorageDevice);
    IMediumAttachment* storageDevicePtr = NULL;
    mRC = ptr()->COMGETTER(StorageDevice)(&storageDevicePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aStorageDevice.setPtr(storageDevicePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStorageDevice;
}

BOOL CStorageDeviceChangedEvent::GetRemoved() const
{
    BOOL aRemoved = FALSE;
    AssertReturn(ptr(), aRemoved);
    mRC = ptr()->COMGETTER(Removed)(&aRemoved);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aRemoved;
}

BOOL CStorageDeviceChangedEvent::GetSilent() const
{
    BOOL aSilent = FALSE;
    AssertReturn(ptr(), aSilent);
    mRC = ptr()->COMGETTER(Silent)(&aSilent);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSilent;
}

KVBoxEventType CStorageDeviceChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CStorageDeviceChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CStorageDeviceChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CStorageDeviceChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CStorageDeviceChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// INATNetworkChangedEvent wrapper

QString CNATNetworkChangedEvent::GetNetworkName() const
{
    QString aNetworkName;
    AssertReturn(ptr(), aNetworkName);
    mRC = ptr()->COMGETTER(NetworkName)(BSTROut(aNetworkName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNetworkName;
}

KVBoxEventType CNATNetworkChangedEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CNATNetworkChangedEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CNATNetworkChangedEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CNATNetworkChangedEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CNATNetworkChangedEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// INATNetworkStartStopEvent wrapper

BOOL CNATNetworkStartStopEvent::GetStartEvent() const
{
    BOOL aStartEvent = FALSE;
    AssertReturn(ptr(), aStartEvent);
    mRC = ptr()->COMGETTER(StartEvent)(&aStartEvent);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aStartEvent;
}

QString CNATNetworkStartStopEvent::GetNetworkName() const
{
    QString aNetworkName;
    AssertReturn(ptr(), aNetworkName);
    mRC = ptr()->COMGETTER(NetworkName)(BSTROut(aNetworkName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNetworkName;
}

KVBoxEventType CNATNetworkStartStopEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CNATNetworkStartStopEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CNATNetworkStartStopEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CNATNetworkStartStopEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CNATNetworkStartStopEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// INATNetworkAlterEvent wrapper

QString CNATNetworkAlterEvent::GetNetworkName() const
{
    QString aNetworkName;
    AssertReturn(ptr(), aNetworkName);
    mRC = ptr()->COMGETTER(NetworkName)(BSTROut(aNetworkName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNetworkName;
}

KVBoxEventType CNATNetworkAlterEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CNATNetworkAlterEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CNATNetworkAlterEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CNATNetworkAlterEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CNATNetworkAlterEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// INATNetworkCreationDeletionEvent wrapper

BOOL CNATNetworkCreationDeletionEvent::GetCreationEvent() const
{
    BOOL aCreationEvent = FALSE;
    AssertReturn(ptr(), aCreationEvent);
    mRC = ptr()->COMGETTER(CreationEvent)(&aCreationEvent);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCreationEvent;
}

QString CNATNetworkCreationDeletionEvent::GetNetworkName() const
{
    QString aNetworkName;
    AssertReturn(ptr(), aNetworkName);
    mRC = ptr()->COMGETTER(NetworkName)(BSTROut(aNetworkName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNetworkName;
}

KVBoxEventType CNATNetworkCreationDeletionEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CNATNetworkCreationDeletionEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CNATNetworkCreationDeletionEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CNATNetworkCreationDeletionEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CNATNetworkCreationDeletionEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// INATNetworkSettingEvent wrapper

BOOL CNATNetworkSettingEvent::GetEnabled() const
{
    BOOL aEnabled = FALSE;
    AssertReturn(ptr(), aEnabled);
    mRC = ptr()->COMGETTER(Enabled)(&aEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aEnabled;
}

QString CNATNetworkSettingEvent::GetNetwork() const
{
    QString aNetwork;
    AssertReturn(ptr(), aNetwork);
    mRC = ptr()->COMGETTER(Network)(BSTROut(aNetwork));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNetwork;
}

QString CNATNetworkSettingEvent::GetGateway() const
{
    QString aGateway;
    AssertReturn(ptr(), aGateway);
    mRC = ptr()->COMGETTER(Gateway)(BSTROut(aGateway));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGateway;
}

BOOL CNATNetworkSettingEvent::GetAdvertiseDefaultIPv6RouteEnabled() const
{
    BOOL aAdvertiseDefaultIPv6RouteEnabled = FALSE;
    AssertReturn(ptr(), aAdvertiseDefaultIPv6RouteEnabled);
    mRC = ptr()->COMGETTER(AdvertiseDefaultIPv6RouteEnabled)(&aAdvertiseDefaultIPv6RouteEnabled);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aAdvertiseDefaultIPv6RouteEnabled;
}

BOOL CNATNetworkSettingEvent::GetNeedDhcpServer() const
{
    BOOL aNeedDhcpServer = FALSE;
    AssertReturn(ptr(), aNeedDhcpServer);
    mRC = ptr()->COMGETTER(NeedDhcpServer)(&aNeedDhcpServer);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNeedDhcpServer;
}

QString CNATNetworkSettingEvent::GetNetworkName() const
{
    QString aNetworkName;
    AssertReturn(ptr(), aNetworkName);
    mRC = ptr()->COMGETTER(NetworkName)(BSTROut(aNetworkName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNetworkName;
}

KVBoxEventType CNATNetworkSettingEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CNATNetworkSettingEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CNATNetworkSettingEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CNATNetworkSettingEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CNATNetworkSettingEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// INATNetworkPortForwardEvent wrapper

BOOL CNATNetworkPortForwardEvent::GetCreate() const
{
    BOOL aCreate = FALSE;
    AssertReturn(ptr(), aCreate);
    mRC = ptr()->COMGETTER(Create)(&aCreate);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aCreate;
}

BOOL CNATNetworkPortForwardEvent::GetIpv6() const
{
    BOOL aIpv6 = FALSE;
    AssertReturn(ptr(), aIpv6);
    mRC = ptr()->COMGETTER(Ipv6)(&aIpv6);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aIpv6;
}

QString CNATNetworkPortForwardEvent::GetName() const
{
    QString aName;
    AssertReturn(ptr(), aName);
    mRC = ptr()->COMGETTER(Name)(BSTROut(aName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aName;
}

KNATProtocol CNATNetworkPortForwardEvent::GetProto() const
{
    KNATProtocol aProto = (KNATProtocol) 0;
    AssertReturn(ptr(), aProto);
    mRC = ptr()->COMGETTER(Proto)(ENUMOut<KNATProtocol, NATProtocol_T>(aProto));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aProto;
}

QString CNATNetworkPortForwardEvent::GetHostIp() const
{
    QString aHostIp;
    AssertReturn(ptr(), aHostIp);
    mRC = ptr()->COMGETTER(HostIp)(BSTROut(aHostIp));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHostIp;
}

LONG CNATNetworkPortForwardEvent::GetHostPort() const
{
    LONG aHostPort = 0;
    AssertReturn(ptr(), aHostPort);
    mRC = ptr()->COMGETTER(HostPort)(&aHostPort);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aHostPort;
}

QString CNATNetworkPortForwardEvent::GetGuestIp() const
{
    QString aGuestIp;
    AssertReturn(ptr(), aGuestIp);
    mRC = ptr()->COMGETTER(GuestIp)(BSTROut(aGuestIp));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGuestIp;
}

LONG CNATNetworkPortForwardEvent::GetGuestPort() const
{
    LONG aGuestPort = 0;
    AssertReturn(ptr(), aGuestPort);
    mRC = ptr()->COMGETTER(GuestPort)(&aGuestPort);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aGuestPort;
}

QString CNATNetworkPortForwardEvent::GetNetworkName() const
{
    QString aNetworkName;
    AssertReturn(ptr(), aNetworkName);
    mRC = ptr()->COMGETTER(NetworkName)(BSTROut(aNetworkName));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aNetworkName;
}

KVBoxEventType CNATNetworkPortForwardEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CNATNetworkPortForwardEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CNATNetworkPortForwardEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CNATNetworkPortForwardEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CNATNetworkPortForwardEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}

// IHostNameResolutionConfigurationChangeEvent wrapper

KVBoxEventType CHostNameResolutionConfigurationChangeEvent::GetType() const
{
    KVBoxEventType aType = (KVBoxEventType) 0;
    AssertReturn(ptr(), aType);
    mRC = ptr()->COMGETTER(Type)(ENUMOut<KVBoxEventType, VBoxEventType_T>(aType));
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aType;
}

CEventSource CHostNameResolutionConfigurationChangeEvent::GetSource() const
{
    CEventSource aSource;
    AssertReturn(ptr(), aSource);
    IEventSource* sourcePtr = NULL;
    mRC = ptr()->COMGETTER(Source)(&sourcePtr);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    aSource.setPtr(sourcePtr);
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aSource;
}

BOOL CHostNameResolutionConfigurationChangeEvent::GetWaitable() const
{
    BOOL aWaitable = FALSE;
    AssertReturn(ptr(), aWaitable);
    mRC = ptr()->COMGETTER(Waitable)(&aWaitable);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aWaitable;
}

void CHostNameResolutionConfigurationChangeEvent::SetProcessed()
{
    AssertReturnVoid(ptr());
    mRC = ptr()->SetProcessed();
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
}

BOOL CHostNameResolutionConfigurationChangeEvent::WaitProcessed(LONG aTimeout)
{
    BOOL aResult = FALSE;
    AssertReturn(ptr(), aResult);
    mRC = ptr()->WaitProcessed(aTimeout, &aResult);
#ifdef RT_OS_WINDOWS
    Assert(mRC != RPC_E_WRONG_THREAD);
    Assert(mRC != CO_E_NOTINITIALIZED);
#endif
    if (RT_UNLIKELY(mRC != S_OK))
    {
        fetchErrorInfo(ptr(), &COM_IIDOF(Base::Iface));
    }
    return aResult;
}


// ##### ENDFILE "COMWrappers.cpp"


